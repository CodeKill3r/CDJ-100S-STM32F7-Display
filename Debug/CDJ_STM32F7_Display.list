
CDJ_STM32F7_Display.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00021308  080001d0  080001d0  000101d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00005b70  080214d8  080214d8  000314d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08027048  08027048  00037048  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08027050  08027050  00037050  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08027054  08027054  00037054  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000110  20000000  08027058  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00019724  20000110  08027168  00040110  2**3
                  ALLOC
  8 ._user_heap_stack 00000604  20019834  08027168  00049834  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00040110  2**0
                  CONTENTS, READONLY
 10 .debug_info   0006a840  00000000  00000000  00040140  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 0000c8a9  00000000  00000000  000aa980  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loc    000691f6  00000000  00000000  000b7229  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 000022b0  00000000  00000000  00120420  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 0000d3e0  00000000  00000000  001226d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  0003400e  00000000  00000000  0012fab0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   000704fb  00000000  00000000  00163abe  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    00105517  00000000  00000000  001d3fb9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000050  00000000  00000000  002d94d0  2**0
                  CONTENTS, READONLY
 19 .debug_frame  000081b0  00000000  00000000  002d9520  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001d0 <__do_global_dtors_aux>:
 80001d0:	b510      	push	{r4, lr}
 80001d2:	4c05      	ldr	r4, [pc, #20]	; (80001e8 <__do_global_dtors_aux+0x18>)
 80001d4:	7823      	ldrb	r3, [r4, #0]
 80001d6:	b933      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x16>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x1c>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x12>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x20>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	20000110 	.word	0x20000110
 80001ec:	00000000 	.word	0x00000000
 80001f0:	080214c0 	.word	0x080214c0

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b03      	ldr	r3, [pc, #12]	; (8000204 <frame_dummy+0x10>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4903      	ldr	r1, [pc, #12]	; (8000208 <frame_dummy+0x14>)
 80001fc:	4803      	ldr	r0, [pc, #12]	; (800020c <frame_dummy+0x18>)
 80001fe:	f3af 8000 	nop.w
 8000202:	bd08      	pop	{r3, pc}
 8000204:	00000000 	.word	0x00000000
 8000208:	20000114 	.word	0x20000114
 800020c:	080214c0 	.word	0x080214c0

08000210 <strcmp>:
 8000210:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000214:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000218:	2a01      	cmp	r2, #1
 800021a:	bf28      	it	cs
 800021c:	429a      	cmpcs	r2, r3
 800021e:	d0f7      	beq.n	8000210 <strcmp>
 8000220:	1ad0      	subs	r0, r2, r3
 8000222:	4770      	bx	lr
	...

08000230 <memchr>:
 8000230:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000234:	2a10      	cmp	r2, #16
 8000236:	db2b      	blt.n	8000290 <memchr+0x60>
 8000238:	f010 0f07 	tst.w	r0, #7
 800023c:	d008      	beq.n	8000250 <memchr+0x20>
 800023e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000242:	3a01      	subs	r2, #1
 8000244:	428b      	cmp	r3, r1
 8000246:	d02d      	beq.n	80002a4 <memchr+0x74>
 8000248:	f010 0f07 	tst.w	r0, #7
 800024c:	b342      	cbz	r2, 80002a0 <memchr+0x70>
 800024e:	d1f6      	bne.n	800023e <memchr+0xe>
 8000250:	b4f0      	push	{r4, r5, r6, r7}
 8000252:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000256:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800025a:	f022 0407 	bic.w	r4, r2, #7
 800025e:	f07f 0700 	mvns.w	r7, #0
 8000262:	2300      	movs	r3, #0
 8000264:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000268:	3c08      	subs	r4, #8
 800026a:	ea85 0501 	eor.w	r5, r5, r1
 800026e:	ea86 0601 	eor.w	r6, r6, r1
 8000272:	fa85 f547 	uadd8	r5, r5, r7
 8000276:	faa3 f587 	sel	r5, r3, r7
 800027a:	fa86 f647 	uadd8	r6, r6, r7
 800027e:	faa5 f687 	sel	r6, r5, r7
 8000282:	b98e      	cbnz	r6, 80002a8 <memchr+0x78>
 8000284:	d1ee      	bne.n	8000264 <memchr+0x34>
 8000286:	bcf0      	pop	{r4, r5, r6, r7}
 8000288:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800028c:	f002 0207 	and.w	r2, r2, #7
 8000290:	b132      	cbz	r2, 80002a0 <memchr+0x70>
 8000292:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000296:	3a01      	subs	r2, #1
 8000298:	ea83 0301 	eor.w	r3, r3, r1
 800029c:	b113      	cbz	r3, 80002a4 <memchr+0x74>
 800029e:	d1f8      	bne.n	8000292 <memchr+0x62>
 80002a0:	2000      	movs	r0, #0
 80002a2:	4770      	bx	lr
 80002a4:	3801      	subs	r0, #1
 80002a6:	4770      	bx	lr
 80002a8:	2d00      	cmp	r5, #0
 80002aa:	bf06      	itte	eq
 80002ac:	4635      	moveq	r5, r6
 80002ae:	3803      	subeq	r0, #3
 80002b0:	3807      	subne	r0, #7
 80002b2:	f015 0f01 	tst.w	r5, #1
 80002b6:	d107      	bne.n	80002c8 <memchr+0x98>
 80002b8:	3001      	adds	r0, #1
 80002ba:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002be:	bf02      	ittt	eq
 80002c0:	3001      	addeq	r0, #1
 80002c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002c6:	3001      	addeq	r0, #1
 80002c8:	bcf0      	pop	{r4, r5, r6, r7}
 80002ca:	3801      	subs	r0, #1
 80002cc:	4770      	bx	lr
 80002ce:	bf00      	nop

080002d0 <__aeabi_dmul>:
 80002d0:	b570      	push	{r4, r5, r6, lr}
 80002d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80002d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80002da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80002de:	bf1d      	ittte	ne
 80002e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80002e4:	ea94 0f0c 	teqne	r4, ip
 80002e8:	ea95 0f0c 	teqne	r5, ip
 80002ec:	f000 f8de 	bleq	80004ac <__aeabi_dmul+0x1dc>
 80002f0:	442c      	add	r4, r5
 80002f2:	ea81 0603 	eor.w	r6, r1, r3
 80002f6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80002fa:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80002fe:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000302:	bf18      	it	ne
 8000304:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000308:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800030c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000310:	d038      	beq.n	8000384 <__aeabi_dmul+0xb4>
 8000312:	fba0 ce02 	umull	ip, lr, r0, r2
 8000316:	f04f 0500 	mov.w	r5, #0
 800031a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800031e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000322:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000326:	f04f 0600 	mov.w	r6, #0
 800032a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800032e:	f09c 0f00 	teq	ip, #0
 8000332:	bf18      	it	ne
 8000334:	f04e 0e01 	orrne.w	lr, lr, #1
 8000338:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800033c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000340:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000344:	d204      	bcs.n	8000350 <__aeabi_dmul+0x80>
 8000346:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800034a:	416d      	adcs	r5, r5
 800034c:	eb46 0606 	adc.w	r6, r6, r6
 8000350:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000354:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000358:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800035c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000360:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000364:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000368:	bf88      	it	hi
 800036a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800036e:	d81e      	bhi.n	80003ae <__aeabi_dmul+0xde>
 8000370:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000374:	bf08      	it	eq
 8000376:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800037a:	f150 0000 	adcs.w	r0, r0, #0
 800037e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000382:	bd70      	pop	{r4, r5, r6, pc}
 8000384:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000388:	ea46 0101 	orr.w	r1, r6, r1
 800038c:	ea40 0002 	orr.w	r0, r0, r2
 8000390:	ea81 0103 	eor.w	r1, r1, r3
 8000394:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000398:	bfc2      	ittt	gt
 800039a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800039e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80003a2:	bd70      	popgt	{r4, r5, r6, pc}
 80003a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80003a8:	f04f 0e00 	mov.w	lr, #0
 80003ac:	3c01      	subs	r4, #1
 80003ae:	f300 80ab 	bgt.w	8000508 <__aeabi_dmul+0x238>
 80003b2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80003b6:	bfde      	ittt	le
 80003b8:	2000      	movle	r0, #0
 80003ba:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80003be:	bd70      	pople	{r4, r5, r6, pc}
 80003c0:	f1c4 0400 	rsb	r4, r4, #0
 80003c4:	3c20      	subs	r4, #32
 80003c6:	da35      	bge.n	8000434 <__aeabi_dmul+0x164>
 80003c8:	340c      	adds	r4, #12
 80003ca:	dc1b      	bgt.n	8000404 <__aeabi_dmul+0x134>
 80003cc:	f104 0414 	add.w	r4, r4, #20
 80003d0:	f1c4 0520 	rsb	r5, r4, #32
 80003d4:	fa00 f305 	lsl.w	r3, r0, r5
 80003d8:	fa20 f004 	lsr.w	r0, r0, r4
 80003dc:	fa01 f205 	lsl.w	r2, r1, r5
 80003e0:	ea40 0002 	orr.w	r0, r0, r2
 80003e4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80003e8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80003ec:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80003f0:	fa21 f604 	lsr.w	r6, r1, r4
 80003f4:	eb42 0106 	adc.w	r1, r2, r6
 80003f8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80003fc:	bf08      	it	eq
 80003fe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000402:	bd70      	pop	{r4, r5, r6, pc}
 8000404:	f1c4 040c 	rsb	r4, r4, #12
 8000408:	f1c4 0520 	rsb	r5, r4, #32
 800040c:	fa00 f304 	lsl.w	r3, r0, r4
 8000410:	fa20 f005 	lsr.w	r0, r0, r5
 8000414:	fa01 f204 	lsl.w	r2, r1, r4
 8000418:	ea40 0002 	orr.w	r0, r0, r2
 800041c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000420:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000424:	f141 0100 	adc.w	r1, r1, #0
 8000428:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800042c:	bf08      	it	eq
 800042e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000432:	bd70      	pop	{r4, r5, r6, pc}
 8000434:	f1c4 0520 	rsb	r5, r4, #32
 8000438:	fa00 f205 	lsl.w	r2, r0, r5
 800043c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000440:	fa20 f304 	lsr.w	r3, r0, r4
 8000444:	fa01 f205 	lsl.w	r2, r1, r5
 8000448:	ea43 0302 	orr.w	r3, r3, r2
 800044c:	fa21 f004 	lsr.w	r0, r1, r4
 8000450:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000454:	fa21 f204 	lsr.w	r2, r1, r4
 8000458:	ea20 0002 	bic.w	r0, r0, r2
 800045c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000460:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000464:	bf08      	it	eq
 8000466:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800046a:	bd70      	pop	{r4, r5, r6, pc}
 800046c:	f094 0f00 	teq	r4, #0
 8000470:	d10f      	bne.n	8000492 <__aeabi_dmul+0x1c2>
 8000472:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000476:	0040      	lsls	r0, r0, #1
 8000478:	eb41 0101 	adc.w	r1, r1, r1
 800047c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000480:	bf08      	it	eq
 8000482:	3c01      	subeq	r4, #1
 8000484:	d0f7      	beq.n	8000476 <__aeabi_dmul+0x1a6>
 8000486:	ea41 0106 	orr.w	r1, r1, r6
 800048a:	f095 0f00 	teq	r5, #0
 800048e:	bf18      	it	ne
 8000490:	4770      	bxne	lr
 8000492:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000496:	0052      	lsls	r2, r2, #1
 8000498:	eb43 0303 	adc.w	r3, r3, r3
 800049c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80004a0:	bf08      	it	eq
 80004a2:	3d01      	subeq	r5, #1
 80004a4:	d0f7      	beq.n	8000496 <__aeabi_dmul+0x1c6>
 80004a6:	ea43 0306 	orr.w	r3, r3, r6
 80004aa:	4770      	bx	lr
 80004ac:	ea94 0f0c 	teq	r4, ip
 80004b0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80004b4:	bf18      	it	ne
 80004b6:	ea95 0f0c 	teqne	r5, ip
 80004ba:	d00c      	beq.n	80004d6 <__aeabi_dmul+0x206>
 80004bc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80004c0:	bf18      	it	ne
 80004c2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80004c6:	d1d1      	bne.n	800046c <__aeabi_dmul+0x19c>
 80004c8:	ea81 0103 	eor.w	r1, r1, r3
 80004cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80004d0:	f04f 0000 	mov.w	r0, #0
 80004d4:	bd70      	pop	{r4, r5, r6, pc}
 80004d6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80004da:	bf06      	itte	eq
 80004dc:	4610      	moveq	r0, r2
 80004de:	4619      	moveq	r1, r3
 80004e0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80004e4:	d019      	beq.n	800051a <__aeabi_dmul+0x24a>
 80004e6:	ea94 0f0c 	teq	r4, ip
 80004ea:	d102      	bne.n	80004f2 <__aeabi_dmul+0x222>
 80004ec:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80004f0:	d113      	bne.n	800051a <__aeabi_dmul+0x24a>
 80004f2:	ea95 0f0c 	teq	r5, ip
 80004f6:	d105      	bne.n	8000504 <__aeabi_dmul+0x234>
 80004f8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80004fc:	bf1c      	itt	ne
 80004fe:	4610      	movne	r0, r2
 8000500:	4619      	movne	r1, r3
 8000502:	d10a      	bne.n	800051a <__aeabi_dmul+0x24a>
 8000504:	ea81 0103 	eor.w	r1, r1, r3
 8000508:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800050c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000510:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000514:	f04f 0000 	mov.w	r0, #0
 8000518:	bd70      	pop	{r4, r5, r6, pc}
 800051a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800051e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000522:	bd70      	pop	{r4, r5, r6, pc}

08000524 <__aeabi_drsub>:
 8000524:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000528:	e002      	b.n	8000530 <__adddf3>
 800052a:	bf00      	nop

0800052c <__aeabi_dsub>:
 800052c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000530 <__adddf3>:
 8000530:	b530      	push	{r4, r5, lr}
 8000532:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000536:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800053a:	ea94 0f05 	teq	r4, r5
 800053e:	bf08      	it	eq
 8000540:	ea90 0f02 	teqeq	r0, r2
 8000544:	bf1f      	itttt	ne
 8000546:	ea54 0c00 	orrsne.w	ip, r4, r0
 800054a:	ea55 0c02 	orrsne.w	ip, r5, r2
 800054e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000552:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000556:	f000 80e2 	beq.w	800071e <__adddf3+0x1ee>
 800055a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800055e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000562:	bfb8      	it	lt
 8000564:	426d      	neglt	r5, r5
 8000566:	dd0c      	ble.n	8000582 <__adddf3+0x52>
 8000568:	442c      	add	r4, r5
 800056a:	ea80 0202 	eor.w	r2, r0, r2
 800056e:	ea81 0303 	eor.w	r3, r1, r3
 8000572:	ea82 0000 	eor.w	r0, r2, r0
 8000576:	ea83 0101 	eor.w	r1, r3, r1
 800057a:	ea80 0202 	eor.w	r2, r0, r2
 800057e:	ea81 0303 	eor.w	r3, r1, r3
 8000582:	2d36      	cmp	r5, #54	; 0x36
 8000584:	bf88      	it	hi
 8000586:	bd30      	pophi	{r4, r5, pc}
 8000588:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800058c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000590:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000594:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000598:	d002      	beq.n	80005a0 <__adddf3+0x70>
 800059a:	4240      	negs	r0, r0
 800059c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005a0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80005a4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80005a8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80005ac:	d002      	beq.n	80005b4 <__adddf3+0x84>
 80005ae:	4252      	negs	r2, r2
 80005b0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80005b4:	ea94 0f05 	teq	r4, r5
 80005b8:	f000 80a7 	beq.w	800070a <__adddf3+0x1da>
 80005bc:	f1a4 0401 	sub.w	r4, r4, #1
 80005c0:	f1d5 0e20 	rsbs	lr, r5, #32
 80005c4:	db0d      	blt.n	80005e2 <__adddf3+0xb2>
 80005c6:	fa02 fc0e 	lsl.w	ip, r2, lr
 80005ca:	fa22 f205 	lsr.w	r2, r2, r5
 80005ce:	1880      	adds	r0, r0, r2
 80005d0:	f141 0100 	adc.w	r1, r1, #0
 80005d4:	fa03 f20e 	lsl.w	r2, r3, lr
 80005d8:	1880      	adds	r0, r0, r2
 80005da:	fa43 f305 	asr.w	r3, r3, r5
 80005de:	4159      	adcs	r1, r3
 80005e0:	e00e      	b.n	8000600 <__adddf3+0xd0>
 80005e2:	f1a5 0520 	sub.w	r5, r5, #32
 80005e6:	f10e 0e20 	add.w	lr, lr, #32
 80005ea:	2a01      	cmp	r2, #1
 80005ec:	fa03 fc0e 	lsl.w	ip, r3, lr
 80005f0:	bf28      	it	cs
 80005f2:	f04c 0c02 	orrcs.w	ip, ip, #2
 80005f6:	fa43 f305 	asr.w	r3, r3, r5
 80005fa:	18c0      	adds	r0, r0, r3
 80005fc:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000600:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000604:	d507      	bpl.n	8000616 <__adddf3+0xe6>
 8000606:	f04f 0e00 	mov.w	lr, #0
 800060a:	f1dc 0c00 	rsbs	ip, ip, #0
 800060e:	eb7e 0000 	sbcs.w	r0, lr, r0
 8000612:	eb6e 0101 	sbc.w	r1, lr, r1
 8000616:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800061a:	d31b      	bcc.n	8000654 <__adddf3+0x124>
 800061c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000620:	d30c      	bcc.n	800063c <__adddf3+0x10c>
 8000622:	0849      	lsrs	r1, r1, #1
 8000624:	ea5f 0030 	movs.w	r0, r0, rrx
 8000628:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800062c:	f104 0401 	add.w	r4, r4, #1
 8000630:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000634:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000638:	f080 809a 	bcs.w	8000770 <__adddf3+0x240>
 800063c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000640:	bf08      	it	eq
 8000642:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000646:	f150 0000 	adcs.w	r0, r0, #0
 800064a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800064e:	ea41 0105 	orr.w	r1, r1, r5
 8000652:	bd30      	pop	{r4, r5, pc}
 8000654:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000658:	4140      	adcs	r0, r0
 800065a:	eb41 0101 	adc.w	r1, r1, r1
 800065e:	3c01      	subs	r4, #1
 8000660:	bf28      	it	cs
 8000662:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000666:	d2e9      	bcs.n	800063c <__adddf3+0x10c>
 8000668:	f091 0f00 	teq	r1, #0
 800066c:	bf04      	itt	eq
 800066e:	4601      	moveq	r1, r0
 8000670:	2000      	moveq	r0, #0
 8000672:	fab1 f381 	clz	r3, r1
 8000676:	bf08      	it	eq
 8000678:	3320      	addeq	r3, #32
 800067a:	f1a3 030b 	sub.w	r3, r3, #11
 800067e:	f1b3 0220 	subs.w	r2, r3, #32
 8000682:	da0c      	bge.n	800069e <__adddf3+0x16e>
 8000684:	320c      	adds	r2, #12
 8000686:	dd08      	ble.n	800069a <__adddf3+0x16a>
 8000688:	f102 0c14 	add.w	ip, r2, #20
 800068c:	f1c2 020c 	rsb	r2, r2, #12
 8000690:	fa01 f00c 	lsl.w	r0, r1, ip
 8000694:	fa21 f102 	lsr.w	r1, r1, r2
 8000698:	e00c      	b.n	80006b4 <__adddf3+0x184>
 800069a:	f102 0214 	add.w	r2, r2, #20
 800069e:	bfd8      	it	le
 80006a0:	f1c2 0c20 	rsble	ip, r2, #32
 80006a4:	fa01 f102 	lsl.w	r1, r1, r2
 80006a8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80006ac:	bfdc      	itt	le
 80006ae:	ea41 010c 	orrle.w	r1, r1, ip
 80006b2:	4090      	lslle	r0, r2
 80006b4:	1ae4      	subs	r4, r4, r3
 80006b6:	bfa2      	ittt	ge
 80006b8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80006bc:	4329      	orrge	r1, r5
 80006be:	bd30      	popge	{r4, r5, pc}
 80006c0:	ea6f 0404 	mvn.w	r4, r4
 80006c4:	3c1f      	subs	r4, #31
 80006c6:	da1c      	bge.n	8000702 <__adddf3+0x1d2>
 80006c8:	340c      	adds	r4, #12
 80006ca:	dc0e      	bgt.n	80006ea <__adddf3+0x1ba>
 80006cc:	f104 0414 	add.w	r4, r4, #20
 80006d0:	f1c4 0220 	rsb	r2, r4, #32
 80006d4:	fa20 f004 	lsr.w	r0, r0, r4
 80006d8:	fa01 f302 	lsl.w	r3, r1, r2
 80006dc:	ea40 0003 	orr.w	r0, r0, r3
 80006e0:	fa21 f304 	lsr.w	r3, r1, r4
 80006e4:	ea45 0103 	orr.w	r1, r5, r3
 80006e8:	bd30      	pop	{r4, r5, pc}
 80006ea:	f1c4 040c 	rsb	r4, r4, #12
 80006ee:	f1c4 0220 	rsb	r2, r4, #32
 80006f2:	fa20 f002 	lsr.w	r0, r0, r2
 80006f6:	fa01 f304 	lsl.w	r3, r1, r4
 80006fa:	ea40 0003 	orr.w	r0, r0, r3
 80006fe:	4629      	mov	r1, r5
 8000700:	bd30      	pop	{r4, r5, pc}
 8000702:	fa21 f004 	lsr.w	r0, r1, r4
 8000706:	4629      	mov	r1, r5
 8000708:	bd30      	pop	{r4, r5, pc}
 800070a:	f094 0f00 	teq	r4, #0
 800070e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8000712:	bf06      	itte	eq
 8000714:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000718:	3401      	addeq	r4, #1
 800071a:	3d01      	subne	r5, #1
 800071c:	e74e      	b.n	80005bc <__adddf3+0x8c>
 800071e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000722:	bf18      	it	ne
 8000724:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000728:	d029      	beq.n	800077e <__adddf3+0x24e>
 800072a:	ea94 0f05 	teq	r4, r5
 800072e:	bf08      	it	eq
 8000730:	ea90 0f02 	teqeq	r0, r2
 8000734:	d005      	beq.n	8000742 <__adddf3+0x212>
 8000736:	ea54 0c00 	orrs.w	ip, r4, r0
 800073a:	bf04      	itt	eq
 800073c:	4619      	moveq	r1, r3
 800073e:	4610      	moveq	r0, r2
 8000740:	bd30      	pop	{r4, r5, pc}
 8000742:	ea91 0f03 	teq	r1, r3
 8000746:	bf1e      	ittt	ne
 8000748:	2100      	movne	r1, #0
 800074a:	2000      	movne	r0, #0
 800074c:	bd30      	popne	{r4, r5, pc}
 800074e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000752:	d105      	bne.n	8000760 <__adddf3+0x230>
 8000754:	0040      	lsls	r0, r0, #1
 8000756:	4149      	adcs	r1, r1
 8000758:	bf28      	it	cs
 800075a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800075e:	bd30      	pop	{r4, r5, pc}
 8000760:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000764:	bf3c      	itt	cc
 8000766:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800076a:	bd30      	popcc	{r4, r5, pc}
 800076c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000770:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000774:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000778:	f04f 0000 	mov.w	r0, #0
 800077c:	bd30      	pop	{r4, r5, pc}
 800077e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000782:	bf1a      	itte	ne
 8000784:	4619      	movne	r1, r3
 8000786:	4610      	movne	r0, r2
 8000788:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800078c:	bf1c      	itt	ne
 800078e:	460b      	movne	r3, r1
 8000790:	4602      	movne	r2, r0
 8000792:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000796:	bf06      	itte	eq
 8000798:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800079c:	ea91 0f03 	teqeq	r1, r3
 80007a0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80007a4:	bd30      	pop	{r4, r5, pc}
 80007a6:	bf00      	nop

080007a8 <__aeabi_ui2d>:
 80007a8:	f090 0f00 	teq	r0, #0
 80007ac:	bf04      	itt	eq
 80007ae:	2100      	moveq	r1, #0
 80007b0:	4770      	bxeq	lr
 80007b2:	b530      	push	{r4, r5, lr}
 80007b4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80007b8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80007bc:	f04f 0500 	mov.w	r5, #0
 80007c0:	f04f 0100 	mov.w	r1, #0
 80007c4:	e750      	b.n	8000668 <__adddf3+0x138>
 80007c6:	bf00      	nop

080007c8 <__aeabi_i2d>:
 80007c8:	f090 0f00 	teq	r0, #0
 80007cc:	bf04      	itt	eq
 80007ce:	2100      	moveq	r1, #0
 80007d0:	4770      	bxeq	lr
 80007d2:	b530      	push	{r4, r5, lr}
 80007d4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80007d8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80007dc:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80007e0:	bf48      	it	mi
 80007e2:	4240      	negmi	r0, r0
 80007e4:	f04f 0100 	mov.w	r1, #0
 80007e8:	e73e      	b.n	8000668 <__adddf3+0x138>
 80007ea:	bf00      	nop

080007ec <__aeabi_f2d>:
 80007ec:	0042      	lsls	r2, r0, #1
 80007ee:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80007f2:	ea4f 0131 	mov.w	r1, r1, rrx
 80007f6:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80007fa:	bf1f      	itttt	ne
 80007fc:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000800:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000804:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000808:	4770      	bxne	lr
 800080a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800080e:	bf08      	it	eq
 8000810:	4770      	bxeq	lr
 8000812:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000816:	bf04      	itt	eq
 8000818:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 800081c:	4770      	bxeq	lr
 800081e:	b530      	push	{r4, r5, lr}
 8000820:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000824:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000828:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800082c:	e71c      	b.n	8000668 <__adddf3+0x138>
 800082e:	bf00      	nop

08000830 <__aeabi_ul2d>:
 8000830:	ea50 0201 	orrs.w	r2, r0, r1
 8000834:	bf08      	it	eq
 8000836:	4770      	bxeq	lr
 8000838:	b530      	push	{r4, r5, lr}
 800083a:	f04f 0500 	mov.w	r5, #0
 800083e:	e00a      	b.n	8000856 <__aeabi_l2d+0x16>

08000840 <__aeabi_l2d>:
 8000840:	ea50 0201 	orrs.w	r2, r0, r1
 8000844:	bf08      	it	eq
 8000846:	4770      	bxeq	lr
 8000848:	b530      	push	{r4, r5, lr}
 800084a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800084e:	d502      	bpl.n	8000856 <__aeabi_l2d+0x16>
 8000850:	4240      	negs	r0, r0
 8000852:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000856:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800085a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800085e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000862:	f43f aed8 	beq.w	8000616 <__adddf3+0xe6>
 8000866:	f04f 0203 	mov.w	r2, #3
 800086a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800086e:	bf18      	it	ne
 8000870:	3203      	addne	r2, #3
 8000872:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000876:	bf18      	it	ne
 8000878:	3203      	addne	r2, #3
 800087a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800087e:	f1c2 0320 	rsb	r3, r2, #32
 8000882:	fa00 fc03 	lsl.w	ip, r0, r3
 8000886:	fa20 f002 	lsr.w	r0, r0, r2
 800088a:	fa01 fe03 	lsl.w	lr, r1, r3
 800088e:	ea40 000e 	orr.w	r0, r0, lr
 8000892:	fa21 f102 	lsr.w	r1, r1, r2
 8000896:	4414      	add	r4, r2
 8000898:	e6bd      	b.n	8000616 <__adddf3+0xe6>
 800089a:	bf00      	nop

0800089c <__gedf2>:
 800089c:	f04f 3cff 	mov.w	ip, #4294967295
 80008a0:	e006      	b.n	80008b0 <__cmpdf2+0x4>
 80008a2:	bf00      	nop

080008a4 <__ledf2>:
 80008a4:	f04f 0c01 	mov.w	ip, #1
 80008a8:	e002      	b.n	80008b0 <__cmpdf2+0x4>
 80008aa:	bf00      	nop

080008ac <__cmpdf2>:
 80008ac:	f04f 0c01 	mov.w	ip, #1
 80008b0:	f84d cd04 	str.w	ip, [sp, #-4]!
 80008b4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80008b8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80008bc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80008c0:	bf18      	it	ne
 80008c2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80008c6:	d01b      	beq.n	8000900 <__cmpdf2+0x54>
 80008c8:	b001      	add	sp, #4
 80008ca:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80008ce:	bf0c      	ite	eq
 80008d0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80008d4:	ea91 0f03 	teqne	r1, r3
 80008d8:	bf02      	ittt	eq
 80008da:	ea90 0f02 	teqeq	r0, r2
 80008de:	2000      	moveq	r0, #0
 80008e0:	4770      	bxeq	lr
 80008e2:	f110 0f00 	cmn.w	r0, #0
 80008e6:	ea91 0f03 	teq	r1, r3
 80008ea:	bf58      	it	pl
 80008ec:	4299      	cmppl	r1, r3
 80008ee:	bf08      	it	eq
 80008f0:	4290      	cmpeq	r0, r2
 80008f2:	bf2c      	ite	cs
 80008f4:	17d8      	asrcs	r0, r3, #31
 80008f6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80008fa:	f040 0001 	orr.w	r0, r0, #1
 80008fe:	4770      	bx	lr
 8000900:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000904:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000908:	d102      	bne.n	8000910 <__cmpdf2+0x64>
 800090a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800090e:	d107      	bne.n	8000920 <__cmpdf2+0x74>
 8000910:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000914:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000918:	d1d6      	bne.n	80008c8 <__cmpdf2+0x1c>
 800091a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800091e:	d0d3      	beq.n	80008c8 <__cmpdf2+0x1c>
 8000920:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000924:	4770      	bx	lr
 8000926:	bf00      	nop

08000928 <__aeabi_cdrcmple>:
 8000928:	4684      	mov	ip, r0
 800092a:	4610      	mov	r0, r2
 800092c:	4662      	mov	r2, ip
 800092e:	468c      	mov	ip, r1
 8000930:	4619      	mov	r1, r3
 8000932:	4663      	mov	r3, ip
 8000934:	e000      	b.n	8000938 <__aeabi_cdcmpeq>
 8000936:	bf00      	nop

08000938 <__aeabi_cdcmpeq>:
 8000938:	b501      	push	{r0, lr}
 800093a:	f7ff ffb7 	bl	80008ac <__cmpdf2>
 800093e:	2800      	cmp	r0, #0
 8000940:	bf48      	it	mi
 8000942:	f110 0f00 	cmnmi.w	r0, #0
 8000946:	bd01      	pop	{r0, pc}

08000948 <__aeabi_dcmpeq>:
 8000948:	f84d ed08 	str.w	lr, [sp, #-8]!
 800094c:	f7ff fff4 	bl	8000938 <__aeabi_cdcmpeq>
 8000950:	bf0c      	ite	eq
 8000952:	2001      	moveq	r0, #1
 8000954:	2000      	movne	r0, #0
 8000956:	f85d fb08 	ldr.w	pc, [sp], #8
 800095a:	bf00      	nop

0800095c <__aeabi_dcmplt>:
 800095c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000960:	f7ff ffea 	bl	8000938 <__aeabi_cdcmpeq>
 8000964:	bf34      	ite	cc
 8000966:	2001      	movcc	r0, #1
 8000968:	2000      	movcs	r0, #0
 800096a:	f85d fb08 	ldr.w	pc, [sp], #8
 800096e:	bf00      	nop

08000970 <__aeabi_dcmple>:
 8000970:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000974:	f7ff ffe0 	bl	8000938 <__aeabi_cdcmpeq>
 8000978:	bf94      	ite	ls
 800097a:	2001      	movls	r0, #1
 800097c:	2000      	movhi	r0, #0
 800097e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000982:	bf00      	nop

08000984 <__aeabi_dcmpge>:
 8000984:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000988:	f7ff ffce 	bl	8000928 <__aeabi_cdrcmple>
 800098c:	bf94      	ite	ls
 800098e:	2001      	movls	r0, #1
 8000990:	2000      	movhi	r0, #0
 8000992:	f85d fb08 	ldr.w	pc, [sp], #8
 8000996:	bf00      	nop

08000998 <__aeabi_dcmpgt>:
 8000998:	f84d ed08 	str.w	lr, [sp, #-8]!
 800099c:	f7ff ffc4 	bl	8000928 <__aeabi_cdrcmple>
 80009a0:	bf34      	ite	cc
 80009a2:	2001      	movcc	r0, #1
 80009a4:	2000      	movcs	r0, #0
 80009a6:	f85d fb08 	ldr.w	pc, [sp], #8
 80009aa:	bf00      	nop

080009ac <__aeabi_d2uiz>:
 80009ac:	004a      	lsls	r2, r1, #1
 80009ae:	d211      	bcs.n	80009d4 <__aeabi_d2uiz+0x28>
 80009b0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80009b4:	d211      	bcs.n	80009da <__aeabi_d2uiz+0x2e>
 80009b6:	d50d      	bpl.n	80009d4 <__aeabi_d2uiz+0x28>
 80009b8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80009bc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80009c0:	d40e      	bmi.n	80009e0 <__aeabi_d2uiz+0x34>
 80009c2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80009c6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80009ca:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80009ce:	fa23 f002 	lsr.w	r0, r3, r2
 80009d2:	4770      	bx	lr
 80009d4:	f04f 0000 	mov.w	r0, #0
 80009d8:	4770      	bx	lr
 80009da:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80009de:	d102      	bne.n	80009e6 <__aeabi_d2uiz+0x3a>
 80009e0:	f04f 30ff 	mov.w	r0, #4294967295
 80009e4:	4770      	bx	lr
 80009e6:	f04f 0000 	mov.w	r0, #0
 80009ea:	4770      	bx	lr

080009ec <__aeabi_d2f>:
 80009ec:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80009f0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80009f4:	bf24      	itt	cs
 80009f6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80009fa:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80009fe:	d90d      	bls.n	8000a1c <__aeabi_d2f+0x30>
 8000a00:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a04:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a08:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a0c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a10:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a14:	bf08      	it	eq
 8000a16:	f020 0001 	biceq.w	r0, r0, #1
 8000a1a:	4770      	bx	lr
 8000a1c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a20:	d121      	bne.n	8000a66 <__aeabi_d2f+0x7a>
 8000a22:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a26:	bfbc      	itt	lt
 8000a28:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a2c:	4770      	bxlt	lr
 8000a2e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a32:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a36:	f1c2 0218 	rsb	r2, r2, #24
 8000a3a:	f1c2 0c20 	rsb	ip, r2, #32
 8000a3e:	fa10 f30c 	lsls.w	r3, r0, ip
 8000a42:	fa20 f002 	lsr.w	r0, r0, r2
 8000a46:	bf18      	it	ne
 8000a48:	f040 0001 	orrne.w	r0, r0, #1
 8000a4c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a50:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000a54:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000a58:	ea40 000c 	orr.w	r0, r0, ip
 8000a5c:	fa23 f302 	lsr.w	r3, r3, r2
 8000a60:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000a64:	e7cc      	b.n	8000a00 <__aeabi_d2f+0x14>
 8000a66:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000a6a:	d107      	bne.n	8000a7c <__aeabi_d2f+0x90>
 8000a6c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000a70:	bf1e      	ittt	ne
 8000a72:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000a76:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000a7a:	4770      	bxne	lr
 8000a7c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000a80:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000a84:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000a88:	4770      	bx	lr
 8000a8a:	bf00      	nop

08000a8c <__aeabi_frsub>:
 8000a8c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000a90:	e002      	b.n	8000a98 <__addsf3>
 8000a92:	bf00      	nop

08000a94 <__aeabi_fsub>:
 8000a94:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000a98 <__addsf3>:
 8000a98:	0042      	lsls	r2, r0, #1
 8000a9a:	bf1f      	itttt	ne
 8000a9c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000aa0:	ea92 0f03 	teqne	r2, r3
 8000aa4:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000aa8:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000aac:	d06a      	beq.n	8000b84 <__addsf3+0xec>
 8000aae:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000ab2:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000ab6:	bfc1      	itttt	gt
 8000ab8:	18d2      	addgt	r2, r2, r3
 8000aba:	4041      	eorgt	r1, r0
 8000abc:	4048      	eorgt	r0, r1
 8000abe:	4041      	eorgt	r1, r0
 8000ac0:	bfb8      	it	lt
 8000ac2:	425b      	neglt	r3, r3
 8000ac4:	2b19      	cmp	r3, #25
 8000ac6:	bf88      	it	hi
 8000ac8:	4770      	bxhi	lr
 8000aca:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000ace:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ad2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000ad6:	bf18      	it	ne
 8000ad8:	4240      	negne	r0, r0
 8000ada:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000ade:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000ae2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000ae6:	bf18      	it	ne
 8000ae8:	4249      	negne	r1, r1
 8000aea:	ea92 0f03 	teq	r2, r3
 8000aee:	d03f      	beq.n	8000b70 <__addsf3+0xd8>
 8000af0:	f1a2 0201 	sub.w	r2, r2, #1
 8000af4:	fa41 fc03 	asr.w	ip, r1, r3
 8000af8:	eb10 000c 	adds.w	r0, r0, ip
 8000afc:	f1c3 0320 	rsb	r3, r3, #32
 8000b00:	fa01 f103 	lsl.w	r1, r1, r3
 8000b04:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000b08:	d502      	bpl.n	8000b10 <__addsf3+0x78>
 8000b0a:	4249      	negs	r1, r1
 8000b0c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000b10:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000b14:	d313      	bcc.n	8000b3e <__addsf3+0xa6>
 8000b16:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000b1a:	d306      	bcc.n	8000b2a <__addsf3+0x92>
 8000b1c:	0840      	lsrs	r0, r0, #1
 8000b1e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000b22:	f102 0201 	add.w	r2, r2, #1
 8000b26:	2afe      	cmp	r2, #254	; 0xfe
 8000b28:	d251      	bcs.n	8000bce <__addsf3+0x136>
 8000b2a:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000b2e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000b32:	bf08      	it	eq
 8000b34:	f020 0001 	biceq.w	r0, r0, #1
 8000b38:	ea40 0003 	orr.w	r0, r0, r3
 8000b3c:	4770      	bx	lr
 8000b3e:	0049      	lsls	r1, r1, #1
 8000b40:	eb40 0000 	adc.w	r0, r0, r0
 8000b44:	3a01      	subs	r2, #1
 8000b46:	bf28      	it	cs
 8000b48:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000b4c:	d2ed      	bcs.n	8000b2a <__addsf3+0x92>
 8000b4e:	fab0 fc80 	clz	ip, r0
 8000b52:	f1ac 0c08 	sub.w	ip, ip, #8
 8000b56:	ebb2 020c 	subs.w	r2, r2, ip
 8000b5a:	fa00 f00c 	lsl.w	r0, r0, ip
 8000b5e:	bfaa      	itet	ge
 8000b60:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000b64:	4252      	neglt	r2, r2
 8000b66:	4318      	orrge	r0, r3
 8000b68:	bfbc      	itt	lt
 8000b6a:	40d0      	lsrlt	r0, r2
 8000b6c:	4318      	orrlt	r0, r3
 8000b6e:	4770      	bx	lr
 8000b70:	f092 0f00 	teq	r2, #0
 8000b74:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000b78:	bf06      	itte	eq
 8000b7a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000b7e:	3201      	addeq	r2, #1
 8000b80:	3b01      	subne	r3, #1
 8000b82:	e7b5      	b.n	8000af0 <__addsf3+0x58>
 8000b84:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000b88:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000b8c:	bf18      	it	ne
 8000b8e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000b92:	d021      	beq.n	8000bd8 <__addsf3+0x140>
 8000b94:	ea92 0f03 	teq	r2, r3
 8000b98:	d004      	beq.n	8000ba4 <__addsf3+0x10c>
 8000b9a:	f092 0f00 	teq	r2, #0
 8000b9e:	bf08      	it	eq
 8000ba0:	4608      	moveq	r0, r1
 8000ba2:	4770      	bx	lr
 8000ba4:	ea90 0f01 	teq	r0, r1
 8000ba8:	bf1c      	itt	ne
 8000baa:	2000      	movne	r0, #0
 8000bac:	4770      	bxne	lr
 8000bae:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000bb2:	d104      	bne.n	8000bbe <__addsf3+0x126>
 8000bb4:	0040      	lsls	r0, r0, #1
 8000bb6:	bf28      	it	cs
 8000bb8:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000bbc:	4770      	bx	lr
 8000bbe:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000bc2:	bf3c      	itt	cc
 8000bc4:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000bc8:	4770      	bxcc	lr
 8000bca:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000bce:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000bd2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000bd6:	4770      	bx	lr
 8000bd8:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000bdc:	bf16      	itet	ne
 8000bde:	4608      	movne	r0, r1
 8000be0:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000be4:	4601      	movne	r1, r0
 8000be6:	0242      	lsls	r2, r0, #9
 8000be8:	bf06      	itte	eq
 8000bea:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000bee:	ea90 0f01 	teqeq	r0, r1
 8000bf2:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000bf6:	4770      	bx	lr

08000bf8 <__aeabi_ui2f>:
 8000bf8:	f04f 0300 	mov.w	r3, #0
 8000bfc:	e004      	b.n	8000c08 <__aeabi_i2f+0x8>
 8000bfe:	bf00      	nop

08000c00 <__aeabi_i2f>:
 8000c00:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000c04:	bf48      	it	mi
 8000c06:	4240      	negmi	r0, r0
 8000c08:	ea5f 0c00 	movs.w	ip, r0
 8000c0c:	bf08      	it	eq
 8000c0e:	4770      	bxeq	lr
 8000c10:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000c14:	4601      	mov	r1, r0
 8000c16:	f04f 0000 	mov.w	r0, #0
 8000c1a:	e01c      	b.n	8000c56 <__aeabi_l2f+0x2a>

08000c1c <__aeabi_ul2f>:
 8000c1c:	ea50 0201 	orrs.w	r2, r0, r1
 8000c20:	bf08      	it	eq
 8000c22:	4770      	bxeq	lr
 8000c24:	f04f 0300 	mov.w	r3, #0
 8000c28:	e00a      	b.n	8000c40 <__aeabi_l2f+0x14>
 8000c2a:	bf00      	nop

08000c2c <__aeabi_l2f>:
 8000c2c:	ea50 0201 	orrs.w	r2, r0, r1
 8000c30:	bf08      	it	eq
 8000c32:	4770      	bxeq	lr
 8000c34:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000c38:	d502      	bpl.n	8000c40 <__aeabi_l2f+0x14>
 8000c3a:	4240      	negs	r0, r0
 8000c3c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000c40:	ea5f 0c01 	movs.w	ip, r1
 8000c44:	bf02      	ittt	eq
 8000c46:	4684      	moveq	ip, r0
 8000c48:	4601      	moveq	r1, r0
 8000c4a:	2000      	moveq	r0, #0
 8000c4c:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000c50:	bf08      	it	eq
 8000c52:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000c56:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000c5a:	fabc f28c 	clz	r2, ip
 8000c5e:	3a08      	subs	r2, #8
 8000c60:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000c64:	db10      	blt.n	8000c88 <__aeabi_l2f+0x5c>
 8000c66:	fa01 fc02 	lsl.w	ip, r1, r2
 8000c6a:	4463      	add	r3, ip
 8000c6c:	fa00 fc02 	lsl.w	ip, r0, r2
 8000c70:	f1c2 0220 	rsb	r2, r2, #32
 8000c74:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000c78:	fa20 f202 	lsr.w	r2, r0, r2
 8000c7c:	eb43 0002 	adc.w	r0, r3, r2
 8000c80:	bf08      	it	eq
 8000c82:	f020 0001 	biceq.w	r0, r0, #1
 8000c86:	4770      	bx	lr
 8000c88:	f102 0220 	add.w	r2, r2, #32
 8000c8c:	fa01 fc02 	lsl.w	ip, r1, r2
 8000c90:	f1c2 0220 	rsb	r2, r2, #32
 8000c94:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000c98:	fa21 f202 	lsr.w	r2, r1, r2
 8000c9c:	eb43 0002 	adc.w	r0, r3, r2
 8000ca0:	bf08      	it	eq
 8000ca2:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000ca6:	4770      	bx	lr

08000ca8 <__aeabi_uldivmod>:
 8000ca8:	b953      	cbnz	r3, 8000cc0 <__aeabi_uldivmod+0x18>
 8000caa:	b94a      	cbnz	r2, 8000cc0 <__aeabi_uldivmod+0x18>
 8000cac:	2900      	cmp	r1, #0
 8000cae:	bf08      	it	eq
 8000cb0:	2800      	cmpeq	r0, #0
 8000cb2:	bf1c      	itt	ne
 8000cb4:	f04f 31ff 	movne.w	r1, #4294967295
 8000cb8:	f04f 30ff 	movne.w	r0, #4294967295
 8000cbc:	f000 b994 	b.w	8000fe8 <__aeabi_idiv0>
 8000cc0:	f1ad 0c08 	sub.w	ip, sp, #8
 8000cc4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000cc8:	f000 f826 	bl	8000d18 <__udivmoddi4>
 8000ccc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000cd0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000cd4:	b004      	add	sp, #16
 8000cd6:	4770      	bx	lr

08000cd8 <__aeabi_f2ulz>:
 8000cd8:	b5d0      	push	{r4, r6, r7, lr}
 8000cda:	f7ff fd87 	bl	80007ec <__aeabi_f2d>
 8000cde:	4b0c      	ldr	r3, [pc, #48]	; (8000d10 <__aeabi_f2ulz+0x38>)
 8000ce0:	2200      	movs	r2, #0
 8000ce2:	4606      	mov	r6, r0
 8000ce4:	460f      	mov	r7, r1
 8000ce6:	f7ff faf3 	bl	80002d0 <__aeabi_dmul>
 8000cea:	f7ff fe5f 	bl	80009ac <__aeabi_d2uiz>
 8000cee:	4604      	mov	r4, r0
 8000cf0:	f7ff fd5a 	bl	80007a8 <__aeabi_ui2d>
 8000cf4:	4b07      	ldr	r3, [pc, #28]	; (8000d14 <__aeabi_f2ulz+0x3c>)
 8000cf6:	2200      	movs	r2, #0
 8000cf8:	f7ff faea 	bl	80002d0 <__aeabi_dmul>
 8000cfc:	4602      	mov	r2, r0
 8000cfe:	460b      	mov	r3, r1
 8000d00:	4630      	mov	r0, r6
 8000d02:	4639      	mov	r1, r7
 8000d04:	f7ff fc12 	bl	800052c <__aeabi_dsub>
 8000d08:	f7ff fe50 	bl	80009ac <__aeabi_d2uiz>
 8000d0c:	4621      	mov	r1, r4
 8000d0e:	bdd0      	pop	{r4, r6, r7, pc}
 8000d10:	3df00000 	.word	0x3df00000
 8000d14:	41f00000 	.word	0x41f00000

08000d18 <__udivmoddi4>:
 8000d18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000d1c:	9d08      	ldr	r5, [sp, #32]
 8000d1e:	4604      	mov	r4, r0
 8000d20:	468e      	mov	lr, r1
 8000d22:	2b00      	cmp	r3, #0
 8000d24:	d14d      	bne.n	8000dc2 <__udivmoddi4+0xaa>
 8000d26:	428a      	cmp	r2, r1
 8000d28:	4694      	mov	ip, r2
 8000d2a:	d969      	bls.n	8000e00 <__udivmoddi4+0xe8>
 8000d2c:	fab2 f282 	clz	r2, r2
 8000d30:	b152      	cbz	r2, 8000d48 <__udivmoddi4+0x30>
 8000d32:	fa01 f302 	lsl.w	r3, r1, r2
 8000d36:	f1c2 0120 	rsb	r1, r2, #32
 8000d3a:	fa20 f101 	lsr.w	r1, r0, r1
 8000d3e:	fa0c fc02 	lsl.w	ip, ip, r2
 8000d42:	ea41 0e03 	orr.w	lr, r1, r3
 8000d46:	4094      	lsls	r4, r2
 8000d48:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000d4c:	0c21      	lsrs	r1, r4, #16
 8000d4e:	fbbe f6f8 	udiv	r6, lr, r8
 8000d52:	fa1f f78c 	uxth.w	r7, ip
 8000d56:	fb08 e316 	mls	r3, r8, r6, lr
 8000d5a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000d5e:	fb06 f107 	mul.w	r1, r6, r7
 8000d62:	4299      	cmp	r1, r3
 8000d64:	d90a      	bls.n	8000d7c <__udivmoddi4+0x64>
 8000d66:	eb1c 0303 	adds.w	r3, ip, r3
 8000d6a:	f106 30ff 	add.w	r0, r6, #4294967295
 8000d6e:	f080 811f 	bcs.w	8000fb0 <__udivmoddi4+0x298>
 8000d72:	4299      	cmp	r1, r3
 8000d74:	f240 811c 	bls.w	8000fb0 <__udivmoddi4+0x298>
 8000d78:	3e02      	subs	r6, #2
 8000d7a:	4463      	add	r3, ip
 8000d7c:	1a5b      	subs	r3, r3, r1
 8000d7e:	b2a4      	uxth	r4, r4
 8000d80:	fbb3 f0f8 	udiv	r0, r3, r8
 8000d84:	fb08 3310 	mls	r3, r8, r0, r3
 8000d88:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000d8c:	fb00 f707 	mul.w	r7, r0, r7
 8000d90:	42a7      	cmp	r7, r4
 8000d92:	d90a      	bls.n	8000daa <__udivmoddi4+0x92>
 8000d94:	eb1c 0404 	adds.w	r4, ip, r4
 8000d98:	f100 33ff 	add.w	r3, r0, #4294967295
 8000d9c:	f080 810a 	bcs.w	8000fb4 <__udivmoddi4+0x29c>
 8000da0:	42a7      	cmp	r7, r4
 8000da2:	f240 8107 	bls.w	8000fb4 <__udivmoddi4+0x29c>
 8000da6:	4464      	add	r4, ip
 8000da8:	3802      	subs	r0, #2
 8000daa:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000dae:	1be4      	subs	r4, r4, r7
 8000db0:	2600      	movs	r6, #0
 8000db2:	b11d      	cbz	r5, 8000dbc <__udivmoddi4+0xa4>
 8000db4:	40d4      	lsrs	r4, r2
 8000db6:	2300      	movs	r3, #0
 8000db8:	e9c5 4300 	strd	r4, r3, [r5]
 8000dbc:	4631      	mov	r1, r6
 8000dbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000dc2:	428b      	cmp	r3, r1
 8000dc4:	d909      	bls.n	8000dda <__udivmoddi4+0xc2>
 8000dc6:	2d00      	cmp	r5, #0
 8000dc8:	f000 80ef 	beq.w	8000faa <__udivmoddi4+0x292>
 8000dcc:	2600      	movs	r6, #0
 8000dce:	e9c5 0100 	strd	r0, r1, [r5]
 8000dd2:	4630      	mov	r0, r6
 8000dd4:	4631      	mov	r1, r6
 8000dd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000dda:	fab3 f683 	clz	r6, r3
 8000dde:	2e00      	cmp	r6, #0
 8000de0:	d14a      	bne.n	8000e78 <__udivmoddi4+0x160>
 8000de2:	428b      	cmp	r3, r1
 8000de4:	d302      	bcc.n	8000dec <__udivmoddi4+0xd4>
 8000de6:	4282      	cmp	r2, r0
 8000de8:	f200 80f9 	bhi.w	8000fde <__udivmoddi4+0x2c6>
 8000dec:	1a84      	subs	r4, r0, r2
 8000dee:	eb61 0303 	sbc.w	r3, r1, r3
 8000df2:	2001      	movs	r0, #1
 8000df4:	469e      	mov	lr, r3
 8000df6:	2d00      	cmp	r5, #0
 8000df8:	d0e0      	beq.n	8000dbc <__udivmoddi4+0xa4>
 8000dfa:	e9c5 4e00 	strd	r4, lr, [r5]
 8000dfe:	e7dd      	b.n	8000dbc <__udivmoddi4+0xa4>
 8000e00:	b902      	cbnz	r2, 8000e04 <__udivmoddi4+0xec>
 8000e02:	deff      	udf	#255	; 0xff
 8000e04:	fab2 f282 	clz	r2, r2
 8000e08:	2a00      	cmp	r2, #0
 8000e0a:	f040 8092 	bne.w	8000f32 <__udivmoddi4+0x21a>
 8000e0e:	eba1 010c 	sub.w	r1, r1, ip
 8000e12:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000e16:	fa1f fe8c 	uxth.w	lr, ip
 8000e1a:	2601      	movs	r6, #1
 8000e1c:	0c20      	lsrs	r0, r4, #16
 8000e1e:	fbb1 f3f7 	udiv	r3, r1, r7
 8000e22:	fb07 1113 	mls	r1, r7, r3, r1
 8000e26:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000e2a:	fb0e f003 	mul.w	r0, lr, r3
 8000e2e:	4288      	cmp	r0, r1
 8000e30:	d908      	bls.n	8000e44 <__udivmoddi4+0x12c>
 8000e32:	eb1c 0101 	adds.w	r1, ip, r1
 8000e36:	f103 38ff 	add.w	r8, r3, #4294967295
 8000e3a:	d202      	bcs.n	8000e42 <__udivmoddi4+0x12a>
 8000e3c:	4288      	cmp	r0, r1
 8000e3e:	f200 80cb 	bhi.w	8000fd8 <__udivmoddi4+0x2c0>
 8000e42:	4643      	mov	r3, r8
 8000e44:	1a09      	subs	r1, r1, r0
 8000e46:	b2a4      	uxth	r4, r4
 8000e48:	fbb1 f0f7 	udiv	r0, r1, r7
 8000e4c:	fb07 1110 	mls	r1, r7, r0, r1
 8000e50:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000e54:	fb0e fe00 	mul.w	lr, lr, r0
 8000e58:	45a6      	cmp	lr, r4
 8000e5a:	d908      	bls.n	8000e6e <__udivmoddi4+0x156>
 8000e5c:	eb1c 0404 	adds.w	r4, ip, r4
 8000e60:	f100 31ff 	add.w	r1, r0, #4294967295
 8000e64:	d202      	bcs.n	8000e6c <__udivmoddi4+0x154>
 8000e66:	45a6      	cmp	lr, r4
 8000e68:	f200 80bb 	bhi.w	8000fe2 <__udivmoddi4+0x2ca>
 8000e6c:	4608      	mov	r0, r1
 8000e6e:	eba4 040e 	sub.w	r4, r4, lr
 8000e72:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8000e76:	e79c      	b.n	8000db2 <__udivmoddi4+0x9a>
 8000e78:	f1c6 0720 	rsb	r7, r6, #32
 8000e7c:	40b3      	lsls	r3, r6
 8000e7e:	fa22 fc07 	lsr.w	ip, r2, r7
 8000e82:	ea4c 0c03 	orr.w	ip, ip, r3
 8000e86:	fa20 f407 	lsr.w	r4, r0, r7
 8000e8a:	fa01 f306 	lsl.w	r3, r1, r6
 8000e8e:	431c      	orrs	r4, r3
 8000e90:	40f9      	lsrs	r1, r7
 8000e92:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000e96:	fa00 f306 	lsl.w	r3, r0, r6
 8000e9a:	fbb1 f8f9 	udiv	r8, r1, r9
 8000e9e:	0c20      	lsrs	r0, r4, #16
 8000ea0:	fa1f fe8c 	uxth.w	lr, ip
 8000ea4:	fb09 1118 	mls	r1, r9, r8, r1
 8000ea8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000eac:	fb08 f00e 	mul.w	r0, r8, lr
 8000eb0:	4288      	cmp	r0, r1
 8000eb2:	fa02 f206 	lsl.w	r2, r2, r6
 8000eb6:	d90b      	bls.n	8000ed0 <__udivmoddi4+0x1b8>
 8000eb8:	eb1c 0101 	adds.w	r1, ip, r1
 8000ebc:	f108 3aff 	add.w	sl, r8, #4294967295
 8000ec0:	f080 8088 	bcs.w	8000fd4 <__udivmoddi4+0x2bc>
 8000ec4:	4288      	cmp	r0, r1
 8000ec6:	f240 8085 	bls.w	8000fd4 <__udivmoddi4+0x2bc>
 8000eca:	f1a8 0802 	sub.w	r8, r8, #2
 8000ece:	4461      	add	r1, ip
 8000ed0:	1a09      	subs	r1, r1, r0
 8000ed2:	b2a4      	uxth	r4, r4
 8000ed4:	fbb1 f0f9 	udiv	r0, r1, r9
 8000ed8:	fb09 1110 	mls	r1, r9, r0, r1
 8000edc:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 8000ee0:	fb00 fe0e 	mul.w	lr, r0, lr
 8000ee4:	458e      	cmp	lr, r1
 8000ee6:	d908      	bls.n	8000efa <__udivmoddi4+0x1e2>
 8000ee8:	eb1c 0101 	adds.w	r1, ip, r1
 8000eec:	f100 34ff 	add.w	r4, r0, #4294967295
 8000ef0:	d26c      	bcs.n	8000fcc <__udivmoddi4+0x2b4>
 8000ef2:	458e      	cmp	lr, r1
 8000ef4:	d96a      	bls.n	8000fcc <__udivmoddi4+0x2b4>
 8000ef6:	3802      	subs	r0, #2
 8000ef8:	4461      	add	r1, ip
 8000efa:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000efe:	fba0 9402 	umull	r9, r4, r0, r2
 8000f02:	eba1 010e 	sub.w	r1, r1, lr
 8000f06:	42a1      	cmp	r1, r4
 8000f08:	46c8      	mov	r8, r9
 8000f0a:	46a6      	mov	lr, r4
 8000f0c:	d356      	bcc.n	8000fbc <__udivmoddi4+0x2a4>
 8000f0e:	d053      	beq.n	8000fb8 <__udivmoddi4+0x2a0>
 8000f10:	b15d      	cbz	r5, 8000f2a <__udivmoddi4+0x212>
 8000f12:	ebb3 0208 	subs.w	r2, r3, r8
 8000f16:	eb61 010e 	sbc.w	r1, r1, lr
 8000f1a:	fa01 f707 	lsl.w	r7, r1, r7
 8000f1e:	fa22 f306 	lsr.w	r3, r2, r6
 8000f22:	40f1      	lsrs	r1, r6
 8000f24:	431f      	orrs	r7, r3
 8000f26:	e9c5 7100 	strd	r7, r1, [r5]
 8000f2a:	2600      	movs	r6, #0
 8000f2c:	4631      	mov	r1, r6
 8000f2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000f32:	f1c2 0320 	rsb	r3, r2, #32
 8000f36:	40d8      	lsrs	r0, r3
 8000f38:	fa0c fc02 	lsl.w	ip, ip, r2
 8000f3c:	fa21 f303 	lsr.w	r3, r1, r3
 8000f40:	4091      	lsls	r1, r2
 8000f42:	4301      	orrs	r1, r0
 8000f44:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000f48:	fa1f fe8c 	uxth.w	lr, ip
 8000f4c:	fbb3 f0f7 	udiv	r0, r3, r7
 8000f50:	fb07 3610 	mls	r6, r7, r0, r3
 8000f54:	0c0b      	lsrs	r3, r1, #16
 8000f56:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8000f5a:	fb00 f60e 	mul.w	r6, r0, lr
 8000f5e:	429e      	cmp	r6, r3
 8000f60:	fa04 f402 	lsl.w	r4, r4, r2
 8000f64:	d908      	bls.n	8000f78 <__udivmoddi4+0x260>
 8000f66:	eb1c 0303 	adds.w	r3, ip, r3
 8000f6a:	f100 38ff 	add.w	r8, r0, #4294967295
 8000f6e:	d22f      	bcs.n	8000fd0 <__udivmoddi4+0x2b8>
 8000f70:	429e      	cmp	r6, r3
 8000f72:	d92d      	bls.n	8000fd0 <__udivmoddi4+0x2b8>
 8000f74:	3802      	subs	r0, #2
 8000f76:	4463      	add	r3, ip
 8000f78:	1b9b      	subs	r3, r3, r6
 8000f7a:	b289      	uxth	r1, r1
 8000f7c:	fbb3 f6f7 	udiv	r6, r3, r7
 8000f80:	fb07 3316 	mls	r3, r7, r6, r3
 8000f84:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000f88:	fb06 f30e 	mul.w	r3, r6, lr
 8000f8c:	428b      	cmp	r3, r1
 8000f8e:	d908      	bls.n	8000fa2 <__udivmoddi4+0x28a>
 8000f90:	eb1c 0101 	adds.w	r1, ip, r1
 8000f94:	f106 38ff 	add.w	r8, r6, #4294967295
 8000f98:	d216      	bcs.n	8000fc8 <__udivmoddi4+0x2b0>
 8000f9a:	428b      	cmp	r3, r1
 8000f9c:	d914      	bls.n	8000fc8 <__udivmoddi4+0x2b0>
 8000f9e:	3e02      	subs	r6, #2
 8000fa0:	4461      	add	r1, ip
 8000fa2:	1ac9      	subs	r1, r1, r3
 8000fa4:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 8000fa8:	e738      	b.n	8000e1c <__udivmoddi4+0x104>
 8000faa:	462e      	mov	r6, r5
 8000fac:	4628      	mov	r0, r5
 8000fae:	e705      	b.n	8000dbc <__udivmoddi4+0xa4>
 8000fb0:	4606      	mov	r6, r0
 8000fb2:	e6e3      	b.n	8000d7c <__udivmoddi4+0x64>
 8000fb4:	4618      	mov	r0, r3
 8000fb6:	e6f8      	b.n	8000daa <__udivmoddi4+0x92>
 8000fb8:	454b      	cmp	r3, r9
 8000fba:	d2a9      	bcs.n	8000f10 <__udivmoddi4+0x1f8>
 8000fbc:	ebb9 0802 	subs.w	r8, r9, r2
 8000fc0:	eb64 0e0c 	sbc.w	lr, r4, ip
 8000fc4:	3801      	subs	r0, #1
 8000fc6:	e7a3      	b.n	8000f10 <__udivmoddi4+0x1f8>
 8000fc8:	4646      	mov	r6, r8
 8000fca:	e7ea      	b.n	8000fa2 <__udivmoddi4+0x28a>
 8000fcc:	4620      	mov	r0, r4
 8000fce:	e794      	b.n	8000efa <__udivmoddi4+0x1e2>
 8000fd0:	4640      	mov	r0, r8
 8000fd2:	e7d1      	b.n	8000f78 <__udivmoddi4+0x260>
 8000fd4:	46d0      	mov	r8, sl
 8000fd6:	e77b      	b.n	8000ed0 <__udivmoddi4+0x1b8>
 8000fd8:	3b02      	subs	r3, #2
 8000fda:	4461      	add	r1, ip
 8000fdc:	e732      	b.n	8000e44 <__udivmoddi4+0x12c>
 8000fde:	4630      	mov	r0, r6
 8000fe0:	e709      	b.n	8000df6 <__udivmoddi4+0xde>
 8000fe2:	4464      	add	r4, ip
 8000fe4:	3802      	subs	r0, #2
 8000fe6:	e742      	b.n	8000e6e <__udivmoddi4+0x156>

08000fe8 <__aeabi_idiv0>:
 8000fe8:	4770      	bx	lr
 8000fea:	bf00      	nop

08000fec <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000fec:	490e      	ldr	r1, [pc, #56]	; (8001028 <HAL_InitTick+0x3c>)
 8000fee:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000ff2:	4a0e      	ldr	r2, [pc, #56]	; (800102c <HAL_InitTick+0x40>)
{
 8000ff4:	b510      	push	{r4, lr}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000ff6:	7809      	ldrb	r1, [r1, #0]
{
 8000ff8:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000ffa:	6812      	ldr	r2, [r2, #0]
 8000ffc:	fbb3 f3f1 	udiv	r3, r3, r1
 8001000:	fbb2 f0f3 	udiv	r0, r2, r3
 8001004:	f000 f8e2 	bl	80011cc <HAL_SYSTICK_Config>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001008:	b908      	cbnz	r0, 800100e <HAL_InitTick+0x22>
 800100a:	2c0f      	cmp	r4, #15
 800100c:	d901      	bls.n	8001012 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800100e:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 8001010:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001012:	2200      	movs	r2, #0
 8001014:	4621      	mov	r1, r4
 8001016:	f04f 30ff 	mov.w	r0, #4294967295
 800101a:	f000 f85f 	bl	80010dc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800101e:	4b04      	ldr	r3, [pc, #16]	; (8001030 <HAL_InitTick+0x44>)
 8001020:	2000      	movs	r0, #0
 8001022:	601c      	str	r4, [r3, #0]
}
 8001024:	bd10      	pop	{r4, pc}
 8001026:	bf00      	nop
 8001028:	20000000 	.word	0x20000000
 800102c:	20000078 	.word	0x20000078
 8001030:	20000004 	.word	0x20000004

08001034 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001034:	4a07      	ldr	r2, [pc, #28]	; (8001054 <HAL_Init+0x20>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001036:	2003      	movs	r0, #3
{
 8001038:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800103a:	6813      	ldr	r3, [r2, #0]
 800103c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001040:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001042:	f000 f82d 	bl	80010a0 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8001046:	2000      	movs	r0, #0
 8001048:	f7ff ffd0 	bl	8000fec <HAL_InitTick>
  HAL_MspInit();
 800104c:	f01c f9d8 	bl	801d400 <HAL_MspInit>
}
 8001050:	2000      	movs	r0, #0
 8001052:	bd08      	pop	{r3, pc}
 8001054:	40023c00 	.word	0x40023c00

08001058 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8001058:	4a03      	ldr	r2, [pc, #12]	; (8001068 <HAL_IncTick+0x10>)
 800105a:	4b04      	ldr	r3, [pc, #16]	; (800106c <HAL_IncTick+0x14>)
 800105c:	6811      	ldr	r1, [r2, #0]
 800105e:	781b      	ldrb	r3, [r3, #0]
 8001060:	440b      	add	r3, r1
 8001062:	6013      	str	r3, [r2, #0]
}
 8001064:	4770      	bx	lr
 8001066:	bf00      	nop
 8001068:	2000012c 	.word	0x2000012c
 800106c:	20000000 	.word	0x20000000

08001070 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001070:	4b01      	ldr	r3, [pc, #4]	; (8001078 <HAL_GetTick+0x8>)
 8001072:	6818      	ldr	r0, [r3, #0]
}
 8001074:	4770      	bx	lr
 8001076:	bf00      	nop
 8001078:	2000012c 	.word	0x2000012c

0800107c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800107c:	b538      	push	{r3, r4, r5, lr}
 800107e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001080:	f7ff fff6 	bl	8001070 <HAL_GetTick>
 8001084:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001086:	1c63      	adds	r3, r4, #1
 8001088:	d002      	beq.n	8001090 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800108a:	4b04      	ldr	r3, [pc, #16]	; (800109c <HAL_Delay+0x20>)
 800108c:	781b      	ldrb	r3, [r3, #0]
 800108e:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8001090:	f7ff ffee 	bl	8001070 <HAL_GetTick>
 8001094:	1b43      	subs	r3, r0, r5
 8001096:	42a3      	cmp	r3, r4
 8001098:	d3fa      	bcc.n	8001090 <HAL_Delay+0x14>
  {
  }
}
 800109a:	bd38      	pop	{r3, r4, r5, pc}
 800109c:	20000000 	.word	0x20000000

080010a0 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80010a0:	1ec3      	subs	r3, r0, #3
 80010a2:	2b04      	cmp	r3, #4
{
 80010a4:	b510      	push	{r4, lr}
 80010a6:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80010a8:	d80c      	bhi.n	80010c4 <HAL_NVIC_SetPriorityGrouping+0x24>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80010aa:	4909      	ldr	r1, [pc, #36]	; (80010d0 <HAL_NVIC_SetPriorityGrouping+0x30>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80010ac:	0224      	lsls	r4, r4, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80010ae:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 80010b2:	4b08      	ldr	r3, [pc, #32]	; (80010d4 <HAL_NVIC_SetPriorityGrouping+0x34>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80010b4:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80010b6:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80010ba:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80010bc:	4314      	orrs	r4, r2
  reg_value  =  (reg_value                                   |
 80010be:	4323      	orrs	r3, r4
  SCB->AIRCR =  reg_value;
 80010c0:	60cb      	str	r3, [r1, #12]
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80010c2:	bd10      	pop	{r4, pc}
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80010c4:	2192      	movs	r1, #146	; 0x92
 80010c6:	4804      	ldr	r0, [pc, #16]	; (80010d8 <HAL_NVIC_SetPriorityGrouping+0x38>)
 80010c8:	f019 feec 	bl	801aea4 <assert_failed>
 80010cc:	e7ed      	b.n	80010aa <HAL_NVIC_SetPriorityGrouping+0xa>
 80010ce:	bf00      	nop
 80010d0:	e000ed00 	.word	0xe000ed00
 80010d4:	05fa0000 	.word	0x05fa0000
 80010d8:	080214e0 	.word	0x080214e0

080010dc <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  uint32_t prioritygroup = 0x00;
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80010dc:	2a0f      	cmp	r2, #15
{ 
 80010de:	b570      	push	{r4, r5, r6, lr}
 80010e0:	4616      	mov	r6, r2
 80010e2:	4605      	mov	r5, r0
 80010e4:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80010e6:	d836      	bhi.n	8001156 <HAL_NVIC_SetPriority+0x7a>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 80010e8:	2c0f      	cmp	r4, #15
 80010ea:	d82f      	bhi.n	800114c <HAL_NVIC_SetPriority+0x70>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80010ec:	4b1c      	ldr	r3, [pc, #112]	; (8001160 <HAL_NVIC_SetPriority+0x84>)
 80010ee:	68db      	ldr	r3, [r3, #12]
 80010f0:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80010f4:	f1c3 0007 	rsb	r0, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80010f8:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80010fa:	2804      	cmp	r0, #4
 80010fc:	bf28      	it	cs
 80010fe:	2004      	movcs	r0, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001100:	2a06      	cmp	r2, #6
 8001102:	d918      	bls.n	8001136 <HAL_NVIC_SetPriority+0x5a>
 8001104:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001106:	f04f 32ff 	mov.w	r2, #4294967295
 800110a:	409a      	lsls	r2, r3
 800110c:	ea26 0602 	bic.w	r6, r6, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001110:	f04f 31ff 	mov.w	r1, #4294967295
  if ((int32_t)(IRQn) >= 0)
 8001114:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001116:	fa01 f100 	lsl.w	r1, r1, r0
 800111a:	ea24 0401 	bic.w	r4, r4, r1
 800111e:	fa04 f403 	lsl.w	r4, r4, r3
 8001122:	ea44 0406 	orr.w	r4, r4, r6
  if ((int32_t)(IRQn) >= 0)
 8001126:	db09      	blt.n	800113c <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001128:	0124      	lsls	r4, r4, #4
 800112a:	4b0e      	ldr	r3, [pc, #56]	; (8001164 <HAL_NVIC_SetPriority+0x88>)
 800112c:	b2e4      	uxtb	r4, r4
 800112e:	442b      	add	r3, r5
 8001130:	f883 4300 	strb.w	r4, [r3, #768]	; 0x300
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001134:	bd70      	pop	{r4, r5, r6, pc}
 8001136:	2600      	movs	r6, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001138:	4633      	mov	r3, r6
 800113a:	e7e9      	b.n	8001110 <HAL_NVIC_SetPriority+0x34>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800113c:	f005 050f 	and.w	r5, r5, #15
 8001140:	0124      	lsls	r4, r4, #4
 8001142:	4b09      	ldr	r3, [pc, #36]	; (8001168 <HAL_NVIC_SetPriority+0x8c>)
 8001144:	b2e4      	uxtb	r4, r4
 8001146:	442b      	add	r3, r5
 8001148:	761c      	strb	r4, [r3, #24]
 800114a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 800114c:	21ab      	movs	r1, #171	; 0xab
 800114e:	4807      	ldr	r0, [pc, #28]	; (800116c <HAL_NVIC_SetPriority+0x90>)
 8001150:	f019 fea8 	bl	801aea4 <assert_failed>
 8001154:	e7ca      	b.n	80010ec <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 8001156:	21aa      	movs	r1, #170	; 0xaa
 8001158:	4804      	ldr	r0, [pc, #16]	; (800116c <HAL_NVIC_SetPriority+0x90>)
 800115a:	f019 fea3 	bl	801aea4 <assert_failed>
 800115e:	e7c3      	b.n	80010e8 <HAL_NVIC_SetPriority+0xc>
 8001160:	e000ed00 	.word	0xe000ed00
 8001164:	e000e100 	.word	0xe000e100
 8001168:	e000ecfc 	.word	0xe000ecfc
 800116c:	080214e0 	.word	0x080214e0

08001170 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8001170:	2800      	cmp	r0, #0
 8001172:	db08      	blt.n	8001186 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001174:	f000 011f 	and.w	r1, r0, #31
 8001178:	2301      	movs	r3, #1
 800117a:	0940      	lsrs	r0, r0, #5
 800117c:	4a04      	ldr	r2, [pc, #16]	; (8001190 <HAL_NVIC_EnableIRQ+0x20>)
 800117e:	408b      	lsls	r3, r1
 8001180:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8001184:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8001186:	21be      	movs	r1, #190	; 0xbe
 8001188:	4802      	ldr	r0, [pc, #8]	; (8001194 <HAL_NVIC_EnableIRQ+0x24>)
 800118a:	f019 be8b 	b.w	801aea4 <assert_failed>
 800118e:	bf00      	nop
 8001190:	e000e100 	.word	0xe000e100
 8001194:	080214e0 	.word	0x080214e0

08001198 <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8001198:	2800      	cmp	r0, #0
 800119a:	db0e      	blt.n	80011ba <HAL_NVIC_DisableIRQ+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800119c:	0943      	lsrs	r3, r0, #5
 800119e:	2201      	movs	r2, #1
 80011a0:	f000 001f 	and.w	r0, r0, #31
 80011a4:	4907      	ldr	r1, [pc, #28]	; (80011c4 <HAL_NVIC_DisableIRQ+0x2c>)
 80011a6:	3320      	adds	r3, #32
 80011a8:	fa02 f000 	lsl.w	r0, r2, r0
 80011ac:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80011b0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80011b4:	f3bf 8f6f 	isb	sy
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80011b8:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 80011ba:	21ce      	movs	r1, #206	; 0xce
 80011bc:	4802      	ldr	r0, [pc, #8]	; (80011c8 <HAL_NVIC_DisableIRQ+0x30>)
 80011be:	f019 be71 	b.w	801aea4 <assert_failed>
 80011c2:	bf00      	nop
 80011c4:	e000e100 	.word	0xe000e100
 80011c8:	080214e0 	.word	0x080214e0

080011cc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80011cc:	1e43      	subs	r3, r0, #1
 80011ce:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80011d2:	d20c      	bcs.n	80011ee <HAL_SYSTICK_Config+0x22>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80011d4:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80011d8:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80011da:	4906      	ldr	r1, [pc, #24]	; (80011f4 <HAL_SYSTICK_Config+0x28>)
 80011dc:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80011e0:	6153      	str	r3, [r2, #20]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80011e2:	2307      	movs	r3, #7
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80011e4:	f881 c023 	strb.w	ip, [r1, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80011e8:	6190      	str	r0, [r2, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80011ea:	6113      	str	r3, [r2, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80011ec:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80011ee:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop
 80011f4:	e000ed00 	.word	0xe000ed00

080011f8 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 80011f8:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80011fc:	4b04      	ldr	r3, [pc, #16]	; (8001210 <HAL_MPU_Disable+0x18>)
  
  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 80011fe:	2100      	movs	r1, #0
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8001200:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001202:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001206:	625a      	str	r2, [r3, #36]	; 0x24
  MPU->CTRL = 0;
 8001208:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
}
 800120c:	4770      	bx	lr
 800120e:	bf00      	nop
 8001210:	e000ed00 	.word	0xe000ed00

08001214 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8001214:	4b06      	ldr	r3, [pc, #24]	; (8001230 <HAL_MPU_Enable+0x1c>)
 8001216:	f040 0001 	orr.w	r0, r0, #1
 800121a:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800121e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001220:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001224:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8001226:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800122a:	f3bf 8f6f 	isb	sy
  
  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800122e:	4770      	bx	lr
 8001230:	e000ed00 	.word	0xe000ed00

08001234 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8001234:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 8001236:	7843      	ldrb	r3, [r0, #1]
{
 8001238:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800123a:	2b07      	cmp	r3, #7
 800123c:	d874      	bhi.n	8001328 <HAL_MPU_ConfigRegion+0xf4>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
 800123e:	7823      	ldrb	r3, [r4, #0]
 8001240:	2b01      	cmp	r3, #1
 8001242:	d905      	bls.n	8001250 <HAL_MPU_ConfigRegion+0x1c>
 8001244:	f44f 7198 	mov.w	r1, #304	; 0x130
 8001248:	484c      	ldr	r0, [pc, #304]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800124a:	f019 fe2b 	bl	801aea4 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;

  if ((MPU_Init->Enable) != RESET)
 800124e:	7823      	ldrb	r3, [r4, #0]
  MPU->RNR = MPU_Init->Number;
 8001250:	7861      	ldrb	r1, [r4, #1]
 8001252:	4a4b      	ldr	r2, [pc, #300]	; (8001380 <HAL_MPU_ConfigRegion+0x14c>)
 8001254:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98
  if ((MPU_Init->Enable) != RESET)
 8001258:	2b00      	cmp	r3, #0
 800125a:	d03b      	beq.n	80012d4 <HAL_MPU_ConfigRegion+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 800125c:	7b23      	ldrb	r3, [r4, #12]
 800125e:	2b01      	cmp	r3, #1
 8001260:	d83d      	bhi.n	80012de <HAL_MPU_ConfigRegion+0xaa>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 8001262:	7ae3      	ldrb	r3, [r4, #11]
 8001264:	1f5a      	subs	r2, r3, #5
 8001266:	2a01      	cmp	r2, #1
 8001268:	d901      	bls.n	800126e <HAL_MPU_ConfigRegion+0x3a>
 800126a:	2b03      	cmp	r3, #3
 800126c:	d872      	bhi.n	8001354 <HAL_MPU_ConfigRegion+0x120>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 800126e:	7aa3      	ldrb	r3, [r4, #10]
 8001270:	2b02      	cmp	r3, #2
 8001272:	d85f      	bhi.n	8001334 <HAL_MPU_ConfigRegion+0x100>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8001274:	7b63      	ldrb	r3, [r4, #13]
 8001276:	2b01      	cmp	r3, #1
 8001278:	d84d      	bhi.n	8001316 <HAL_MPU_ConfigRegion+0xe2>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 800127a:	7ba3      	ldrb	r3, [r4, #14]
 800127c:	2b01      	cmp	r3, #1
 800127e:	d841      	bhi.n	8001304 <HAL_MPU_ConfigRegion+0xd0>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 8001280:	7be3      	ldrb	r3, [r4, #15]
 8001282:	2b01      	cmp	r3, #1
 8001284:	d835      	bhi.n	80012f2 <HAL_MPU_ConfigRegion+0xbe>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 8001286:	7a63      	ldrb	r3, [r4, #9]
 8001288:	2bff      	cmp	r3, #255	; 0xff
 800128a:	d06c      	beq.n	8001366 <HAL_MPU_ConfigRegion+0x132>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 800128c:	7a22      	ldrb	r2, [r4, #8]
 800128e:	1f13      	subs	r3, r2, #4
 8001290:	2b1b      	cmp	r3, #27
 8001292:	d858      	bhi.n	8001346 <HAL_MPU_ConfigRegion+0x112>
    
    MPU->RBAR = MPU_Init->BaseAddress;
 8001294:	6863      	ldr	r3, [r4, #4]
 8001296:	493a      	ldr	r1, [pc, #232]	; (8001380 <HAL_MPU_ConfigRegion+0x14c>)
 8001298:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800129c:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800129e:	7b20      	ldrb	r0, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80012a0:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80012a2:	f894 c00f 	ldrb.w	ip, [r4, #15]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80012a6:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 80012aa:	7820      	ldrb	r0, [r4, #0]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80012ac:	4303      	orrs	r3, r0
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80012ae:	7aa0      	ldrb	r0, [r4, #10]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80012b0:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80012b4:	7b60      	ldrb	r0, [r4, #13]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80012b6:	ea43 4380 	orr.w	r3, r3, r0, lsl #18
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80012ba:	7ba0      	ldrb	r0, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80012bc:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80012c0:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80012c2:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 80012c6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80012ca:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80012ce:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 80012d2:	bd10      	pop	{r4, pc}
    MPU->RBAR = 0x00;
 80012d4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    MPU->RASR = 0x00;
 80012d8:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
}
 80012dc:	bd10      	pop	{r4, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 80012de:	f44f 719c 	mov.w	r1, #312	; 0x138
 80012e2:	4826      	ldr	r0, [pc, #152]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 80012e4:	f019 fdde 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 80012e8:	7ae3      	ldrb	r3, [r4, #11]
 80012ea:	1f5a      	subs	r2, r3, #5
 80012ec:	2a01      	cmp	r2, #1
 80012ee:	d8bc      	bhi.n	800126a <HAL_MPU_ConfigRegion+0x36>
 80012f0:	e7bd      	b.n	800126e <HAL_MPU_ConfigRegion+0x3a>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 80012f2:	f240 113d 	movw	r1, #317	; 0x13d
 80012f6:	4821      	ldr	r0, [pc, #132]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 80012f8:	f019 fdd4 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 80012fc:	7a63      	ldrb	r3, [r4, #9]
 80012fe:	2bff      	cmp	r3, #255	; 0xff
 8001300:	d1c4      	bne.n	800128c <HAL_MPU_ConfigRegion+0x58>
 8001302:	e030      	b.n	8001366 <HAL_MPU_ConfigRegion+0x132>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8001304:	f44f 719e 	mov.w	r1, #316	; 0x13c
 8001308:	481c      	ldr	r0, [pc, #112]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800130a:	f019 fdcb 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 800130e:	7be3      	ldrb	r3, [r4, #15]
 8001310:	2b01      	cmp	r3, #1
 8001312:	d9b8      	bls.n	8001286 <HAL_MPU_ConfigRegion+0x52>
 8001314:	e7ed      	b.n	80012f2 <HAL_MPU_ConfigRegion+0xbe>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8001316:	f240 113b 	movw	r1, #315	; 0x13b
 800131a:	4818      	ldr	r0, [pc, #96]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800131c:	f019 fdc2 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8001320:	7ba3      	ldrb	r3, [r4, #14]
 8001322:	2b01      	cmp	r3, #1
 8001324:	d9ac      	bls.n	8001280 <HAL_MPU_ConfigRegion+0x4c>
 8001326:	e7ed      	b.n	8001304 <HAL_MPU_ConfigRegion+0xd0>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 8001328:	f240 112f 	movw	r1, #303	; 0x12f
 800132c:	4813      	ldr	r0, [pc, #76]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800132e:	f019 fdb9 	bl	801aea4 <assert_failed>
 8001332:	e784      	b.n	800123e <HAL_MPU_ConfigRegion+0xa>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 8001334:	f44f 719d 	mov.w	r1, #314	; 0x13a
 8001338:	4810      	ldr	r0, [pc, #64]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800133a:	f019 fdb3 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 800133e:	7b63      	ldrb	r3, [r4, #13]
 8001340:	2b01      	cmp	r3, #1
 8001342:	d99a      	bls.n	800127a <HAL_MPU_ConfigRegion+0x46>
 8001344:	e7e7      	b.n	8001316 <HAL_MPU_ConfigRegion+0xe2>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 8001346:	f240 113f 	movw	r1, #319	; 0x13f
 800134a:	480c      	ldr	r0, [pc, #48]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800134c:	f019 fdaa 	bl	801aea4 <assert_failed>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8001350:	7a22      	ldrb	r2, [r4, #8]
 8001352:	e79f      	b.n	8001294 <HAL_MPU_ConfigRegion+0x60>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 8001354:	f240 1139 	movw	r1, #313	; 0x139
 8001358:	4808      	ldr	r0, [pc, #32]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800135a:	f019 fda3 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 800135e:	7aa3      	ldrb	r3, [r4, #10]
 8001360:	2b02      	cmp	r3, #2
 8001362:	d987      	bls.n	8001274 <HAL_MPU_ConfigRegion+0x40>
 8001364:	e7e6      	b.n	8001334 <HAL_MPU_ConfigRegion+0x100>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 8001366:	f44f 719f 	mov.w	r1, #318	; 0x13e
 800136a:	4804      	ldr	r0, [pc, #16]	; (800137c <HAL_MPU_ConfigRegion+0x148>)
 800136c:	f019 fd9a 	bl	801aea4 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 8001370:	7a22      	ldrb	r2, [r4, #8]
 8001372:	1f13      	subs	r3, r2, #4
 8001374:	2b1b      	cmp	r3, #27
 8001376:	d98d      	bls.n	8001294 <HAL_MPU_ConfigRegion+0x60>
 8001378:	e7e5      	b.n	8001346 <HAL_MPU_ConfigRegion+0x112>
 800137a:	bf00      	nop
 800137c:	080214e0 	.word	0x080214e0
 8001380:	e000ed00 	.word	0xe000ed00

08001384 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8001384:	b538      	push	{r3, r4, r5, lr}
 8001386:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8001388:	f7ff fe72 	bl	8001070 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800138c:	2c00      	cmp	r4, #0
 800138e:	f000 8135 	beq.w	80015fc <HAL_DMA_Init+0x278>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
 8001392:	6822      	ldr	r2, [r4, #0]
 8001394:	4605      	mov	r5, r0
 8001396:	4bad      	ldr	r3, [pc, #692]	; (800164c <HAL_DMA_Init+0x2c8>)
 8001398:	49ad      	ldr	r1, [pc, #692]	; (8001650 <HAL_DMA_Init+0x2cc>)
 800139a:	429a      	cmp	r2, r3
 800139c:	bf18      	it	ne
 800139e:	428a      	cmpne	r2, r1
 80013a0:	f101 0118 	add.w	r1, r1, #24
 80013a4:	bf14      	ite	ne
 80013a6:	2301      	movne	r3, #1
 80013a8:	2300      	moveq	r3, #0
 80013aa:	428a      	cmp	r2, r1
 80013ac:	bf0c      	ite	eq
 80013ae:	2300      	moveq	r3, #0
 80013b0:	f003 0301 	andne.w	r3, r3, #1
 80013b4:	3118      	adds	r1, #24
 80013b6:	428a      	cmp	r2, r1
 80013b8:	bf0c      	ite	eq
 80013ba:	2300      	moveq	r3, #0
 80013bc:	f003 0301 	andne.w	r3, r3, #1
 80013c0:	3118      	adds	r1, #24
 80013c2:	428a      	cmp	r2, r1
 80013c4:	bf0c      	ite	eq
 80013c6:	2300      	moveq	r3, #0
 80013c8:	f003 0301 	andne.w	r3, r3, #1
 80013cc:	3118      	adds	r1, #24
 80013ce:	428a      	cmp	r2, r1
 80013d0:	bf0c      	ite	eq
 80013d2:	2300      	moveq	r3, #0
 80013d4:	f003 0301 	andne.w	r3, r3, #1
 80013d8:	3118      	adds	r1, #24
 80013da:	428a      	cmp	r2, r1
 80013dc:	bf0c      	ite	eq
 80013de:	2300      	moveq	r3, #0
 80013e0:	f003 0301 	andne.w	r3, r3, #1
 80013e4:	3118      	adds	r1, #24
 80013e6:	428a      	cmp	r2, r1
 80013e8:	bf0c      	ite	eq
 80013ea:	2300      	moveq	r3, #0
 80013ec:	f003 0301 	andne.w	r3, r3, #1
 80013f0:	f501 7156 	add.w	r1, r1, #856	; 0x358
 80013f4:	428a      	cmp	r2, r1
 80013f6:	bf0c      	ite	eq
 80013f8:	2300      	moveq	r3, #0
 80013fa:	f003 0301 	andne.w	r3, r3, #1
 80013fe:	3118      	adds	r1, #24
 8001400:	428a      	cmp	r2, r1
 8001402:	bf0c      	ite	eq
 8001404:	2300      	moveq	r3, #0
 8001406:	f003 0301 	andne.w	r3, r3, #1
 800140a:	3118      	adds	r1, #24
 800140c:	428a      	cmp	r2, r1
 800140e:	bf0c      	ite	eq
 8001410:	2300      	moveq	r3, #0
 8001412:	f003 0301 	andne.w	r3, r3, #1
 8001416:	3118      	adds	r1, #24
 8001418:	428a      	cmp	r2, r1
 800141a:	bf0c      	ite	eq
 800141c:	2300      	moveq	r3, #0
 800141e:	f003 0301 	andne.w	r3, r3, #1
 8001422:	3118      	adds	r1, #24
 8001424:	428a      	cmp	r2, r1
 8001426:	bf0c      	ite	eq
 8001428:	2300      	moveq	r3, #0
 800142a:	f003 0301 	andne.w	r3, r3, #1
 800142e:	3118      	adds	r1, #24
 8001430:	428a      	cmp	r2, r1
 8001432:	bf0c      	ite	eq
 8001434:	2300      	moveq	r3, #0
 8001436:	f003 0301 	andne.w	r3, r3, #1
 800143a:	3118      	adds	r1, #24
 800143c:	428a      	cmp	r2, r1
 800143e:	bf0c      	ite	eq
 8001440:	2300      	moveq	r3, #0
 8001442:	f003 0301 	andne.w	r3, r3, #1
 8001446:	b11b      	cbz	r3, 8001450 <HAL_DMA_Init+0xcc>
 8001448:	4b82      	ldr	r3, [pc, #520]	; (8001654 <HAL_DMA_Init+0x2d0>)
 800144a:	429a      	cmp	r2, r3
 800144c:	f040 811f 	bne.w	800168e <HAL_DMA_Init+0x30a>
  assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
 8001450:	6863      	ldr	r3, [r4, #4]
 8001452:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8001456:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800145a:	d002      	beq.n	8001462 <HAL_DMA_Init+0xde>
 800145c:	2b00      	cmp	r3, #0
 800145e:	f040 8111 	bne.w	8001684 <HAL_DMA_Init+0x300>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8001462:	68a3      	ldr	r3, [r4, #8]
 8001464:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 8001468:	d002      	beq.n	8001470 <HAL_DMA_Init+0xec>
 800146a:	2b80      	cmp	r3, #128	; 0x80
 800146c:	f040 80a8 	bne.w	80015c0 <HAL_DMA_Init+0x23c>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8001470:	68e3      	ldr	r3, [r4, #12]
 8001472:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8001476:	f040 80ac 	bne.w	80015d2 <HAL_DMA_Init+0x24e>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 800147a:	6923      	ldr	r3, [r4, #16]
 800147c:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 8001480:	f040 80b0 	bne.w	80015e4 <HAL_DMA_Init+0x260>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8001484:	6963      	ldr	r3, [r4, #20]
 8001486:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 800148a:	d003      	beq.n	8001494 <HAL_DMA_Init+0x110>
 800148c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001490:	f040 8091 	bne.w	80015b6 <HAL_DMA_Init+0x232>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8001494:	69a3      	ldr	r3, [r4, #24]
 8001496:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
 800149a:	d003      	beq.n	80014a4 <HAL_DMA_Init+0x120>
 800149c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80014a0:	f040 8084 	bne.w	80015ac <HAL_DMA_Init+0x228>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 80014a4:	69e3      	ldr	r3, [r4, #28]
 80014a6:	f033 0220 	bics.w	r2, r3, #32
 80014aa:	d002      	beq.n	80014b2 <HAL_DMA_Init+0x12e>
 80014ac:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80014b0:	d16f      	bne.n	8001592 <HAL_DMA_Init+0x20e>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 80014b2:	6a23      	ldr	r3, [r4, #32]
 80014b4:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
 80014b8:	d173      	bne.n	80015a2 <HAL_DMA_Init+0x21e>
  assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 80014ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80014bc:	f033 0204 	bics.w	r2, r3, #4
 80014c0:	d15f      	bne.n	8001582 <HAL_DMA_Init+0x1fe>
  /* Check the memory burst, peripheral burst and FIFO threshold parameters only
     when FIFO mode is enabled */
  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 80014c2:	2b00      	cmp	r3, #0
 80014c4:	d14d      	bne.n	8001562 <HAL_DMA_Init+0x1de>

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80014c6:	6823      	ldr	r3, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 80014c8:	2202      	movs	r2, #2
  __HAL_UNLOCK(hdma);
 80014ca:	2100      	movs	r1, #0
  hdma->State = HAL_DMA_STATE_BUSY;
 80014cc:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
 80014d0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 80014d4:	681a      	ldr	r2, [r3, #0]
 80014d6:	f022 0201 	bic.w	r2, r2, #1
 80014da:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80014dc:	e006      	b.n	80014ec <HAL_DMA_Init+0x168>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80014de:	f7ff fdc7 	bl	8001070 <HAL_GetTick>
 80014e2:	1b40      	subs	r0, r0, r5
 80014e4:	2805      	cmp	r0, #5
 80014e6:	f200 8082 	bhi.w	80015ee <HAL_DMA_Init+0x26a>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80014ea:	6823      	ldr	r3, [r4, #0]
 80014ec:	681a      	ldr	r2, [r3, #0]
 80014ee:	07d1      	lsls	r1, r2, #31
 80014f0:	d4f5      	bmi.n	80014de <HAL_DMA_Init+0x15a>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80014f2:	e9d4 2501 	ldrd	r2, r5, [r4, #4]
 80014f6:	68e1      	ldr	r1, [r4, #12]
 80014f8:	432a      	orrs	r2, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80014fa:	69a0      	ldr	r0, [r4, #24]
  tmp = hdma->Instance->CR;
 80014fc:	681d      	ldr	r5, [r3, #0]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80014fe:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001500:	6921      	ldr	r1, [r4, #16]
 8001502:	430a      	orrs	r2, r1
 8001504:	6961      	ldr	r1, [r4, #20]
 8001506:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001508:	69e1      	ldr	r1, [r4, #28]
 800150a:	4302      	orrs	r2, r0
 800150c:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800150e:	4952      	ldr	r1, [pc, #328]	; (8001658 <HAL_DMA_Init+0x2d4>)
 8001510:	4029      	ands	r1, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8001512:	6a25      	ldr	r5, [r4, #32]
 8001514:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001516:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001518:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800151a:	2904      	cmp	r1, #4
 800151c:	d070      	beq.n	8001600 <HAL_DMA_Init+0x27c>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800151e:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8001520:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001522:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8001526:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001528:	b2da      	uxtb	r2, r3
  hdma->Instance->FCR = tmp;
 800152a:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800152c:	494b      	ldr	r1, [pc, #300]	; (800165c <HAL_DMA_Init+0x2d8>)
 800152e:	3a10      	subs	r2, #16
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001530:	484b      	ldr	r0, [pc, #300]	; (8001660 <HAL_DMA_Init+0x2dc>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001532:	fba1 5102 	umull	r5, r1, r1, r2
  
  if (stream_number > 3U)
 8001536:	2a5f      	cmp	r2, #95	; 0x5f
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001538:	4a4a      	ldr	r2, [pc, #296]	; (8001664 <HAL_DMA_Init+0x2e0>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800153a:	ea4f 1111 	mov.w	r1, r1, lsr #4
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800153e:	ea02 0203 	and.w	r2, r2, r3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001542:	f04f 033f 	mov.w	r3, #63	; 0x3f
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001546:	5c41      	ldrb	r1, [r0, r1]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001548:	f04f 0000 	mov.w	r0, #0
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800154c:	bf88      	it	hi
 800154e:	3204      	addhi	r2, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001550:	408b      	lsls	r3, r1
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001552:	65e1      	str	r1, [r4, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001554:	65a2      	str	r2, [r4, #88]	; 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001556:	6093      	str	r3, [r2, #8]
  hdma->State = HAL_DMA_STATE_READY;
 8001558:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800155a:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 800155c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8001560:	bd38      	pop	{r3, r4, r5, pc}
    assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 8001562:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001564:	2b03      	cmp	r3, #3
 8001566:	d86c      	bhi.n	8001642 <HAL_DMA_Init+0x2be>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 8001568:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800156a:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
 800156e:	d17d      	bne.n	800166c <HAL_DMA_Init+0x2e8>
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
 8001570:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001572:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
 8001576:	d0a6      	beq.n	80014c6 <HAL_DMA_Init+0x142>
 8001578:	21c9      	movs	r1, #201	; 0xc9
 800157a:	483b      	ldr	r0, [pc, #236]	; (8001668 <HAL_DMA_Init+0x2e4>)
 800157c:	f019 fc92 	bl	801aea4 <assert_failed>
 8001580:	e7a1      	b.n	80014c6 <HAL_DMA_Init+0x142>
  assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 8001582:	21c2      	movs	r1, #194	; 0xc2
 8001584:	4838      	ldr	r0, [pc, #224]	; (8001668 <HAL_DMA_Init+0x2e4>)
 8001586:	f019 fc8d 	bl	801aea4 <assert_failed>
  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 800158a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800158c:	2b00      	cmp	r3, #0
 800158e:	d09a      	beq.n	80014c6 <HAL_DMA_Init+0x142>
 8001590:	e7e7      	b.n	8001562 <HAL_DMA_Init+0x1de>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8001592:	21c0      	movs	r1, #192	; 0xc0
 8001594:	4834      	ldr	r0, [pc, #208]	; (8001668 <HAL_DMA_Init+0x2e4>)
 8001596:	f019 fc85 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 800159a:	6a23      	ldr	r3, [r4, #32]
 800159c:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
 80015a0:	d08b      	beq.n	80014ba <HAL_DMA_Init+0x136>
 80015a2:	21c1      	movs	r1, #193	; 0xc1
 80015a4:	4830      	ldr	r0, [pc, #192]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015a6:	f019 fc7d 	bl	801aea4 <assert_failed>
 80015aa:	e786      	b.n	80014ba <HAL_DMA_Init+0x136>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 80015ac:	21bf      	movs	r1, #191	; 0xbf
 80015ae:	482e      	ldr	r0, [pc, #184]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015b0:	f019 fc78 	bl	801aea4 <assert_failed>
 80015b4:	e776      	b.n	80014a4 <HAL_DMA_Init+0x120>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 80015b6:	21be      	movs	r1, #190	; 0xbe
 80015b8:	482b      	ldr	r0, [pc, #172]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015ba:	f019 fc73 	bl	801aea4 <assert_failed>
 80015be:	e769      	b.n	8001494 <HAL_DMA_Init+0x110>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 80015c0:	21bb      	movs	r1, #187	; 0xbb
 80015c2:	4829      	ldr	r0, [pc, #164]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015c4:	f019 fc6e 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 80015c8:	68e3      	ldr	r3, [r4, #12]
 80015ca:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 80015ce:	f43f af54 	beq.w	800147a <HAL_DMA_Init+0xf6>
 80015d2:	21bc      	movs	r1, #188	; 0xbc
 80015d4:	4824      	ldr	r0, [pc, #144]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015d6:	f019 fc65 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 80015da:	6923      	ldr	r3, [r4, #16]
 80015dc:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 80015e0:	f43f af50 	beq.w	8001484 <HAL_DMA_Init+0x100>
 80015e4:	21bd      	movs	r1, #189	; 0xbd
 80015e6:	4820      	ldr	r0, [pc, #128]	; (8001668 <HAL_DMA_Init+0x2e4>)
 80015e8:	f019 fc5c 	bl	801aea4 <assert_failed>
 80015ec:	e74a      	b.n	8001484 <HAL_DMA_Init+0x100>
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80015ee:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80015f0:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 80015f2:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80015f4:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80015f6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80015fa:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80015fc:	2001      	movs	r0, #1
}
 80015fe:	bd38      	pop	{r3, r4, r5, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8001600:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	; 0x2c
 8001604:	4329      	orrs	r1, r5
 8001606:	430a      	orrs	r2, r1
  hdma->Instance->CR = tmp;  
 8001608:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 800160a:	6959      	ldr	r1, [r3, #20]
    tmp |= hdma->Init.FIFOThreshold;
 800160c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800160e:	f021 0107 	bic.w	r1, r1, #7
 8001612:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 8001614:	f041 0104 	orr.w	r1, r1, #4
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001618:	2d00      	cmp	r5, #0
 800161a:	d085      	beq.n	8001528 <HAL_DMA_Init+0x1a4>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800161c:	b358      	cbz	r0, 8001676 <HAL_DMA_Init+0x2f2>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800161e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8001622:	d03e      	beq.n	80016a2 <HAL_DMA_Init+0x31e>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8001624:	2a02      	cmp	r2, #2
 8001626:	d905      	bls.n	8001634 <HAL_DMA_Init+0x2b0>
 8001628:	2a03      	cmp	r2, #3
 800162a:	f47f af7d 	bne.w	8001528 <HAL_DMA_Init+0x1a4>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800162e:	01ea      	lsls	r2, r5, #7
 8001630:	f57f af7a 	bpl.w	8001528 <HAL_DMA_Init+0x1a4>
        hdma->State = HAL_DMA_STATE_READY;
 8001634:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001636:	2240      	movs	r2, #64	; 0x40
        return HAL_ERROR; 
 8001638:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800163a:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 800163c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8001640:	bd38      	pop	{r3, r4, r5, pc}
    assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 8001642:	21c7      	movs	r1, #199	; 0xc7
 8001644:	4808      	ldr	r0, [pc, #32]	; (8001668 <HAL_DMA_Init+0x2e4>)
 8001646:	f019 fc2d 	bl	801aea4 <assert_failed>
 800164a:	e78d      	b.n	8001568 <HAL_DMA_Init+0x1e4>
 800164c:	40026010 	.word	0x40026010
 8001650:	40026028 	.word	0x40026028
 8001654:	400264b8 	.word	0x400264b8
 8001658:	f010803f 	.word	0xf010803f
 800165c:	aaaaaaab 	.word	0xaaaaaaab
 8001660:	08021554 	.word	0x08021554
 8001664:	fffffc00 	.word	0xfffffc00
 8001668:	0802151c 	.word	0x0802151c
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 800166c:	21c8      	movs	r1, #200	; 0xc8
 800166e:	4814      	ldr	r0, [pc, #80]	; (80016c0 <HAL_DMA_Init+0x33c>)
 8001670:	f019 fc18 	bl	801aea4 <assert_failed>
 8001674:	e77c      	b.n	8001570 <HAL_DMA_Init+0x1ec>
    switch (tmp)
 8001676:	2a01      	cmp	r2, #1
 8001678:	d00e      	beq.n	8001698 <HAL_DMA_Init+0x314>
 800167a:	f032 0202 	bics.w	r2, r2, #2
 800167e:	f47f af53 	bne.w	8001528 <HAL_DMA_Init+0x1a4>
 8001682:	e7d4      	b.n	800162e <HAL_DMA_Init+0x2aa>
  assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
 8001684:	21ba      	movs	r1, #186	; 0xba
 8001686:	480e      	ldr	r0, [pc, #56]	; (80016c0 <HAL_DMA_Init+0x33c>)
 8001688:	f019 fc0c 	bl	801aea4 <assert_failed>
 800168c:	e6e9      	b.n	8001462 <HAL_DMA_Init+0xde>
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
 800168e:	21b9      	movs	r1, #185	; 0xb9
 8001690:	480b      	ldr	r0, [pc, #44]	; (80016c0 <HAL_DMA_Init+0x33c>)
 8001692:	f019 fc07 	bl	801aea4 <assert_failed>
 8001696:	e6db      	b.n	8001450 <HAL_DMA_Init+0xcc>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8001698:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 800169c:	f47f af44 	bne.w	8001528 <HAL_DMA_Init+0x1a4>
 80016a0:	e7c8      	b.n	8001634 <HAL_DMA_Init+0x2b0>
    switch (tmp)
 80016a2:	2a03      	cmp	r2, #3
 80016a4:	f63f af40 	bhi.w	8001528 <HAL_DMA_Init+0x1a4>
 80016a8:	a001      	add	r0, pc, #4	; (adr r0, 80016b0 <HAL_DMA_Init+0x32c>)
 80016aa:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 80016ae:	bf00      	nop
 80016b0:	08001635 	.word	0x08001635
 80016b4:	0800162f 	.word	0x0800162f
 80016b8:	08001635 	.word	0x08001635
 80016bc:	08001699 	.word	0x08001699
 80016c0:	0802151c 	.word	0x0802151c

080016c4 <HAL_DMA_Start_IT>:
{
 80016c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80016c8:	461e      	mov	r6, r3
 80016ca:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80016cc:	f8d0 9058 	ldr.w	r9, [r0, #88]	; 0x58
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 80016d0:	1e58      	subs	r0, r3, #1
 80016d2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
 80016d6:	4688      	mov	r8, r1
 80016d8:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 80016da:	4298      	cmp	r0, r3
 80016dc:	d83b      	bhi.n	8001756 <HAL_DMA_Start_IT+0x92>
  __HAL_LOCK(hdma);
 80016de:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 80016e2:	2b01      	cmp	r3, #1
 80016e4:	d040      	beq.n	8001768 <HAL_DMA_Start_IT+0xa4>
 80016e6:	2301      	movs	r3, #1
 80016e8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 80016ec:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 80016f0:	2b01      	cmp	r3, #1
 80016f2:	d005      	beq.n	8001700 <HAL_DMA_Start_IT+0x3c>
    __HAL_UNLOCK(hdma);	  
 80016f4:	2300      	movs	r3, #0
    status = HAL_BUSY;
 80016f6:	2002      	movs	r0, #2
    __HAL_UNLOCK(hdma);	  
 80016f8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 80016fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 8001700:	2302      	movs	r3, #2
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001702:	6825      	ldr	r5, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8001704:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001708:	2300      	movs	r3, #0
 800170a:	6563      	str	r3, [r4, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800170c:	682b      	ldr	r3, [r5, #0]
 800170e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001712:	602b      	str	r3, [r5, #0]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001714:	68a3      	ldr	r3, [r4, #8]
  hdma->Instance->NDTR = DataLength;
 8001716:	606e      	str	r6, [r5, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001718:	2b40      	cmp	r3, #64	; 0x40
 800171a:	d028      	beq.n	800176e <HAL_DMA_Start_IT+0xaa>
    hdma->Instance->PAR = SrcAddress;
 800171c:	f8c5 8008 	str.w	r8, [r5, #8]
    hdma->Instance->M0AR = DstAddress;
 8001720:	60ef      	str	r7, [r5, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001722:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8001724:	233f      	movs	r3, #63	; 0x3f
    if(hdma->XferHalfCpltCallback != NULL)
 8001726:	6c22      	ldr	r2, [r4, #64]	; 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001728:	408b      	lsls	r3, r1
 800172a:	f8c9 3008 	str.w	r3, [r9, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 800172e:	682b      	ldr	r3, [r5, #0]
 8001730:	f043 0316 	orr.w	r3, r3, #22
 8001734:	602b      	str	r3, [r5, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8001736:	696b      	ldr	r3, [r5, #20]
 8001738:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800173c:	616b      	str	r3, [r5, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 800173e:	b11a      	cbz	r2, 8001748 <HAL_DMA_Start_IT+0x84>
      hdma->Instance->CR  |= DMA_IT_HT;
 8001740:	682b      	ldr	r3, [r5, #0]
 8001742:	f043 0308 	orr.w	r3, r3, #8
 8001746:	602b      	str	r3, [r5, #0]
    __HAL_DMA_ENABLE(hdma);
 8001748:	682b      	ldr	r3, [r5, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800174a:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 800174c:	f043 0301 	orr.w	r3, r3, #1
 8001750:	602b      	str	r3, [r5, #0]
}
 8001752:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8001756:	f240 11cd 	movw	r1, #461	; 0x1cd
 800175a:	4807      	ldr	r0, [pc, #28]	; (8001778 <HAL_DMA_Start_IT+0xb4>)
 800175c:	f019 fba2 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hdma);
 8001760:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8001764:	2b01      	cmp	r3, #1
 8001766:	d1be      	bne.n	80016e6 <HAL_DMA_Start_IT+0x22>
 8001768:	2002      	movs	r0, #2
}
 800176a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hdma->Instance->PAR = DstAddress;
 800176e:	60af      	str	r7, [r5, #8]
    hdma->Instance->M0AR = SrcAddress;
 8001770:	f8c5 800c 	str.w	r8, [r5, #12]
 8001774:	e7d5      	b.n	8001722 <HAL_DMA_Start_IT+0x5e>
 8001776:	bf00      	nop
 8001778:	0802151c 	.word	0x0802151c

0800177c <HAL_DMA_Abort>:
{
 800177c:	b570      	push	{r4, r5, r6, lr}
 800177e:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001780:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t tickstart = HAL_GetTick();
 8001782:	f7ff fc75 	bl	8001070 <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001786:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800178a:	2b02      	cmp	r3, #2
 800178c:	d006      	beq.n	800179c <HAL_DMA_Abort+0x20>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800178e:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 8001790:	2300      	movs	r3, #0
    return HAL_ERROR;
 8001792:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001794:	6562      	str	r2, [r4, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 8001796:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800179a:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800179c:	6823      	ldr	r3, [r4, #0]
 800179e:	4605      	mov	r5, r0
 80017a0:	681a      	ldr	r2, [r3, #0]
 80017a2:	f022 0216 	bic.w	r2, r2, #22
 80017a6:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 80017a8:	695a      	ldr	r2, [r3, #20]
 80017aa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80017ae:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80017b0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80017b2:	b33a      	cbz	r2, 8001804 <HAL_DMA_Abort+0x88>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 80017b4:	681a      	ldr	r2, [r3, #0]
 80017b6:	f022 0208 	bic.w	r2, r2, #8
 80017ba:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 80017bc:	681a      	ldr	r2, [r3, #0]
 80017be:	f022 0201 	bic.w	r2, r2, #1
 80017c2:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80017c4:	e005      	b.n	80017d2 <HAL_DMA_Abort+0x56>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80017c6:	f7ff fc53 	bl	8001070 <HAL_GetTick>
 80017ca:	1b43      	subs	r3, r0, r5
 80017cc:	2b05      	cmp	r3, #5
 80017ce:	d80f      	bhi.n	80017f0 <HAL_DMA_Abort+0x74>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80017d0:	6823      	ldr	r3, [r4, #0]
 80017d2:	681b      	ldr	r3, [r3, #0]
 80017d4:	f013 0301 	ands.w	r3, r3, #1
 80017d8:	d1f5      	bne.n	80017c6 <HAL_DMA_Abort+0x4a>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017da:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80017dc:	223f      	movs	r2, #63	; 0x3f
  return HAL_OK;
 80017de:	4618      	mov	r0, r3
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017e0:	408a      	lsls	r2, r1
    hdma->State = HAL_DMA_STATE_READY;
 80017e2:	2101      	movs	r1, #1
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017e4:	60b2      	str	r2, [r6, #8]
    __HAL_UNLOCK(hdma);
 80017e6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_READY;
 80017ea:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
}
 80017ee:	bd70      	pop	{r4, r5, r6, pc}
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 80017f0:	2303      	movs	r3, #3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80017f2:	2120      	movs	r1, #32
        __HAL_UNLOCK(hdma);
 80017f4:	2200      	movs	r2, #0
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80017f6:	6561      	str	r1, [r4, #84]	; 0x54
        return HAL_TIMEOUT;
 80017f8:	4618      	mov	r0, r3
        __HAL_UNLOCK(hdma);
 80017fa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 80017fe:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8001802:	bd70      	pop	{r4, r5, r6, pc}
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001804:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001806:	2a00      	cmp	r2, #0
 8001808:	d1d4      	bne.n	80017b4 <HAL_DMA_Abort+0x38>
 800180a:	e7d7      	b.n	80017bc <HAL_DMA_Abort+0x40>

0800180c <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800180c:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
{
 8001810:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001812:	2a02      	cmp	r2, #2
 8001814:	d003      	beq.n	800181e <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001816:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8001818:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800181a:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 800181c:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 800181e:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8001820:	2105      	movs	r1, #5
  return HAL_OK;
 8001822:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 8001824:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8001828:	6813      	ldr	r3, [r2, #0]
 800182a:	f023 0301 	bic.w	r3, r3, #1
 800182e:	6013      	str	r3, [r2, #0]
}
 8001830:	4770      	bx	lr
 8001832:	bf00      	nop

08001834 <HAL_DMA_IRQHandler>:
{
 8001834:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __IO uint32_t count = 0;
 8001838:	2200      	movs	r2, #0
  uint32_t timeout = SystemCoreClock / 9600;
 800183a:	4b74      	ldr	r3, [pc, #464]	; (8001a0c <HAL_DMA_IRQHandler+0x1d8>)
{
 800183c:	b082      	sub	sp, #8
 800183e:	4680      	mov	r8, r0
  uint32_t timeout = SystemCoreClock / 9600;
 8001840:	681d      	ldr	r5, [r3, #0]
  __IO uint32_t count = 0;
 8001842:	9201      	str	r2, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001844:	2208      	movs	r2, #8
 8001846:	e9d0 6316 	ldrd	r6, r3, [r0, #88]	; 0x58
  tmpisr = regs->ISR;
 800184a:	6834      	ldr	r4, [r6, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800184c:	409a      	lsls	r2, r3
 800184e:	4222      	tst	r2, r4
 8001850:	d004      	beq.n	800185c <HAL_DMA_IRQHandler+0x28>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001852:	6801      	ldr	r1, [r0, #0]
 8001854:	680f      	ldr	r7, [r1, #0]
 8001856:	0778      	lsls	r0, r7, #29
 8001858:	f100 80ab 	bmi.w	80019b2 <HAL_DMA_IRQHandler+0x17e>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 800185c:	2201      	movs	r2, #1
 800185e:	409a      	lsls	r2, r3
 8001860:	4222      	tst	r2, r4
 8001862:	d005      	beq.n	8001870 <HAL_DMA_IRQHandler+0x3c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8001864:	f8d8 1000 	ldr.w	r1, [r8]
 8001868:	6949      	ldr	r1, [r1, #20]
 800186a:	0609      	lsls	r1, r1, #24
 800186c:	f100 8099 	bmi.w	80019a2 <HAL_DMA_IRQHandler+0x16e>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8001870:	2204      	movs	r2, #4
 8001872:	409a      	lsls	r2, r3
 8001874:	4222      	tst	r2, r4
 8001876:	d005      	beq.n	8001884 <HAL_DMA_IRQHandler+0x50>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8001878:	f8d8 1000 	ldr.w	r1, [r8]
 800187c:	6809      	ldr	r1, [r1, #0]
 800187e:	078f      	lsls	r7, r1, #30
 8001880:	f100 8087 	bmi.w	8001992 <HAL_DMA_IRQHandler+0x15e>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8001884:	2210      	movs	r2, #16
 8001886:	409a      	lsls	r2, r3
 8001888:	4222      	tst	r2, r4
 800188a:	d004      	beq.n	8001896 <HAL_DMA_IRQHandler+0x62>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 800188c:	f8d8 1000 	ldr.w	r1, [r8]
 8001890:	680f      	ldr	r7, [r1, #0]
 8001892:	0738      	lsls	r0, r7, #28
 8001894:	d468      	bmi.n	8001968 <HAL_DMA_IRQHandler+0x134>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8001896:	2220      	movs	r2, #32
 8001898:	409a      	lsls	r2, r3
 800189a:	4222      	tst	r2, r4
 800189c:	d017      	beq.n	80018ce <HAL_DMA_IRQHandler+0x9a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800189e:	f8d8 1000 	ldr.w	r1, [r8]
 80018a2:	680c      	ldr	r4, [r1, #0]
 80018a4:	06e0      	lsls	r0, r4, #27
 80018a6:	d512      	bpl.n	80018ce <HAL_DMA_IRQHandler+0x9a>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80018a8:	60b2      	str	r2, [r6, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 80018aa:	f898 2035 	ldrb.w	r2, [r8, #53]	; 0x35
 80018ae:	2a05      	cmp	r2, #5
 80018b0:	d039      	beq.n	8001926 <HAL_DMA_IRQHandler+0xf2>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80018b2:	680b      	ldr	r3, [r1, #0]
 80018b4:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80018b8:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80018ba:	f000 808d 	beq.w	80019d8 <HAL_DMA_IRQHandler+0x1a4>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80018be:	0319      	lsls	r1, r3, #12
 80018c0:	f140 8098 	bpl.w	80019f4 <HAL_DMA_IRQHandler+0x1c0>
        if(hdma->XferCpltCallback != NULL)
 80018c4:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 80018c8:	b10b      	cbz	r3, 80018ce <HAL_DMA_IRQHandler+0x9a>
          hdma->XferCpltCallback(hdma);
 80018ca:	4640      	mov	r0, r8
 80018cc:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 80018ce:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 80018d2:	2b00      	cmp	r3, #0
 80018d4:	d045      	beq.n	8001962 <HAL_DMA_IRQHandler+0x12e>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 80018d6:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 80018da:	07da      	lsls	r2, r3, #31
 80018dc:	d51b      	bpl.n	8001916 <HAL_DMA_IRQHandler+0xe2>
      __HAL_DMA_DISABLE(hdma);
 80018de:	f8d8 2000 	ldr.w	r2, [r8]
      hdma->State = HAL_DMA_STATE_ABORT;
 80018e2:	2305      	movs	r3, #5
  uint32_t timeout = SystemCoreClock / 9600;
 80018e4:	494a      	ldr	r1, [pc, #296]	; (8001a10 <HAL_DMA_IRQHandler+0x1dc>)
      hdma->State = HAL_DMA_STATE_ABORT;
 80018e6:	f888 3035 	strb.w	r3, [r8, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 80018ea:	6813      	ldr	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600;
 80018ec:	fba1 1505 	umull	r1, r5, r1, r5
      __HAL_DMA_DISABLE(hdma);
 80018f0:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 80018f4:	0aad      	lsrs	r5, r5, #10
      __HAL_DMA_DISABLE(hdma);
 80018f6:	6013      	str	r3, [r2, #0]
 80018f8:	e002      	b.n	8001900 <HAL_DMA_IRQHandler+0xcc>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80018fa:	6813      	ldr	r3, [r2, #0]
 80018fc:	07db      	lsls	r3, r3, #31
 80018fe:	d504      	bpl.n	800190a <HAL_DMA_IRQHandler+0xd6>
        if (++count > timeout)
 8001900:	9b01      	ldr	r3, [sp, #4]
 8001902:	3301      	adds	r3, #1
 8001904:	42ab      	cmp	r3, r5
 8001906:	9301      	str	r3, [sp, #4]
 8001908:	d9f7      	bls.n	80018fa <HAL_DMA_IRQHandler+0xc6>
      __HAL_UNLOCK(hdma);
 800190a:	2200      	movs	r2, #0
      hdma->State = HAL_DMA_STATE_READY;
 800190c:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
 800190e:	f888 2034 	strb.w	r2, [r8, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8001912:	f888 3035 	strb.w	r3, [r8, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8001916:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 800191a:	b313      	cbz	r3, 8001962 <HAL_DMA_IRQHandler+0x12e>
      hdma->XferErrorCallback(hdma);
 800191c:	4640      	mov	r0, r8
}
 800191e:	b002      	add	sp, #8
 8001920:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      hdma->XferErrorCallback(hdma);
 8001924:	4718      	bx	r3
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001926:	680a      	ldr	r2, [r1, #0]
 8001928:	f022 0216 	bic.w	r2, r2, #22
 800192c:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 800192e:	694a      	ldr	r2, [r1, #20]
 8001930:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001934:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001936:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 800193a:	2a00      	cmp	r2, #0
 800193c:	d060      	beq.n	8001a00 <HAL_DMA_IRQHandler+0x1cc>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800193e:	680a      	ldr	r2, [r1, #0]
 8001940:	f022 0208 	bic.w	r2, r2, #8
 8001944:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001946:	223f      	movs	r2, #63	; 0x3f
        __HAL_UNLOCK(hdma);
 8001948:	2100      	movs	r1, #0
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 800194a:	fa02 f303 	lsl.w	r3, r2, r3
        hdma->State = HAL_DMA_STATE_READY;
 800194e:	2201      	movs	r2, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001950:	60b3      	str	r3, [r6, #8]
        if(hdma->XferAbortCallback != NULL)
 8001952:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
        __HAL_UNLOCK(hdma);
 8001956:	f888 1034 	strb.w	r1, [r8, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 800195a:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 800195e:	2b00      	cmp	r3, #0
 8001960:	d1dc      	bne.n	800191c <HAL_DMA_IRQHandler+0xe8>
}
 8001962:	b002      	add	sp, #8
 8001964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8001968:	60b2      	str	r2, [r6, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800196a:	680a      	ldr	r2, [r1, #0]
 800196c:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001970:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001972:	d12a      	bne.n	80019ca <HAL_DMA_IRQHandler+0x196>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001974:	05d7      	lsls	r7, r2, #23
 8001976:	d403      	bmi.n	8001980 <HAL_DMA_IRQHandler+0x14c>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001978:	680a      	ldr	r2, [r1, #0]
 800197a:	f022 0208 	bic.w	r2, r2, #8
 800197e:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8001980:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8001984:	2a00      	cmp	r2, #0
 8001986:	d086      	beq.n	8001896 <HAL_DMA_IRQHandler+0x62>
          hdma->XferHalfCpltCallback(hdma);
 8001988:	4640      	mov	r0, r8
 800198a:	4790      	blx	r2
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 800198c:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 8001990:	e781      	b.n	8001896 <HAL_DMA_IRQHandler+0x62>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8001992:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8001994:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8001998:	f042 0204 	orr.w	r2, r2, #4
 800199c:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 80019a0:	e770      	b.n	8001884 <HAL_DMA_IRQHandler+0x50>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 80019a2:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80019a4:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 80019a8:	f042 0202 	orr.w	r2, r2, #2
 80019ac:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 80019b0:	e75e      	b.n	8001870 <HAL_DMA_IRQHandler+0x3c>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 80019b2:	680f      	ldr	r7, [r1, #0]
 80019b4:	f027 0704 	bic.w	r7, r7, #4
 80019b8:	600f      	str	r7, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 80019ba:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 80019bc:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 80019c0:	f042 0201 	orr.w	r2, r2, #1
 80019c4:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 80019c8:	e748      	b.n	800185c <HAL_DMA_IRQHandler+0x28>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80019ca:	0312      	lsls	r2, r2, #12
 80019cc:	d5d8      	bpl.n	8001980 <HAL_DMA_IRQHandler+0x14c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 80019ce:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 80019d2:	2a00      	cmp	r2, #0
 80019d4:	d1d8      	bne.n	8001988 <HAL_DMA_IRQHandler+0x154>
 80019d6:	e75e      	b.n	8001896 <HAL_DMA_IRQHandler+0x62>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80019d8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 80019dc:	f47f af72 	bne.w	80018c4 <HAL_DMA_IRQHandler+0x90>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 80019e0:	680a      	ldr	r2, [r1, #0]
 80019e2:	f022 0210 	bic.w	r2, r2, #16
 80019e6:	600a      	str	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 80019e8:	2201      	movs	r2, #1
          __HAL_UNLOCK(hdma);
 80019ea:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 80019ee:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
 80019f2:	e767      	b.n	80018c4 <HAL_DMA_IRQHandler+0x90>
          if(hdma->XferM1CpltCallback != NULL)
 80019f4:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 80019f8:	2b00      	cmp	r3, #0
 80019fa:	f47f af66 	bne.w	80018ca <HAL_DMA_IRQHandler+0x96>
 80019fe:	e766      	b.n	80018ce <HAL_DMA_IRQHandler+0x9a>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001a00:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 8001a04:	2a00      	cmp	r2, #0
 8001a06:	d19a      	bne.n	800193e <HAL_DMA_IRQHandler+0x10a>
 8001a08:	e79d      	b.n	8001946 <HAL_DMA_IRQHandler+0x112>
 8001a0a:	bf00      	nop
 8001a0c:	20000078 	.word	0x20000078
 8001a10:	1b4e81b5 	.word	0x1b4e81b5

08001a14 <HAL_DMA2D_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
  /* Check the DMA2D peripheral state */
  if(hdma2d == NULL)
 8001a14:	2800      	cmp	r0, #0
 8001a16:	d045      	beq.n	8001aa4 <HAL_DMA2D_Init+0x90>
  {
     return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
 8001a18:	6802      	ldr	r2, [r0, #0]
{
 8001a1a:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
 8001a1c:	4b25      	ldr	r3, [pc, #148]	; (8001ab4 <HAL_DMA2D_Init+0xa0>)
 8001a1e:	4604      	mov	r4, r0
 8001a20:	429a      	cmp	r2, r3
 8001a22:	d003      	beq.n	8001a2c <HAL_DMA2D_Init+0x18>
 8001a24:	21f6      	movs	r1, #246	; 0xf6
 8001a26:	4824      	ldr	r0, [pc, #144]	; (8001ab8 <HAL_DMA2D_Init+0xa4>)
 8001a28:	f019 fa3c 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
 8001a2c:	6863      	ldr	r3, [r4, #4]
 8001a2e:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
 8001a32:	d139      	bne.n	8001aa8 <HAL_DMA2D_Init+0x94>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
 8001a34:	68a3      	ldr	r3, [r4, #8]
 8001a36:	2b04      	cmp	r3, #4
 8001a38:	d82f      	bhi.n	8001a9a <HAL_DMA2D_Init+0x86>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
 8001a3a:	68e3      	ldr	r3, [r4, #12]
 8001a3c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8001a40:	d226      	bcs.n	8001a90 <HAL_DMA2D_Init+0x7c>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8001a42:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8001a46:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001a4a:	b1db      	cbz	r3, 8001a84 <HAL_DMA2D_Init+0x70>

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001a4c:	6823      	ldr	r3, [r4, #0]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001a4e:	2102      	movs	r1, #2
 8001a50:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001a54:	6818      	ldr	r0, [r3, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8001a56:	e9d4 2501 	ldrd	r2, r5, [r4, #4]
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001a5a:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
 8001a5e:	4310      	orrs	r0, r2

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8001a60:	4a16      	ldr	r2, [pc, #88]	; (8001abc <HAL_DMA2D_Init+0xa8>)
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001a62:	6018      	str	r0, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR,(DMA2D_OPFCCR_AI|DMA2D_OPFCCR_RBS), ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001a64:	2000      	movs	r0, #0
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8001a66:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001a68:	f021 0107 	bic.w	r1, r1, #7
 8001a6c:	4329      	orrs	r1, r5
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8001a6e:	68e5      	ldr	r5, [r4, #12]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8001a70:	6359      	str	r1, [r3, #52]	; 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8001a72:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8001a74:	400a      	ands	r2, r1
 8001a76:	432a      	orrs	r2, r5
 8001a78:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001a7a:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001a7c:	63e0      	str	r0, [r4, #60]	; 0x3c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001a7e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  return HAL_OK;
}
 8001a82:	bd38      	pop	{r3, r4, r5, pc}
    HAL_DMA2D_MspInit(hdma2d);
 8001a84:	4620      	mov	r0, r4
    hdma2d->Lock = HAL_UNLOCKED;
 8001a86:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    HAL_DMA2D_MspInit(hdma2d);
 8001a8a:	f018 f89f 	bl	8019bcc <HAL_DMA2D_MspInit>
 8001a8e:	e7dd      	b.n	8001a4c <HAL_DMA2D_Init+0x38>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
 8001a90:	21f9      	movs	r1, #249	; 0xf9
 8001a92:	4809      	ldr	r0, [pc, #36]	; (8001ab8 <HAL_DMA2D_Init+0xa4>)
 8001a94:	f019 fa06 	bl	801aea4 <assert_failed>
 8001a98:	e7d3      	b.n	8001a42 <HAL_DMA2D_Init+0x2e>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
 8001a9a:	21f8      	movs	r1, #248	; 0xf8
 8001a9c:	4806      	ldr	r0, [pc, #24]	; (8001ab8 <HAL_DMA2D_Init+0xa4>)
 8001a9e:	f019 fa01 	bl	801aea4 <assert_failed>
 8001aa2:	e7ca      	b.n	8001a3a <HAL_DMA2D_Init+0x26>
     return HAL_ERROR;
 8001aa4:	2001      	movs	r0, #1
}
 8001aa6:	4770      	bx	lr
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
 8001aa8:	21f7      	movs	r1, #247	; 0xf7
 8001aaa:	4803      	ldr	r0, [pc, #12]	; (8001ab8 <HAL_DMA2D_Init+0xa4>)
 8001aac:	f019 f9fa 	bl	801aea4 <assert_failed>
 8001ab0:	e7c0      	b.n	8001a34 <HAL_DMA2D_Init+0x20>
 8001ab2:	bf00      	nop
 8001ab4:	4002b000 	.word	0x4002b000
 8001ab8:	0802155c 	.word	0x0802155c
 8001abc:	ffffc000 	.word	0xffffc000

08001ac0 <HAL_DMA2D_Start>:
  * @param  Width      The width of data to be transferred from source to destination (expressed in number of pixels per line).
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
{
 8001ac0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001ac4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8001ac8:	4604      	mov	r4, r0
 8001aca:	460f      	mov	r7, r1
 8001acc:	4690      	mov	r8, r2
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
 8001ace:	f5b9 3f80 	cmp.w	r9, #65536	; 0x10000
{
 8001ad2:	461e      	mov	r6, r3
  assert_param(IS_DMA2D_LINE(Height));
 8001ad4:	d223      	bcs.n	8001b1e <HAL_DMA2D_Start+0x5e>
  assert_param(IS_DMA2D_PIXEL(Width));
 8001ad6:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
 8001ada:	d228      	bcs.n	8001b2e <HAL_DMA2D_Start+0x6e>

  /* Process locked */
  __HAL_LOCK(hdma2d);
 8001adc:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001ae0:	2b01      	cmp	r3, #1
 8001ae2:	d02d      	beq.n	8001b40 <HAL_DMA2D_Start+0x80>
 8001ae4:	2301      	movs	r3, #1
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8001ae6:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hdma2d);
 8001ae8:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001aec:	2302      	movs	r3, #2
 8001aee:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8001af2:	6c68      	ldr	r0, [r5, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001af4:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8001af6:	f000 4040 	and.w	r0, r0, #3221225472	; 0xc0000000
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001afa:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8001afe:	ea40 0009 	orr.w	r0, r0, r9
 8001b02:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8001b06:	6468      	str	r0, [r5, #68]	; 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 8001b08:	f8c5 803c 	str.w	r8, [r5, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001b0c:	d01b      	beq.n	8001b46 <HAL_DMA2D_Start+0x86>
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
  }
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
 8001b0e:	60ef      	str	r7, [r5, #12]
  __HAL_DMA2D_ENABLE(hdma2d);
 8001b10:	682b      	ldr	r3, [r5, #0]
  return HAL_OK;
 8001b12:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
 8001b14:	f043 0301 	orr.w	r3, r3, #1
 8001b18:	602b      	str	r3, [r5, #0]
}
 8001b1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_DMA2D_LINE(Height));
 8001b1e:	f44f 7129 	mov.w	r1, #676	; 0x2a4
 8001b22:	4821      	ldr	r0, [pc, #132]	; (8001ba8 <HAL_DMA2D_Start+0xe8>)
 8001b24:	f019 f9be 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA2D_PIXEL(Width));
 8001b28:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
 8001b2c:	d3d6      	bcc.n	8001adc <HAL_DMA2D_Start+0x1c>
 8001b2e:	f240 21a5 	movw	r1, #677	; 0x2a5
 8001b32:	481d      	ldr	r0, [pc, #116]	; (8001ba8 <HAL_DMA2D_Start+0xe8>)
 8001b34:	f019 f9b6 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hdma2d);
 8001b38:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001b3c:	2b01      	cmp	r3, #1
 8001b3e:	d1d1      	bne.n	8001ae4 <HAL_DMA2D_Start+0x24>
 8001b40:	2002      	movs	r0, #2
}
 8001b42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
 8001b46:	68a3      	ldr	r3, [r4, #8]
 8001b48:	b1b3      	cbz	r3, 8001b78 <HAL_DMA2D_Start+0xb8>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
 8001b4a:	2b01      	cmp	r3, #1
 8001b4c:	d021      	beq.n	8001b92 <HAL_DMA2D_Start+0xd2>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 8001b4e:	2b02      	cmp	r3, #2
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
 8001b50:	f407 027f 	and.w	r2, r7, #16711680	; 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
 8001b54:	f407 447f 	and.w	r4, r7, #65280	; 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
 8001b58:	b2f8      	uxtb	r0, r7
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 8001b5a:	d01d      	beq.n	8001b98 <HAL_DMA2D_Start+0xd8>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8001b5c:	2b03      	cmp	r3, #3
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
 8001b5e:	f007 477f 	and.w	r7, r7, #4278190080	; 0xff000000
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8001b62:	d00b      	beq.n	8001b7c <HAL_DMA2D_Start+0xbc>
      tmp2 = (tmp2 >> 20U);
 8001b64:	0d13      	lsrs	r3, r2, #20
      tmp3 = (tmp3 >> 12U);
 8001b66:	0b24      	lsrs	r4, r4, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
 8001b68:	021b      	lsls	r3, r3, #8
      tmp1 = (tmp1 >> 28U);
 8001b6a:	0f3f      	lsrs	r7, r7, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
 8001b6c:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8001b70:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8001b74:	ea43 3707 	orr.w	r7, r3, r7, lsl #12
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
 8001b78:	63af      	str	r7, [r5, #56]	; 0x38
 8001b7a:	e7c9      	b.n	8001b10 <HAL_DMA2D_Start+0x50>
      tmp2 = (tmp2 >> 19U);
 8001b7c:	0cd2      	lsrs	r2, r2, #19
      tmp3 = (tmp3 >> 11U);
 8001b7e:	0ae4      	lsrs	r4, r4, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
 8001b80:	0293      	lsls	r3, r2, #10
      tmp1 = (tmp1 >> 31U);
 8001b82:	0fff      	lsrs	r7, r7, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
 8001b84:	ea43 1344 	orr.w	r3, r3, r4, lsl #5
 8001b88:	ea43 03d0 	orr.w	r3, r3, r0, lsr #3
 8001b8c:	ea43 37c7 	orr.w	r7, r3, r7, lsl #15
 8001b90:	e7f2      	b.n	8001b78 <HAL_DMA2D_Start+0xb8>
      tmp = (tmp3 | tmp2 | tmp4);
 8001b92:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
 8001b96:	e7ef      	b.n	8001b78 <HAL_DMA2D_Start+0xb8>
      tmp2 = (tmp2 >> 19U);
 8001b98:	0cd7      	lsrs	r7, r2, #19
      tmp3 = (tmp3 >> 10U);
 8001b9a:	0aa4      	lsrs	r4, r4, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
 8001b9c:	02ff      	lsls	r7, r7, #11
 8001b9e:	ea47 1744 	orr.w	r7, r7, r4, lsl #5
 8001ba2:	ea47 07d0 	orr.w	r7, r7, r0, lsr #3
 8001ba6:	e7e7      	b.n	8001b78 <HAL_DMA2D_Start+0xb8>
 8001ba8:	0802155c 	.word	0x0802155c

08001bac <HAL_DMA2D_PollForTransfer>:
{
 8001bac:	b570      	push	{r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
 8001bae:	2300      	movs	r3, #0
{
 8001bb0:	b082      	sub	sp, #8
 8001bb2:	4604      	mov	r4, r0
 8001bb4:	460d      	mov	r5, r1
  __IO uint32_t isrflags = 0x0U;
 8001bb6:	9301      	str	r3, [sp, #4]
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
 8001bb8:	6803      	ldr	r3, [r0, #0]
 8001bba:	681a      	ldr	r2, [r3, #0]
 8001bbc:	07d6      	lsls	r6, r2, #31
 8001bbe:	d40f      	bmi.n	8001be0 <HAL_DMA2D_PollForTransfer+0x34>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
 8001bc0:	69da      	ldr	r2, [r3, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
 8001bc2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001bc4:	430a      	orrs	r2, r1
  if (layer_start != 0U)
 8001bc6:	0691      	lsls	r1, r2, #26
 8001bc8:	d432      	bmi.n	8001c30 <HAL_DMA2D_PollForTransfer+0x84>
  __HAL_UNLOCK(hdma2d);
 8001bca:	2200      	movs	r2, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8001bcc:	2012      	movs	r0, #18
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001bce:	2101      	movs	r1, #1
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8001bd0:	6098      	str	r0, [r3, #8]
  return HAL_OK;
 8001bd2:	4610      	mov	r0, r2
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001bd4:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);
 8001bd8:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
}
 8001bdc:	b002      	add	sp, #8
 8001bde:	bd70      	pop	{r4, r5, r6, pc}
   tickstart = HAL_GetTick();
 8001be0:	f7ff fa46 	bl	8001070 <HAL_GetTick>
 8001be4:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
 8001be6:	1c6a      	adds	r2, r5, #1
 8001be8:	6823      	ldr	r3, [r4, #0]
 8001bea:	d147      	bne.n	8001c7c <HAL_DMA2D_PollForTransfer+0xd0>
 8001bec:	685a      	ldr	r2, [r3, #4]
 8001bee:	0796      	lsls	r6, r2, #30
 8001bf0:	d4e6      	bmi.n	8001bc0 <HAL_DMA2D_PollForTransfer+0x14>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001bf2:	685a      	ldr	r2, [r3, #4]
 8001bf4:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 8001bf6:	9a01      	ldr	r2, [sp, #4]
 8001bf8:	f012 0f21 	tst.w	r2, #33	; 0x21
 8001bfc:	d0f6      	beq.n	8001bec <HAL_DMA2D_PollForTransfer+0x40>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8001bfe:	9a01      	ldr	r2, [sp, #4]
 8001c00:	0690      	lsls	r0, r2, #26
 8001c02:	d503      	bpl.n	8001c0c <HAL_DMA2D_PollForTransfer+0x60>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 8001c04:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001c06:	f042 0202 	orr.w	r2, r2, #2
 8001c0a:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 8001c0c:	9a01      	ldr	r2, [sp, #4]
 8001c0e:	07d1      	lsls	r1, r2, #31
 8001c10:	d503      	bpl.n	8001c1a <HAL_DMA2D_PollForTransfer+0x6e>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 8001c12:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001c14:	f042 0201 	orr.w	r2, r2, #1
 8001c18:	63e2      	str	r2, [r4, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001c1a:	2021      	movs	r0, #33	; 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001c1c:	6098      	str	r0, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8001c1e:	2104      	movs	r1, #4
        __HAL_UNLOCK(hdma2d);
 8001c20:	2200      	movs	r2, #0
        return HAL_ERROR;
 8001c22:	2001      	movs	r0, #1
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8001c24:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
        __HAL_UNLOCK(hdma2d);
 8001c28:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
}
 8001c2c:	b002      	add	sp, #8
 8001c2e:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
 8001c30:	f7ff fa1e 	bl	8001070 <HAL_GetTick>
 8001c34:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
 8001c36:	1c68      	adds	r0, r5, #1
 8001c38:	6823      	ldr	r3, [r4, #0]
 8001c3a:	d13b      	bne.n	8001cb4 <HAL_DMA2D_PollForTransfer+0x108>
 8001c3c:	685a      	ldr	r2, [r3, #4]
 8001c3e:	06d1      	lsls	r1, r2, #27
 8001c40:	d4c3      	bmi.n	8001bca <HAL_DMA2D_PollForTransfer+0x1e>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001c42:	685a      	ldr	r2, [r3, #4]
 8001c44:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 8001c46:	9a01      	ldr	r2, [sp, #4]
 8001c48:	f012 0f29 	tst.w	r2, #41	; 0x29
 8001c4c:	d0f6      	beq.n	8001c3c <HAL_DMA2D_PollForTransfer+0x90>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
 8001c4e:	9a01      	ldr	r2, [sp, #4]
 8001c50:	0712      	lsls	r2, r2, #28
 8001c52:	d503      	bpl.n	8001c5c <HAL_DMA2D_PollForTransfer+0xb0>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
 8001c54:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001c56:	f042 0204 	orr.w	r2, r2, #4
 8001c5a:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8001c5c:	9a01      	ldr	r2, [sp, #4]
 8001c5e:	0696      	lsls	r6, r2, #26
 8001c60:	d503      	bpl.n	8001c6a <HAL_DMA2D_PollForTransfer+0xbe>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 8001c62:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001c64:	f042 0202 	orr.w	r2, r2, #2
 8001c68:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 8001c6a:	9a01      	ldr	r2, [sp, #4]
 8001c6c:	07d5      	lsls	r5, r2, #31
 8001c6e:	d503      	bpl.n	8001c78 <HAL_DMA2D_PollForTransfer+0xcc>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 8001c70:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001c72:	f042 0201 	orr.w	r2, r2, #1
 8001c76:	63e2      	str	r2, [r4, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001c78:	2029      	movs	r0, #41	; 0x29
 8001c7a:	e7cf      	b.n	8001c1c <HAL_DMA2D_PollForTransfer+0x70>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
 8001c7c:	685a      	ldr	r2, [r3, #4]
 8001c7e:	0790      	lsls	r0, r2, #30
 8001c80:	d49e      	bmi.n	8001bc0 <HAL_DMA2D_PollForTransfer+0x14>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001c82:	685a      	ldr	r2, [r3, #4]
 8001c84:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 8001c86:	9a01      	ldr	r2, [sp, #4]
 8001c88:	f012 0f21 	tst.w	r2, #33	; 0x21
 8001c8c:	d1b7      	bne.n	8001bfe <HAL_DMA2D_PollForTransfer+0x52>
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 8001c8e:	f7ff f9ef 	bl	8001070 <HAL_GetTick>
 8001c92:	1b80      	subs	r0, r0, r6
 8001c94:	42a8      	cmp	r0, r5
 8001c96:	d801      	bhi.n	8001c9c <HAL_DMA2D_PollForTransfer+0xf0>
 8001c98:	2d00      	cmp	r5, #0
 8001c9a:	d1a4      	bne.n	8001be6 <HAL_DMA2D_PollForTransfer+0x3a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8001c9c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8001c9e:	2203      	movs	r2, #3
          __HAL_UNLOCK(hdma2d);
 8001ca0:	2100      	movs	r1, #0
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8001ca2:	f043 0320 	orr.w	r3, r3, #32
          return HAL_TIMEOUT;
 8001ca6:	4610      	mov	r0, r2
          __HAL_UNLOCK(hdma2d);
 8001ca8:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8001cac:	63e3      	str	r3, [r4, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8001cae:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
          return HAL_TIMEOUT;
 8001cb2:	e793      	b.n	8001bdc <HAL_DMA2D_PollForTransfer+0x30>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
 8001cb4:	685a      	ldr	r2, [r3, #4]
 8001cb6:	06d2      	lsls	r2, r2, #27
 8001cb8:	d487      	bmi.n	8001bca <HAL_DMA2D_PollForTransfer+0x1e>
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001cba:	685a      	ldr	r2, [r3, #4]
 8001cbc:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 8001cbe:	9a01      	ldr	r2, [sp, #4]
 8001cc0:	f012 0f29 	tst.w	r2, #41	; 0x29
 8001cc4:	d1c3      	bne.n	8001c4e <HAL_DMA2D_PollForTransfer+0xa2>
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 8001cc6:	f7ff f9d3 	bl	8001070 <HAL_GetTick>
 8001cca:	1b80      	subs	r0, r0, r6
 8001ccc:	42a8      	cmp	r0, r5
 8001cce:	d8e5      	bhi.n	8001c9c <HAL_DMA2D_PollForTransfer+0xf0>
 8001cd0:	2d00      	cmp	r5, #0
 8001cd2:	d1b0      	bne.n	8001c36 <HAL_DMA2D_PollForTransfer+0x8a>
 8001cd4:	e7e2      	b.n	8001c9c <HAL_DMA2D_PollForTransfer+0xf0>
 8001cd6:	bf00      	nop

08001cd8 <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_LAYER(LayerIdx));
 8001cd8:	2901      	cmp	r1, #1
{
 8001cda:	b570      	push	{r4, r5, r6, lr}
 8001cdc:	460d      	mov	r5, r1
 8001cde:	4604      	mov	r4, r0
  assert_param(IS_DMA2D_LAYER(LayerIdx));
 8001ce0:	d904      	bls.n	8001cec <HAL_DMA2D_ConfigLayer+0x14>
 8001ce2:	f240 614a 	movw	r1, #1610	; 0x64a
 8001ce6:	483f      	ldr	r0, [pc, #252]	; (8001de4 <HAL_DMA2D_ConfigLayer+0x10c>)
 8001ce8:	f019 f8dc 	bl	801aea4 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
 8001cec:	eb04 1205 	add.w	r2, r4, r5, lsl #4
 8001cf0:	012e      	lsls	r6, r5, #4
 8001cf2:	6993      	ldr	r3, [r2, #24]
 8001cf4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8001cf8:	d261      	bcs.n	8001dbe <HAL_DMA2D_ConfigLayer+0xe6>
  if(hdma2d->Init.Mode != DMA2D_R2M)
 8001cfa:	6862      	ldr	r2, [r4, #4]
 8001cfc:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 8001d00:	d004      	beq.n	8001d0c <HAL_DMA2D_ConfigLayer+0x34>
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
 8001d02:	19a3      	adds	r3, r4, r6
 8001d04:	69db      	ldr	r3, [r3, #28]
 8001d06:	2b0a      	cmp	r3, #10
 8001d08:	d83f      	bhi.n	8001d8a <HAL_DMA2D_ConfigLayer+0xb2>
    if(hdma2d->Init.Mode != DMA2D_M2M)
 8001d0a:	bb2a      	cbnz	r2, 8001d58 <HAL_DMA2D_ConfigLayer+0x80>
  __HAL_LOCK(hdma2d);
 8001d0c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001d10:	2b01      	cmp	r3, #1
 8001d12:	d02f      	beq.n	8001d74 <HAL_DMA2D_ConfigLayer+0x9c>
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8001d14:	19a3      	adds	r3, r4, r6
  __HAL_LOCK(hdma2d);
 8001d16:	2101      	movs	r1, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001d18:	2202      	movs	r2, #2
  __HAL_LOCK(hdma2d);
 8001d1a:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001d1e:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8001d22:	e9d3 1207 	ldrd	r1, r2, [r3, #28]
 8001d26:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001d2a:	3909      	subs	r1, #9
 8001d2c:	2901      	cmp	r1, #1
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 8001d2e:	6a59      	ldr	r1, [r3, #36]	; 0x24
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001d30:	d934      	bls.n	8001d9c <HAL_DMA2D_ConfigLayer+0xc4>
    regValue |=  (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 8001d32:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  if(LayerIdx == DMA2D_BACKGROUND_LAYER)
 8001d36:	b1fd      	cbz	r5, 8001d78 <HAL_DMA2D_ConfigLayer+0xa0>
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001d38:	6821      	ldr	r1, [r4, #0]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8001d3a:	6998      	ldr	r0, [r3, #24]
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001d3c:	69cd      	ldr	r5, [r1, #28]
 8001d3e:	4b2a      	ldr	r3, [pc, #168]	; (8001de8 <HAL_DMA2D_ConfigLayer+0x110>)
 8001d40:	402b      	ands	r3, r5
 8001d42:	431a      	orrs	r2, r3
 8001d44:	61ca      	str	r2, [r1, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8001d46:	6108      	str	r0, [r1, #16]
  __HAL_UNLOCK(hdma2d);
 8001d48:	2300      	movs	r3, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001d4a:	2201      	movs	r2, #1
  return HAL_OK;
 8001d4c:	4618      	mov	r0, r3
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001d4e:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);
 8001d52:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 8001d56:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
 8001d58:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8001d5c:	6a1b      	ldr	r3, [r3, #32]
 8001d5e:	2b02      	cmp	r3, #2
 8001d60:	d9d4      	bls.n	8001d0c <HAL_DMA2D_ConfigLayer+0x34>
 8001d62:	f240 6151 	movw	r1, #1617	; 0x651
 8001d66:	481f      	ldr	r0, [pc, #124]	; (8001de4 <HAL_DMA2D_ConfigLayer+0x10c>)
 8001d68:	f019 f89c 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hdma2d);
 8001d6c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001d70:	2b01      	cmp	r3, #1
 8001d72:	d1cf      	bne.n	8001d14 <HAL_DMA2D_ConfigLayer+0x3c>
 8001d74:	2002      	movs	r0, #2
}
 8001d76:	bd70      	pop	{r4, r5, r6, pc}
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001d78:	6821      	ldr	r1, [r4, #0]
 8001d7a:	4b1b      	ldr	r3, [pc, #108]	; (8001de8 <HAL_DMA2D_ConfigLayer+0x110>)
 8001d7c:	6a4d      	ldr	r5, [r1, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8001d7e:	69a0      	ldr	r0, [r4, #24]
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001d80:	402b      	ands	r3, r5
 8001d82:	431a      	orrs	r2, r3
 8001d84:	624a      	str	r2, [r1, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8001d86:	6188      	str	r0, [r1, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001d88:	e7de      	b.n	8001d48 <HAL_DMA2D_ConfigLayer+0x70>
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
 8001d8a:	f240 614e 	movw	r1, #1614	; 0x64e
 8001d8e:	4815      	ldr	r0, [pc, #84]	; (8001de4 <HAL_DMA2D_ConfigLayer+0x10c>)
 8001d90:	f019 f888 	bl	801aea4 <assert_failed>
    if(hdma2d->Init.Mode != DMA2D_M2M)
 8001d94:	6862      	ldr	r2, [r4, #4]
 8001d96:	2a00      	cmp	r2, #0
 8001d98:	d0b8      	beq.n	8001d0c <HAL_DMA2D_ConfigLayer+0x34>
 8001d9a:	e7dd      	b.n	8001d58 <HAL_DMA2D_ConfigLayer+0x80>
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 8001d9c:	f001 407f 	and.w	r0, r1, #4278190080	; 0xff000000
 8001da0:	4302      	orrs	r2, r0
  if(LayerIdx == DMA2D_BACKGROUND_LAYER)
 8001da2:	b995      	cbnz	r5, 8001dca <HAL_DMA2D_ConfigLayer+0xf2>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001da4:	6821      	ldr	r1, [r4, #0]
 8001da6:	4b10      	ldr	r3, [pc, #64]	; (8001de8 <HAL_DMA2D_ConfigLayer+0x110>)
 8001da8:	6a4e      	ldr	r6, [r1, #36]	; 0x24
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8001daa:	6a60      	ldr	r0, [r4, #36]	; 0x24
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001dac:	4033      	ands	r3, r6
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8001dae:	69a5      	ldr	r5, [r4, #24]
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8001db0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001db4:	431a      	orrs	r2, r3
 8001db6:	624a      	str	r2, [r1, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8001db8:	618d      	str	r5, [r1, #24]
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8001dba:	6288      	str	r0, [r1, #40]	; 0x28
 8001dbc:	e7c4      	b.n	8001d48 <HAL_DMA2D_ConfigLayer+0x70>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
 8001dbe:	f240 614b 	movw	r1, #1611	; 0x64b
 8001dc2:	4808      	ldr	r0, [pc, #32]	; (8001de4 <HAL_DMA2D_ConfigLayer+0x10c>)
 8001dc4:	f019 f86e 	bl	801aea4 <assert_failed>
 8001dc8:	e797      	b.n	8001cfa <HAL_DMA2D_ConfigLayer+0x22>
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001dca:	6820      	ldr	r0, [r4, #0]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
 8001dcc:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8001dd0:	699d      	ldr	r5, [r3, #24]
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8001dd2:	69c6      	ldr	r6, [r0, #28]
 8001dd4:	4b04      	ldr	r3, [pc, #16]	; (8001de8 <HAL_DMA2D_ConfigLayer+0x110>)
 8001dd6:	4033      	ands	r3, r6
 8001dd8:	431a      	orrs	r2, r3
 8001dda:	61c2      	str	r2, [r0, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8001ddc:	6105      	str	r5, [r0, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
 8001dde:	6201      	str	r1, [r0, #32]
 8001de0:	e7b2      	b.n	8001d48 <HAL_DMA2D_ConfigLayer+0x70>
 8001de2:	bf00      	nop
 8001de4:	0802155c 	.word	0x0802155c
 8001de8:	00fcfff0 	.word	0x00fcfff0

08001dec <HAL_GPIO_Init>:
  uint32_t ioposition = 0x00;
  uint32_t iocurrent = 0x00;
  uint32_t temp = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8001dec:	4bb5      	ldr	r3, [pc, #724]	; (80020c4 <HAL_GPIO_Init+0x2d8>)
 8001dee:	4ab6      	ldr	r2, [pc, #728]	; (80020c8 <HAL_GPIO_Init+0x2dc>)
 8001df0:	4290      	cmp	r0, r2
 8001df2:	bf18      	it	ne
 8001df4:	4298      	cmpne	r0, r3
{
 8001df6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8001dfa:	bf18      	it	ne
 8001dfc:	2301      	movne	r3, #1
{
 8001dfe:	b085      	sub	sp, #20
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8001e00:	bf08      	it	eq
 8001e02:	2300      	moveq	r3, #0
{
 8001e04:	4606      	mov	r6, r0
 8001e06:	4688      	mov	r8, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8001e08:	9301      	str	r3, [sp, #4]
 8001e0a:	d026      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e0c:	4baf      	ldr	r3, [pc, #700]	; (80020cc <HAL_GPIO_Init+0x2e0>)
 8001e0e:	4298      	cmp	r0, r3
 8001e10:	d023      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e12:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e16:	4298      	cmp	r0, r3
 8001e18:	d01f      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e1a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e1e:	4298      	cmp	r0, r3
 8001e20:	d01b      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e22:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e26:	4298      	cmp	r0, r3
 8001e28:	d017      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e2a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e2e:	4298      	cmp	r0, r3
 8001e30:	d013      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e32:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e36:	4298      	cmp	r0, r3
 8001e38:	d00f      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e3a:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 8001e3e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8001e42:	4290      	cmp	r0, r2
 8001e44:	bf18      	it	ne
 8001e46:	4298      	cmpne	r0, r3
 8001e48:	d007      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e4a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001e4e:	4298      	cmp	r0, r3
 8001e50:	d003      	beq.n	8001e5a <HAL_GPIO_Init+0x6e>
 8001e52:	21b1      	movs	r1, #177	; 0xb1
 8001e54:	489e      	ldr	r0, [pc, #632]	; (80020d0 <HAL_GPIO_Init+0x2e4>)
 8001e56:	f019 f825 	bl	801aea4 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 8001e5a:	f8b8 3000 	ldrh.w	r3, [r8]
 8001e5e:	2b00      	cmp	r3, #0
 8001e60:	f000 810c 	beq.w	800207c <HAL_GPIO_Init+0x290>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8001e64:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8001e68:	4b9a      	ldr	r3, [pc, #616]	; (80020d4 <HAL_GPIO_Init+0x2e8>)
 8001e6a:	489b      	ldr	r0, [pc, #620]	; (80020d8 <HAL_GPIO_Init+0x2ec>)
 8001e6c:	f422 1100 	bic.w	r1, r2, #2097152	; 0x200000
 8001e70:	429a      	cmp	r2, r3
 8001e72:	bf18      	it	ne
 8001e74:	2a03      	cmpne	r2, #3
 8001e76:	bf8c      	ite	hi
 8001e78:	2301      	movhi	r3, #1
 8001e7a:	2300      	movls	r3, #0
 8001e7c:	4282      	cmp	r2, r0
 8001e7e:	bf0c      	ite	eq
 8001e80:	2300      	moveq	r3, #0
 8001e82:	f003 0301 	andne.w	r3, r3, #1
 8001e86:	3a11      	subs	r2, #17
 8001e88:	2a01      	cmp	r2, #1
 8001e8a:	bf94      	ite	ls
 8001e8c:	2300      	movls	r3, #0
 8001e8e:	f003 0301 	andhi.w	r3, r3, #1
 8001e92:	4a92      	ldr	r2, [pc, #584]	; (80020dc <HAL_GPIO_Init+0x2f0>)
 8001e94:	4291      	cmp	r1, r2
 8001e96:	bf0c      	ite	eq
 8001e98:	2300      	moveq	r3, #0
 8001e9a:	f003 0301 	andne.w	r3, r3, #1
 8001e9e:	b11b      	cbz	r3, 8001ea8 <HAL_GPIO_Init+0xbc>
 8001ea0:	4b8f      	ldr	r3, [pc, #572]	; (80020e0 <HAL_GPIO_Init+0x2f4>)
 8001ea2:	4299      	cmp	r1, r3
 8001ea4:	f040 8132 	bne.w	800210c <HAL_GPIO_Init+0x320>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8001ea8:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8001eac:	2b02      	cmp	r3, #2
 8001eae:	f200 80ea 	bhi.w	8002086 <HAL_GPIO_Init+0x29a>
{
 8001eb2:	2400      	movs	r4, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001eb4:	f8df b250 	ldr.w	fp, [pc, #592]	; 8002108 <HAL_GPIO_Init+0x31c>
 8001eb8:	e003      	b.n	8001ec2 <HAL_GPIO_Init+0xd6>
  for(position = 0; position < GPIO_NUMBER; position++)
 8001eba:	3401      	adds	r4, #1
 8001ebc:	2c10      	cmp	r4, #16
 8001ebe:	f000 80bc 	beq.w	800203a <HAL_GPIO_Init+0x24e>
    ioposition = ((uint32_t)0x01) << position;
 8001ec2:	2501      	movs	r5, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001ec4:	f8d8 3000 	ldr.w	r3, [r8]
    ioposition = ((uint32_t)0x01) << position;
 8001ec8:	40a5      	lsls	r5, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001eca:	ea05 0a03 	and.w	sl, r5, r3
    if(iocurrent == ioposition)
 8001ece:	ea35 0303 	bics.w	r3, r5, r3
 8001ed2:	d1f2      	bne.n	8001eba <HAL_GPIO_Init+0xce>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001ed4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8001ed8:	f023 0010 	bic.w	r0, r3, #16
 8001edc:	2802      	cmp	r0, #2
 8001ede:	d114      	bne.n	8001f0a <HAL_GPIO_Init+0x11e>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 8001ee0:	f8d8 1010 	ldr.w	r1, [r8, #16]
 8001ee4:	290f      	cmp	r1, #15
 8001ee6:	f200 80b9 	bhi.w	800205c <HAL_GPIO_Init+0x270>
        temp = GPIOx->AFR[position >> 3];
 8001eea:	08e7      	lsrs	r7, r4, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001eec:	f004 0207 	and.w	r2, r4, #7
 8001ef0:	f04f 0c0f 	mov.w	ip, #15
 8001ef4:	0092      	lsls	r2, r2, #2
 8001ef6:	eb06 0787 	add.w	r7, r6, r7, lsl #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001efa:	4091      	lsls	r1, r2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001efc:	fa0c fc02 	lsl.w	ip, ip, r2
        temp = GPIOx->AFR[position >> 3];
 8001f00:	6a3a      	ldr	r2, [r7, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f02:	ea22 020c 	bic.w	r2, r2, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f06:	430a      	orrs	r2, r1
        GPIOx->AFR[position >> 3] = temp;
 8001f08:	623a      	str	r2, [r7, #32]
      temp = GPIOx->MODER;
 8001f0a:	ea4f 0944 	mov.w	r9, r4, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f0e:	2703      	movs	r7, #3
      temp = GPIOx->MODER;
 8001f10:	6831      	ldr	r1, [r6, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001f12:	3801      	subs	r0, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f14:	fa07 f709 	lsl.w	r7, r7, r9
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f18:	2801      	cmp	r0, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f1a:	ea21 0c07 	bic.w	ip, r1, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f1e:	f003 0103 	and.w	r1, r3, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f22:	ea6f 0707 	mvn.w	r7, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f26:	fa01 f109 	lsl.w	r1, r1, r9
 8001f2a:	ea41 010c 	orr.w	r1, r1, ip
      GPIOx->MODER = temp;
 8001f2e:	6031      	str	r1, [r6, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f30:	d812      	bhi.n	8001f58 <HAL_GPIO_Init+0x16c>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8001f32:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8001f36:	2903      	cmp	r1, #3
 8001f38:	f200 8082 	bhi.w	8002040 <HAL_GPIO_Init+0x254>
        temp = GPIOx->OSPEEDR; 
 8001f3c:	68b0      	ldr	r0, [r6, #8]
        temp |= (GPIO_Init->Speed << (position * 2));
 8001f3e:	fa01 f109 	lsl.w	r1, r1, r9
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001f42:	4038      	ands	r0, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8001f44:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
 8001f46:	60b1      	str	r1, [r6, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f48:	f3c3 1100 	ubfx	r1, r3, #4, #1
        temp = GPIOx->OTYPER;
 8001f4c:	6870      	ldr	r0, [r6, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f4e:	40a1      	lsls	r1, r4
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001f50:	ea20 0505 	bic.w	r5, r0, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f54:	430d      	orrs	r5, r1
        GPIOx->OTYPER = temp;
 8001f56:	6075      	str	r5, [r6, #4]
      temp = GPIOx->PUPDR;
 8001f58:	68f1      	ldr	r1, [r6, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001f5a:	00da      	lsls	r2, r3, #3
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001f5c:	ea07 0701 	and.w	r7, r7, r1
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001f60:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8001f64:	fa01 f109 	lsl.w	r1, r1, r9
 8001f68:	ea41 0107 	orr.w	r1, r1, r7
      GPIOx->PUPDR = temp;
 8001f6c:	60f1      	str	r1, [r6, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001f6e:	d5a4      	bpl.n	8001eba <HAL_GPIO_Init+0xce>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f70:	f8db 1044 	ldr.w	r1, [fp, #68]	; 0x44
 8001f74:	f024 0203 	bic.w	r2, r4, #3

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001f78:	f004 0503 	and.w	r5, r4, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f7c:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001f80:	00ad      	lsls	r5, r5, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f82:	f8cb 1044 	str.w	r1, [fp, #68]	; 0x44
 8001f86:	f8db 1044 	ldr.w	r1, [fp, #68]	; 0x44
 8001f8a:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 8001f8e:	9103      	str	r1, [sp, #12]
 8001f90:	4954      	ldr	r1, [pc, #336]	; (80020e4 <HAL_GPIO_Init+0x2f8>)
 8001f92:	9803      	ldr	r0, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2];
 8001f94:	4411      	add	r1, r2
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001f96:	220f      	movs	r2, #15
        temp = SYSCFG->EXTICR[position >> 2];
 8001f98:	6888      	ldr	r0, [r1, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001f9a:	40aa      	lsls	r2, r5
 8001f9c:	ea20 0202 	bic.w	r2, r0, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001fa0:	4849      	ldr	r0, [pc, #292]	; (80020c8 <HAL_GPIO_Init+0x2dc>)
 8001fa2:	4286      	cmp	r6, r0
 8001fa4:	d020      	beq.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 8001fa6:	9801      	ldr	r0, [sp, #4]
 8001fa8:	2800      	cmp	r0, #0
 8001faa:	d052      	beq.n	8002052 <HAL_GPIO_Init+0x266>
 8001fac:	4847      	ldr	r0, [pc, #284]	; (80020cc <HAL_GPIO_Init+0x2e0>)
 8001fae:	4286      	cmp	r6, r0
 8001fb0:	d05f      	beq.n	8002072 <HAL_GPIO_Init+0x286>
 8001fb2:	484d      	ldr	r0, [pc, #308]	; (80020e8 <HAL_GPIO_Init+0x2fc>)
 8001fb4:	4286      	cmp	r6, r0
 8001fb6:	d06b      	beq.n	8002090 <HAL_GPIO_Init+0x2a4>
 8001fb8:	484c      	ldr	r0, [pc, #304]	; (80020ec <HAL_GPIO_Init+0x300>)
 8001fba:	4286      	cmp	r6, r0
 8001fbc:	d06d      	beq.n	800209a <HAL_GPIO_Init+0x2ae>
 8001fbe:	484c      	ldr	r0, [pc, #304]	; (80020f0 <HAL_GPIO_Init+0x304>)
 8001fc0:	4286      	cmp	r6, r0
 8001fc2:	d074      	beq.n	80020ae <HAL_GPIO_Init+0x2c2>
 8001fc4:	484b      	ldr	r0, [pc, #300]	; (80020f4 <HAL_GPIO_Init+0x308>)
 8001fc6:	4286      	cmp	r6, r0
 8001fc8:	d076      	beq.n	80020b8 <HAL_GPIO_Init+0x2cc>
 8001fca:	484b      	ldr	r0, [pc, #300]	; (80020f8 <HAL_GPIO_Init+0x30c>)
 8001fcc:	4286      	cmp	r6, r0
 8001fce:	d069      	beq.n	80020a4 <HAL_GPIO_Init+0x2b8>
 8001fd0:	484a      	ldr	r0, [pc, #296]	; (80020fc <HAL_GPIO_Init+0x310>)
 8001fd2:	4286      	cmp	r6, r0
 8001fd4:	f000 809f 	beq.w	8002116 <HAL_GPIO_Init+0x32a>
 8001fd8:	4849      	ldr	r0, [pc, #292]	; (8002100 <HAL_GPIO_Init+0x314>)
 8001fda:	4286      	cmp	r6, r0
 8001fdc:	bf0c      	ite	eq
 8001fde:	2009      	moveq	r0, #9
 8001fe0:	200a      	movne	r0, #10
 8001fe2:	fa00 f505 	lsl.w	r5, r0, r5
 8001fe6:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2] = temp;
 8001fe8:	608a      	str	r2, [r1, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001fea:	03df      	lsls	r7, r3, #15
        temp = EXTI->IMR;
 8001fec:	4a45      	ldr	r2, [pc, #276]	; (8002104 <HAL_GPIO_Init+0x318>)
        temp &= ~((uint32_t)iocurrent);
 8001fee:	ea6f 010a 	mvn.w	r1, sl
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 8001ff2:	4844      	ldr	r0, [pc, #272]	; (8002104 <HAL_GPIO_Init+0x318>)
  for(position = 0; position < GPIO_NUMBER; position++)
 8001ff4:	f104 0401 	add.w	r4, r4, #1
        temp = EXTI->IMR;
 8001ff8:	6812      	ldr	r2, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8001ffa:	bf54      	ite	pl
 8001ffc:	400a      	andpl	r2, r1
          temp |= iocurrent;
 8001ffe:	ea4a 0202 	orrmi.w	r2, sl, r2

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002002:	039d      	lsls	r5, r3, #14
        EXTI->IMR = temp;
 8002004:	6002      	str	r2, [r0, #0]
        temp = EXTI->EMR;
 8002006:	6842      	ldr	r2, [r0, #4]
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8002008:	483e      	ldr	r0, [pc, #248]	; (8002104 <HAL_GPIO_Init+0x318>)
        temp &= ~((uint32_t)iocurrent);
 800200a:	bf54      	ite	pl
 800200c:	400a      	andpl	r2, r1
          temp |= iocurrent;
 800200e:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->EMR = temp;
 8002012:	6042      	str	r2, [r0, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002014:	6882      	ldr	r2, [r0, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002016:	02d8      	lsls	r0, r3, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8002018:	483a      	ldr	r0, [pc, #232]	; (8002104 <HAL_GPIO_Init+0x318>)
        temp &= ~((uint32_t)iocurrent);
 800201a:	bf54      	ite	pl
 800201c:	400a      	andpl	r2, r1
          temp |= iocurrent;
 800201e:	ea4a 0202 	orrmi.w	r2, sl, r2

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002022:	029b      	lsls	r3, r3, #10
        EXTI->RTSR = temp;
 8002024:	6082      	str	r2, [r0, #8]
        temp = EXTI->FTSR;
 8002026:	68c2      	ldr	r2, [r0, #12]
        temp &= ~((uint32_t)iocurrent);
 8002028:	bf54      	ite	pl
 800202a:	4011      	andpl	r1, r2
        {
          temp |= iocurrent;
 800202c:	ea4a 0102 	orrmi.w	r1, sl, r2
        }
        EXTI->FTSR = temp;
 8002030:	4a34      	ldr	r2, [pc, #208]	; (8002104 <HAL_GPIO_Init+0x318>)
  for(position = 0; position < GPIO_NUMBER; position++)
 8002032:	2c10      	cmp	r4, #16
        EXTI->FTSR = temp;
 8002034:	60d1      	str	r1, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8002036:	f47f af44 	bne.w	8001ec2 <HAL_GPIO_Init+0xd6>
      }
    }
  }
}
 800203a:	b005      	add	sp, #20
 800203c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8002040:	21d9      	movs	r1, #217	; 0xd9
 8002042:	4823      	ldr	r0, [pc, #140]	; (80020d0 <HAL_GPIO_Init+0x2e4>)
 8002044:	f018 ff2e 	bl	801aea4 <assert_failed>
        temp |= (GPIO_Init->Speed << (position * 2));
 8002048:	f8d8 100c 	ldr.w	r1, [r8, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800204c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8002050:	e774      	b.n	8001f3c <HAL_GPIO_Init+0x150>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8002052:	2001      	movs	r0, #1
 8002054:	fa00 f505 	lsl.w	r5, r0, r5
 8002058:	432a      	orrs	r2, r5
 800205a:	e7c5      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 800205c:	21c5      	movs	r1, #197	; 0xc5
 800205e:	481c      	ldr	r0, [pc, #112]	; (80020d0 <HAL_GPIO_Init+0x2e4>)
 8002060:	f018 ff20 	bl	801aea4 <assert_failed>
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8002064:	f8d8 3004 	ldr.w	r3, [r8, #4]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8002068:	f8d8 1010 	ldr.w	r1, [r8, #16]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800206c:	f023 0010 	bic.w	r0, r3, #16
 8002070:	e73b      	b.n	8001eea <HAL_GPIO_Init+0xfe>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8002072:	2002      	movs	r0, #2
 8002074:	fa00 f505 	lsl.w	r5, r0, r5
 8002078:	432a      	orrs	r2, r5
 800207a:	e7b5      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 800207c:	21b2      	movs	r1, #178	; 0xb2
 800207e:	4814      	ldr	r0, [pc, #80]	; (80020d0 <HAL_GPIO_Init+0x2e4>)
 8002080:	f018 ff10 	bl	801aea4 <assert_failed>
 8002084:	e6ee      	b.n	8001e64 <HAL_GPIO_Init+0x78>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8002086:	21b4      	movs	r1, #180	; 0xb4
 8002088:	4811      	ldr	r0, [pc, #68]	; (80020d0 <HAL_GPIO_Init+0x2e4>)
 800208a:	f018 ff0b 	bl	801aea4 <assert_failed>
 800208e:	e710      	b.n	8001eb2 <HAL_GPIO_Init+0xc6>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8002090:	2003      	movs	r0, #3
 8002092:	fa00 f505 	lsl.w	r5, r0, r5
 8002096:	432a      	orrs	r2, r5
 8002098:	e7a6      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 800209a:	2004      	movs	r0, #4
 800209c:	fa00 f505 	lsl.w	r5, r0, r5
 80020a0:	432a      	orrs	r2, r5
 80020a2:	e7a1      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 80020a4:	2007      	movs	r0, #7
 80020a6:	fa00 f505 	lsl.w	r5, r0, r5
 80020aa:	432a      	orrs	r2, r5
 80020ac:	e79c      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 80020ae:	2005      	movs	r0, #5
 80020b0:	fa00 f505 	lsl.w	r5, r0, r5
 80020b4:	432a      	orrs	r2, r5
 80020b6:	e797      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 80020b8:	2006      	movs	r0, #6
 80020ba:	fa00 f505 	lsl.w	r5, r0, r5
 80020be:	432a      	orrs	r2, r5
 80020c0:	e792      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 80020c2:	bf00      	nop
 80020c4:	40020400 	.word	0x40020400
 80020c8:	40020000 	.word	0x40020000
 80020cc:	40020800 	.word	0x40020800
 80020d0:	08021598 	.word	0x08021598
 80020d4:	10210000 	.word	0x10210000
 80020d8:	10220000 	.word	0x10220000
 80020dc:	10110000 	.word	0x10110000
 80020e0:	10120000 	.word	0x10120000
 80020e4:	40013800 	.word	0x40013800
 80020e8:	40020c00 	.word	0x40020c00
 80020ec:	40021000 	.word	0x40021000
 80020f0:	40021400 	.word	0x40021400
 80020f4:	40021800 	.word	0x40021800
 80020f8:	40021c00 	.word	0x40021c00
 80020fc:	40022000 	.word	0x40022000
 8002100:	40022400 	.word	0x40022400
 8002104:	40013c00 	.word	0x40013c00
 8002108:	40023800 	.word	0x40023800
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 800210c:	21b3      	movs	r1, #179	; 0xb3
 800210e:	4804      	ldr	r0, [pc, #16]	; (8002120 <HAL_GPIO_Init+0x334>)
 8002110:	f018 fec8 	bl	801aea4 <assert_failed>
 8002114:	e6c8      	b.n	8001ea8 <HAL_GPIO_Init+0xbc>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8002116:	2008      	movs	r0, #8
 8002118:	fa00 f505 	lsl.w	r5, r0, r5
 800211c:	432a      	orrs	r2, r5
 800211e:	e763      	b.n	8001fe8 <HAL_GPIO_Init+0x1fc>
 8002120:	08021598 	.word	0x08021598

08002124 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002124:	b538      	push	{r3, r4, r5, lr}
 8002126:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8002128:	460c      	mov	r4, r1
 800212a:	b129      	cbz	r1, 8002138 <HAL_GPIO_ReadPin+0x14>

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 800212c:	692b      	ldr	r3, [r5, #16]
 800212e:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8002130:	bf14      	ite	ne
 8002132:	2001      	movne	r0, #1
 8002134:	2000      	moveq	r0, #0
 8002136:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8002138:	f44f 71bd 	mov.w	r1, #378	; 0x17a
 800213c:	4801      	ldr	r0, [pc, #4]	; (8002144 <HAL_GPIO_ReadPin+0x20>)
 800213e:	f018 feb1 	bl	801aea4 <assert_failed>
 8002142:	e7f3      	b.n	800212c <HAL_GPIO_ReadPin+0x8>
 8002144:	08021598 	.word	0x08021598

08002148 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002148:	b570      	push	{r4, r5, r6, lr}
 800214a:	4606      	mov	r6, r0
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800214c:	460c      	mov	r4, r1
{
 800214e:	4615      	mov	r5, r2
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8002150:	b161      	cbz	r1, 800216c <HAL_GPIO_WritePin+0x24>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8002152:	2d01      	cmp	r5, #1
 8002154:	d803      	bhi.n	800215e <HAL_GPIO_WritePin+0x16>

  if(PinState != GPIO_PIN_RESET)
 8002156:	b905      	cbnz	r5, 800215a <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8002158:	0424      	lsls	r4, r4, #16
 800215a:	61b4      	str	r4, [r6, #24]
  }
}
 800215c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 800215e:	f240 119b 	movw	r1, #411	; 0x19b
 8002162:	4805      	ldr	r0, [pc, #20]	; (8002178 <HAL_GPIO_WritePin+0x30>)
 8002164:	f018 fe9e 	bl	801aea4 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8002168:	61b4      	str	r4, [r6, #24]
}
 800216a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800216c:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 8002170:	4801      	ldr	r0, [pc, #4]	; (8002178 <HAL_GPIO_WritePin+0x30>)
 8002172:	f018 fe97 	bl	801aea4 <assert_failed>
 8002176:	e7ec      	b.n	8002152 <HAL_GPIO_WritePin+0xa>
 8002178:	08021598 	.word	0x08021598

0800217c <HAL_GPIO_EXTI_Callback>:
  UNUSED(GPIO_Pin);
  
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 800217c:	4770      	bx	lr
 800217e:	bf00      	nop

08002180 <HAL_GPIO_EXTI_IRQHandler>:
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8002180:	4a04      	ldr	r2, [pc, #16]	; (8002194 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8002182:	6951      	ldr	r1, [r2, #20]
 8002184:	4201      	tst	r1, r0
 8002186:	d100      	bne.n	800218a <HAL_GPIO_EXTI_IRQHandler+0xa>
 8002188:	4770      	bx	lr
{
 800218a:	b508      	push	{r3, lr}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800218c:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800218e:	f7ff fff5 	bl	800217c <HAL_GPIO_EXTI_Callback>
}
 8002192:	bd08      	pop	{r3, pc}
 8002194:	40013c00 	.word	0x40013c00

08002198 <HAL_HCD_HC_Init>:
  *          This parameter can be a value from 0 to32K
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd, uint8_t ch_num, uint8_t epnum,
                                  uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8002198:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
 800219c:	f890 62f8 	ldrb.w	r6, [r0, #760]	; 0x2f8
{
 80021a0:	b085      	sub	sp, #20
 80021a2:	4604      	mov	r4, r0
  __HAL_LOCK(hhcd);
 80021a4:	2e01      	cmp	r6, #1
{
 80021a6:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
 80021aa:	f89d 703c 	ldrb.w	r7, [sp, #60]	; 0x3c
 80021ae:	f8bd 8040 	ldrh.w	r8, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
 80021b2:	d026      	beq.n	8002202 <HAL_HCD_HC_Init+0x6a>
  hhcd->hc[ch_num].do_ping = 0U;
 80021b4:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
 80021b8:	2600      	movs	r6, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 80021ba:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
 80021be:	f04f 0b01 	mov.w	fp, #1
  hhcd->hc[ch_num].do_ping = 0U;
 80021c2:	fb0c 0c01 	mla	ip, ip, r1, r0

  if ((epnum & 0x80U) == 0x80U)
 80021c6:	09d0      	lsrs	r0, r2, #7
  __HAL_LOCK(hhcd);
 80021c8:	f884 b2f8 	strb.w	fp, [r4, #760]	; 0x2f8
  hhcd->hc[ch_num].dev_addr = dev_address;
 80021cc:	f88c 3038 	strb.w	r3, [ip, #56]	; 0x38
  hhcd->hc[ch_num].ch_num = ch_num;
 80021d0:	f88c 1039 	strb.w	r1, [ip, #57]	; 0x39
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 80021d4:	f88c a03a 	strb.w	sl, [ip, #58]	; 0x3a
 80021d8:	f88c 003b 	strb.w	r0, [ip, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
 80021dc:	f88c 603d 	strb.w	r6, [ip, #61]	; 0x3d
  hhcd->hc[ch_num].ep_type = ep_type;
 80021e0:	f88c 703f 	strb.w	r7, [ip, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
 80021e4:	f88c 503c 	strb.w	r5, [ip, #60]	; 0x3c
  hhcd->hc[ch_num].max_packet = mps;
 80021e8:	f8ac 8040 	strh.w	r8, [ip, #64]	; 0x40

  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 80021ec:	9500      	str	r5, [sp, #0]
 80021ee:	e9cd 7801 	strd	r7, r8, [sp, #4]
 80021f2:	6820      	ldr	r0, [r4, #0]
 80021f4:	f005 fc5e 	bl	8007ab4 <USB_HC_Init>
                        dev_address, speed, ep_type, mps);

  __HAL_UNLOCK(hhcd);
 80021f8:	f884 62f8 	strb.w	r6, [r4, #760]	; 0x2f8

  return status;
}
 80021fc:	b005      	add	sp, #20
 80021fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
 8002202:	2002      	movs	r0, #2
}
 8002204:	b005      	add	sp, #20
 8002206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800220a:	bf00      	nop

0800220c <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
 800220c:	f890 32f8 	ldrb.w	r3, [r0, #760]	; 0x2f8
 8002210:	2b01      	cmp	r3, #1
 8002212:	d00c      	beq.n	800222e <HAL_HCD_HC_Halt+0x22>
 8002214:	2301      	movs	r3, #1
{
 8002216:	b510      	push	{r4, lr}
 8002218:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800221a:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 800221c:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002220:	f005 fdc4 	bl	8007dac <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 8002224:	2300      	movs	r3, #0

  return status;
 8002226:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 8002228:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
}
 800222c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 800222e:	2002      	movs	r0, #2
}
 8002230:	4770      	bx	lr
 8002232:	bf00      	nop

08002234 <HAL_HCD_Init>:
  if (hhcd == NULL)
 8002234:	2800      	cmp	r0, #0
 8002236:	d05f      	beq.n	80022f8 <HAL_HCD_Init+0xc4>
{
 8002238:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 800223c:	6804      	ldr	r4, [r0, #0]
{
 800223e:	b08a      	sub	sp, #40	; 0x28
 8002240:	4606      	mov	r6, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 8002242:	f1b4 4fa0 	cmp.w	r4, #1342177280	; 0x50000000
 8002246:	d002      	beq.n	800224e <HAL_HCD_Init+0x1a>
 8002248:	4b2c      	ldr	r3, [pc, #176]	; (80022fc <HAL_HCD_Init+0xc8>)
 800224a:	429c      	cmp	r4, r3
 800224c:	d142      	bne.n	80022d4 <HAL_HCD_Init+0xa0>
  if (hhcd->State == HAL_HCD_STATE_RESET)
 800224e:	f896 32f9 	ldrb.w	r3, [r6, #761]	; 0x2f9
 8002252:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002256:	2b00      	cmp	r3, #0
 8002258:	d047      	beq.n	80022ea <HAL_HCD_Init+0xb6>
 800225a:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
 800225c:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 800225e:	466d      	mov	r5, sp
 8002260:	1d37      	adds	r7, r6, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
 8002262:	f886 32f9 	strb.w	r3, [r6, #761]	; 0x2f9
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8002266:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8002268:	4634      	mov	r4, r6
  if ((USBx->CID & (0x1U << 8)) == 0U)
 800226a:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
 800226e:	bf08      	it	eq
 8002270:	6133      	streq	r3, [r6, #16]
  __HAL_HCD_DISABLE(hhcd);
 8002272:	f005 fa2b 	bl	80076cc <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8002276:	f854 cb10 	ldr.w	ip, [r4], #16
 800227a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800227c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800227e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002280:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002282:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002286:	e885 0003 	stmia.w	r5, {r0, r1}
 800228a:	4660      	mov	r0, ip
 800228c:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8002290:	f005 f988 	bl	80075a4 <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
 8002294:	2101      	movs	r1, #1
 8002296:	6830      	ldr	r0, [r6, #0]
 8002298:	f005 fa20 	bl	80076dc <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 800229c:	46b4      	mov	ip, r6
 800229e:	46ee      	mov	lr, sp
 80022a0:	f85c 8b10 	ldr.w	r8, [ip], #16
 80022a4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80022a8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80022ac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80022b0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80022b4:	e894 0003 	ldmia.w	r4, {r0, r1}
 80022b8:	e885 0003 	stmia.w	r5, {r0, r1}
 80022bc:	4640      	mov	r0, r8
 80022be:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80022c2:	f005 fac9 	bl	8007858 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
 80022c6:	2301      	movs	r3, #1
  return HAL_OK;
 80022c8:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
 80022ca:	f886 32f9 	strb.w	r3, [r6, #761]	; 0x2f9
}
 80022ce:	b00a      	add	sp, #40	; 0x28
 80022d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 80022d4:	2179      	movs	r1, #121	; 0x79
 80022d6:	480a      	ldr	r0, [pc, #40]	; (8002300 <HAL_HCD_Init+0xcc>)
 80022d8:	f018 fde4 	bl	801aea4 <assert_failed>
  if (hhcd->State == HAL_HCD_STATE_RESET)
 80022dc:	f896 32f9 	ldrb.w	r3, [r6, #761]	; 0x2f9
  USBx = hhcd->Instance;
 80022e0:	6834      	ldr	r4, [r6, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
 80022e2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80022e6:	2b00      	cmp	r3, #0
 80022e8:	d1b7      	bne.n	800225a <HAL_HCD_Init+0x26>
    HAL_HCD_MspInit(hhcd);
 80022ea:	4630      	mov	r0, r6
    hhcd->Lock = HAL_UNLOCKED;
 80022ec:	f886 22f8 	strb.w	r2, [r6, #760]	; 0x2f8
    HAL_HCD_MspInit(hhcd);
 80022f0:	f01c fb14 	bl	801e91c <HAL_HCD_MspInit>
  __HAL_HCD_DISABLE(hhcd);
 80022f4:	6830      	ldr	r0, [r6, #0]
 80022f6:	e7b1      	b.n	800225c <HAL_HCD_Init+0x28>
    return HAL_ERROR;
 80022f8:	2001      	movs	r0, #1
}
 80022fa:	4770      	bx	lr
 80022fc:	40040000 	.word	0x40040000
 8002300:	080215d4 	.word	0x080215d4

08002304 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 8002304:	468c      	mov	ip, r1
  hhcd->hc[ch_num].ep_is_in = direction;
 8002306:	212c      	movs	r1, #44	; 0x2c
{
 8002308:	b570      	push	{r4, r5, r6, lr}
  hhcd->hc[ch_num].ep_is_in = direction;
 800230a:	fb01 010c 	mla	r1, r1, ip, r0
{
 800230e:	f89d 6010 	ldrb.w	r6, [sp, #16]
 8002312:	9d05      	ldr	r5, [sp, #20]
 8002314:	f8bd 4018 	ldrh.w	r4, [sp, #24]
 8002318:	f89d e01c 	ldrb.w	lr, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
 800231c:	f881 203b 	strb.w	r2, [r1, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
 8002320:	f881 303f 	strb.w	r3, [r1, #63]	; 0x3f

  if (token == 0U)
 8002324:	bb4e      	cbnz	r6, 800237a <HAL_HCD_HC_SubmitRequest+0x76>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
 8002326:	f881 e03d 	strb.w	lr, [r1, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 800232a:	f04f 0e03 	mov.w	lr, #3
 800232e:	212c      	movs	r1, #44	; 0x2c
 8002330:	fb01 010c 	mla	r1, r1, ip, r0
 8002334:	f881 e042 	strb.w	lr, [r1, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
 8002338:	2b03      	cmp	r3, #3
 800233a:	d809      	bhi.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
 800233c:	e8df f003 	tbb	[pc, r3]
 8002340:	2020022c 	.word	0x2020022c
        }
      }
      break;

    case EP_TYPE_ISOC:
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002344:	232c      	movs	r3, #44	; 0x2c
 8002346:	2200      	movs	r2, #0
 8002348:	fb03 030c 	mla	r3, r3, ip, r0
 800234c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 8002350:	212c      	movs	r1, #44	; 0x2c
  hhcd->hc[ch_num].xfer_len  = length;
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
 8002352:	2600      	movs	r6, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8002354:	fb01 f30c 	mul.w	r3, r1, ip
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8002358:	fb01 010c 	mla	r1, r1, ip, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800235c:	18c2      	adds	r2, r0, r3
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 800235e:	3360      	adds	r3, #96	; 0x60
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8002360:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].ch_num = ch_num;
 8002362:	f882 c039 	strb.w	ip, [r2, #57]	; 0x39
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8002366:	6455      	str	r5, [r2, #68]	; 0x44
  hhcd->hc[ch_num].xfer_len  = length;
 8002368:	64d4      	str	r4, [r2, #76]	; 0x4c
  hhcd->hc[ch_num].xfer_count = 0U;
 800236a:	6516      	str	r6, [r2, #80]	; 0x50
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 800236c:	52c6      	strh	r6, [r0, r3]
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800236e:	7c02      	ldrb	r2, [r0, #16]
 8002370:	6800      	ldr	r0, [r0, #0]
}
 8002372:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8002376:	f005 bc51 	b.w	8007c1c <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800237a:	f04f 0e02 	mov.w	lr, #2
 800237e:	e7d6      	b.n	800232e <HAL_HCD_HC_SubmitRequest+0x2a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8002380:	232c      	movs	r3, #44	; 0x2c
 8002382:	fb03 030c 	mla	r3, r3, ip, r0
      if (direction == 0U)
 8002386:	b9ca      	cbnz	r2, 80023bc <HAL_HCD_HC_SubmitRequest+0xb8>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8002388:	f893 1055 	ldrb.w	r1, [r3, #85]	; 0x55
 800238c:	2900      	cmp	r1, #0
 800238e:	d0dd      	beq.n	800234c <HAL_HCD_HC_SubmitRequest+0x48>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8002390:	2202      	movs	r2, #2
 8002392:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8002396:	e7db      	b.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
      if ((token == 1U) && (direction == 0U)) /*send data */
 8002398:	2e01      	cmp	r6, #1
 800239a:	d1d9      	bne.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
 800239c:	2a00      	cmp	r2, #0
 800239e:	d1d7      	bne.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
          hhcd->hc[ch_num].toggle_out = 1U;
 80023a0:	232c      	movs	r3, #44	; 0x2c
 80023a2:	fb03 030c 	mla	r3, r3, ip, r0
        if (length == 0U)
 80023a6:	b98c      	cbnz	r4, 80023cc <HAL_HCD_HC_SubmitRequest+0xc8>
          hhcd->hc[ch_num].toggle_out = 1U;
 80023a8:	2201      	movs	r2, #1
 80023aa:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80023ae:	232c      	movs	r3, #44	; 0x2c
 80023b0:	2202      	movs	r2, #2
 80023b2:	fb03 030c 	mla	r3, r3, ip, r0
 80023b6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80023ba:	e7c9      	b.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 80023bc:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 80023c0:	2a00      	cmp	r2, #0
 80023c2:	d0c3      	beq.n	800234c <HAL_HCD_HC_SubmitRequest+0x48>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80023c4:	2202      	movs	r2, #2
 80023c6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80023ca:	e7c1      	b.n	8002350 <HAL_HCD_HC_SubmitRequest+0x4c>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80023cc:	f893 2055 	ldrb.w	r2, [r3, #85]	; 0x55
 80023d0:	2a00      	cmp	r2, #0
 80023d2:	d0bb      	beq.n	800234c <HAL_HCD_HC_SubmitRequest+0x48>
 80023d4:	e7eb      	b.n	80023ae <HAL_HCD_HC_SubmitRequest+0xaa>
 80023d6:	bf00      	nop

080023d8 <HAL_HCD_IRQHandler>:
  * @brief  Handle HCD interrupt request.
  * @param  hhcd HCD handle
  * @retval None
  */
void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 80023d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80023dc:	6805      	ldr	r5, [r0, #0]
{
 80023de:	b085      	sub	sp, #20
 80023e0:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;
  uint32_t interrupt;

  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 80023e2:	4628      	mov	r0, r5
 80023e4:	f005 fa34 	bl	8007850 <USB_GetMode>
 80023e8:	2801      	cmp	r0, #1
 80023ea:	d002      	beq.n	80023f2 <HAL_HCD_IRQHandler+0x1a>
        }
      }
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
    }
  }
}
 80023ec:	b005      	add	sp, #20
 80023ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 80023f2:	6820      	ldr	r0, [r4, #0]
 80023f4:	f005 fa20 	bl	8007838 <USB_ReadInterrupts>
 80023f8:	2800      	cmp	r0, #0
 80023fa:	d0f7      	beq.n	80023ec <HAL_HCD_IRQHandler+0x14>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80023fc:	6820      	ldr	r0, [r4, #0]
 80023fe:	f005 fa1b 	bl	8007838 <USB_ReadInterrupts>
 8002402:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002406:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002408:	d002      	beq.n	8002410 <HAL_HCD_IRQHandler+0x38>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800240a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800240e:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 8002410:	f005 fa12 	bl	8007838 <USB_ReadInterrupts>
 8002414:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8002418:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 800241a:	d002      	beq.n	8002422 <HAL_HCD_IRQHandler+0x4a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 800241c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8002420:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 8002422:	f005 fa09 	bl	8007838 <USB_ReadInterrupts>
 8002426:	f010 6f80 	tst.w	r0, #67108864	; 0x4000000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 800242a:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 800242c:	d002      	beq.n	8002434 <HAL_HCD_IRQHandler+0x5c>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 800242e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8002432:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 8002434:	f005 fa00 	bl	8007838 <USB_ReadInterrupts>
 8002438:	f010 0f02 	tst.w	r0, #2
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 800243c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 800243e:	d001      	beq.n	8002444 <HAL_HCD_IRQHandler+0x6c>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8002440:	2302      	movs	r3, #2
 8002442:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 8002444:	f005 f9f8 	bl	8007838 <USB_ReadInterrupts>
 8002448:	f010 5f00 	tst.w	r0, #536870912	; 0x20000000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 800244c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 800244e:	d179      	bne.n	8002544 <HAL_HCD_IRQHandler+0x16c>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8002450:	f005 f9f2 	bl	8007838 <USB_ReadInterrupts>
 8002454:	01c0      	lsls	r0, r0, #7
 8002456:	f100 80fb 	bmi.w	8002650 <HAL_HCD_IRQHandler+0x278>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 800245a:	6820      	ldr	r0, [r4, #0]
 800245c:	f005 f9ec 	bl	8007838 <USB_ReadInterrupts>
 8002460:	0701      	lsls	r1, r0, #28
 8002462:	f100 80ee 	bmi.w	8002642 <HAL_HCD_IRQHandler+0x26a>
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 8002466:	6820      	ldr	r0, [r4, #0]
 8002468:	f005 f9e6 	bl	8007838 <USB_ReadInterrupts>
 800246c:	06c2      	lsls	r2, r0, #27
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800246e:	6826      	ldr	r6, [r4, #0]
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 8002470:	f100 812d 	bmi.w	80026ce <HAL_HCD_IRQHandler+0x2f6>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 8002474:	4630      	mov	r0, r6
 8002476:	f005 f9df 	bl	8007838 <USB_ReadInterrupts>
 800247a:	0183      	lsls	r3, r0, #6
 800247c:	d5b6      	bpl.n	80023ec <HAL_HCD_IRQHandler+0x14>
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 800247e:	6820      	ldr	r0, [r4, #0]
 8002480:	f005 fc90 	bl	8007da4 <USB_HC_ReadInterrupt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002484:	68a2      	ldr	r2, [r4, #8]
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8002486:	4681      	mov	r9, r0
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002488:	2a00      	cmp	r2, #0
 800248a:	f000 811b 	beq.w	80026c4 <HAL_HCD_IRQHandler+0x2ec>
 800248e:	2600      	movs	r6, #0
 8002490:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_CHH))
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002494:	f04f 0a2c 	mov.w	sl, #44	; 0x2c
 8002498:	e030      	b.n	80024fc <HAL_HCD_IRQHandler+0x124>
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800249a:	f8d4 8000 	ldr.w	r8, [r4]
 800249e:	b2f7      	uxtb	r7, r6
  if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_AHBERR))
 80024a0:	4640      	mov	r0, r8
 80024a2:	4639      	mov	r1, r7
 80024a4:	f005 f9cc 	bl	8007840 <USB_ReadChInterrupts>
 80024a8:	0741      	lsls	r1, r0, #29
 80024aa:	d563      	bpl.n	8002574 <HAL_HCD_IRQHandler+0x19c>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 80024ac:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 80024b0:	2204      	movs	r2, #4
 80024b2:	eb03 1347 	add.w	r3, r3, r7, lsl #5
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 80024b6:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_XACTERR;
 80024b8:	2207      	movs	r2, #7
 80024ba:	fb0a 4307 	mla	r3, sl, r7, r4
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80024be:	4639      	mov	r1, r7
    hhcd->hc[ch_num].state = HC_XACTERR;
 80024c0:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80024c4:	6820      	ldr	r0, [r4, #0]
 80024c6:	f005 fc71 	bl	8007dac <USB_HC_Halt>
  if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_FRMOR))
 80024ca:	4639      	mov	r1, r7
 80024cc:	6820      	ldr	r0, [r4, #0]
 80024ce:	f005 f9b7 	bl	8007840 <USB_ReadChInterrupts>
 80024d2:	f410 7f00 	tst.w	r0, #512	; 0x200
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80024d6:	4639      	mov	r1, r7
 80024d8:	6820      	ldr	r0, [r4, #0]
  if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_FRMOR))
 80024da:	d063      	beq.n	80025a4 <HAL_HCD_IRQHandler+0x1cc>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 80024dc:	f508 68a0 	add.w	r8, r8, #1280	; 0x500
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80024e0:	f005 fc64 	bl	8007dac <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 80024e4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80024e8:	eb08 1847 	add.w	r8, r8, r7, lsl #5
 80024ec:	f8c8 3008 	str.w	r3, [r8, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 80024f0:	68a2      	ldr	r2, [r4, #8]
 80024f2:	3601      	adds	r6, #1
 80024f4:	3520      	adds	r5, #32
 80024f6:	4296      	cmp	r6, r2
 80024f8:	f080 80e4 	bcs.w	80026c4 <HAL_HCD_IRQHandler+0x2ec>
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 80024fc:	f006 030f 	and.w	r3, r6, #15
 8002500:	fa29 f303 	lsr.w	r3, r9, r3
 8002504:	07df      	lsls	r7, r3, #31
 8002506:	d5f4      	bpl.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8002508:	682b      	ldr	r3, [r5, #0]
 800250a:	0418      	lsls	r0, r3, #16
 800250c:	d4c5      	bmi.n	800249a <HAL_HCD_IRQHandler+0xc2>
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800250e:	6827      	ldr	r7, [r4, #0]
 8002510:	fa5f f886 	uxtb.w	r8, r6
  if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_AHBERR))
 8002514:	4638      	mov	r0, r7
 8002516:	4641      	mov	r1, r8
 8002518:	f005 f992 	bl	8007840 <USB_ReadChInterrupts>
 800251c:	f010 0b04 	ands.w	fp, r0, #4
 8002520:	d079      	beq.n	8002616 <HAL_HCD_IRQHandler+0x23e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8002522:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
 8002526:	2304      	movs	r3, #4
    hhcd->hc[ch_num].state = HC_XACTERR;
 8002528:	2207      	movs	r2, #7
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800252a:	4641      	mov	r1, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 800252c:	eb07 1748 	add.w	r7, r7, r8, lsl #5
 8002530:	60bb      	str	r3, [r7, #8]
    hhcd->hc[ch_num].state = HC_XACTERR;
 8002532:	fb0a 4308 	mla	r3, sl, r8, r4
 8002536:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800253a:	6820      	ldr	r0, [r4, #0]
 800253c:	f005 fc36 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002540:	68a2      	ldr	r2, [r4, #8]
 8002542:	e7d6      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 8002544:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8002548:	6143      	str	r3, [r0, #20]
      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 800254a:	f8d5 3440 	ldr.w	r3, [r5, #1088]	; 0x440
 800254e:	07de      	lsls	r6, r3, #31
 8002550:	f53f af7e 	bmi.w	8002450 <HAL_HCD_IRQHandler+0x78>
        (void)USB_FlushTxFifo(USBx, 0x10U);
 8002554:	2110      	movs	r1, #16
 8002556:	4628      	mov	r0, r5
 8002558:	f005 f8f6 	bl	8007748 <USB_FlushTxFifo>
        (void)USB_FlushRxFifo(USBx);
 800255c:	4628      	mov	r0, r5
 800255e:	f005 f91d 	bl	800779c <USB_FlushRxFifo>
        (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8002562:	2101      	movs	r1, #1
 8002564:	6820      	ldr	r0, [r4, #0]
 8002566:	f005 fa2b 	bl	80079c0 <USB_InitFSLSPClkSel>
        HAL_HCD_Disconnect_Callback(hhcd);
 800256a:	4620      	mov	r0, r4
 800256c:	f01c fad6 	bl	801eb1c <HAL_HCD_Disconnect_Callback>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8002570:	6820      	ldr	r0, [r4, #0]
 8002572:	e76d      	b.n	8002450 <HAL_HCD_IRQHandler+0x78>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_BBERR))
 8002574:	4639      	mov	r1, r7
 8002576:	6820      	ldr	r0, [r4, #0]
 8002578:	f005 f962 	bl	8007840 <USB_ReadChInterrupts>
 800257c:	05c2      	lsls	r2, r0, #23
 800257e:	f140 80b8 	bpl.w	80026f2 <HAL_HCD_IRQHandler+0x31a>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_BBERR);
 8002582:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 8002586:	f44f 7280 	mov.w	r2, #256	; 0x100
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800258a:	4639      	mov	r1, r7
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_BBERR);
 800258c:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 8002590:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_BBLERR;
 8002592:	2208      	movs	r2, #8
 8002594:	fb0a 4307 	mla	r3, sl, r7, r4
 8002598:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800259c:	6820      	ldr	r0, [r4, #0]
 800259e:	f005 fc05 	bl	8007dac <USB_HC_Halt>
 80025a2:	e792      	b.n	80024ca <HAL_HCD_IRQHandler+0xf2>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_XFRC))
 80025a4:	f005 f94c 	bl	8007840 <USB_ReadChInterrupts>
 80025a8:	07c2      	lsls	r2, r0, #31
 80025aa:	f140 80cc 	bpl.w	8002746 <HAL_HCD_IRQHandler+0x36e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 80025ae:	f508 68a0 	add.w	r8, r8, #1280	; 0x500
 80025b2:	2320      	movs	r3, #32
    if (hhcd->Init.dma_enable != 0U)
 80025b4:	6921      	ldr	r1, [r4, #16]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 80025b6:	0178      	lsls	r0, r7, #5
 80025b8:	eb08 1b47 	add.w	fp, r8, r7, lsl #5
 80025bc:	f8cb 3008 	str.w	r3, [fp, #8]
    if (hhcd->Init.dma_enable != 0U)
 80025c0:	b151      	cbz	r1, 80025d8 <HAL_HCD_IRQHandler+0x200>
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 80025c2:	f8db 2010 	ldr.w	r2, [fp, #16]
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].XferSize - \
 80025c6:	fb0a 4c07 	mla	ip, sl, r7, r4
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 80025ca:	f3c2 0212 	ubfx	r2, r2, #0, #19
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].XferSize - \
 80025ce:	f8dc 3048 	ldr.w	r3, [ip, #72]	; 0x48
 80025d2:	1a9b      	subs	r3, r3, r2
 80025d4:	f8cc 3050 	str.w	r3, [ip, #80]	; 0x50
    hhcd->hc[ch_num].state = HC_XFRC;
 80025d8:	fb0a 4307 	mla	r3, sl, r7, r4
    hhcd->hc[ch_num].ErrCnt = 0U;
 80025dc:	2200      	movs	r2, #0
 80025de:	65da      	str	r2, [r3, #92]	; 0x5c
    hhcd->hc[ch_num].state = HC_XFRC;
 80025e0:	2201      	movs	r2, #1
 80025e2:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 80025e6:	f8cb 2008 	str.w	r2, [fp, #8]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 80025ea:	f893 203f 	ldrb.w	r2, [r3, #63]	; 0x3f
 80025ee:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
 80025f2:	f000 80d9 	beq.w	80027a8 <HAL_HCD_IRQHandler+0x3d0>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_INTR) ||
 80025f6:	2a01      	cmp	r2, #1
 80025f8:	f000 8127 	beq.w	800284a <HAL_HCD_IRQHandler+0x472>
    if (hhcd->Init.dma_enable == 1U)
 80025fc:	2901      	cmp	r1, #1
      if (((hhcd->hc[ch_num].XferSize / hhcd->hc[ch_num].max_packet) & 1U) != 0U)
 80025fe:	fb0a 4707 	mla	r7, sl, r7, r4
    if (hhcd->Init.dma_enable == 1U)
 8002602:	f000 80c8 	beq.w	8002796 <HAL_HCD_IRQHandler+0x3be>
      hhcd->hc[ch_num].toggle_in ^= 1U;
 8002606:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 800260a:	f083 0301 	eor.w	r3, r3, #1
 800260e:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002612:	68a2      	ldr	r2, [r4, #8]
 8002614:	e76d      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_ACK))
 8002616:	4641      	mov	r1, r8
 8002618:	6820      	ldr	r0, [r4, #0]
 800261a:	f005 f911 	bl	8007840 <USB_ReadChInterrupts>
 800261e:	0681      	lsls	r1, r0, #26
 8002620:	d57d      	bpl.n	800271e <HAL_HCD_IRQHandler+0x346>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8002622:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
 8002626:	2220      	movs	r2, #32
    if (hhcd->hc[ch_num].do_ping == 1U)
 8002628:	fb0a f308 	mul.w	r3, sl, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 800262c:	eb07 1748 	add.w	r7, r7, r8, lsl #5
 8002630:	60ba      	str	r2, [r7, #8]
    if (hhcd->hc[ch_num].do_ping == 1U)
 8002632:	18e2      	adds	r2, r4, r3
 8002634:	f892 103d 	ldrb.w	r1, [r2, #61]	; 0x3d
 8002638:	2901      	cmp	r1, #1
 800263a:	f000 8114 	beq.w	8002866 <HAL_HCD_IRQHandler+0x48e>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800263e:	68a2      	ldr	r2, [r4, #8]
 8002640:	e757      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      HAL_HCD_SOF_Callback(hhcd);
 8002642:	4620      	mov	r0, r4
 8002644:	f01c fa62 	bl	801eb0c <HAL_HCD_SOF_Callback>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8002648:	6820      	ldr	r0, [r4, #0]
 800264a:	2308      	movs	r3, #8
 800264c:	6143      	str	r3, [r0, #20]
 800264e:	e70b      	b.n	8002468 <HAL_HCD_IRQHandler+0x90>
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
 8002650:	6826      	ldr	r6, [r4, #0]
  __IO uint32_t hprt0;
  __IO uint32_t hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 8002652:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 8002656:	9302      	str	r3, [sp, #8]
  hprt0_dup = USBx_HPRT0;
 8002658:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 800265c:	9303      	str	r3, [sp, #12]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 800265e:	9b03      	ldr	r3, [sp, #12]
 8002660:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8002664:	9303      	str	r3, [sp, #12]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8002666:	9b02      	ldr	r3, [sp, #8]
 8002668:	0799      	lsls	r1, r3, #30
 800266a:	d507      	bpl.n	800267c <HAL_HCD_IRQHandler+0x2a4>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 800266c:	9b02      	ldr	r3, [sp, #8]
 800266e:	07da      	lsls	r2, r3, #31
 8002670:	f100 80bd 	bmi.w	80027ee <HAL_HCD_IRQHandler+0x416>
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup |= USB_OTG_HPRT_PCDET;
 8002674:	9b03      	ldr	r3, [sp, #12]
 8002676:	f043 0302 	orr.w	r3, r3, #2
 800267a:	9303      	str	r3, [sp, #12]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 800267c:	9b02      	ldr	r3, [sp, #8]
 800267e:	071b      	lsls	r3, r3, #28
 8002680:	d515      	bpl.n	80026ae <HAL_HCD_IRQHandler+0x2d6>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8002682:	9b03      	ldr	r3, [sp, #12]
 8002684:	f043 0308 	orr.w	r3, r3, #8
 8002688:	9303      	str	r3, [sp, #12]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 800268a:	9b02      	ldr	r3, [sp, #8]
 800268c:	075f      	lsls	r7, r3, #29
 800268e:	f140 80aa 	bpl.w	80027e6 <HAL_HCD_IRQHandler+0x40e>
    {
      if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
 8002692:	69a1      	ldr	r1, [r4, #24]
 8002694:	2902      	cmp	r1, #2
 8002696:	f000 80ff 	beq.w	8002898 <HAL_HCD_IRQHandler+0x4c0>
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 800269a:	68e3      	ldr	r3, [r4, #12]
 800269c:	2b01      	cmp	r3, #1
 800269e:	d103      	bne.n	80026a8 <HAL_HCD_IRQHandler+0x2d0>
        {
          USBx_HOST->HFIR = 60000U;
 80026a0:	f64e 2260 	movw	r2, #60000	; 0xea60
 80026a4:	f8c6 2404 	str.w	r2, [r6, #1028]	; 0x404
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 80026a8:	4620      	mov	r0, r4
 80026aa:	f01c fa3b 	bl	801eb24 <HAL_HCD_PortEnabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 80026ae:	9b02      	ldr	r3, [sp, #8]
 80026b0:	0698      	lsls	r0, r3, #26
 80026b2:	d503      	bpl.n	80026bc <HAL_HCD_IRQHandler+0x2e4>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 80026b4:	9b03      	ldr	r3, [sp, #12]
 80026b6:	f043 0320 	orr.w	r3, r3, #32
 80026ba:	9303      	str	r3, [sp, #12]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 80026bc:	9b03      	ldr	r3, [sp, #12]
 80026be:	f8c6 3440 	str.w	r3, [r6, #1088]	; 0x440
}
 80026c2:	e6ca      	b.n	800245a <HAL_HCD_IRQHandler+0x82>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 80026c4:	6823      	ldr	r3, [r4, #0]
 80026c6:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80026ca:	615a      	str	r2, [r3, #20]
 80026cc:	e68e      	b.n	80023ec <HAL_HCD_IRQHandler+0x14>
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80026ce:	69b3      	ldr	r3, [r6, #24]
 80026d0:	f023 0310 	bic.w	r3, r3, #16
 80026d4:	61b3      	str	r3, [r6, #24]
  GrxstspReg = hhcd->Instance->GRXSTSP;
 80026d6:	6a37      	ldr	r7, [r6, #32]
  pktsts = (GrxstspReg & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 80026d8:	f3c7 4143 	ubfx	r1, r7, #17, #4
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;
 80026dc:	f3c7 120a 	ubfx	r2, r7, #4, #11
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 80026e0:	2902      	cmp	r1, #2
 80026e2:	d101      	bne.n	80026e8 <HAL_HCD_IRQHandler+0x310>
 80026e4:	2a00      	cmp	r2, #0
 80026e6:	d168      	bne.n	80027ba <HAL_HCD_IRQHandler+0x3e2>
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80026e8:	69b3      	ldr	r3, [r6, #24]
 80026ea:	f043 0310 	orr.w	r3, r3, #16
 80026ee:	61b3      	str	r3, [r6, #24]
 80026f0:	e6c0      	b.n	8002474 <HAL_HCD_IRQHandler+0x9c>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_STALL))
 80026f2:	4639      	mov	r1, r7
 80026f4:	6820      	ldr	r0, [r4, #0]
 80026f6:	f005 f8a3 	bl	8007840 <USB_ReadChInterrupts>
 80026fa:	0703      	lsls	r3, r0, #28
 80026fc:	d533      	bpl.n	8002766 <HAL_HCD_IRQHandler+0x38e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 80026fe:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 8002702:	2208      	movs	r2, #8
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002704:	4639      	mov	r1, r7
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8002706:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 800270a:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_STALL;
 800270c:	2206      	movs	r2, #6
 800270e:	fb0a 4307 	mla	r3, sl, r7, r4
 8002712:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002716:	6820      	ldr	r0, [r4, #0]
 8002718:	f005 fb48 	bl	8007dac <USB_HC_Halt>
 800271c:	e6d5      	b.n	80024ca <HAL_HCD_IRQHandler+0xf2>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_FRMOR))
 800271e:	4641      	mov	r1, r8
 8002720:	6820      	ldr	r0, [r4, #0]
 8002722:	f005 f88d 	bl	8007840 <USB_ReadChInterrupts>
 8002726:	f410 7b00 	ands.w	fp, r0, #512	; 0x200
 800272a:	d064      	beq.n	80027f6 <HAL_HCD_IRQHandler+0x41e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 800272c:	f507 63a0 	add.w	r3, r7, #1280	; 0x500
 8002730:	f44f 7200 	mov.w	r2, #512	; 0x200
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002734:	4641      	mov	r1, r8
 8002736:	6820      	ldr	r0, [r4, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8002738:	eb03 1348 	add.w	r3, r3, r8, lsl #5
 800273c:	609a      	str	r2, [r3, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800273e:	f005 fb35 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002742:	68a2      	ldr	r2, [r4, #8]
 8002744:	e6d5      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_ACK))
 8002746:	4639      	mov	r1, r7
 8002748:	6820      	ldr	r0, [r4, #0]
 800274a:	f005 f879 	bl	8007840 <USB_ReadChInterrupts>
 800274e:	0680      	lsls	r0, r0, #26
 8002750:	f140 80ad 	bpl.w	80028ae <HAL_HCD_IRQHandler+0x4d6>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8002754:	f508 68a0 	add.w	r8, r8, #1280	; 0x500
 8002758:	2320      	movs	r3, #32
 800275a:	eb08 1847 	add.w	r8, r8, r7, lsl #5
 800275e:	f8c8 3008 	str.w	r3, [r8, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002762:	68a2      	ldr	r2, [r4, #8]
 8002764:	e6c5      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_DTERR))
 8002766:	4639      	mov	r1, r7
 8002768:	6820      	ldr	r0, [r4, #0]
 800276a:	f005 f869 	bl	8007840 <USB_ReadChInterrupts>
 800276e:	0540      	lsls	r0, r0, #21
 8002770:	f140 8085 	bpl.w	800287e <HAL_HCD_IRQHandler+0x4a6>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002774:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 8002778:	f44f 6280 	mov.w	r2, #1024	; 0x400
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800277c:	4639      	mov	r1, r7
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 800277e:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 8002782:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8002784:	2209      	movs	r2, #9
 8002786:	fb0a 4307 	mla	r3, sl, r7, r4
 800278a:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800278e:	6820      	ldr	r0, [r4, #0]
 8002790:	f005 fb0c 	bl	8007dac <USB_HC_Halt>
 8002794:	e699      	b.n	80024ca <HAL_HCD_IRQHandler+0xf2>
      if (((hhcd->hc[ch_num].XferSize / hhcd->hc[ch_num].max_packet) & 1U) != 0U)
 8002796:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 800279a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800279c:	fbb3 f3f2 	udiv	r3, r3, r2
 80027a0:	07db      	lsls	r3, r3, #31
 80027a2:	f53f af30 	bmi.w	8002606 <HAL_HCD_IRQHandler+0x22e>
 80027a6:	e74a      	b.n	800263e <HAL_HCD_IRQHandler+0x266>
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80027a8:	4639      	mov	r1, r7
 80027aa:	6820      	ldr	r0, [r4, #0]
 80027ac:	f005 fafe 	bl	8007dac <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 80027b0:	2310      	movs	r3, #16
    if (hhcd->Init.dma_enable == 1U)
 80027b2:	6921      	ldr	r1, [r4, #16]
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 80027b4:	f8cb 3008 	str.w	r3, [fp, #8]
 80027b8:	e720      	b.n	80025fc <HAL_HCD_IRQHandler+0x224>
  ch_num = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
 80027ba:	f007 070f 	and.w	r7, r7, #15
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 80027be:	f04f 082c 	mov.w	r8, #44	; 0x2c
 80027c2:	fb08 4807 	mla	r8, r8, r7, r4
 80027c6:	f8d8 1044 	ldr.w	r1, [r8, #68]	; 0x44
 80027ca:	2900      	cmp	r1, #0
 80027cc:	d08c      	beq.n	80026e8 <HAL_HCD_IRQHandler+0x310>
        if ((hhcd->hc[ch_num].xfer_count + pktcnt) <= hhcd->hc[ch_num].xfer_len)
 80027ce:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 80027d2:	f8d8 004c 	ldr.w	r0, [r8, #76]	; 0x4c
 80027d6:	4413      	add	r3, r2
 80027d8:	4283      	cmp	r3, r0
 80027da:	f240 80d6 	bls.w	800298a <HAL_HCD_IRQHandler+0x5b2>
          hhcd->hc[ch_num].urb_state = URB_ERROR;
 80027de:	2304      	movs	r3, #4
 80027e0:	f888 3060 	strb.w	r3, [r8, #96]	; 0x60
 80027e4:	e780      	b.n	80026e8 <HAL_HCD_IRQHandler+0x310>
      HAL_HCD_PortDisabled_Callback(hhcd);
 80027e6:	4620      	mov	r0, r4
 80027e8:	f01c f9a0 	bl	801eb2c <HAL_HCD_PortDisabled_Callback>
 80027ec:	e75f      	b.n	80026ae <HAL_HCD_IRQHandler+0x2d6>
      HAL_HCD_Connect_Callback(hhcd);
 80027ee:	4620      	mov	r0, r4
 80027f0:	f01c f990 	bl	801eb14 <HAL_HCD_Connect_Callback>
 80027f4:	e73e      	b.n	8002674 <HAL_HCD_IRQHandler+0x29c>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_XFRC))
 80027f6:	4641      	mov	r1, r8
 80027f8:	6820      	ldr	r0, [r4, #0]
 80027fa:	f005 f821 	bl	8007840 <USB_ReadChInterrupts>
 80027fe:	f010 0301 	ands.w	r3, r0, #1
 8002802:	f000 808d 	beq.w	8002920 <HAL_HCD_IRQHandler+0x548>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002806:	fb0a 4208 	mla	r2, sl, r8, r4
    if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 800280a:	4641      	mov	r1, r8
 800280c:	6820      	ldr	r0, [r4, #0]
    hhcd->hc[ch_num].ErrCnt = 0U;
 800280e:	f8c2 b05c 	str.w	fp, [r2, #92]	; 0x5c
 8002812:	9201      	str	r2, [sp, #4]
    if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 8002814:	f005 f814 	bl	8007840 <USB_ReadChInterrupts>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8002818:	f507 63a0 	add.w	r3, r7, #1280	; 0x500
    if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 800281c:	f010 0f40 	tst.w	r0, #64	; 0x40
 8002820:	9a01      	ldr	r2, [sp, #4]
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8002822:	eb03 1348 	add.w	r3, r3, r8, lsl #5
    if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 8002826:	d004      	beq.n	8002832 <HAL_HCD_IRQHandler+0x45a>
      hhcd->hc[ch_num].do_ping = 1U;
 8002828:	2101      	movs	r1, #1
 800282a:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 800282e:	2240      	movs	r2, #64	; 0x40
 8002830:	609a      	str	r2, [r3, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8002832:	2201      	movs	r2, #1
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002834:	4641      	mov	r1, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8002836:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_XFRC;
 8002838:	fb0a 4308 	mla	r3, sl, r8, r4
 800283c:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002840:	6820      	ldr	r0, [r4, #0]
 8002842:	f005 fab3 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002846:	68a2      	ldr	r2, [r4, #8]
 8002848:	e653      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 800284a:	f850 1008 	ldr.w	r1, [r0, r8]
 800284e:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 8002852:	f840 1008 	str.w	r1, [r0, r8]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002856:	4639      	mov	r1, r7
 8002858:	4620      	mov	r0, r4
      hhcd->hc[ch_num].urb_state = URB_DONE;
 800285a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 800285e:	f01c f969 	bl	801eb34 <HAL_HCD_HC_NotifyURBChange_Callback>
    if (hhcd->Init.dma_enable == 1U)
 8002862:	6921      	ldr	r1, [r4, #16]
 8002864:	e6ca      	b.n	80025fc <HAL_HCD_IRQHandler+0x224>
      hhcd->hc[ch_num].do_ping = 0U;
 8002866:	f882 b03d 	strb.w	fp, [r2, #61]	; 0x3d
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 800286a:	3360      	adds	r3, #96	; 0x60
 800286c:	f240 3202 	movw	r2, #770	; 0x302
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002870:	4641      	mov	r1, r8
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002872:	52e2      	strh	r2, [r4, r3]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002874:	6820      	ldr	r0, [r4, #0]
 8002876:	f005 fa99 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800287a:	68a2      	ldr	r2, [r4, #8]
 800287c:	e639      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_TXERR))
 800287e:	4639      	mov	r1, r7
 8002880:	6820      	ldr	r0, [r4, #0]
 8002882:	f004 ffdd 	bl	8007840 <USB_ReadChInterrupts>
 8002886:	0601      	lsls	r1, r0, #24
 8002888:	f57f ae1f 	bpl.w	80024ca <HAL_HCD_IRQHandler+0xf2>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 800288c:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 8002890:	2280      	movs	r2, #128	; 0x80
 8002892:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 8002896:	e60e      	b.n	80024b6 <HAL_HCD_IRQHandler+0xde>
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8002898:	9b02      	ldr	r3, [sp, #8]
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 800289a:	6820      	ldr	r0, [r4, #0]
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 800289c:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 80028a0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80028a4:	bf18      	it	ne
 80028a6:	2101      	movne	r1, #1
 80028a8:	f005 f88a 	bl	80079c0 <USB_InitFSLSPClkSel>
 80028ac:	e6fc      	b.n	80026a8 <HAL_HCD_IRQHandler+0x2d0>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_CHH))
 80028ae:	4639      	mov	r1, r7
 80028b0:	6820      	ldr	r0, [r4, #0]
 80028b2:	f004 ffc5 	bl	8007840 <USB_ReadChInterrupts>
 80028b6:	f010 0b02 	ands.w	fp, r0, #2
 80028ba:	f000 8085 	beq.w	80029c8 <HAL_HCD_IRQHandler+0x5f0>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 80028be:	f508 68a0 	add.w	r8, r8, #1280	; 0x500
 80028c2:	2002      	movs	r0, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 80028c4:	fb0a f207 	mul.w	r2, sl, r7
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 80028c8:	0179      	lsls	r1, r7, #5
 80028ca:	eb08 1347 	add.w	r3, r8, r7, lsl #5
 80028ce:	6098      	str	r0, [r3, #8]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 80028d0:	18a0      	adds	r0, r4, r2
 80028d2:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
 80028d6:	2b01      	cmp	r3, #1
 80028d8:	f000 8090 	beq.w	80029fc <HAL_HCD_IRQHandler+0x624>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 80028dc:	2b06      	cmp	r3, #6
 80028de:	f000 80e9 	beq.w	8002ab4 <HAL_HCD_IRQHandler+0x6dc>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 80028e2:	2b07      	cmp	r3, #7
 80028e4:	f000 80d5 	beq.w	8002a92 <HAL_HCD_IRQHandler+0x6ba>
 80028e8:	2b09      	cmp	r3, #9
 80028ea:	f000 80d2 	beq.w	8002a92 <HAL_HCD_IRQHandler+0x6ba>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 80028ee:	2b05      	cmp	r3, #5
 80028f0:	f000 811d 	beq.w	8002b2e <HAL_HCD_IRQHandler+0x756>
    else if (hhcd->hc[ch_num].state == HC_ACK)
 80028f4:	2b03      	cmp	r3, #3
 80028f6:	f000 811f 	beq.w	8002b38 <HAL_HCD_IRQHandler+0x760>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 80028fa:	2b04      	cmp	r3, #4
 80028fc:	f000 812e 	beq.w	8002b5c <HAL_HCD_IRQHandler+0x784>
    else if (hhcd->hc[ch_num].state == HC_BBLERR)
 8002900:	2b08      	cmp	r3, #8
 8002902:	f000 8120 	beq.w	8002b46 <HAL_HCD_IRQHandler+0x76e>
      if (hhcd->hc[ch_num].state == HC_HALTED)
 8002906:	2b02      	cmp	r3, #2
 8002908:	f43f ae99 	beq.w	800263e <HAL_HCD_IRQHandler+0x266>
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 800290c:	fb0a 4307 	mla	r3, sl, r7, r4
 8002910:	4639      	mov	r1, r7
 8002912:	4620      	mov	r0, r4
 8002914:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
 8002918:	f01c f90c 	bl	801eb34 <HAL_HCD_HC_NotifyURBChange_Callback>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800291c:	68a2      	ldr	r2, [r4, #8]
 800291e:	e5e8      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 8002920:	4641      	mov	r1, r8
 8002922:	6820      	ldr	r0, [r4, #0]
 8002924:	9301      	str	r3, [sp, #4]
 8002926:	f004 ff8b 	bl	8007840 <USB_ReadChInterrupts>
 800292a:	0642      	lsls	r2, r0, #25
 800292c:	d515      	bpl.n	800295a <HAL_HCD_IRQHandler+0x582>
    hhcd->hc[ch_num].state = HC_NYET;
 800292e:	fb0a 4208 	mla	r2, sl, r8, r4
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002932:	9b01      	ldr	r3, [sp, #4]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8002934:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002938:	4641      	mov	r1, r8
    hhcd->hc[ch_num].ErrCnt = 0U;
 800293a:	65d3      	str	r3, [r2, #92]	; 0x5c
    hhcd->hc[ch_num].state = HC_NYET;
 800293c:	2305      	movs	r3, #5
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 800293e:	eb07 1748 	add.w	r7, r7, r8, lsl #5
    hhcd->hc[ch_num].state = HC_NYET;
 8002942:	f882 3061 	strb.w	r3, [r2, #97]	; 0x61
    hhcd->hc[ch_num].do_ping = 1U;
 8002946:	2301      	movs	r3, #1
 8002948:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800294c:	6820      	ldr	r0, [r4, #0]
 800294e:	f005 fa2d 	bl	8007dac <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8002952:	2340      	movs	r3, #64	; 0x40
 8002954:	60bb      	str	r3, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002956:	68a2      	ldr	r2, [r4, #8]
 8002958:	e5cb      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_STALL))
 800295a:	4641      	mov	r1, r8
 800295c:	6820      	ldr	r0, [r4, #0]
 800295e:	f004 ff6f 	bl	8007840 <USB_ReadChInterrupts>
 8002962:	f010 0b08 	ands.w	fp, r0, #8
 8002966:	d04e      	beq.n	8002a06 <HAL_HCD_IRQHandler+0x62e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8002968:	f507 63a0 	add.w	r3, r7, #1280	; 0x500
 800296c:	2208      	movs	r2, #8
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800296e:	4641      	mov	r1, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8002970:	eb03 1348 	add.w	r3, r3, r8, lsl #5
 8002974:	609a      	str	r2, [r3, #8]
    hhcd->hc[ch_num].state = HC_STALL;
 8002976:	2206      	movs	r2, #6
 8002978:	fb0a 4308 	mla	r3, sl, r8, r4
 800297c:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002980:	6820      	ldr	r0, [r4, #0]
 8002982:	f005 fa13 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002986:	68a2      	ldr	r2, [r4, #8]
 8002988:	e5b3      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
          (void)USB_ReadPacket(hhcd->Instance,
 800298a:	4630      	mov	r0, r6
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 800298c:	f506 66a0 	add.w	r6, r6, #1280	; 0x500
          (void)USB_ReadPacket(hhcd->Instance,
 8002990:	9201      	str	r2, [sp, #4]
 8002992:	f004 ff2b 	bl	80077ec <USB_ReadPacket>
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8002996:	eb06 1147 	add.w	r1, r6, r7, lsl #5
          hhcd->hc[ch_num].xfer_buff += pktcnt;
 800299a:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 800299e:	9a01      	ldr	r2, [sp, #4]
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 80029a0:	6909      	ldr	r1, [r1, #16]
          hhcd->hc[ch_num].xfer_count += pktcnt;
 80029a2:	f8d8 0050 	ldr.w	r0, [r8, #80]	; 0x50
          hhcd->hc[ch_num].xfer_buff += pktcnt;
 80029a6:	4413      	add	r3, r2
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 80029a8:	f3c1 41c9 	ubfx	r1, r1, #19, #10
          hhcd->hc[ch_num].xfer_count += pktcnt;
 80029ac:	4410      	add	r0, r2
          hhcd->hc[ch_num].xfer_buff += pktcnt;
 80029ae:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 80029b2:	017b      	lsls	r3, r7, #5
          hhcd->hc[ch_num].xfer_count += pktcnt;
 80029b4:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
          if ((hhcd->hc[ch_num].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 80029b8:	b121      	cbz	r1, 80029c4 <HAL_HCD_IRQHandler+0x5ec>
 80029ba:	f8b8 1040 	ldrh.w	r1, [r8, #64]	; 0x40
 80029be:	4291      	cmp	r1, r2
 80029c0:	f000 80a8 	beq.w	8002b14 <HAL_HCD_IRQHandler+0x73c>
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80029c4:	6826      	ldr	r6, [r4, #0]
 80029c6:	e68f      	b.n	80026e8 <HAL_HCD_IRQHandler+0x310>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NYET))
 80029c8:	4639      	mov	r1, r7
 80029ca:	6820      	ldr	r0, [r4, #0]
 80029cc:	f004 ff38 	bl	8007840 <USB_ReadChInterrupts>
 80029d0:	f010 0240 	ands.w	r2, r0, #64	; 0x40
 80029d4:	d03b      	beq.n	8002a4e <HAL_HCD_IRQHandler+0x676>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 80029d6:	f508 63a0 	add.w	r3, r8, #1280	; 0x500
 80029da:	2040      	movs	r0, #64	; 0x40
    hhcd->hc[ch_num].state = HC_NYET;
 80029dc:	fb0a 4207 	mla	r2, sl, r7, r4
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80029e0:	4639      	mov	r1, r7
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 80029e2:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 80029e6:	6098      	str	r0, [r3, #8]
    hhcd->hc[ch_num].state = HC_NYET;
 80029e8:	2305      	movs	r3, #5
    hhcd->hc[ch_num].ErrCnt = 0U;
 80029ea:	f8c2 b05c 	str.w	fp, [r2, #92]	; 0x5c
    hhcd->hc[ch_num].state = HC_NYET;
 80029ee:	f882 3061 	strb.w	r3, [r2, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80029f2:	6820      	ldr	r0, [r4, #0]
 80029f4:	f005 f9da 	bl	8007dac <USB_HC_Halt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 80029f8:	68a2      	ldr	r2, [r4, #8]
 80029fa:	e57a      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      hhcd->hc[ch_num].urb_state = URB_DONE;
 80029fc:	3260      	adds	r2, #96	; 0x60
 80029fe:	f240 2301 	movw	r3, #513	; 0x201
 8002a02:	52a3      	strh	r3, [r4, r2]
 8002a04:	e782      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NAK))
 8002a06:	4641      	mov	r1, r8
 8002a08:	6820      	ldr	r0, [r4, #0]
 8002a0a:	f004 ff19 	bl	8007840 <USB_ReadChInterrupts>
 8002a0e:	06c3      	lsls	r3, r0, #27
 8002a10:	d562      	bpl.n	8002ad8 <HAL_HCD_IRQHandler+0x700>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002a12:	fb0a 4308 	mla	r3, sl, r8, r4
    hhcd->hc[ch_num].state = HC_NAK;
 8002a16:	2204      	movs	r2, #4
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002a18:	f8c3 b05c 	str.w	fp, [r3, #92]	; 0x5c
    hhcd->hc[ch_num].state = HC_NAK;
 8002a1c:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    if (hhcd->hc[ch_num].do_ping == 0U)
 8002a20:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8002a24:	b93b      	cbnz	r3, 8002a36 <HAL_HCD_IRQHandler+0x65e>
      if (hhcd->hc[ch_num].speed == HCD_DEVICE_SPEED_HIGH)
 8002a26:	fb0a 4308 	mla	r3, sl, r8, r4
 8002a2a:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8002a2e:	b912      	cbnz	r2, 8002a36 <HAL_HCD_IRQHandler+0x65e>
        hhcd->hc[ch_num].do_ping = 1U;
 8002a30:	2201      	movs	r2, #1
 8002a32:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002a36:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002a3a:	4641      	mov	r1, r8
 8002a3c:	6820      	ldr	r0, [r4, #0]
 8002a3e:	f005 f9b5 	bl	8007dac <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002a42:	2310      	movs	r3, #16
 8002a44:	eb07 1748 	add.w	r7, r7, r8, lsl #5
 8002a48:	60bb      	str	r3, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002a4a:	68a2      	ldr	r2, [r4, #8]
 8002a4c:	e551      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_NAK))
 8002a4e:	4639      	mov	r1, r7
 8002a50:	6820      	ldr	r0, [r4, #0]
 8002a52:	9201      	str	r2, [sp, #4]
 8002a54:	f004 fef4 	bl	8007840 <USB_ReadChInterrupts>
 8002a58:	f010 0f10 	tst.w	r0, #16
 8002a5c:	9a01      	ldr	r2, [sp, #4]
 8002a5e:	f43f adee 	beq.w	800263e <HAL_HCD_IRQHandler+0x266>
    if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8002a62:	fb0a 4307 	mla	r3, sl, r7, r4
 8002a66:	f893 103f 	ldrb.w	r1, [r3, #63]	; 0x3f
 8002a6a:	2903      	cmp	r1, #3
 8002a6c:	f000 80a5 	beq.w	8002bba <HAL_HCD_IRQHandler+0x7e2>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002a70:	f011 01fd 	ands.w	r1, r1, #253	; 0xfd
 8002a74:	d104      	bne.n	8002a80 <HAL_HCD_IRQHandler+0x6a8>
      if (hhcd->Init.dma_enable == 0U)
 8002a76:	6922      	ldr	r2, [r4, #16]
      hhcd->hc[ch_num].ErrCnt = 0U;
 8002a78:	65d9      	str	r1, [r3, #92]	; 0x5c
      if (hhcd->Init.dma_enable == 0U)
 8002a7a:	2a00      	cmp	r2, #0
 8002a7c:	f000 809e 	beq.w	8002bbc <HAL_HCD_IRQHandler+0x7e4>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002a80:	f508 68a0 	add.w	r8, r8, #1280	; 0x500
 8002a84:	2310      	movs	r3, #16
 8002a86:	eb08 1847 	add.w	r8, r8, r7, lsl #5
 8002a8a:	f8c8 3008 	str.w	r3, [r8, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002a8e:	68a2      	ldr	r2, [r4, #8]
 8002a90:	e52f      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      hhcd->hc[ch_num].state = HC_HALTED;
 8002a92:	fb0a 4207 	mla	r2, sl, r7, r4
 8002a96:	f04f 0302 	mov.w	r3, #2
 8002a9a:	f882 3061 	strb.w	r3, [r2, #97]	; 0x61
      hhcd->hc[ch_num].ErrCnt++;
 8002a9e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 8002aa0:	3301      	adds	r3, #1
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002aa2:	2b02      	cmp	r3, #2
      hhcd->hc[ch_num].ErrCnt++;
 8002aa4:	65d3      	str	r3, [r2, #92]	; 0x5c
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002aa6:	d90a      	bls.n	8002abe <HAL_HCD_IRQHandler+0x6e6>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002aa8:	2300      	movs	r3, #0
 8002aaa:	65d3      	str	r3, [r2, #92]	; 0x5c
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002aac:	2304      	movs	r3, #4
 8002aae:	f882 3060 	strb.w	r3, [r2, #96]	; 0x60
 8002ab2:	e72b      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
      hhcd->hc[ch_num].urb_state = URB_STALL;
 8002ab4:	3260      	adds	r2, #96	; 0x60
 8002ab6:	f240 2305 	movw	r3, #517	; 0x205
 8002aba:	52a3      	strh	r3, [r4, r2]
 8002abc:	e726      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002abe:	f04f 0302 	mov.w	r3, #2
 8002ac2:	f882 3060 	strb.w	r3, [r2, #96]	; 0x60
        tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002ac6:	f851 3008 	ldr.w	r3, [r1, r8]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002aca:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002ace:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
        USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002ad2:	f841 3008 	str.w	r3, [r1, r8]
 8002ad6:	e719      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_TXERR))
 8002ad8:	4641      	mov	r1, r8
 8002ada:	6820      	ldr	r0, [r4, #0]
 8002adc:	f004 feb0 	bl	8007840 <USB_ReadChInterrupts>
 8002ae0:	0600      	lsls	r0, r0, #24
 8002ae2:	d552      	bpl.n	8002b8a <HAL_HCD_IRQHandler+0x7b2>
    if (hhcd->Init.dma_enable == 0U)
 8002ae4:	6923      	ldr	r3, [r4, #16]
 8002ae6:	2b00      	cmp	r3, #0
 8002ae8:	f000 80ef 	beq.w	8002cca <HAL_HCD_IRQHandler+0x8f2>
      hhcd->hc[ch_num].ErrCnt++;
 8002aec:	fb0a 4308 	mla	r3, sl, r8, r4
 8002af0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8002af2:	3201      	adds	r2, #1
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002af4:	2a02      	cmp	r2, #2
      hhcd->hc[ch_num].ErrCnt++;
 8002af6:	65da      	str	r2, [r3, #92]	; 0x5c
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002af8:	f200 80dd 	bhi.w	8002cb6 <HAL_HCD_IRQHandler+0x8de>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002afc:	f04f 0202 	mov.w	r2, #2
 8002b00:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8002b04:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
 8002b08:	2380      	movs	r3, #128	; 0x80
 8002b0a:	eb07 1748 	add.w	r7, r7, r8, lsl #5
 8002b0e:	60bb      	str	r3, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002b10:	68a2      	ldr	r2, [r4, #8]
 8002b12:	e4ee      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
            tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002b14:	599a      	ldr	r2, [r3, r6]
            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002b16:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
            tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002b1a:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
            USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002b1e:	519a      	str	r2, [r3, r6]
            hhcd->hc[ch_num].toggle_in ^= 1U;
 8002b20:	f898 3054 	ldrb.w	r3, [r8, #84]	; 0x54
 8002b24:	f083 0301 	eor.w	r3, r3, #1
 8002b28:	f888 3054 	strb.w	r3, [r8, #84]	; 0x54
 8002b2c:	e74a      	b.n	80029c4 <HAL_HCD_IRQHandler+0x5ec>
      hhcd->hc[ch_num].state = HC_HALTED;
 8002b2e:	f04f 0302 	mov.w	r3, #2
 8002b32:	f880 3061 	strb.w	r3, [r0, #97]	; 0x61
 8002b36:	e6e9      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
      hhcd->hc[ch_num].state = HC_HALTED;
 8002b38:	fb0a 4307 	mla	r3, sl, r7, r4
 8002b3c:	f04f 0202 	mov.w	r2, #2
 8002b40:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
 8002b44:	e6e2      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
      hhcd->hc[ch_num].ErrCnt++;
 8002b46:	fb0a f307 	mul.w	r3, sl, r7
      hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002b4a:	f44f 7001 	mov.w	r0, #516	; 0x204
      hhcd->hc[ch_num].ErrCnt++;
 8002b4e:	18e1      	adds	r1, r4, r3
      hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002b50:	3360      	adds	r3, #96	; 0x60
      hhcd->hc[ch_num].ErrCnt++;
 8002b52:	6dca      	ldr	r2, [r1, #92]	; 0x5c
 8002b54:	3201      	adds	r2, #1
 8002b56:	65ca      	str	r2, [r1, #92]	; 0x5c
      hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002b58:	52e0      	strh	r0, [r4, r3]
 8002b5a:	e6d7      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002b5c:	fb0a f307 	mul.w	r3, sl, r7
 8002b60:	f240 2002 	movw	r0, #514	; 0x202
 8002b64:	f103 0260 	add.w	r2, r3, #96	; 0x60
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002b68:	4423      	add	r3, r4
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002b6a:	52a0      	strh	r0, [r4, r2]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002b6c:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 8002b70:	f013 0ffd 	tst.w	r3, #253	; 0xfd
 8002b74:	f47f aeca 	bne.w	800290c <HAL_HCD_IRQHandler+0x534>
        tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002b78:	f851 3008 	ldr.w	r3, [r1, r8]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002b7c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002b80:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
        USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002b84:	f841 3008 	str.w	r3, [r1, r8]
 8002b88:	e6c0      	b.n	800290c <HAL_HCD_IRQHandler+0x534>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_DTERR))
 8002b8a:	4641      	mov	r1, r8
 8002b8c:	6820      	ldr	r0, [r4, #0]
 8002b8e:	f004 fe57 	bl	8007840 <USB_ReadChInterrupts>
 8002b92:	0541      	lsls	r1, r0, #21
 8002b94:	d51a      	bpl.n	8002bcc <HAL_HCD_IRQHandler+0x7f4>
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8002b96:	fb0a 4308 	mla	r3, sl, r8, r4
 8002b9a:	2209      	movs	r2, #9
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002b9c:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002ba0:	4641      	mov	r1, r8
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8002ba2:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002ba6:	6820      	ldr	r0, [r4, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002ba8:	eb07 1748 	add.w	r7, r7, r8, lsl #5
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002bac:	f005 f8fe 	bl	8007dac <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002bb0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002bb4:	60bb      	str	r3, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002bb6:	68a2      	ldr	r2, [r4, #8]
 8002bb8:	e49b      	b.n	80024f2 <HAL_HCD_IRQHandler+0x11a>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8002bba:	65da      	str	r2, [r3, #92]	; 0x5c
        hhcd->hc[ch_num].state = HC_NAK;
 8002bbc:	2204      	movs	r2, #4
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002bbe:	4639      	mov	r1, r7
        hhcd->hc[ch_num].state = HC_NAK;
 8002bc0:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002bc4:	6820      	ldr	r0, [r4, #0]
 8002bc6:	f005 f8f1 	bl	8007dac <USB_HC_Halt>
 8002bca:	e759      	b.n	8002a80 <HAL_HCD_IRQHandler+0x6a8>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, ch_num, USB_OTG_HCINT_CHH))
 8002bcc:	4641      	mov	r1, r8
 8002bce:	6820      	ldr	r0, [r4, #0]
 8002bd0:	f004 fe36 	bl	8007840 <USB_ReadChInterrupts>
 8002bd4:	0782      	lsls	r2, r0, #30
 8002bd6:	f57f ad32 	bpl.w	800263e <HAL_HCD_IRQHandler+0x266>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8002bda:	f507 67a0 	add.w	r7, r7, #1280	; 0x500
 8002bde:	2102      	movs	r1, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002be0:	fb0a f308 	mul.w	r3, sl, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8002be4:	ea4f 1048 	mov.w	r0, r8, lsl #5
 8002be8:	eb07 1248 	add.w	r2, r7, r8, lsl #5
 8002bec:	6091      	str	r1, [r2, #8]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002bee:	18e2      	adds	r2, r4, r3
 8002bf0:	f892 1061 	ldrb.w	r1, [r2, #97]	; 0x61
 8002bf4:	2901      	cmp	r1, #1
 8002bf6:	d03f      	beq.n	8002c78 <HAL_HCD_IRQHandler+0x8a0>
    else if (hhcd->hc[ch_num].state == HC_ACK)
 8002bf8:	2903      	cmp	r1, #3
 8002bfa:	d038      	beq.n	8002c6e <HAL_HCD_IRQHandler+0x896>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8002bfc:	2904      	cmp	r1, #4
 8002bfe:	d026      	beq.n	8002c4e <HAL_HCD_IRQHandler+0x876>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 8002c00:	2905      	cmp	r1, #5
 8002c02:	d024      	beq.n	8002c4e <HAL_HCD_IRQHandler+0x876>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8002c04:	2906      	cmp	r1, #6
 8002c06:	d01d      	beq.n	8002c44 <HAL_HCD_IRQHandler+0x86c>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002c08:	2907      	cmp	r1, #7
 8002c0a:	d002      	beq.n	8002c12 <HAL_HCD_IRQHandler+0x83a>
 8002c0c:	2909      	cmp	r1, #9
 8002c0e:	f47f ad16 	bne.w	800263e <HAL_HCD_IRQHandler+0x266>
      hhcd->hc[ch_num].state = HC_HALTED;
 8002c12:	fb0a 4308 	mla	r3, sl, r8, r4
 8002c16:	f04f 0202 	mov.w	r2, #2
 8002c1a:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
      hhcd->hc[ch_num].ErrCnt++;
 8002c1e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8002c20:	3201      	adds	r2, #1
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002c22:	2a02      	cmp	r2, #2
      hhcd->hc[ch_num].ErrCnt++;
 8002c24:	65da      	str	r2, [r3, #92]	; 0x5c
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002c26:	d917      	bls.n	8002c58 <HAL_HCD_IRQHandler+0x880>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002c28:	2200      	movs	r2, #0
 8002c2a:	65da      	str	r2, [r3, #92]	; 0x5c
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002c2c:	2204      	movs	r2, #4
 8002c2e:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002c32:	fb0a 4308 	mla	r3, sl, r8, r4
 8002c36:	4641      	mov	r1, r8
 8002c38:	4620      	mov	r0, r4
 8002c3a:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
 8002c3e:	f01b ff79 	bl	801eb34 <HAL_HCD_HC_NotifyURBChange_Callback>
 8002c42:	e4fc      	b.n	800263e <HAL_HCD_IRQHandler+0x266>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8002c44:	3360      	adds	r3, #96	; 0x60
 8002c46:	f240 2205 	movw	r2, #517	; 0x205
 8002c4a:	52e2      	strh	r2, [r4, r3]
 8002c4c:	e7f1      	b.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8002c4e:	3360      	adds	r3, #96	; 0x60
 8002c50:	f240 2202 	movw	r2, #514	; 0x202
 8002c54:	52e2      	strh	r2, [r4, r3]
 8002c56:	e7ec      	b.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002c58:	f04f 0202 	mov.w	r2, #2
 8002c5c:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
        tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002c60:	583b      	ldr	r3, [r7, r0]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002c62:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002c66:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
        USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002c6a:	503b      	str	r3, [r7, r0]
 8002c6c:	e7e1      	b.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
      hhcd->hc[ch_num].state = HC_HALTED;
 8002c6e:	f04f 0302 	mov.w	r3, #2
 8002c72:	f882 3061 	strb.w	r3, [r2, #97]	; 0x61
 8002c76:	e7dc      	b.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 8002c78:	3360      	adds	r3, #96	; 0x60
 8002c7a:	f240 2101 	movw	r1, #513	; 0x201
 8002c7e:	52e1      	strh	r1, [r4, r3]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8002c80:	f892 303f 	ldrb.w	r3, [r2, #63]	; 0x3f
 8002c84:	3b02      	subs	r3, #2
 8002c86:	2b01      	cmp	r3, #1
 8002c88:	d8d3      	bhi.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
        if (hhcd->Init.dma_enable == 0U)
 8002c8a:	6923      	ldr	r3, [r4, #16]
 8002c8c:	b163      	cbz	r3, 8002ca8 <HAL_HCD_IRQHandler+0x8d0>
        if ((hhcd->Init.dma_enable == 1U) && (hhcd->hc[ch_num].xfer_len > 0U))
 8002c8e:	2b01      	cmp	r3, #1
 8002c90:	d1cf      	bne.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
 8002c92:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8002c94:	2b00      	cmp	r3, #0
 8002c96:	d0cc      	beq.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
          num_packets = (hhcd->hc[ch_num].xfer_len + hhcd->hc[ch_num].max_packet - 1U) / hhcd->hc[ch_num].max_packet;
 8002c98:	f8b2 1040 	ldrh.w	r1, [r2, #64]	; 0x40
 8002c9c:	3b01      	subs	r3, #1
 8002c9e:	440b      	add	r3, r1
 8002ca0:	fbb3 f3f1 	udiv	r3, r3, r1
          if ((num_packets & 1U) != 0U)
 8002ca4:	07db      	lsls	r3, r3, #31
 8002ca6:	d5c4      	bpl.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
            hhcd->hc[ch_num].toggle_out ^= 1U;
 8002ca8:	f892 3055 	ldrb.w	r3, [r2, #85]	; 0x55
 8002cac:	f083 0301 	eor.w	r3, r3, #1
 8002cb0:	f882 3055 	strb.w	r3, [r2, #85]	; 0x55
 8002cb4:	e7bd      	b.n	8002c32 <HAL_HCD_IRQHandler+0x85a>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002cb6:	2200      	movs	r2, #0
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002cb8:	4641      	mov	r1, r8
 8002cba:	4620      	mov	r0, r4
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002cbc:	65da      	str	r2, [r3, #92]	; 0x5c
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002cbe:	2204      	movs	r2, #4
 8002cc0:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002cc4:	f01b ff36 	bl	801eb34 <HAL_HCD_HC_NotifyURBChange_Callback>
 8002cc8:	e71c      	b.n	8002b04 <HAL_HCD_IRQHandler+0x72c>
      hhcd->hc[ch_num].state = HC_XACTERR;
 8002cca:	fb0a 4308 	mla	r3, sl, r8, r4
 8002cce:	2207      	movs	r2, #7
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002cd0:	4641      	mov	r1, r8
      hhcd->hc[ch_num].state = HC_XACTERR;
 8002cd2:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002cd6:	6820      	ldr	r0, [r4, #0]
 8002cd8:	f005 f868 	bl	8007dac <USB_HC_Halt>
 8002cdc:	e712      	b.n	8002b04 <HAL_HCD_IRQHandler+0x72c>
 8002cde:	bf00      	nop

08002ce0 <HAL_HCD_Start>:
{
 8002ce0:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
 8002ce2:	f890 32f8 	ldrb.w	r3, [r0, #760]	; 0x2f8
 8002ce6:	2b01      	cmp	r3, #1
 8002ce8:	d00f      	beq.n	8002d0a <HAL_HCD_Start+0x2a>
 8002cea:	4604      	mov	r4, r0
 8002cec:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
 8002cee:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 8002cf0:	f884 52f8 	strb.w	r5, [r4, #760]	; 0x2f8
  __HAL_HCD_ENABLE(hhcd);
 8002cf4:	f004 fce2 	bl	80076bc <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 8002cf8:	4629      	mov	r1, r5
 8002cfa:	6820      	ldr	r0, [r4, #0]
 8002cfc:	f004 fea2 	bl	8007a44 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
 8002d00:	2300      	movs	r3, #0
  return HAL_OK;
 8002d02:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 8002d04:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
}
 8002d08:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
 8002d0a:	2002      	movs	r0, #2
}
 8002d0c:	bd38      	pop	{r3, r4, r5, pc}
 8002d0e:	bf00      	nop

08002d10 <HAL_HCD_Stop>:
  __HAL_LOCK(hhcd);
 8002d10:	f890 32f8 	ldrb.w	r3, [r0, #760]	; 0x2f8
 8002d14:	2b01      	cmp	r3, #1
 8002d16:	d00c      	beq.n	8002d32 <HAL_HCD_Stop+0x22>
 8002d18:	2301      	movs	r3, #1
{
 8002d1a:	b510      	push	{r4, lr}
 8002d1c:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
 8002d1e:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 8002d20:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
  (void)USB_StopHost(hhcd->Instance);
 8002d24:	f005 f8a8 	bl	8007e78 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 8002d28:	2300      	movs	r3, #0
  return HAL_OK;
 8002d2a:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 8002d2c:	f884 32f8 	strb.w	r3, [r4, #760]	; 0x2f8
}
 8002d30:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 8002d32:	2002      	movs	r0, #2
}
 8002d34:	4770      	bx	lr
 8002d36:	bf00      	nop

08002d38 <HAL_HCD_ResetPort>:
  return (USB_ResetPort(hhcd->Instance));
 8002d38:	6800      	ldr	r0, [r0, #0]
 8002d3a:	f004 be63 	b.w	8007a04 <USB_ResetPort>
 8002d3e:	bf00      	nop

08002d40 <HAL_HCD_HC_GetURBState>:
  return hhcd->hc[chnum].urb_state;
 8002d40:	232c      	movs	r3, #44	; 0x2c
 8002d42:	fb03 0101 	mla	r1, r3, r1, r0
}
 8002d46:	f891 0060 	ldrb.w	r0, [r1, #96]	; 0x60
 8002d4a:	4770      	bx	lr

08002d4c <HAL_HCD_HC_GetXferCount>:
  return hhcd->hc[chnum].xfer_count;
 8002d4c:	232c      	movs	r3, #44	; 0x2c
 8002d4e:	fb03 0101 	mla	r1, r3, r1, r0
}
 8002d52:	6d08      	ldr	r0, [r1, #80]	; 0x50
 8002d54:	4770      	bx	lr
 8002d56:	bf00      	nop

08002d58 <HAL_HCD_GetCurrentFrame>:
  return (USB_GetCurrentFrame(hhcd->Instance));
 8002d58:	6800      	ldr	r0, [r0, #0]
 8002d5a:	f004 bea7 	b.w	8007aac <USB_GetCurrentFrame>
 8002d5e:	bf00      	nop

08002d60 <HAL_HCD_GetCurrentSpeed>:
  return (USB_GetHostSpeed(hhcd->Instance));
 8002d60:	6800      	ldr	r0, [r0, #0]
 8002d62:	f004 be97 	b.w	8007a94 <USB_GetHostSpeed>
 8002d66:	bf00      	nop

08002d68 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8002d68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002d6a:	4605      	mov	r5, r0
 8002d6c:	460e      	mov	r6, r1
 8002d6e:	4617      	mov	r7, r2
 8002d70:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8002d72:	682c      	ldr	r4, [r5, #0]
 8002d74:	d12c      	bne.n	8002dd0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
 8002d76:	69a3      	ldr	r3, [r4, #24]
 8002d78:	0799      	lsls	r1, r3, #30
 8002d7a:	d427      	bmi.n	8002dcc <I2C_WaitOnTXISFlagUntilTimeout+0x64>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002d7c:	69a3      	ldr	r3, [r4, #24]
 8002d7e:	06da      	lsls	r2, r3, #27
 8002d80:	d5f9      	bpl.n	8002d76 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002d82:	69a3      	ldr	r3, [r4, #24]
 8002d84:	069a      	lsls	r2, r3, #26
 8002d86:	d5fc      	bpl.n	8002d82 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002d88:	2320      	movs	r3, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002d8a:	2210      	movs	r2, #16
 8002d8c:	61e2      	str	r2, [r4, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002d8e:	61e3      	str	r3, [r4, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8002d90:	69a3      	ldr	r3, [r4, #24]
 8002d92:	079f      	lsls	r7, r3, #30
 8002d94:	d501      	bpl.n	8002d9a <I2C_WaitOnTXISFlagUntilTimeout+0x32>
    hi2c->Instance->TXDR = 0x00U;
 8002d96:	2300      	movs	r3, #0
 8002d98:	62a3      	str	r3, [r4, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8002d9a:	69a3      	ldr	r3, [r4, #24]
 8002d9c:	07de      	lsls	r6, r3, #31
 8002d9e:	d403      	bmi.n	8002da8 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8002da0:	69a3      	ldr	r3, [r4, #24]
 8002da2:	f043 0301 	orr.w	r3, r3, #1
 8002da6:	61a3      	str	r3, [r4, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002da8:	6863      	ldr	r3, [r4, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002daa:	2200      	movs	r2, #0
    I2C_RESET_CR2(hi2c);
 8002dac:	481b      	ldr	r0, [pc, #108]	; (8002e1c <I2C_WaitOnTXISFlagUntilTimeout+0xb4>)
    hi2c->State = HAL_I2C_STATE_READY;
 8002dae:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8002db0:	4003      	ands	r3, r0
      return HAL_ERROR;
 8002db2:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8002db4:	6063      	str	r3, [r4, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002db6:	6c6b      	ldr	r3, [r5, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002db8:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002dbc:	f043 0304 	orr.w	r3, r3, #4
 8002dc0:	646b      	str	r3, [r5, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8002dc2:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002dc6:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8002dca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8002dcc:	2000      	movs	r0, #0
}
 8002dce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8002dd0:	69a3      	ldr	r3, [r4, #24]
 8002dd2:	079b      	lsls	r3, r3, #30
 8002dd4:	d4fa      	bmi.n	8002dcc <I2C_WaitOnTXISFlagUntilTimeout+0x64>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002dd6:	69a3      	ldr	r3, [r4, #24]
 8002dd8:	06d9      	lsls	r1, r3, #27
 8002dda:	d41b      	bmi.n	8002e14 <I2C_WaitOnTXISFlagUntilTimeout+0xac>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002ddc:	f7fe f948 	bl	8001070 <HAL_GetTick>
 8002de0:	1bc0      	subs	r0, r0, r7
 8002de2:	42b0      	cmp	r0, r6
 8002de4:	d801      	bhi.n	8002dea <I2C_WaitOnTXISFlagUntilTimeout+0x82>
 8002de6:	2e00      	cmp	r6, #0
 8002de8:	d1c2      	bne.n	8002d70 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002dea:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002dec:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002dee:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8002df0:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002df2:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8002df4:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002df8:	646b      	str	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002dfa:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002dfe:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8002e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002e04:	f7fe f934 	bl	8001070 <HAL_GetTick>
 8002e08:	1bc0      	subs	r0, r0, r7
 8002e0a:	4286      	cmp	r6, r0
 8002e0c:	d3ed      	bcc.n	8002dea <I2C_WaitOnTXISFlagUntilTimeout+0x82>
 8002e0e:	2e00      	cmp	r6, #0
 8002e10:	d0eb      	beq.n	8002dea <I2C_WaitOnTXISFlagUntilTimeout+0x82>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002e12:	682c      	ldr	r4, [r5, #0]
 8002e14:	69a3      	ldr	r3, [r4, #24]
 8002e16:	069b      	lsls	r3, r3, #26
 8002e18:	d5f4      	bpl.n	8002e04 <I2C_WaitOnTXISFlagUntilTimeout+0x9c>
 8002e1a:	e7b5      	b.n	8002d88 <I2C_WaitOnTXISFlagUntilTimeout+0x20>
 8002e1c:	fe00e800 	.word	0xfe00e800

08002e20 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8002e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002e22:	4605      	mov	r5, r0
 8002e24:	460e      	mov	r6, r1
 8002e26:	4617      	mov	r7, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002e28:	682c      	ldr	r4, [r5, #0]
 8002e2a:	69a3      	ldr	r3, [r4, #24]
 8002e2c:	069b      	lsls	r3, r3, #26
 8002e2e:	d449      	bmi.n	8002ec4 <I2C_WaitOnSTOPFlagUntilTimeout+0xa4>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002e30:	69a3      	ldr	r3, [r4, #24]
 8002e32:	06da      	lsls	r2, r3, #27
 8002e34:	d526      	bpl.n	8002e84 <I2C_WaitOnSTOPFlagUntilTimeout+0x64>
 8002e36:	1c73      	adds	r3, r6, #1
 8002e38:	d138      	bne.n	8002eac <I2C_WaitOnSTOPFlagUntilTimeout+0x8c>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002e3a:	69a3      	ldr	r3, [r4, #24]
 8002e3c:	069e      	lsls	r6, r3, #26
 8002e3e:	d5fc      	bpl.n	8002e3a <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002e40:	2320      	movs	r3, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002e42:	2210      	movs	r2, #16
 8002e44:	61e2      	str	r2, [r4, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002e46:	61e3      	str	r3, [r4, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8002e48:	69a3      	ldr	r3, [r4, #24]
 8002e4a:	0799      	lsls	r1, r3, #30
 8002e4c:	d501      	bpl.n	8002e52 <I2C_WaitOnSTOPFlagUntilTimeout+0x32>
    hi2c->Instance->TXDR = 0x00U;
 8002e4e:	2300      	movs	r3, #0
 8002e50:	62a3      	str	r3, [r4, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8002e52:	69a3      	ldr	r3, [r4, #24]
 8002e54:	07da      	lsls	r2, r3, #31
 8002e56:	d403      	bmi.n	8002e60 <I2C_WaitOnSTOPFlagUntilTimeout+0x40>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8002e58:	69a3      	ldr	r3, [r4, #24]
 8002e5a:	f043 0301 	orr.w	r3, r3, #1
 8002e5e:	61a3      	str	r3, [r4, #24]
    I2C_RESET_CR2(hi2c);
 8002e60:	6863      	ldr	r3, [r4, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002e62:	2200      	movs	r2, #0
    I2C_RESET_CR2(hi2c);
 8002e64:	4818      	ldr	r0, [pc, #96]	; (8002ec8 <I2C_WaitOnSTOPFlagUntilTimeout+0xa8>)
    hi2c->State = HAL_I2C_STATE_READY;
 8002e66:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8002e68:	4003      	ands	r3, r0
      return HAL_ERROR;
 8002e6a:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8002e6c:	6063      	str	r3, [r4, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002e6e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
 8002e70:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002e74:	f043 0304 	orr.w	r3, r3, #4
 8002e78:	646b      	str	r3, [r5, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8002e7a:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002e7e:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8002e82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002e84:	f7fe f8f4 	bl	8001070 <HAL_GetTick>
 8002e88:	1bc0      	subs	r0, r0, r7
 8002e8a:	42b0      	cmp	r0, r6
 8002e8c:	d801      	bhi.n	8002e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8002e8e:	2e00      	cmp	r6, #0
 8002e90:	d1ca      	bne.n	8002e28 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002e92:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002e94:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002e96:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8002e98:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002e9a:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8002e9c:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002ea0:	646b      	str	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002ea2:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002ea6:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8002eaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002eac:	69a3      	ldr	r3, [r4, #24]
 8002eae:	0698      	lsls	r0, r3, #26
 8002eb0:	d4c6      	bmi.n	8002e40 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002eb2:	f7fe f8dd 	bl	8001070 <HAL_GetTick>
 8002eb6:	1bc0      	subs	r0, r0, r7
 8002eb8:	4286      	cmp	r6, r0
 8002eba:	d3ea      	bcc.n	8002e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8002ebc:	2e00      	cmp	r6, #0
 8002ebe:	d0e8      	beq.n	8002e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002ec0:	682c      	ldr	r4, [r5, #0]
 8002ec2:	e7b8      	b.n	8002e36 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8002ec4:	2000      	movs	r0, #0
}
 8002ec6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ec8:	fe00e800 	.word	0xfe00e800

08002ecc <I2C_RequestMemoryWrite>:
{
 8002ecc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002ed0:	4698      	mov	r8, r3
 8002ed2:	468a      	mov	sl, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002ed4:	6803      	ldr	r3, [r0, #0]
{
 8002ed6:	4617      	mov	r7, r2
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002ed8:	4934      	ldr	r1, [pc, #208]	; (8002fac <I2C_RequestMemoryWrite+0xe0>)
{
 8002eda:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002edc:	4a34      	ldr	r2, [pc, #208]	; (8002fb0 <I2C_RequestMemoryWrite+0xe4>)
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8002ede:	fa5f f988 	uxtb.w	r9, r8
{
 8002ee2:	9d08      	ldr	r5, [sp, #32]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002ee4:	4293      	cmp	r3, r2
 8002ee6:	bf18      	it	ne
 8002ee8:	428b      	cmpne	r3, r1
 8002eea:	f501 6180 	add.w	r1, r1, #1024	; 0x400
{
 8002eee:	9e09      	ldr	r6, [sp, #36]	; 0x24
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002ef0:	bf14      	ite	ne
 8002ef2:	2201      	movne	r2, #1
 8002ef4:	2200      	moveq	r2, #0
 8002ef6:	428b      	cmp	r3, r1
 8002ef8:	bf0c      	ite	eq
 8002efa:	2200      	moveq	r2, #0
 8002efc:	f002 0201 	andne.w	r2, r2, #1
 8002f00:	b112      	cbz	r2, 8002f08 <I2C_RequestMemoryWrite+0x3c>
 8002f02:	4a2c      	ldr	r2, [pc, #176]	; (8002fb4 <I2C_RequestMemoryWrite+0xe8>)
 8002f04:	4293      	cmp	r3, r2
 8002f06:	d13a      	bne.n	8002f7e <I2C_RequestMemoryWrite+0xb2>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8002f08:	6859      	ldr	r1, [r3, #4]
 8002f0a:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 8002f0e:	4a2a      	ldr	r2, [pc, #168]	; (8002fb8 <I2C_RequestMemoryWrite+0xec>)
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002f10:	4620      	mov	r0, r4
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8002f12:	4011      	ands	r1, r2
 8002f14:	4a29      	ldr	r2, [pc, #164]	; (8002fbc <I2C_RequestMemoryWrite+0xf0>)
 8002f16:	ea41 010a 	orr.w	r1, r1, sl
 8002f1a:	ea41 4109 	orr.w	r1, r1, r9, lsl #16
 8002f1e:	430a      	orrs	r2, r1
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002f20:	4629      	mov	r1, r5
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8002f22:	605a      	str	r2, [r3, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002f24:	4632      	mov	r2, r6
 8002f26:	f7ff ff1f 	bl	8002d68 <I2C_WaitOnTXISFlagUntilTimeout>
 8002f2a:	4681      	mov	r9, r0
 8002f2c:	bb10      	cbnz	r0, 8002f74 <I2C_RequestMemoryWrite+0xa8>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8002f2e:	f1b8 0f01 	cmp.w	r8, #1
 8002f32:	d115      	bne.n	8002f60 <I2C_RequestMemoryWrite+0x94>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8002f34:	b2ff      	uxtb	r7, r7
 8002f36:	6822      	ldr	r2, [r4, #0]
 8002f38:	6297      	str	r7, [r2, #40]	; 0x28
 8002f3a:	1c68      	adds	r0, r5, #1
 8002f3c:	d105      	bne.n	8002f4a <I2C_RequestMemoryWrite+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8002f3e:	6993      	ldr	r3, [r2, #24]
 8002f40:	0619      	lsls	r1, r3, #24
 8002f42:	d5fc      	bpl.n	8002f3e <I2C_RequestMemoryWrite+0x72>
}
 8002f44:	4648      	mov	r0, r9
 8002f46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8002f4a:	6993      	ldr	r3, [r2, #24]
 8002f4c:	061b      	lsls	r3, r3, #24
 8002f4e:	d4f9      	bmi.n	8002f44 <I2C_RequestMemoryWrite+0x78>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002f50:	f7fe f88e 	bl	8001070 <HAL_GetTick>
 8002f54:	1b80      	subs	r0, r0, r6
 8002f56:	4285      	cmp	r5, r0
 8002f58:	d318      	bcc.n	8002f8c <I2C_RequestMemoryWrite+0xc0>
 8002f5a:	b1bd      	cbz	r5, 8002f8c <I2C_RequestMemoryWrite+0xc0>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8002f5c:	6822      	ldr	r2, [r4, #0]
 8002f5e:	e7ec      	b.n	8002f3a <I2C_RequestMemoryWrite+0x6e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8002f60:	0a3a      	lsrs	r2, r7, #8
 8002f62:	6823      	ldr	r3, [r4, #0]
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002f64:	4629      	mov	r1, r5
 8002f66:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8002f68:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002f6a:	4632      	mov	r2, r6
 8002f6c:	f7ff fefc 	bl	8002d68 <I2C_WaitOnTXISFlagUntilTimeout>
 8002f70:	2800      	cmp	r0, #0
 8002f72:	d0df      	beq.n	8002f34 <I2C_RequestMemoryWrite+0x68>
    return HAL_ERROR;
 8002f74:	f04f 0901 	mov.w	r9, #1
}
 8002f78:	4648      	mov	r0, r9
 8002f7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002f7e:	f641 01c1 	movw	r1, #6337	; 0x18c1
 8002f82:	480f      	ldr	r0, [pc, #60]	; (8002fc0 <I2C_RequestMemoryWrite+0xf4>)
 8002f84:	f017 ff8e 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8002f88:	6823      	ldr	r3, [r4, #0]
 8002f8a:	e7bd      	b.n	8002f08 <I2C_RequestMemoryWrite+0x3c>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002f8c:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002f8e:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002f90:	2200      	movs	r2, #0
    return HAL_ERROR;
 8002f92:	f04f 0901 	mov.w	r9, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002f96:	430b      	orrs	r3, r1
}
 8002f98:	4648      	mov	r0, r9
        __HAL_UNLOCK(hi2c);
 8002f9a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002f9e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8002fa0:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002fa4:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 8002fa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002fac:	40005800 	.word	0x40005800
 8002fb0:	40005400 	.word	0x40005400
 8002fb4:	40006000 	.word	0x40006000
 8002fb8:	fc009800 	.word	0xfc009800
 8002fbc:	81002000 	.word	0x81002000
 8002fc0:	0802160c 	.word	0x0802160c

08002fc4 <I2C_RequestMemoryRead>:
{
 8002fc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002fc8:	4698      	mov	r8, r3
 8002fca:	468a      	mov	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002fcc:	6803      	ldr	r3, [r0, #0]
{
 8002fce:	4617      	mov	r7, r2
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002fd0:	4934      	ldr	r1, [pc, #208]	; (80030a4 <I2C_RequestMemoryRead+0xe0>)
{
 8002fd2:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002fd4:	4a34      	ldr	r2, [pc, #208]	; (80030a8 <I2C_RequestMemoryRead+0xe4>)
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8002fd6:	fa5f f988 	uxtb.w	r9, r8
{
 8002fda:	9d08      	ldr	r5, [sp, #32]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002fdc:	4293      	cmp	r3, r2
 8002fde:	bf18      	it	ne
 8002fe0:	428b      	cmpne	r3, r1
 8002fe2:	f501 6180 	add.w	r1, r1, #1024	; 0x400
{
 8002fe6:	9e09      	ldr	r6, [sp, #36]	; 0x24
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8002fe8:	bf14      	ite	ne
 8002fea:	2201      	movne	r2, #1
 8002fec:	2200      	moveq	r2, #0
 8002fee:	428b      	cmp	r3, r1
 8002ff0:	bf0c      	ite	eq
 8002ff2:	2200      	moveq	r2, #0
 8002ff4:	f002 0201 	andne.w	r2, r2, #1
 8002ff8:	b112      	cbz	r2, 8003000 <I2C_RequestMemoryRead+0x3c>
 8002ffa:	4a2c      	ldr	r2, [pc, #176]	; (80030ac <I2C_RequestMemoryRead+0xe8>)
 8002ffc:	4293      	cmp	r3, r2
 8002ffe:	d13a      	bne.n	8003076 <I2C_RequestMemoryRead+0xb2>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003000:	6859      	ldr	r1, [r3, #4]
 8003002:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 8003006:	4a2a      	ldr	r2, [pc, #168]	; (80030b0 <I2C_RequestMemoryRead+0xec>)
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8003008:	4620      	mov	r0, r4
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800300a:	4011      	ands	r1, r2
 800300c:	4a29      	ldr	r2, [pc, #164]	; (80030b4 <I2C_RequestMemoryRead+0xf0>)
 800300e:	ea41 010a 	orr.w	r1, r1, sl
 8003012:	ea41 4109 	orr.w	r1, r1, r9, lsl #16
 8003016:	430a      	orrs	r2, r1
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8003018:	4629      	mov	r1, r5
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800301a:	605a      	str	r2, [r3, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800301c:	4632      	mov	r2, r6
 800301e:	f7ff fea3 	bl	8002d68 <I2C_WaitOnTXISFlagUntilTimeout>
 8003022:	4681      	mov	r9, r0
 8003024:	bb10      	cbnz	r0, 800306c <I2C_RequestMemoryRead+0xa8>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8003026:	f1b8 0f01 	cmp.w	r8, #1
 800302a:	d115      	bne.n	8003058 <I2C_RequestMemoryRead+0x94>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800302c:	b2ff      	uxtb	r7, r7
 800302e:	6822      	ldr	r2, [r4, #0]
 8003030:	6297      	str	r7, [r2, #40]	; 0x28
 8003032:	1c68      	adds	r0, r5, #1
 8003034:	d105      	bne.n	8003042 <I2C_RequestMemoryRead+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003036:	6993      	ldr	r3, [r2, #24]
 8003038:	0659      	lsls	r1, r3, #25
 800303a:	d5fc      	bpl.n	8003036 <I2C_RequestMemoryRead+0x72>
}
 800303c:	4648      	mov	r0, r9
 800303e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003042:	6993      	ldr	r3, [r2, #24]
 8003044:	065b      	lsls	r3, r3, #25
 8003046:	d4f9      	bmi.n	800303c <I2C_RequestMemoryRead+0x78>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003048:	f7fe f812 	bl	8001070 <HAL_GetTick>
 800304c:	1b80      	subs	r0, r0, r6
 800304e:	4285      	cmp	r5, r0
 8003050:	d318      	bcc.n	8003084 <I2C_RequestMemoryRead+0xc0>
 8003052:	b1bd      	cbz	r5, 8003084 <I2C_RequestMemoryRead+0xc0>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003054:	6822      	ldr	r2, [r4, #0]
 8003056:	e7ec      	b.n	8003032 <I2C_RequestMemoryRead+0x6e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8003058:	0a3a      	lsrs	r2, r7, #8
 800305a:	6823      	ldr	r3, [r4, #0]
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800305c:	4629      	mov	r1, r5
 800305e:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8003060:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8003062:	4632      	mov	r2, r6
 8003064:	f7ff fe80 	bl	8002d68 <I2C_WaitOnTXISFlagUntilTimeout>
 8003068:	2800      	cmp	r0, #0
 800306a:	d0df      	beq.n	800302c <I2C_RequestMemoryRead+0x68>
    return HAL_ERROR;
 800306c:	f04f 0901 	mov.w	r9, #1
}
 8003070:	4648      	mov	r0, r9
 8003072:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003076:	f641 01c1 	movw	r1, #6337	; 0x18c1
 800307a:	480f      	ldr	r0, [pc, #60]	; (80030b8 <I2C_RequestMemoryRead+0xf4>)
 800307c:	f017 ff12 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003080:	6823      	ldr	r3, [r4, #0]
 8003082:	e7bd      	b.n	8003000 <I2C_RequestMemoryRead+0x3c>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003084:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003086:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003088:	2200      	movs	r2, #0
    return HAL_ERROR;
 800308a:	f04f 0901 	mov.w	r9, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800308e:	430b      	orrs	r3, r1
}
 8003090:	4648      	mov	r0, r9
        __HAL_UNLOCK(hi2c);
 8003092:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003096:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003098:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800309c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80030a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80030a4:	40005800 	.word	0x40005800
 80030a8:	40005400 	.word	0x40005400
 80030ac:	40006000 	.word	0x40006000
 80030b0:	fc009800 	.word	0xfc009800
 80030b4:	80002000 	.word	0x80002000
 80030b8:	0802160c 	.word	0x0802160c

080030bc <HAL_I2C_Init>:
  if (hi2c == NULL)
 80030bc:	2800      	cmp	r0, #0
 80030be:	f000 80c1 	beq.w	8003244 <HAL_I2C_Init+0x188>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80030c2:	4b61      	ldr	r3, [pc, #388]	; (8003248 <HAL_I2C_Init+0x18c>)
 80030c4:	6802      	ldr	r2, [r0, #0]
 80030c6:	4961      	ldr	r1, [pc, #388]	; (800324c <HAL_I2C_Init+0x190>)
{
 80030c8:	b510      	push	{r4, lr}
 80030ca:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80030cc:	4860      	ldr	r0, [pc, #384]	; (8003250 <HAL_I2C_Init+0x194>)
 80030ce:	429a      	cmp	r2, r3
 80030d0:	bf18      	it	ne
 80030d2:	4282      	cmpne	r2, r0
 80030d4:	bf14      	ite	ne
 80030d6:	2301      	movne	r3, #1
 80030d8:	2300      	moveq	r3, #0
 80030da:	428a      	cmp	r2, r1
 80030dc:	bf0c      	ite	eq
 80030de:	2300      	moveq	r3, #0
 80030e0:	f003 0301 	andne.w	r3, r3, #1
 80030e4:	b11b      	cbz	r3, 80030ee <HAL_I2C_Init+0x32>
 80030e6:	4b5b      	ldr	r3, [pc, #364]	; (8003254 <HAL_I2C_Init+0x198>)
 80030e8:	429a      	cmp	r2, r3
 80030ea:	f040 80a5 	bne.w	8003238 <HAL_I2C_Init+0x17c>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 80030ee:	68a3      	ldr	r3, [r4, #8]
 80030f0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80030f4:	f080 809a 	bcs.w	800322c <HAL_I2C_Init+0x170>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 80030f8:	68e3      	ldr	r3, [r4, #12]
 80030fa:	3b01      	subs	r3, #1
 80030fc:	2b01      	cmp	r3, #1
 80030fe:	d855      	bhi.n	80031ac <HAL_I2C_Init+0xf0>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8003100:	6923      	ldr	r3, [r4, #16]
 8003102:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 8003106:	d15a      	bne.n	80031be <HAL_I2C_Init+0x102>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 8003108:	6963      	ldr	r3, [r4, #20]
 800310a:	2bff      	cmp	r3, #255	; 0xff
 800310c:	d85f      	bhi.n	80031ce <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 800310e:	69a3      	ldr	r3, [r4, #24]
 8003110:	2b07      	cmp	r3, #7
 8003112:	d864      	bhi.n	80031de <HAL_I2C_Init+0x122>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 8003114:	69e3      	ldr	r3, [r4, #28]
 8003116:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 800311a:	d169      	bne.n	80031f0 <HAL_I2C_Init+0x134>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 800311c:	6a23      	ldr	r3, [r4, #32]
 800311e:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 8003122:	d16e      	bne.n	8003202 <HAL_I2C_Init+0x146>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8003124:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003128:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800312c:	2b00      	cmp	r3, #0
 800312e:	d073      	beq.n	8003218 <HAL_I2C_Init+0x15c>
  __HAL_I2C_DISABLE(hi2c);
 8003130:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8003132:	2124      	movs	r1, #36	; 0x24
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8003134:	6862      	ldr	r2, [r4, #4]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8003136:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 800313a:	6819      	ldr	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800313c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003140:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8003142:	f021 0101 	bic.w	r1, r1, #1
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003146:	2801      	cmp	r0, #1
  __HAL_I2C_DISABLE(hi2c);
 8003148:	6019      	str	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800314a:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800314c:	689a      	ldr	r2, [r3, #8]
 800314e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003152:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8003154:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003156:	d065      	beq.n	8003224 <HAL_I2C_Init+0x168>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8003158:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800315c:	2802      	cmp	r0, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800315e:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8003160:	d102      	bne.n	8003168 <HAL_I2C_Init+0xac>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8003162:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8003166:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8003168:	6858      	ldr	r0, [r3, #4]
  hi2c->State = HAL_I2C_STATE_READY;
 800316a:	f04f 0c20 	mov.w	ip, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800316e:	493a      	ldr	r1, [pc, #232]	; (8003258 <HAL_I2C_Init+0x19c>)
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8003170:	6922      	ldr	r2, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8003172:	4301      	orrs	r1, r0
 8003174:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8003176:	68d9      	ldr	r1, [r3, #12]
 8003178:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 800317c:	60d9      	str	r1, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800317e:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
 8003182:	4302      	orrs	r2, r0
 8003184:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8003188:	e9d4 1007 	ldrd	r1, r0, [r4, #28]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800318c:	60da      	str	r2, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800318e:	2200      	movs	r2, #0
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8003190:	4301      	orrs	r1, r0
  return HAL_OK;
 8003192:	4610      	mov	r0, r2
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8003194:	6019      	str	r1, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8003196:	6819      	ldr	r1, [r3, #0]
 8003198:	f041 0101 	orr.w	r1, r1, #1
 800319c:	6019      	str	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800319e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 80031a0:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80031a4:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80031a6:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80031aa:	bd10      	pop	{r4, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 80031ac:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 80031b0:	482a      	ldr	r0, [pc, #168]	; (800325c <HAL_I2C_Init+0x1a0>)
 80031b2:	f017 fe77 	bl	801aea4 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 80031b6:	6923      	ldr	r3, [r4, #16]
 80031b8:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 80031bc:	d0a4      	beq.n	8003108 <HAL_I2C_Init+0x4c>
 80031be:	f240 11e1 	movw	r1, #481	; 0x1e1
 80031c2:	4826      	ldr	r0, [pc, #152]	; (800325c <HAL_I2C_Init+0x1a0>)
 80031c4:	f017 fe6e 	bl	801aea4 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 80031c8:	6963      	ldr	r3, [r4, #20]
 80031ca:	2bff      	cmp	r3, #255	; 0xff
 80031cc:	d99f      	bls.n	800310e <HAL_I2C_Init+0x52>
 80031ce:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
 80031d2:	4822      	ldr	r0, [pc, #136]	; (800325c <HAL_I2C_Init+0x1a0>)
 80031d4:	f017 fe66 	bl	801aea4 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 80031d8:	69a3      	ldr	r3, [r4, #24]
 80031da:	2b07      	cmp	r3, #7
 80031dc:	d99a      	bls.n	8003114 <HAL_I2C_Init+0x58>
 80031de:	f240 11e3 	movw	r1, #483	; 0x1e3
 80031e2:	481e      	ldr	r0, [pc, #120]	; (800325c <HAL_I2C_Init+0x1a0>)
 80031e4:	f017 fe5e 	bl	801aea4 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 80031e8:	69e3      	ldr	r3, [r4, #28]
 80031ea:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 80031ee:	d095      	beq.n	800311c <HAL_I2C_Init+0x60>
 80031f0:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
 80031f4:	4819      	ldr	r0, [pc, #100]	; (800325c <HAL_I2C_Init+0x1a0>)
 80031f6:	f017 fe55 	bl	801aea4 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 80031fa:	6a23      	ldr	r3, [r4, #32]
 80031fc:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 8003200:	d090      	beq.n	8003124 <HAL_I2C_Init+0x68>
 8003202:	f240 11e5 	movw	r1, #485	; 0x1e5
 8003206:	4815      	ldr	r0, [pc, #84]	; (800325c <HAL_I2C_Init+0x1a0>)
 8003208:	f017 fe4c 	bl	801aea4 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800320c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003210:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003214:	2b00      	cmp	r3, #0
 8003216:	d18b      	bne.n	8003130 <HAL_I2C_Init+0x74>
    HAL_I2C_MspInit(hi2c);
 8003218:	4620      	mov	r0, r4
    hi2c->Lock = HAL_UNLOCKED;
 800321a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 800321e:	f017 f8db 	bl	801a3d8 <HAL_I2C_MspInit>
 8003222:	e785      	b.n	8003130 <HAL_I2C_Init+0x74>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8003224:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003228:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800322a:	e79d      	b.n	8003168 <HAL_I2C_Init+0xac>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 800322c:	f240 11df 	movw	r1, #479	; 0x1df
 8003230:	480a      	ldr	r0, [pc, #40]	; (800325c <HAL_I2C_Init+0x1a0>)
 8003232:	f017 fe37 	bl	801aea4 <assert_failed>
 8003236:	e75f      	b.n	80030f8 <HAL_I2C_Init+0x3c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003238:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 800323c:	4807      	ldr	r0, [pc, #28]	; (800325c <HAL_I2C_Init+0x1a0>)
 800323e:	f017 fe31 	bl	801aea4 <assert_failed>
 8003242:	e754      	b.n	80030ee <HAL_I2C_Init+0x32>
    return HAL_ERROR;
 8003244:	2001      	movs	r0, #1
}
 8003246:	4770      	bx	lr
 8003248:	40005400 	.word	0x40005400
 800324c:	40005c00 	.word	0x40005c00
 8003250:	40005800 	.word	0x40005800
 8003254:	40006000 	.word	0x40006000
 8003258:	02008000 	.word	0x02008000
 800325c:	0802160c 	.word	0x0802160c

08003260 <HAL_I2C_Mem_Write>:
{
 8003260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003264:	461e      	mov	r6, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8003266:	3b01      	subs	r3, #1
{
 8003268:	b083      	sub	sp, #12
 800326a:	4604      	mov	r4, r0
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 800326c:	2b01      	cmp	r3, #1
{
 800326e:	460f      	mov	r7, r1
 8003270:	4691      	mov	r9, r2
 8003272:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8003276:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 800327a:	d904      	bls.n	8003286 <HAL_I2C_Mem_Write+0x26>
 800327c:	f640 01ed 	movw	r1, #2285	; 0x8ed
 8003280:	48a6      	ldr	r0, [pc, #664]	; (800351c <HAL_I2C_Mem_Write+0x2bc>)
 8003282:	f017 fe0f 	bl	801aea4 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003286:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800328a:	2b20      	cmp	r3, #32
 800328c:	f040 80b5 	bne.w	80033fa <HAL_I2C_Mem_Write+0x19a>
    if ((pData == NULL) || (Size == 0U))
 8003290:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003292:	2b00      	cmp	r3, #0
 8003294:	f000 80aa 	beq.w	80033ec <HAL_I2C_Mem_Write+0x18c>
 8003298:	f1ba 0f00 	cmp.w	sl, #0
 800329c:	f000 80a6 	beq.w	80033ec <HAL_I2C_Mem_Write+0x18c>
    __HAL_LOCK(hi2c);
 80032a0:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80032a4:	2b01      	cmp	r3, #1
 80032a6:	f000 80a8 	beq.w	80033fa <HAL_I2C_Mem_Write+0x19a>
 80032aa:	2301      	movs	r3, #1
 80032ac:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    tickstart = HAL_GetTick();
 80032b0:	f7fd fede 	bl	8001070 <HAL_GetTick>
 80032b4:	4605      	mov	r5, r0
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
 80032b6:	e005      	b.n	80032c4 <HAL_I2C_Mem_Write+0x64>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80032b8:	f7fd feda 	bl	8001070 <HAL_GetTick>
 80032bc:	1b40      	subs	r0, r0, r5
 80032be:	2819      	cmp	r0, #25
 80032c0:	f200 80b0 	bhi.w	8003424 <HAL_I2C_Mem_Write+0x1c4>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80032c4:	6823      	ldr	r3, [r4, #0]
 80032c6:	699b      	ldr	r3, [r3, #24]
 80032c8:	f413 4b00 	ands.w	fp, r3, #32768	; 0x8000
 80032cc:	d1f4      	bne.n	80032b8 <HAL_I2C_Mem_Write+0x58>
    hi2c->pBuffPtr  = pData;
 80032ce:	990c      	ldr	r1, [sp, #48]	; 0x30
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80032d0:	4633      	mov	r3, r6
    hi2c->XferISR   = NULL;
 80032d2:	f8c4 b034 	str.w	fp, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80032d6:	464a      	mov	r2, r9
    hi2c->pBuffPtr  = pData;
 80032d8:	6261      	str	r1, [r4, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80032da:	2121      	movs	r1, #33	; 0x21
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80032dc:	4620      	mov	r0, r4
 80032de:	e9cd 8500 	strd	r8, r5, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80032e2:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80032e6:	2140      	movs	r1, #64	; 0x40
 80032e8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80032ec:	4639      	mov	r1, r7
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80032ee:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 80032f2:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80032f6:	f7ff fde9 	bl	8002ecc <I2C_RequestMemoryWrite>
 80032fa:	2800      	cmp	r0, #0
 80032fc:	f040 8081 	bne.w	8003402 <HAL_I2C_Mem_Write+0x1a2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003300:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003302:	b29b      	uxth	r3, r3
 8003304:	2bff      	cmp	r3, #255	; 0xff
 8003306:	f240 80bc 	bls.w	8003482 <HAL_I2C_Mem_Write+0x222>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800330a:	23ff      	movs	r3, #255	; 0xff
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800330c:	4a84      	ldr	r2, [pc, #528]	; (8003520 <HAL_I2C_Mem_Write+0x2c0>)
 800330e:	4985      	ldr	r1, [pc, #532]	; (8003524 <HAL_I2C_Mem_Write+0x2c4>)
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8003310:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003312:	6823      	ldr	r3, [r4, #0]
 8003314:	4293      	cmp	r3, r2
 8003316:	bf18      	it	ne
 8003318:	428b      	cmpne	r3, r1
 800331a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800331e:	bf14      	ite	ne
 8003320:	2201      	movne	r2, #1
 8003322:	2200      	moveq	r2, #0
 8003324:	428b      	cmp	r3, r1
 8003326:	bf0c      	ite	eq
 8003328:	2200      	moveq	r2, #0
 800332a:	f002 0201 	andne.w	r2, r2, #1
 800332e:	b142      	cbz	r2, 8003342 <HAL_I2C_Mem_Write+0xe2>
 8003330:	4a7d      	ldr	r2, [pc, #500]	; (8003528 <HAL_I2C_Mem_Write+0x2c8>)
 8003332:	4293      	cmp	r3, r2
 8003334:	d005      	beq.n	8003342 <HAL_I2C_Mem_Write+0xe2>
 8003336:	f641 01c1 	movw	r1, #6337	; 0x18c1
 800333a:	4878      	ldr	r0, [pc, #480]	; (800351c <HAL_I2C_Mem_Write+0x2bc>)
 800333c:	f017 fdb2 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003340:	6823      	ldr	r3, [r4, #0]
 8003342:	685a      	ldr	r2, [r3, #4]
 8003344:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8003348:	4978      	ldr	r1, [pc, #480]	; (800352c <HAL_I2C_Mem_Write+0x2cc>)
 800334a:	400a      	ands	r2, r1
 800334c:	4978      	ldr	r1, [pc, #480]	; (8003530 <HAL_I2C_Mem_Write+0x2d0>)
 800334e:	433a      	orrs	r2, r7
 8003350:	4311      	orrs	r1, r2
 8003352:	6059      	str	r1, [r3, #4]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003354:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 8003520 <HAL_I2C_Mem_Write+0x2c0>
 8003358:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 8003524 <HAL_I2C_Mem_Write+0x2c4>
 800335c:	4e75      	ldr	r6, [pc, #468]	; (8003534 <HAL_I2C_Mem_Write+0x2d4>)
 800335e:	e004      	b.n	800336a <HAL_I2C_Mem_Write+0x10a>
    while (hi2c->XferCount > 0U);
 8003360:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003362:	b29b      	uxth	r3, r3
 8003364:	2b00      	cmp	r3, #0
 8003366:	f000 80c4 	beq.w	80034f2 <HAL_I2C_Mem_Write+0x292>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800336a:	462a      	mov	r2, r5
 800336c:	4641      	mov	r1, r8
 800336e:	4620      	mov	r0, r4
 8003370:	f7ff fcfa 	bl	8002d68 <I2C_WaitOnTXISFlagUntilTimeout>
 8003374:	2800      	cmp	r0, #0
 8003376:	f040 8082 	bne.w	800347e <HAL_I2C_Mem_Write+0x21e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800337a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800337c:	6821      	ldr	r1, [r4, #0]
 800337e:	f812 0b01 	ldrb.w	r0, [r2], #1
      hi2c->XferSize--;
 8003382:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8003384:	6288      	str	r0, [r1, #40]	; 0x28
      hi2c->pBuffPtr++;
 8003386:	6262      	str	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8003388:	3b01      	subs	r3, #1
      hi2c->XferCount--;
 800338a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800338c:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
 800338e:	3a01      	subs	r2, #1
      hi2c->XferSize--;
 8003390:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8003392:	b292      	uxth	r2, r2
 8003394:	8562      	strh	r2, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003396:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8003398:	b292      	uxth	r2, r2
 800339a:	2b00      	cmp	r3, #0
 800339c:	d1e0      	bne.n	8003360 <HAL_I2C_Mem_Write+0x100>
 800339e:	2a00      	cmp	r2, #0
 80033a0:	d0de      	beq.n	8003360 <HAL_I2C_Mem_Write+0x100>
 80033a2:	f1b8 3fff 	cmp.w	r8, #4294967295
 80033a6:	d130      	bne.n	800340a <HAL_I2C_Mem_Write+0x1aa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80033a8:	698b      	ldr	r3, [r1, #24]
 80033aa:	061a      	lsls	r2, r3, #24
 80033ac:	d5fc      	bpl.n	80033a8 <HAL_I2C_Mem_Write+0x148>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80033ae:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80033b0:	b29b      	uxth	r3, r3
 80033b2:	2bff      	cmp	r3, #255	; 0xff
 80033b4:	d945      	bls.n	8003442 <HAL_I2C_Mem_Write+0x1e2>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80033b6:	4551      	cmp	r1, sl
 80033b8:	bf18      	it	ne
 80033ba:	4549      	cmpne	r1, r9
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80033bc:	f04f 02ff 	mov.w	r2, #255	; 0xff
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80033c0:	bf14      	ite	ne
 80033c2:	2301      	movne	r3, #1
 80033c4:	2300      	moveq	r3, #0
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80033c6:	8522      	strh	r2, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80033c8:	42b1      	cmp	r1, r6
 80033ca:	bf0c      	ite	eq
 80033cc:	2300      	moveq	r3, #0
 80033ce:	f003 0301 	andne.w	r3, r3, #1
 80033d2:	b11b      	cbz	r3, 80033dc <HAL_I2C_Mem_Write+0x17c>
 80033d4:	4b54      	ldr	r3, [pc, #336]	; (8003528 <HAL_I2C_Mem_Write+0x2c8>)
 80033d6:	4299      	cmp	r1, r3
 80033d8:	f040 8084 	bne.w	80034e4 <HAL_I2C_Mem_Write+0x284>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80033dc:	684b      	ldr	r3, [r1, #4]
 80033de:	4a53      	ldr	r2, [pc, #332]	; (800352c <HAL_I2C_Mem_Write+0x2cc>)
 80033e0:	4013      	ands	r3, r2
 80033e2:	4a53      	ldr	r2, [pc, #332]	; (8003530 <HAL_I2C_Mem_Write+0x2d0>)
 80033e4:	433b      	orrs	r3, r7
 80033e6:	431a      	orrs	r2, r3
 80033e8:	604a      	str	r2, [r1, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 80033ea:	e7b9      	b.n	8003360 <HAL_I2C_Mem_Write+0x100>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80033ec:	f44f 7300 	mov.w	r3, #512	; 0x200
      return  HAL_ERROR;
 80033f0:	2001      	movs	r0, #1
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80033f2:	6463      	str	r3, [r4, #68]	; 0x44
}
 80033f4:	b003      	add	sp, #12
 80033f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_BUSY;
 80033fa:	2002      	movs	r0, #2
}
 80033fc:	b003      	add	sp, #12
 80033fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return HAL_ERROR;
 8003402:	2001      	movs	r0, #1
      __HAL_UNLOCK(hi2c);
 8003404:	f884 b040 	strb.w	fp, [r4, #64]	; 0x40
      return HAL_ERROR;
 8003408:	e7f4      	b.n	80033f4 <HAL_I2C_Mem_Write+0x194>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800340a:	698b      	ldr	r3, [r1, #24]
 800340c:	061b      	lsls	r3, r3, #24
 800340e:	d4ce      	bmi.n	80033ae <HAL_I2C_Mem_Write+0x14e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003410:	f7fd fe2e 	bl	8001070 <HAL_GetTick>
 8003414:	1b40      	subs	r0, r0, r5
 8003416:	4580      	cmp	r8, r0
 8003418:	d304      	bcc.n	8003424 <HAL_I2C_Mem_Write+0x1c4>
 800341a:	f1b8 0f00 	cmp.w	r8, #0
 800341e:	d001      	beq.n	8003424 <HAL_I2C_Mem_Write+0x1c4>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003420:	6821      	ldr	r1, [r4, #0]
 8003422:	e7be      	b.n	80033a2 <HAL_I2C_Mem_Write+0x142>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003424:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003426:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003428:	2200      	movs	r2, #0
          return HAL_ERROR;
 800342a:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800342c:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 800342e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003432:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003434:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003438:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 800343c:	b003      	add	sp, #12
 800343e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          hi2c->XferSize = hi2c->XferCount;
 8003442:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003444:	4551      	cmp	r1, sl
 8003446:	bf18      	it	ne
 8003448:	4549      	cmpne	r1, r9
          hi2c->XferSize = hi2c->XferCount;
 800344a:	b29b      	uxth	r3, r3
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800344c:	fa5f fb83 	uxtb.w	fp, r3
          hi2c->XferSize = hi2c->XferCount;
 8003450:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003452:	bf14      	ite	ne
 8003454:	2301      	movne	r3, #1
 8003456:	2300      	moveq	r3, #0
 8003458:	42b1      	cmp	r1, r6
 800345a:	bf0c      	ite	eq
 800345c:	2300      	moveq	r3, #0
 800345e:	f003 0301 	andne.w	r3, r3, #1
 8003462:	b113      	cbz	r3, 800346a <HAL_I2C_Mem_Write+0x20a>
 8003464:	4b30      	ldr	r3, [pc, #192]	; (8003528 <HAL_I2C_Mem_Write+0x2c8>)
 8003466:	4299      	cmp	r1, r3
 8003468:	d135      	bne.n	80034d6 <HAL_I2C_Mem_Write+0x276>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800346a:	684b      	ldr	r3, [r1, #4]
 800346c:	4a2f      	ldr	r2, [pc, #188]	; (800352c <HAL_I2C_Mem_Write+0x2cc>)
 800346e:	4013      	ands	r3, r2
 8003470:	ea43 430b 	orr.w	r3, r3, fp, lsl #16
 8003474:	433b      	orrs	r3, r7
 8003476:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800347a:	604b      	str	r3, [r1, #4]
}
 800347c:	e770      	b.n	8003360 <HAL_I2C_Mem_Write+0x100>
        return HAL_ERROR;
 800347e:	2001      	movs	r0, #1
 8003480:	e7b8      	b.n	80033f4 <HAL_I2C_Mem_Write+0x194>
      hi2c->XferSize = hi2c->XferCount;
 8003482:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003484:	6822      	ldr	r2, [r4, #0]
      hi2c->XferSize = hi2c->XferCount;
 8003486:	b29b      	uxth	r3, r3
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003488:	4926      	ldr	r1, [pc, #152]	; (8003524 <HAL_I2C_Mem_Write+0x2c4>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800348a:	b2de      	uxtb	r6, r3
      hi2c->XferSize = hi2c->XferCount;
 800348c:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800348e:	4b24      	ldr	r3, [pc, #144]	; (8003520 <HAL_I2C_Mem_Write+0x2c0>)
 8003490:	429a      	cmp	r2, r3
 8003492:	bf18      	it	ne
 8003494:	428a      	cmpne	r2, r1
 8003496:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800349a:	bf14      	ite	ne
 800349c:	2301      	movne	r3, #1
 800349e:	2300      	moveq	r3, #0
 80034a0:	428a      	cmp	r2, r1
 80034a2:	bf0c      	ite	eq
 80034a4:	2300      	moveq	r3, #0
 80034a6:	f003 0301 	andne.w	r3, r3, #1
 80034aa:	b143      	cbz	r3, 80034be <HAL_I2C_Mem_Write+0x25e>
 80034ac:	4b1e      	ldr	r3, [pc, #120]	; (8003528 <HAL_I2C_Mem_Write+0x2c8>)
 80034ae:	429a      	cmp	r2, r3
 80034b0:	d005      	beq.n	80034be <HAL_I2C_Mem_Write+0x25e>
 80034b2:	f641 01c1 	movw	r1, #6337	; 0x18c1
 80034b6:	4819      	ldr	r0, [pc, #100]	; (800351c <HAL_I2C_Mem_Write+0x2bc>)
 80034b8:	f017 fcf4 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80034bc:	6822      	ldr	r2, [r4, #0]
 80034be:	6853      	ldr	r3, [r2, #4]
 80034c0:	f3c7 0709 	ubfx	r7, r7, #0, #10
 80034c4:	4919      	ldr	r1, [pc, #100]	; (800352c <HAL_I2C_Mem_Write+0x2cc>)
 80034c6:	400b      	ands	r3, r1
 80034c8:	433b      	orrs	r3, r7
 80034ca:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 80034ce:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80034d2:	6053      	str	r3, [r2, #4]
}
 80034d4:	e73e      	b.n	8003354 <HAL_I2C_Mem_Write+0xf4>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80034d6:	f641 01c1 	movw	r1, #6337	; 0x18c1
 80034da:	4810      	ldr	r0, [pc, #64]	; (800351c <HAL_I2C_Mem_Write+0x2bc>)
 80034dc:	f017 fce2 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80034e0:	6821      	ldr	r1, [r4, #0]
 80034e2:	e7c2      	b.n	800346a <HAL_I2C_Mem_Write+0x20a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80034e4:	f641 01c1 	movw	r1, #6337	; 0x18c1
 80034e8:	480c      	ldr	r0, [pc, #48]	; (800351c <HAL_I2C_Mem_Write+0x2bc>)
 80034ea:	f017 fcdb 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80034ee:	6821      	ldr	r1, [r4, #0]
 80034f0:	e774      	b.n	80033dc <HAL_I2C_Mem_Write+0x17c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80034f2:	462a      	mov	r2, r5
 80034f4:	4641      	mov	r1, r8
 80034f6:	4620      	mov	r0, r4
 80034f8:	f7ff fc92 	bl	8002e20 <I2C_WaitOnSTOPFlagUntilTimeout>
 80034fc:	2800      	cmp	r0, #0
 80034fe:	d1be      	bne.n	800347e <HAL_I2C_Mem_Write+0x21e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003500:	6823      	ldr	r3, [r4, #0]
 8003502:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8003504:	4d0c      	ldr	r5, [pc, #48]	; (8003538 <HAL_I2C_Mem_Write+0x2d8>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003506:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8003508:	685a      	ldr	r2, [r3, #4]
 800350a:	402a      	ands	r2, r5
 800350c:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 800350e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8003512:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8003516:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 800351a:	e76b      	b.n	80033f4 <HAL_I2C_Mem_Write+0x194>
 800351c:	0802160c 	.word	0x0802160c
 8003520:	40005400 	.word	0x40005400
 8003524:	40005800 	.word	0x40005800
 8003528:	40006000 	.word	0x40006000
 800352c:	fc009c00 	.word	0xfc009c00
 8003530:	01ff0000 	.word	0x01ff0000
 8003534:	40005c00 	.word	0x40005c00
 8003538:	fe00e800 	.word	0xfe00e800

0800353c <HAL_I2C_Mem_Read>:
{
 800353c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003540:	4698      	mov	r8, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8003542:	3b01      	subs	r3, #1
{
 8003544:	b083      	sub	sp, #12
 8003546:	4604      	mov	r4, r0
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8003548:	2b01      	cmp	r3, #1
{
 800354a:	460f      	mov	r7, r1
 800354c:	4691      	mov	r9, r2
 800354e:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8003552:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8003554:	d904      	bls.n	8003560 <HAL_I2C_Mem_Read+0x24>
 8003556:	f640 1174 	movw	r1, #2420	; 0x974
 800355a:	489e      	ldr	r0, [pc, #632]	; (80037d4 <HAL_I2C_Mem_Read+0x298>)
 800355c:	f017 fca2 	bl	801aea4 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003560:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003564:	2b20      	cmp	r3, #32
 8003566:	f040 80a7 	bne.w	80036b8 <HAL_I2C_Mem_Read+0x17c>
    if ((pData == NULL) || (Size == 0U))
 800356a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800356c:	2b00      	cmp	r3, #0
 800356e:	f000 809c 	beq.w	80036aa <HAL_I2C_Mem_Read+0x16e>
 8003572:	f1ba 0f00 	cmp.w	sl, #0
 8003576:	f000 8098 	beq.w	80036aa <HAL_I2C_Mem_Read+0x16e>
    __HAL_LOCK(hi2c);
 800357a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800357e:	2b01      	cmp	r3, #1
 8003580:	f000 809a 	beq.w	80036b8 <HAL_I2C_Mem_Read+0x17c>
 8003584:	2301      	movs	r3, #1
 8003586:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    tickstart = HAL_GetTick();
 800358a:	f7fd fd71 	bl	8001070 <HAL_GetTick>
 800358e:	4606      	mov	r6, r0
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
 8003590:	e004      	b.n	800359c <HAL_I2C_Mem_Read+0x60>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003592:	f7fd fd6d 	bl	8001070 <HAL_GetTick>
 8003596:	1b80      	subs	r0, r0, r6
 8003598:	2819      	cmp	r0, #25
 800359a:	d877      	bhi.n	800368c <HAL_I2C_Mem_Read+0x150>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800359c:	6823      	ldr	r3, [r4, #0]
 800359e:	699b      	ldr	r3, [r3, #24]
 80035a0:	f413 4b00 	ands.w	fp, r3, #32768	; 0x8000
 80035a4:	d1f5      	bne.n	8003592 <HAL_I2C_Mem_Read+0x56>
    hi2c->pBuffPtr  = pData;
 80035a6:	990c      	ldr	r1, [sp, #48]	; 0x30
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80035a8:	4643      	mov	r3, r8
    hi2c->XferISR   = NULL;
 80035aa:	f8c4 b034 	str.w	fp, [r4, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80035ae:	464a      	mov	r2, r9
    hi2c->pBuffPtr  = pData;
 80035b0:	6261      	str	r1, [r4, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80035b2:	2122      	movs	r1, #34	; 0x22
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80035b4:	4620      	mov	r0, r4
 80035b6:	e9cd 5600 	strd	r5, r6, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80035ba:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80035be:	2140      	movs	r1, #64	; 0x40
 80035c0:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80035c4:	4639      	mov	r1, r7
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80035c6:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 80035ca:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80035ce:	f7ff fcf9 	bl	8002fc4 <I2C_RequestMemoryRead>
 80035d2:	2800      	cmp	r0, #0
 80035d4:	d174      	bne.n	80036c0 <HAL_I2C_Mem_Read+0x184>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80035d6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80035d8:	b29b      	uxth	r3, r3
 80035da:	2bff      	cmp	r3, #255	; 0xff
 80035dc:	f240 80c0 	bls.w	8003760 <HAL_I2C_Mem_Read+0x224>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80035e0:	23ff      	movs	r3, #255	; 0xff
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80035e2:	6822      	ldr	r2, [r4, #0]
 80035e4:	497c      	ldr	r1, [pc, #496]	; (80037d8 <HAL_I2C_Mem_Read+0x29c>)
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80035e6:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80035e8:	4b7c      	ldr	r3, [pc, #496]	; (80037dc <HAL_I2C_Mem_Read+0x2a0>)
 80035ea:	429a      	cmp	r2, r3
 80035ec:	bf18      	it	ne
 80035ee:	428a      	cmpne	r2, r1
 80035f0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80035f4:	bf14      	ite	ne
 80035f6:	2301      	movne	r3, #1
 80035f8:	2300      	moveq	r3, #0
 80035fa:	428a      	cmp	r2, r1
 80035fc:	bf0c      	ite	eq
 80035fe:	2300      	moveq	r3, #0
 8003600:	f003 0301 	andne.w	r3, r3, #1
 8003604:	b143      	cbz	r3, 8003618 <HAL_I2C_Mem_Read+0xdc>
 8003606:	4b76      	ldr	r3, [pc, #472]	; (80037e0 <HAL_I2C_Mem_Read+0x2a4>)
 8003608:	429a      	cmp	r2, r3
 800360a:	d005      	beq.n	8003618 <HAL_I2C_Mem_Read+0xdc>
 800360c:	f641 01c1 	movw	r1, #6337	; 0x18c1
 8003610:	4870      	ldr	r0, [pc, #448]	; (80037d4 <HAL_I2C_Mem_Read+0x298>)
 8003612:	f017 fc47 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003616:	6822      	ldr	r2, [r4, #0]
 8003618:	6853      	ldr	r3, [r2, #4]
 800361a:	4972      	ldr	r1, [pc, #456]	; (80037e4 <HAL_I2C_Mem_Read+0x2a8>)
 800361c:	400b      	ands	r3, r1
 800361e:	f3c7 0109 	ubfx	r1, r7, #0, #10
 8003622:	430b      	orrs	r3, r1
 8003624:	460f      	mov	r7, r1
 8003626:	4970      	ldr	r1, [pc, #448]	; (80037e8 <HAL_I2C_Mem_Read+0x2ac>)
 8003628:	4319      	orrs	r1, r3
 800362a:	6051      	str	r1, [r2, #4]
 800362c:	1c68      	adds	r0, r5, #1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800362e:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 80037dc <HAL_I2C_Mem_Read+0x2a0>
 8003632:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 80037d8 <HAL_I2C_Mem_Read+0x29c>
 8003636:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 80037f8 <HAL_I2C_Mem_Read+0x2bc>
 800363a:	d11d      	bne.n	8003678 <HAL_I2C_Mem_Read+0x13c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800363c:	6993      	ldr	r3, [r2, #24]
 800363e:	0759      	lsls	r1, r3, #29
 8003640:	d5fc      	bpl.n	800363c <HAL_I2C_Mem_Read+0x100>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8003642:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8003644:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003646:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 8003648:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 800364a:	6a63      	ldr	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 800364c:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
 800364e:	3301      	adds	r3, #1
      hi2c->XferCount--;
 8003650:	b292      	uxth	r2, r2
      hi2c->pBuffPtr++;
 8003652:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8003654:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8003656:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8003658:	3b01      	subs	r3, #1
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800365a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800365c:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800365e:	b292      	uxth	r2, r2
      hi2c->XferSize--;
 8003660:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003662:	b10a      	cbz	r2, 8003668 <HAL_I2C_Mem_Read+0x12c>
 8003664:	2b00      	cmp	r3, #0
 8003666:	d039      	beq.n	80036dc <HAL_I2C_Mem_Read+0x1a0>
    while (hi2c->XferCount > 0U);
 8003668:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800366a:	b29b      	uxth	r3, r3
 800366c:	2b00      	cmp	r3, #0
 800366e:	f000 80c5 	beq.w	80037fc <HAL_I2C_Mem_Read+0x2c0>
 8003672:	1c68      	adds	r0, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003674:	6822      	ldr	r2, [r4, #0]
 8003676:	d0e1      	beq.n	800363c <HAL_I2C_Mem_Read+0x100>
 8003678:	6993      	ldr	r3, [r2, #24]
 800367a:	075b      	lsls	r3, r3, #29
 800367c:	d4e1      	bmi.n	8003642 <HAL_I2C_Mem_Read+0x106>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800367e:	f7fd fcf7 	bl	8001070 <HAL_GetTick>
 8003682:	1b80      	subs	r0, r0, r6
 8003684:	4285      	cmp	r5, r0
 8003686:	d301      	bcc.n	800368c <HAL_I2C_Mem_Read+0x150>
 8003688:	2d00      	cmp	r5, #0
 800368a:	d1f2      	bne.n	8003672 <HAL_I2C_Mem_Read+0x136>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800368c:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800368e:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003690:	2200      	movs	r2, #0
          return HAL_ERROR;
 8003692:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003694:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8003696:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800369a:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800369c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80036a0:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80036a4:	b003      	add	sp, #12
 80036a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80036aa:	f44f 7300 	mov.w	r3, #512	; 0x200
      return  HAL_ERROR;
 80036ae:	2001      	movs	r0, #1
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80036b0:	6463      	str	r3, [r4, #68]	; 0x44
}
 80036b2:	b003      	add	sp, #12
 80036b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_BUSY;
 80036b8:	2002      	movs	r0, #2
}
 80036ba:	b003      	add	sp, #12
 80036bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return HAL_ERROR;
 80036c0:	2001      	movs	r0, #1
      __HAL_UNLOCK(hi2c);
 80036c2:	f884 b040 	strb.w	fp, [r4, #64]	; 0x40
      return HAL_ERROR;
 80036c6:	e7f4      	b.n	80036b2 <HAL_I2C_Mem_Read+0x176>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80036c8:	6993      	ldr	r3, [r2, #24]
 80036ca:	061b      	lsls	r3, r3, #24
 80036cc:	d40c      	bmi.n	80036e8 <HAL_I2C_Mem_Read+0x1ac>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80036ce:	f7fd fccf 	bl	8001070 <HAL_GetTick>
 80036d2:	1b80      	subs	r0, r0, r6
 80036d4:	4285      	cmp	r5, r0
 80036d6:	d3d9      	bcc.n	800368c <HAL_I2C_Mem_Read+0x150>
 80036d8:	2d00      	cmp	r5, #0
 80036da:	d0d7      	beq.n	800368c <HAL_I2C_Mem_Read+0x150>
 80036dc:	1c68      	adds	r0, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80036de:	6822      	ldr	r2, [r4, #0]
 80036e0:	d1f2      	bne.n	80036c8 <HAL_I2C_Mem_Read+0x18c>
 80036e2:	6993      	ldr	r3, [r2, #24]
 80036e4:	0619      	lsls	r1, r3, #24
 80036e6:	d5fc      	bpl.n	80036e2 <HAL_I2C_Mem_Read+0x1a6>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80036e8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80036ea:	b29b      	uxth	r3, r3
 80036ec:	2bff      	cmp	r3, #255	; 0xff
 80036ee:	d919      	bls.n	8003724 <HAL_I2C_Mem_Read+0x1e8>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80036f0:	4552      	cmp	r2, sl
 80036f2:	bf18      	it	ne
 80036f4:	454a      	cmpne	r2, r9
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80036f6:	f04f 01ff 	mov.w	r1, #255	; 0xff
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80036fa:	bf14      	ite	ne
 80036fc:	2301      	movne	r3, #1
 80036fe:	2300      	moveq	r3, #0
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8003700:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003702:	4542      	cmp	r2, r8
 8003704:	bf0c      	ite	eq
 8003706:	2300      	moveq	r3, #0
 8003708:	f003 0301 	andne.w	r3, r3, #1
 800370c:	b113      	cbz	r3, 8003714 <HAL_I2C_Mem_Read+0x1d8>
 800370e:	4b34      	ldr	r3, [pc, #208]	; (80037e0 <HAL_I2C_Mem_Read+0x2a4>)
 8003710:	429a      	cmp	r2, r3
 8003712:	d158      	bne.n	80037c6 <HAL_I2C_Mem_Read+0x28a>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003714:	6853      	ldr	r3, [r2, #4]
 8003716:	4935      	ldr	r1, [pc, #212]	; (80037ec <HAL_I2C_Mem_Read+0x2b0>)
 8003718:	400b      	ands	r3, r1
 800371a:	4935      	ldr	r1, [pc, #212]	; (80037f0 <HAL_I2C_Mem_Read+0x2b4>)
 800371c:	433b      	orrs	r3, r7
 800371e:	4319      	orrs	r1, r3
 8003720:	6051      	str	r1, [r2, #4]
}
 8003722:	e7a1      	b.n	8003668 <HAL_I2C_Mem_Read+0x12c>
          hi2c->XferSize = hi2c->XferCount;
 8003724:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003726:	4552      	cmp	r2, sl
 8003728:	bf18      	it	ne
 800372a:	454a      	cmpne	r2, r9
          hi2c->XferSize = hi2c->XferCount;
 800372c:	b29b      	uxth	r3, r3
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800372e:	fa5f fb83 	uxtb.w	fp, r3
          hi2c->XferSize = hi2c->XferCount;
 8003732:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003734:	bf14      	ite	ne
 8003736:	2301      	movne	r3, #1
 8003738:	2300      	moveq	r3, #0
 800373a:	4542      	cmp	r2, r8
 800373c:	bf0c      	ite	eq
 800373e:	2300      	moveq	r3, #0
 8003740:	f003 0301 	andne.w	r3, r3, #1
 8003744:	b113      	cbz	r3, 800374c <HAL_I2C_Mem_Read+0x210>
 8003746:	4b26      	ldr	r3, [pc, #152]	; (80037e0 <HAL_I2C_Mem_Read+0x2a4>)
 8003748:	429a      	cmp	r2, r3
 800374a:	d135      	bne.n	80037b8 <HAL_I2C_Mem_Read+0x27c>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800374c:	6853      	ldr	r3, [r2, #4]
 800374e:	4927      	ldr	r1, [pc, #156]	; (80037ec <HAL_I2C_Mem_Read+0x2b0>)
 8003750:	400b      	ands	r3, r1
 8003752:	433b      	orrs	r3, r7
 8003754:	ea43 430b 	orr.w	r3, r3, fp, lsl #16
 8003758:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800375c:	6053      	str	r3, [r2, #4]
}
 800375e:	e783      	b.n	8003668 <HAL_I2C_Mem_Read+0x12c>
      hi2c->XferSize = hi2c->XferCount;
 8003760:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003762:	6822      	ldr	r2, [r4, #0]
      hi2c->XferSize = hi2c->XferCount;
 8003764:	b29b      	uxth	r3, r3
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003766:	491c      	ldr	r1, [pc, #112]	; (80037d8 <HAL_I2C_Mem_Read+0x29c>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8003768:	fa5f f883 	uxtb.w	r8, r3
      hi2c->XferSize = hi2c->XferCount;
 800376c:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800376e:	4b1b      	ldr	r3, [pc, #108]	; (80037dc <HAL_I2C_Mem_Read+0x2a0>)
 8003770:	429a      	cmp	r2, r3
 8003772:	bf18      	it	ne
 8003774:	428a      	cmpne	r2, r1
 8003776:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800377a:	bf14      	ite	ne
 800377c:	2301      	movne	r3, #1
 800377e:	2300      	moveq	r3, #0
 8003780:	428a      	cmp	r2, r1
 8003782:	bf0c      	ite	eq
 8003784:	2300      	moveq	r3, #0
 8003786:	f003 0301 	andne.w	r3, r3, #1
 800378a:	b143      	cbz	r3, 800379e <HAL_I2C_Mem_Read+0x262>
 800378c:	4b14      	ldr	r3, [pc, #80]	; (80037e0 <HAL_I2C_Mem_Read+0x2a4>)
 800378e:	429a      	cmp	r2, r3
 8003790:	d005      	beq.n	800379e <HAL_I2C_Mem_Read+0x262>
 8003792:	f641 01c1 	movw	r1, #6337	; 0x18c1
 8003796:	480f      	ldr	r0, [pc, #60]	; (80037d4 <HAL_I2C_Mem_Read+0x298>)
 8003798:	f017 fb84 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800379c:	6822      	ldr	r2, [r4, #0]
 800379e:	6853      	ldr	r3, [r2, #4]
 80037a0:	4910      	ldr	r1, [pc, #64]	; (80037e4 <HAL_I2C_Mem_Read+0x2a8>)
 80037a2:	400b      	ands	r3, r1
 80037a4:	f3c7 0109 	ubfx	r1, r7, #0, #10
 80037a8:	430b      	orrs	r3, r1
 80037aa:	460f      	mov	r7, r1
 80037ac:	4911      	ldr	r1, [pc, #68]	; (80037f4 <HAL_I2C_Mem_Read+0x2b8>)
 80037ae:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80037b2:	4319      	orrs	r1, r3
 80037b4:	6051      	str	r1, [r2, #4]
}
 80037b6:	e739      	b.n	800362c <HAL_I2C_Mem_Read+0xf0>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80037b8:	f641 01c1 	movw	r1, #6337	; 0x18c1
 80037bc:	4805      	ldr	r0, [pc, #20]	; (80037d4 <HAL_I2C_Mem_Read+0x298>)
 80037be:	f017 fb71 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80037c2:	6822      	ldr	r2, [r4, #0]
 80037c4:	e7c2      	b.n	800374c <HAL_I2C_Mem_Read+0x210>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80037c6:	f641 01c1 	movw	r1, #6337	; 0x18c1
 80037ca:	4802      	ldr	r0, [pc, #8]	; (80037d4 <HAL_I2C_Mem_Read+0x298>)
 80037cc:	f017 fb6a 	bl	801aea4 <assert_failed>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80037d0:	6822      	ldr	r2, [r4, #0]
 80037d2:	e79f      	b.n	8003714 <HAL_I2C_Mem_Read+0x1d8>
 80037d4:	0802160c 	.word	0x0802160c
 80037d8:	40005800 	.word	0x40005800
 80037dc:	40005400 	.word	0x40005400
 80037e0:	40006000 	.word	0x40006000
 80037e4:	fc009800 	.word	0xfc009800
 80037e8:	81ff2400 	.word	0x81ff2400
 80037ec:	fc009c00 	.word	0xfc009c00
 80037f0:	01ff0000 	.word	0x01ff0000
 80037f4:	82002400 	.word	0x82002400
 80037f8:	40005c00 	.word	0x40005c00
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80037fc:	4632      	mov	r2, r6
 80037fe:	4629      	mov	r1, r5
 8003800:	4620      	mov	r0, r4
 8003802:	f7ff fb0d 	bl	8002e20 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003806:	b968      	cbnz	r0, 8003824 <HAL_I2C_Mem_Read+0x2e8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003808:	6823      	ldr	r3, [r4, #0]
 800380a:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 800380c:	4d06      	ldr	r5, [pc, #24]	; (8003828 <HAL_I2C_Mem_Read+0x2ec>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800380e:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8003810:	685a      	ldr	r2, [r3, #4]
 8003812:	402a      	ands	r2, r5
 8003814:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8003816:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800381a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800381e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8003822:	e746      	b.n	80036b2 <HAL_I2C_Mem_Read+0x176>
      return HAL_ERROR;
 8003824:	2001      	movs	r0, #1
 8003826:	e744      	b.n	80036b2 <HAL_I2C_Mem_Read+0x176>
 8003828:	fe00e800 	.word	0xfe00e800

0800382c <HAL_I2CEx_ConfigAnalogFilter>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800382c:	4b23      	ldr	r3, [pc, #140]	; (80038bc <HAL_I2CEx_ConfigAnalogFilter+0x90>)
 800382e:	6802      	ldr	r2, [r0, #0]
{
 8003830:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003832:	4d23      	ldr	r5, [pc, #140]	; (80038c0 <HAL_I2CEx_ConfigAnalogFilter+0x94>)
{
 8003834:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003836:	4e23      	ldr	r6, [pc, #140]	; (80038c4 <HAL_I2CEx_ConfigAnalogFilter+0x98>)
 8003838:	429a      	cmp	r2, r3
 800383a:	bf18      	it	ne
 800383c:	42aa      	cmpne	r2, r5
{
 800383e:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003840:	bf14      	ite	ne
 8003842:	2301      	movne	r3, #1
 8003844:	2300      	moveq	r3, #0
 8003846:	42b2      	cmp	r2, r6
 8003848:	bf0c      	ite	eq
 800384a:	2300      	moveq	r3, #0
 800384c:	f003 0301 	andne.w	r3, r3, #1
 8003850:	b113      	cbz	r3, 8003858 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
 8003852:	4b1d      	ldr	r3, [pc, #116]	; (80038c8 <HAL_I2CEx_ConfigAnalogFilter+0x9c>)
 8003854:	429a      	cmp	r2, r3
 8003856:	d12c      	bne.n	80038b2 <HAL_I2CEx_ConfigAnalogFilter+0x86>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 8003858:	f435 5380 	bics.w	r3, r5, #4096	; 0x1000
 800385c:	d124      	bne.n	80038a8 <HAL_I2CEx_ConfigAnalogFilter+0x7c>

  if (hi2c->State == HAL_I2C_STATE_READY)
 800385e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003862:	2b20      	cmp	r3, #32
 8003864:	b2de      	uxtb	r6, r3
 8003866:	d11d      	bne.n	80038a4 <HAL_I2CEx_ConfigAnalogFilter+0x78>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003868:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800386c:	2b01      	cmp	r3, #1
 800386e:	d019      	beq.n	80038a4 <HAL_I2CEx_ConfigAnalogFilter+0x78>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8003870:	6823      	ldr	r3, [r4, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8003872:	2224      	movs	r2, #36	; 0x24
 8003874:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 8003878:	681a      	ldr	r2, [r3, #0]
 800387a:	f022 0201 	bic.w	r2, r2, #1
 800387e:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8003880:	681a      	ldr	r2, [r3, #0]
 8003882:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003886:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8003888:	6819      	ldr	r1, [r3, #0]
 800388a:	430d      	orrs	r5, r1
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800388c:	2100      	movs	r1, #0
    hi2c->Instance->CR1 |= AnalogFilter;
 800388e:	601d      	str	r5, [r3, #0]

    return HAL_OK;
 8003890:	4608      	mov	r0, r1
    __HAL_I2C_ENABLE(hi2c);
 8003892:	681a      	ldr	r2, [r3, #0]
 8003894:	f042 0201 	orr.w	r2, r2, #1
 8003898:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 800389a:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800389e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 80038a2:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 80038a4:	2002      	movs	r0, #2
}
 80038a6:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 80038a8:	2160      	movs	r1, #96	; 0x60
 80038aa:	4808      	ldr	r0, [pc, #32]	; (80038cc <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
 80038ac:	f017 fafa 	bl	801aea4 <assert_failed>
 80038b0:	e7d5      	b.n	800385e <HAL_I2CEx_ConfigAnalogFilter+0x32>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80038b2:	215f      	movs	r1, #95	; 0x5f
 80038b4:	4805      	ldr	r0, [pc, #20]	; (80038cc <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
 80038b6:	f017 faf5 	bl	801aea4 <assert_failed>
 80038ba:	e7cd      	b.n	8003858 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
 80038bc:	40005400 	.word	0x40005400
 80038c0:	40005800 	.word	0x40005800
 80038c4:	40005c00 	.word	0x40005c00
 80038c8:	40006000 	.word	0x40006000
 80038cc:	08021644 	.word	0x08021644

080038d0 <HAL_I2CEx_ConfigDigitalFilter>:
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80038d0:	4b22      	ldr	r3, [pc, #136]	; (800395c <HAL_I2CEx_ConfigDigitalFilter+0x8c>)
 80038d2:	6802      	ldr	r2, [r0, #0]
{
 80038d4:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80038d6:	4d22      	ldr	r5, [pc, #136]	; (8003960 <HAL_I2CEx_ConfigDigitalFilter+0x90>)
{
 80038d8:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80038da:	4e22      	ldr	r6, [pc, #136]	; (8003964 <HAL_I2CEx_ConfigDigitalFilter+0x94>)
 80038dc:	429a      	cmp	r2, r3
 80038de:	bf18      	it	ne
 80038e0:	42aa      	cmpne	r2, r5
{
 80038e2:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80038e4:	bf14      	ite	ne
 80038e6:	2301      	movne	r3, #1
 80038e8:	2300      	moveq	r3, #0
 80038ea:	42b2      	cmp	r2, r6
 80038ec:	bf0c      	ite	eq
 80038ee:	2300      	moveq	r3, #0
 80038f0:	f003 0301 	andne.w	r3, r3, #1
 80038f4:	b113      	cbz	r3, 80038fc <HAL_I2CEx_ConfigDigitalFilter+0x2c>
 80038f6:	4b1c      	ldr	r3, [pc, #112]	; (8003968 <HAL_I2CEx_ConfigDigitalFilter+0x98>)
 80038f8:	429a      	cmp	r2, r3
 80038fa:	d12a      	bne.n	8003952 <HAL_I2CEx_ConfigDigitalFilter+0x82>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 80038fc:	2d0f      	cmp	r5, #15
 80038fe:	d823      	bhi.n	8003948 <HAL_I2CEx_ConfigDigitalFilter+0x78>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8003900:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003904:	2b20      	cmp	r3, #32
 8003906:	b2de      	uxtb	r6, r3
 8003908:	d11c      	bne.n	8003944 <HAL_I2CEx_ConfigDigitalFilter+0x74>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800390a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800390e:	2b01      	cmp	r3, #1
 8003910:	d018      	beq.n	8003944 <HAL_I2CEx_ConfigDigitalFilter+0x74>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8003912:	6823      	ldr	r3, [r4, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8003914:	2224      	movs	r2, #36	; 0x24
 8003916:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 800391a:	681a      	ldr	r2, [r3, #0]
 800391c:	f022 0201 	bic.w	r2, r2, #1
 8003920:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8003922:	6819      	ldr	r1, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8003924:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8003928:	ea41 2505 	orr.w	r5, r1, r5, lsl #8
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800392c:	2100      	movs	r1, #0
    hi2c->Instance->CR1 = tmpreg;
 800392e:	601d      	str	r5, [r3, #0]

    return HAL_OK;
 8003930:	4608      	mov	r0, r1
    __HAL_I2C_ENABLE(hi2c);
 8003932:	681a      	ldr	r2, [r3, #0]
 8003934:	f042 0201 	orr.w	r2, r2, #1
 8003938:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 800393a:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800393e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8003942:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8003944:	2002      	movs	r0, #2
}
 8003946:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8003948:	218e      	movs	r1, #142	; 0x8e
 800394a:	4808      	ldr	r0, [pc, #32]	; (800396c <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
 800394c:	f017 faaa 	bl	801aea4 <assert_failed>
 8003950:	e7d6      	b.n	8003900 <HAL_I2CEx_ConfigDigitalFilter+0x30>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8003952:	218d      	movs	r1, #141	; 0x8d
 8003954:	4805      	ldr	r0, [pc, #20]	; (800396c <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
 8003956:	f017 faa5 	bl	801aea4 <assert_failed>
 800395a:	e7cf      	b.n	80038fc <HAL_I2CEx_ConfigDigitalFilter+0x2c>
 800395c:	40005400 	.word	0x40005400
 8003960:	40005800 	.word	0x40005800
 8003964:	40005c00 	.word	0x40005c00
 8003968:	40006000 	.word	0x40006000
 800396c:	08021644 	.word	0x08021644

08003970 <LTDC_SetConfig>:
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003970:	01d2      	lsls	r2, r2, #7
{
 8003972:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003976:	6804      	ldr	r4, [r0, #0]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003978:	f102 0084 	add.w	r0, r2, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800397c:	f8d1 a004 	ldr.w	sl, [r1, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003980:	1823      	adds	r3, r4, r0
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003982:	68e6      	ldr	r6, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);

  /* Configure the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8003984:	f8d1 e00c 	ldr.w	lr, [r1, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003988:	685d      	ldr	r5, [r3, #4]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800398a:	f3c6 460b 	ubfx	r6, r6, #16, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800398e:	680f      	ldr	r7, [r1, #0]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003990:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003994:	eb06 0c0a 	add.w	ip, r6, sl
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);
 8003998:	f8d1 9018 	ldr.w	r9, [r1, #24]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800399c:	605d      	str	r5, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800399e:	1c7d      	adds	r5, r7, #1
 80039a0:	68e6      	ldr	r6, [r4, #12]
 80039a2:	f3c6 460b 	ubfx	r6, r6, #16, #12
 80039a6:	442e      	add	r6, r5
 80039a8:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
 80039ac:	605e      	str	r6, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80039ae:	68e5      	ldr	r5, [r4, #12]
 80039b0:	f3c5 050a 	ubfx	r5, r5, #0, #11
 80039b4:	eb05 060e 	add.w	r6, r5, lr
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80039b8:	689d      	ldr	r5, [r3, #8]
 80039ba:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
 80039be:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80039c0:	688d      	ldr	r5, [r1, #8]
 80039c2:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 80039c6:	3501      	adds	r5, #1
 80039c8:	f3cc 0c0a 	ubfx	ip, ip, #0, #11
 80039cc:	4465      	add	r5, ip
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80039ce:	f04f 0c00 	mov.w	ip, #0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80039d2:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80039d6:	690e      	ldr	r6, [r1, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80039d8:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80039da:	691d      	ldr	r5, [r3, #16]
 80039dc:	f025 0507 	bic.w	r5, r5, #7
 80039e0:	611d      	str	r5, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80039e2:	611e      	str	r6, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80039e4:	699d      	ldr	r5, [r3, #24]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 80039e6:	f891 e032 	ldrb.w	lr, [r1, #50]	; 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 80039ea:	f891 8031 	ldrb.w	r8, [r1, #49]	; 0x31
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80039ee:	f8c3 c018 	str.w	ip, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80039f2:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 80039f6:	ea45 6509 	orr.w	r5, r5, r9, lsl #24
 80039fa:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
 80039fe:	ea45 450e 	orr.w	r5, r5, lr, lsl #16
 8003a02:	619d      	str	r5, [r3, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 8003a04:	695d      	ldr	r5, [r3, #20]
 8003a06:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
 8003a0a:	615d      	str	r5, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8003a0c:	694d      	ldr	r5, [r1, #20]
 8003a0e:	615d      	str	r5, [r3, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8003a10:	4d1c      	ldr	r5, [pc, #112]	; (8003a84 <LTDC_SetConfig+0x114>)
 8003a12:	f8d3 e01c 	ldr.w	lr, [r3, #28]
 8003a16:	ea0e 0505 	and.w	r5, lr, r5
 8003a1a:	61dd      	str	r5, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8003a1c:	e9d1 5207 	ldrd	r5, r2, [r1, #28]
 8003a20:	4315      	orrs	r5, r2
 8003a22:	61dd      	str	r5, [r3, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8003a24:	6a9d      	ldr	r5, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8003a26:	6a4d      	ldr	r5, [r1, #36]	; 0x24
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8003a28:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8003a2c:	629d      	str	r5, [r3, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8003a2e:	b146      	cbz	r6, 8003a42 <LTDC_SetConfig+0xd2>
  {
    tmp = 4U;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8003a30:	2e01      	cmp	r6, #1
 8003a32:	d022      	beq.n	8003a7a <LTDC_SetConfig+0x10a>
  {
    tmp = 3U;
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8003a34:	1eb5      	subs	r5, r6, #2
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 8003a36:	2d02      	cmp	r5, #2
 8003a38:	d901      	bls.n	8003a3e <LTDC_SetConfig+0xce>
 8003a3a:	2e07      	cmp	r6, #7
 8003a3c:	d11f      	bne.n	8003a7e <LTDC_SetConfig+0x10e>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
  {
    tmp = 2U;
 8003a3e:	2502      	movs	r5, #2
 8003a40:	e000      	b.n	8003a44 <LTDC_SetConfig+0xd4>
    tmp = 4U;
 8003a42:	2504      	movs	r5, #4
    tmp = 1U;
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003a44:	ebaa 0207 	sub.w	r2, sl, r7
 8003a48:	6a8e      	ldr	r6, [r1, #40]	; 0x28
 8003a4a:	fb05 f202 	mul.w	r2, r5, r2
 8003a4e:	fb06 f505 	mul.w	r5, r6, r5
 8003a52:	3203      	adds	r2, #3
 8003a54:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8003a58:	6acd      	ldr	r5, [r1, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8003a5a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8003a5c:	f001 21e0 	and.w	r1, r1, #3758153728	; 0xe000e000
 8003a60:	62d9      	str	r1, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003a62:	62da      	str	r2, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8003a64:	4a08      	ldr	r2, [pc, #32]	; (8003a88 <LTDC_SetConfig+0x118>)
 8003a66:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003a68:	400a      	ands	r2, r1
 8003a6a:	631a      	str	r2, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8003a6c:	631d      	str	r5, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8003a6e:	5823      	ldr	r3, [r4, r0]
 8003a70:	f043 0301 	orr.w	r3, r3, #1
 8003a74:	5023      	str	r3, [r4, r0]
}
 8003a76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    tmp = 3U;
 8003a7a:	2503      	movs	r5, #3
 8003a7c:	e7e2      	b.n	8003a44 <LTDC_SetConfig+0xd4>
    tmp = 1U;
 8003a7e:	2501      	movs	r5, #1
 8003a80:	e7e0      	b.n	8003a44 <LTDC_SetConfig+0xd4>
 8003a82:	bf00      	nop
 8003a84:	fffff8f8 	.word	0xfffff8f8
 8003a88:	fffff800 	.word	0xfffff800

08003a8c <HAL_LTDC_Init>:
  if (hltdc == NULL)
 8003a8c:	2800      	cmp	r0, #0
 8003a8e:	f000 80e6 	beq.w	8003c5e <HAL_LTDC_Init+0x1d2>
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
 8003a92:	6802      	ldr	r2, [r0, #0]
{
 8003a94:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
 8003a96:	4b73      	ldr	r3, [pc, #460]	; (8003c64 <HAL_LTDC_Init+0x1d8>)
 8003a98:	4604      	mov	r4, r0
 8003a9a:	429a      	cmp	r2, r3
 8003a9c:	d003      	beq.n	8003aa6 <HAL_LTDC_Init+0x1a>
 8003a9e:	21ca      	movs	r1, #202	; 0xca
 8003aa0:	4871      	ldr	r0, [pc, #452]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003aa2:	f017 f9ff 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
 8003aa6:	6963      	ldr	r3, [r4, #20]
 8003aa8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003aac:	f080 80d2 	bcs.w	8003c54 <HAL_LTDC_Init+0x1c8>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
 8003ab0:	69a3      	ldr	r3, [r4, #24]
 8003ab2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003ab6:	f080 80c8 	bcs.w	8003c4a <HAL_LTDC_Init+0x1be>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
 8003aba:	69e3      	ldr	r3, [r4, #28]
 8003abc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003ac0:	f080 80be 	bcs.w	8003c40 <HAL_LTDC_Init+0x1b4>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
 8003ac4:	6a23      	ldr	r3, [r4, #32]
 8003ac6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003aca:	f080 80b4 	bcs.w	8003c36 <HAL_LTDC_Init+0x1aa>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
 8003ace:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003ad0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003ad4:	f080 80aa 	bcs.w	8003c2c <HAL_LTDC_Init+0x1a0>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
 8003ad8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003ada:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003ade:	f080 80a0 	bcs.w	8003c22 <HAL_LTDC_Init+0x196>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
 8003ae2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ae4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003ae8:	f080 8096 	bcs.w	8003c18 <HAL_LTDC_Init+0x18c>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
 8003aec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003aee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003af2:	f080 808c 	bcs.w	8003c0e <HAL_LTDC_Init+0x182>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
 8003af6:	6863      	ldr	r3, [r4, #4]
 8003af8:	f033 4300 	bics.w	r3, r3, #2147483648	; 0x80000000
 8003afc:	f040 8082 	bne.w	8003c04 <HAL_LTDC_Init+0x178>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
 8003b00:	68a3      	ldr	r3, [r4, #8]
 8003b02:	f033 4380 	bics.w	r3, r3, #1073741824	; 0x40000000
 8003b06:	d178      	bne.n	8003bfa <HAL_LTDC_Init+0x16e>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
 8003b08:	68e3      	ldr	r3, [r4, #12]
 8003b0a:	f033 5300 	bics.w	r3, r3, #536870912	; 0x20000000
 8003b0e:	d16f      	bne.n	8003bf0 <HAL_LTDC_Init+0x164>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
 8003b10:	6923      	ldr	r3, [r4, #16]
 8003b12:	f033 5380 	bics.w	r3, r3, #268435456	; 0x10000000
 8003b16:	d166      	bne.n	8003be6 <HAL_LTDC_Init+0x15a>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
 8003b18:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
 8003b1c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003b20:	2b00      	cmp	r3, #0
 8003b22:	d05a      	beq.n	8003bda <HAL_LTDC_Init+0x14e>
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b24:	68a0      	ldr	r0, [r4, #8]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003b26:	2102      	movs	r1, #2
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
 8003b28:	69e5      	ldr	r5, [r4, #28]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003b2a:	f884 10a1 	strb.w	r1, [r4, #161]	; 0xa1
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b2e:	e9d4 3200 	ldrd	r3, r2, [r4]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8003b32:	6999      	ldr	r1, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b34:	4302      	orrs	r2, r0
 8003b36:	68e0      	ldr	r0, [r4, #12]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8003b38:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b3c:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8003b3e:	6920      	ldr	r0, [r4, #16]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8003b40:	6199      	str	r1, [r3, #24]
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8003b42:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b44:	6999      	ldr	r1, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8003b46:	4849      	ldr	r0, [pc, #292]	; (8003c6c <HAL_LTDC_Init+0x1e0>)
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003b48:	430a      	orrs	r2, r1
 8003b4a:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8003b4c:	689a      	ldr	r2, [r3, #8]
 8003b4e:	4002      	ands	r2, r0
 8003b50:	609a      	str	r2, [r3, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
 8003b52:	6962      	ldr	r2, [r4, #20]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8003b54:	6899      	ldr	r1, [r3, #8]
 8003b56:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8003b5a:	69a2      	ldr	r2, [r4, #24]
 8003b5c:	4311      	orrs	r1, r2
 8003b5e:	6099      	str	r1, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8003b60:	68d9      	ldr	r1, [r3, #12]
 8003b62:	4001      	ands	r1, r0
 8003b64:	60d9      	str	r1, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8003b66:	68da      	ldr	r2, [r3, #12]
 8003b68:	6a21      	ldr	r1, [r4, #32]
 8003b6a:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
 8003b6e:	6a65      	ldr	r5, [r4, #36]	; 0x24
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8003b70:	430a      	orrs	r2, r1
 8003b72:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8003b74:	691a      	ldr	r2, [r3, #16]
 8003b76:	4002      	ands	r2, r0
 8003b78:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8003b7a:	6919      	ldr	r1, [r3, #16]
 8003b7c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003b7e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
  tmp = (hltdc->Init.TotalWidth << 16U);
 8003b82:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8003b84:	4311      	orrs	r1, r2
 8003b86:	6119      	str	r1, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8003b88:	6959      	ldr	r1, [r3, #20]
 8003b8a:	4008      	ands	r0, r1
 8003b8c:	6158      	str	r0, [r3, #20]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8003b8e:	695a      	ldr	r2, [r3, #20]
 8003b90:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003b92:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 8003b96:	430a      	orrs	r2, r1
 8003b98:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8003b9a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8003b9c:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8003ba0:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8003ba4:	f894 c036 	ldrb.w	ip, [r4, #54]	; 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8003ba8:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8003baa:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8003bac:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8003bb0:	430a      	orrs	r2, r1
 8003bb2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8003bb6:	2000      	movs	r0, #0
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8003bb8:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 8003bbc:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8003bbe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003bc0:	f042 0206 	orr.w	r2, r2, #6
 8003bc4:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
 8003bc6:	699a      	ldr	r2, [r3, #24]
 8003bc8:	f042 0201 	orr.w	r2, r2, #1
 8003bcc:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
 8003bce:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8003bd0:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 8003bd4:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
}
 8003bd8:	bd38      	pop	{r3, r4, r5, pc}
    HAL_LTDC_MspInit(hltdc);
 8003bda:	4620      	mov	r0, r4
    hltdc->Lock = HAL_UNLOCKED;
 8003bdc:	f884 20a0 	strb.w	r2, [r4, #160]	; 0xa0
    HAL_LTDC_MspInit(hltdc);
 8003be0:	f016 fcc2 	bl	801a568 <HAL_LTDC_MspInit>
 8003be4:	e79e      	b.n	8003b24 <HAL_LTDC_Init+0x98>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
 8003be6:	21d6      	movs	r1, #214	; 0xd6
 8003be8:	481f      	ldr	r0, [pc, #124]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003bea:	f017 f95b 	bl	801aea4 <assert_failed>
 8003bee:	e793      	b.n	8003b18 <HAL_LTDC_Init+0x8c>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
 8003bf0:	21d5      	movs	r1, #213	; 0xd5
 8003bf2:	481d      	ldr	r0, [pc, #116]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003bf4:	f017 f956 	bl	801aea4 <assert_failed>
 8003bf8:	e78a      	b.n	8003b10 <HAL_LTDC_Init+0x84>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
 8003bfa:	21d4      	movs	r1, #212	; 0xd4
 8003bfc:	481a      	ldr	r0, [pc, #104]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003bfe:	f017 f951 	bl	801aea4 <assert_failed>
 8003c02:	e781      	b.n	8003b08 <HAL_LTDC_Init+0x7c>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
 8003c04:	21d3      	movs	r1, #211	; 0xd3
 8003c06:	4818      	ldr	r0, [pc, #96]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c08:	f017 f94c 	bl	801aea4 <assert_failed>
 8003c0c:	e778      	b.n	8003b00 <HAL_LTDC_Init+0x74>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
 8003c0e:	21d2      	movs	r1, #210	; 0xd2
 8003c10:	4815      	ldr	r0, [pc, #84]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c12:	f017 f947 	bl	801aea4 <assert_failed>
 8003c16:	e76e      	b.n	8003af6 <HAL_LTDC_Init+0x6a>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
 8003c18:	21d1      	movs	r1, #209	; 0xd1
 8003c1a:	4813      	ldr	r0, [pc, #76]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c1c:	f017 f942 	bl	801aea4 <assert_failed>
 8003c20:	e764      	b.n	8003aec <HAL_LTDC_Init+0x60>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
 8003c22:	21d0      	movs	r1, #208	; 0xd0
 8003c24:	4810      	ldr	r0, [pc, #64]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c26:	f017 f93d 	bl	801aea4 <assert_failed>
 8003c2a:	e75a      	b.n	8003ae2 <HAL_LTDC_Init+0x56>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
 8003c2c:	21cf      	movs	r1, #207	; 0xcf
 8003c2e:	480e      	ldr	r0, [pc, #56]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c30:	f017 f938 	bl	801aea4 <assert_failed>
 8003c34:	e750      	b.n	8003ad8 <HAL_LTDC_Init+0x4c>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
 8003c36:	21ce      	movs	r1, #206	; 0xce
 8003c38:	480b      	ldr	r0, [pc, #44]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c3a:	f017 f933 	bl	801aea4 <assert_failed>
 8003c3e:	e746      	b.n	8003ace <HAL_LTDC_Init+0x42>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
 8003c40:	21cd      	movs	r1, #205	; 0xcd
 8003c42:	4809      	ldr	r0, [pc, #36]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c44:	f017 f92e 	bl	801aea4 <assert_failed>
 8003c48:	e73c      	b.n	8003ac4 <HAL_LTDC_Init+0x38>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
 8003c4a:	21cc      	movs	r1, #204	; 0xcc
 8003c4c:	4806      	ldr	r0, [pc, #24]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c4e:	f017 f929 	bl	801aea4 <assert_failed>
 8003c52:	e732      	b.n	8003aba <HAL_LTDC_Init+0x2e>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
 8003c54:	21cb      	movs	r1, #203	; 0xcb
 8003c56:	4804      	ldr	r0, [pc, #16]	; (8003c68 <HAL_LTDC_Init+0x1dc>)
 8003c58:	f017 f924 	bl	801aea4 <assert_failed>
 8003c5c:	e728      	b.n	8003ab0 <HAL_LTDC_Init+0x24>
    return HAL_ERROR;
 8003c5e:	2001      	movs	r0, #1
}
 8003c60:	4770      	bx	lr
 8003c62:	bf00      	nop
 8003c64:	40016800 	.word	0x40016800
 8003c68:	08021680 	.word	0x08021680
 8003c6c:	f000f800 	.word	0xf000f800

08003c70 <HAL_LTDC_ConfigLayer>:
  assert_param(IS_LTDC_LAYER(LayerIdx));
 8003c70:	2a01      	cmp	r2, #1
{
 8003c72:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c74:	4616      	mov	r6, r2
 8003c76:	4605      	mov	r5, r0
 8003c78:	460c      	mov	r4, r1
  assert_param(IS_LTDC_LAYER(LayerIdx));
 8003c7a:	d904      	bls.n	8003c86 <HAL_LTDC_ConfigLayer+0x16>
 8003c7c:	f240 21fe 	movw	r1, #766	; 0x2fe
 8003c80:	4865      	ldr	r0, [pc, #404]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003c82:	f017 f90f 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
 8003c86:	6823      	ldr	r3, [r4, #0]
 8003c88:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003c8c:	d25a      	bcs.n	8003d44 <HAL_LTDC_ConfigLayer+0xd4>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
 8003c8e:	6863      	ldr	r3, [r4, #4]
 8003c90:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003c94:	d25f      	bcs.n	8003d56 <HAL_LTDC_ConfigLayer+0xe6>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
 8003c96:	68a3      	ldr	r3, [r4, #8]
 8003c98:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003c9c:	d264      	bcs.n	8003d68 <HAL_LTDC_ConfigLayer+0xf8>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
 8003c9e:	68e3      	ldr	r3, [r4, #12]
 8003ca0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003ca4:	d269      	bcs.n	8003d7a <HAL_LTDC_ConfigLayer+0x10a>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
 8003ca6:	6923      	ldr	r3, [r4, #16]
 8003ca8:	2b07      	cmp	r3, #7
 8003caa:	d86e      	bhi.n	8003d8a <HAL_LTDC_ConfigLayer+0x11a>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
 8003cac:	6963      	ldr	r3, [r4, #20]
 8003cae:	2bff      	cmp	r3, #255	; 0xff
 8003cb0:	d873      	bhi.n	8003d9a <HAL_LTDC_ConfigLayer+0x12a>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
 8003cb2:	69a3      	ldr	r3, [r4, #24]
 8003cb4:	2bff      	cmp	r3, #255	; 0xff
 8003cb6:	d878      	bhi.n	8003daa <HAL_LTDC_ConfigLayer+0x13a>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
 8003cb8:	69e3      	ldr	r3, [r4, #28]
 8003cba:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003cbe:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003cc2:	d17d      	bne.n	8003dc0 <HAL_LTDC_ConfigLayer+0x150>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
 8003cc4:	6a23      	ldr	r3, [r4, #32]
 8003cc6:	f023 0302 	bic.w	r3, r3, #2
 8003cca:	2b05      	cmp	r3, #5
 8003ccc:	f040 8083 	bne.w	8003dd6 <HAL_LTDC_ConfigLayer+0x166>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
 8003cd0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003cd2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003cd6:	f080 8088 	bcs.w	8003dea <HAL_LTDC_ConfigLayer+0x17a>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
 8003cda:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003cdc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003ce0:	f080 808d 	bcs.w	8003dfe <HAL_LTDC_ConfigLayer+0x18e>
  __HAL_LOCK(hltdc);
 8003ce4:	f895 30a0 	ldrb.w	r3, [r5, #160]	; 0xa0
 8003ce8:	2b01      	cmp	r3, #1
 8003cea:	f000 8092 	beq.w	8003e12 <HAL_LTDC_ConfigLayer+0x1a2>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8003cee:	f04f 0c34 	mov.w	ip, #52	; 0x34
  __HAL_LOCK(hltdc);
 8003cf2:	2701      	movs	r7, #1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003cf4:	2302      	movs	r3, #2
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8003cf6:	46a6      	mov	lr, r4
 8003cf8:	fb0c 5c06 	mla	ip, ip, r6, r5
  __HAL_LOCK(hltdc);
 8003cfc:	f885 70a0 	strb.w	r7, [r5, #160]	; 0xa0
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003d00:	f885 30a1 	strb.w	r3, [r5, #161]	; 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8003d04:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 8003d08:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003d0c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8003d10:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003d14:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8003d18:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003d1c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8003d20:	f8de 3000 	ldr.w	r3, [lr]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8003d24:	4632      	mov	r2, r6
 8003d26:	4628      	mov	r0, r5
 8003d28:	4621      	mov	r1, r4
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8003d2a:	f8cc 3000 	str.w	r3, [ip]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8003d2e:	f7ff fe1f 	bl	8003970 <LTDC_SetConfig>
  __HAL_UNLOCK(hltdc);
 8003d32:	2300      	movs	r3, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8003d34:	682a      	ldr	r2, [r5, #0]
  return HAL_OK;
 8003d36:	4618      	mov	r0, r3
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8003d38:	6257      	str	r7, [r2, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
 8003d3a:	f885 70a1 	strb.w	r7, [r5, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8003d3e:	f885 30a0 	strb.w	r3, [r5, #160]	; 0xa0
}
 8003d42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
 8003d44:	f240 21ff 	movw	r1, #767	; 0x2ff
 8003d48:	4833      	ldr	r0, [pc, #204]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003d4a:	f017 f8ab 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
 8003d4e:	6863      	ldr	r3, [r4, #4]
 8003d50:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003d54:	d39f      	bcc.n	8003c96 <HAL_LTDC_ConfigLayer+0x26>
 8003d56:	f44f 7140 	mov.w	r1, #768	; 0x300
 8003d5a:	482f      	ldr	r0, [pc, #188]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003d5c:	f017 f8a2 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
 8003d60:	68a3      	ldr	r3, [r4, #8]
 8003d62:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003d66:	d39a      	bcc.n	8003c9e <HAL_LTDC_ConfigLayer+0x2e>
 8003d68:	f240 3101 	movw	r1, #769	; 0x301
 8003d6c:	482a      	ldr	r0, [pc, #168]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003d6e:	f017 f899 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
 8003d72:	68e3      	ldr	r3, [r4, #12]
 8003d74:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003d78:	d395      	bcc.n	8003ca6 <HAL_LTDC_ConfigLayer+0x36>
 8003d7a:	f240 3102 	movw	r1, #770	; 0x302
 8003d7e:	4826      	ldr	r0, [pc, #152]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003d80:	f017 f890 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
 8003d84:	6923      	ldr	r3, [r4, #16]
 8003d86:	2b07      	cmp	r3, #7
 8003d88:	d990      	bls.n	8003cac <HAL_LTDC_ConfigLayer+0x3c>
 8003d8a:	f240 3103 	movw	r1, #771	; 0x303
 8003d8e:	4822      	ldr	r0, [pc, #136]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003d90:	f017 f888 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
 8003d94:	6963      	ldr	r3, [r4, #20]
 8003d96:	2bff      	cmp	r3, #255	; 0xff
 8003d98:	d98b      	bls.n	8003cb2 <HAL_LTDC_ConfigLayer+0x42>
 8003d9a:	f44f 7141 	mov.w	r1, #772	; 0x304
 8003d9e:	481e      	ldr	r0, [pc, #120]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003da0:	f017 f880 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
 8003da4:	69a3      	ldr	r3, [r4, #24]
 8003da6:	2bff      	cmp	r3, #255	; 0xff
 8003da8:	d986      	bls.n	8003cb8 <HAL_LTDC_ConfigLayer+0x48>
 8003daa:	f240 3105 	movw	r1, #773	; 0x305
 8003dae:	481a      	ldr	r0, [pc, #104]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003db0:	f017 f878 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
 8003db4:	69e3      	ldr	r3, [r4, #28]
 8003db6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003dba:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003dbe:	d081      	beq.n	8003cc4 <HAL_LTDC_ConfigLayer+0x54>
 8003dc0:	f240 3106 	movw	r1, #774	; 0x306
 8003dc4:	4814      	ldr	r0, [pc, #80]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003dc6:	f017 f86d 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
 8003dca:	6a23      	ldr	r3, [r4, #32]
 8003dcc:	f023 0302 	bic.w	r3, r3, #2
 8003dd0:	2b05      	cmp	r3, #5
 8003dd2:	f43f af7d 	beq.w	8003cd0 <HAL_LTDC_ConfigLayer+0x60>
 8003dd6:	f240 3107 	movw	r1, #775	; 0x307
 8003dda:	480f      	ldr	r0, [pc, #60]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003ddc:	f017 f862 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
 8003de0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003de2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003de6:	f4ff af78 	bcc.w	8003cda <HAL_LTDC_ConfigLayer+0x6a>
 8003dea:	f44f 7142 	mov.w	r1, #776	; 0x308
 8003dee:	480a      	ldr	r0, [pc, #40]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003df0:	f017 f858 	bl	801aea4 <assert_failed>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
 8003df4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003df6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003dfa:	f4ff af73 	bcc.w	8003ce4 <HAL_LTDC_ConfigLayer+0x74>
 8003dfe:	f240 3109 	movw	r1, #777	; 0x309
 8003e02:	4805      	ldr	r0, [pc, #20]	; (8003e18 <HAL_LTDC_ConfigLayer+0x1a8>)
 8003e04:	f017 f84e 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hltdc);
 8003e08:	f895 30a0 	ldrb.w	r3, [r5, #160]	; 0xa0
 8003e0c:	2b01      	cmp	r3, #1
 8003e0e:	f47f af6e 	bne.w	8003cee <HAL_LTDC_ConfigLayer+0x7e>
 8003e12:	2002      	movs	r0, #2
}
 8003e14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003e16:	bf00      	nop
 8003e18:	08021680 	.word	0x08021680

08003e1c <HAL_LTDC_SetAddress>:
  assert_param(IS_LTDC_LAYER(LayerIdx));
 8003e1c:	2a01      	cmp	r2, #1
{
 8003e1e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003e22:	4614      	mov	r4, r2
 8003e24:	4605      	mov	r5, r0
 8003e26:	460e      	mov	r6, r1
  assert_param(IS_LTDC_LAYER(LayerIdx));
 8003e28:	d904      	bls.n	8003e34 <HAL_LTDC_SetAddress+0x18>
 8003e2a:	f240 5111 	movw	r1, #1297	; 0x511
 8003e2e:	485a      	ldr	r0, [pc, #360]	; (8003f98 <HAL_LTDC_SetAddress+0x17c>)
 8003e30:	f017 f838 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hltdc);
 8003e34:	f895 30a0 	ldrb.w	r3, [r5, #160]	; 0xa0
 8003e38:	2b01      	cmp	r3, #1
 8003e3a:	f000 80a7 	beq.w	8003f8c <HAL_LTDC_SetAddress+0x170>
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003e3e:	6828      	ldr	r0, [r5, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003e40:	2302      	movs	r3, #2
  pLayerCfg->FBStartAdress = Address;
 8003e42:	f04f 0c34 	mov.w	ip, #52	; 0x34
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003e46:	f885 30a1 	strb.w	r3, [r5, #161]	; 0xa1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003e4a:	f100 0e84 	add.w	lr, r0, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003e4e:	68c7      	ldr	r7, [r0, #12]
  pLayerCfg->FBStartAdress = Address;
 8003e50:	fb0c 5c04 	mla	ip, ip, r4, r5
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003e54:	eb0e 13c4 	add.w	r3, lr, r4, lsl #7
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003e58:	f3c7 470b 	ubfx	r7, r7, #16, #12
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8003e5c:	f8dc 9044 	ldr.w	r9, [ip, #68]	; 0x44
  pLayerCfg->FBStartAdress = Address;
 8003e60:	f8cc 605c 	str.w	r6, [ip, #92]	; 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8003e64:	f8dc 2040 	ldr.w	r2, [ip, #64]	; 0x40
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8003e68:	e9dc 1b0e 	ldrd	r1, fp, [ip, #56]	; 0x38
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003e6c:	eb07 080b 	add.w	r8, r7, fp
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003e70:	685f      	ldr	r7, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8003e72:	f101 0a01 	add.w	sl, r1, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003e76:	f407 4770 	and.w	r7, r7, #61440	; 0xf000
 8003e7a:	605f      	str	r7, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8003e7c:	68c7      	ldr	r7, [r0, #12]
 8003e7e:	f3c7 470b 	ubfx	r7, r7, #16, #12
 8003e82:	4457      	add	r7, sl
 8003e84:	ea47 4708 	orr.w	r7, r7, r8, lsl #16
 8003e88:	605f      	str	r7, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8003e8a:	68c7      	ldr	r7, [r0, #12]
 8003e8c:	f3c7 070a 	ubfx	r7, r7, #0, #11
 8003e90:	eb07 0809 	add.w	r8, r7, r9
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8003e94:	689f      	ldr	r7, [r3, #8]
 8003e96:	f407 4770 	and.w	r7, r7, #61440	; 0xf000
 8003e9a:	609f      	str	r7, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8003e9c:	68c7      	ldr	r7, [r0, #12]
 8003e9e:	f3c7 070a 	ubfx	r7, r7, #0, #11
 8003ea2:	4417      	add	r7, r2
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8003ea4:	f8dc 2050 	ldr.w	r2, [ip, #80]	; 0x50
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8003ea8:	3701      	adds	r7, #1
 8003eaa:	ea47 4708 	orr.w	r7, r7, r8, lsl #16
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 8003eae:	f89c 8069 	ldrb.w	r8, [ip, #105]	; 0x69
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8003eb2:	609f      	str	r7, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8003eb4:	f89c 7068 	ldrb.w	r7, [ip, #104]	; 0x68
 8003eb8:	ea47 6702 	orr.w	r7, r7, r2, lsl #24
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8003ebc:	f8dc 204c 	ldr.w	r2, [ip, #76]	; 0x4c
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8003ec0:	ea47 2708 	orr.w	r7, r7, r8, lsl #8
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8003ec4:	f8d3 8010 	ldr.w	r8, [r3, #16]
 8003ec8:	f028 0807 	bic.w	r8, r8, #7
 8003ecc:	f8c3 8010 	str.w	r8, [r3, #16]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 8003ed0:	f89c 806a 	ldrb.w	r8, [ip, #106]	; 0x6a
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8003ed4:	ea47 4708 	orr.w	r7, r7, r8, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8003ed8:	f8dc 8048 	ldr.w	r8, [ip, #72]	; 0x48
 8003edc:	f8c3 8010 	str.w	r8, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8003ee0:	f8d3 9018 	ldr.w	r9, [r3, #24]
 8003ee4:	f04f 0900 	mov.w	r9, #0
 8003ee8:	f8c3 9018 	str.w	r9, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8003eec:	619f      	str	r7, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 8003eee:	695f      	ldr	r7, [r3, #20]
 8003ef0:	f027 07ff 	bic.w	r7, r7, #255	; 0xff
 8003ef4:	615f      	str	r7, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8003ef6:	4f29      	ldr	r7, [pc, #164]	; (8003f9c <HAL_LTDC_SetAddress+0x180>)
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8003ef8:	615a      	str	r2, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8003efa:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 8003efe:	ea0a 0707 	and.w	r7, sl, r7
 8003f02:	61df      	str	r7, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8003f04:	e9dc 7c15 	ldrd	r7, ip, [ip, #84]	; 0x54
 8003f08:	ea47 070c 	orr.w	r7, r7, ip
 8003f0c:	61df      	str	r7, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8003f0e:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 8003f10:	f8c3 9028 	str.w	r9, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8003f14:	629e      	str	r6, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003f16:	01e6      	lsls	r6, r4, #7
  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8003f18:	f1b8 0f00 	cmp.w	r8, #0
 8003f1c:	d128      	bne.n	8003f70 <HAL_LTDC_SetAddress+0x154>
    tmp = 4U;
 8003f1e:	2704      	movs	r7, #4
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003f20:	2234      	movs	r2, #52	; 0x34
 8003f22:	ebab 0101 	sub.w	r1, fp, r1
 8003f26:	fb02 5404 	mla	r4, r2, r4, r5
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8003f2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003f2c:	fb07 f101 	mul.w	r1, r7, r1
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8003f30:	f002 22e0 	and.w	r2, r2, #3758153728	; 0xe000e000
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003f34:	3103      	adds	r1, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8003f36:	62da      	str	r2, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003f38:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8003f3a:	fb07 f202 	mul.w	r2, r7, r2
 8003f3e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8003f42:	4a17      	ldr	r2, [pc, #92]	; (8003fa0 <HAL_LTDC_SetAddress+0x184>)
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8003f44:	62d9      	str	r1, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8003f46:	6e61      	ldr	r1, [r4, #100]	; 0x64
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8003f48:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8003f4a:	4022      	ands	r2, r4
 8003f4c:	631a      	str	r2, [r3, #48]	; 0x30
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8003f4e:	2201      	movs	r2, #1
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8003f50:	6319      	str	r1, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8003f52:	f85e 3006 	ldr.w	r3, [lr, r6]
 8003f56:	f043 0301 	orr.w	r3, r3, #1
 8003f5a:	f84e 3006 	str.w	r3, [lr, r6]
  __HAL_UNLOCK(hltdc);
 8003f5e:	2300      	movs	r3, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8003f60:	6242      	str	r2, [r0, #36]	; 0x24
  return HAL_OK;
 8003f62:	4618      	mov	r0, r3
  hltdc->State = HAL_LTDC_STATE_READY;
 8003f64:	f885 20a1 	strb.w	r2, [r5, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8003f68:	f885 30a0 	strb.w	r3, [r5, #160]	; 0xa0
}
 8003f6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8003f70:	f1b8 0f01 	cmp.w	r8, #1
 8003f74:	d00d      	beq.n	8003f92 <HAL_LTDC_SetAddress+0x176>
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8003f76:	f1a8 0702 	sub.w	r7, r8, #2
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 8003f7a:	2f02      	cmp	r7, #2
 8003f7c:	d904      	bls.n	8003f88 <HAL_LTDC_SetAddress+0x16c>
 8003f7e:	f1b8 0f07 	cmp.w	r8, #7
 8003f82:	d001      	beq.n	8003f88 <HAL_LTDC_SetAddress+0x16c>
    tmp = 1U;
 8003f84:	2701      	movs	r7, #1
 8003f86:	e7cb      	b.n	8003f20 <HAL_LTDC_SetAddress+0x104>
    tmp = 2U;
 8003f88:	2702      	movs	r7, #2
 8003f8a:	e7c9      	b.n	8003f20 <HAL_LTDC_SetAddress+0x104>
  __HAL_LOCK(hltdc);
 8003f8c:	2002      	movs	r0, #2
}
 8003f8e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tmp = 3U;
 8003f92:	2703      	movs	r7, #3
 8003f94:	e7c4      	b.n	8003f20 <HAL_LTDC_SetAddress+0x104>
 8003f96:	bf00      	nop
 8003f98:	08021680 	.word	0x08021680
 8003f9c:	fffff8f8 	.word	0xfffff8f8
 8003fa0:	fffff800 	.word	0xfffff800

08003fa4 <HAL_LTDC_Reload>:
{
 8003fa4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_LTDC_RELOAD(ReloadType));
 8003fa6:	1e4b      	subs	r3, r1, #1
{
 8003fa8:	460d      	mov	r5, r1
 8003faa:	4604      	mov	r4, r0
  assert_param(IS_LTDC_RELOAD(ReloadType));
 8003fac:	2b01      	cmp	r3, #1
 8003fae:	d904      	bls.n	8003fba <HAL_LTDC_Reload+0x16>
 8003fb0:	f240 51aa 	movw	r1, #1450	; 0x5aa
 8003fb4:	480d      	ldr	r0, [pc, #52]	; (8003fec <HAL_LTDC_Reload+0x48>)
 8003fb6:	f016 ff75 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hltdc);
 8003fba:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
 8003fbe:	2b01      	cmp	r3, #1
 8003fc0:	d011      	beq.n	8003fe6 <HAL_LTDC_Reload+0x42>
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
 8003fc2:	6823      	ldr	r3, [r4, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003fc4:	2202      	movs	r2, #2
  __HAL_UNLOCK(hltdc);
 8003fc6:	f04f 0c00 	mov.w	ip, #0
  hltdc->State = HAL_LTDC_STATE_READY;
 8003fca:	2101      	movs	r1, #1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003fcc:	f884 20a1 	strb.w	r2, [r4, #161]	; 0xa1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
 8003fd0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  return HAL_OK;
 8003fd2:	4660      	mov	r0, ip
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
 8003fd4:	f042 0208 	orr.w	r2, r2, #8
 8003fd8:	635a      	str	r2, [r3, #52]	; 0x34
  hltdc->Instance->SRCR = ReloadType;
 8003fda:	625d      	str	r5, [r3, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
 8003fdc:	f884 10a1 	strb.w	r1, [r4, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8003fe0:	f884 c0a0 	strb.w	ip, [r4, #160]	; 0xa0
}
 8003fe4:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hltdc);
 8003fe6:	2002      	movs	r0, #2
}
 8003fe8:	bd38      	pop	{r3, r4, r5, pc}
 8003fea:	bf00      	nop
 8003fec:	08021680 	.word	0x08021680

08003ff0 <HAL_LTDC_SetAlpha_NoReload>:
  assert_param(IS_LTDC_ALPHA(Alpha));
 8003ff0:	29ff      	cmp	r1, #255	; 0xff
{
 8003ff2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003ff6:	460e      	mov	r6, r1
 8003ff8:	4604      	mov	r4, r0
 8003ffa:	4615      	mov	r5, r2
  assert_param(IS_LTDC_ALPHA(Alpha));
 8003ffc:	f200 80b5 	bhi.w	800416a <HAL_LTDC_SetAlpha_NoReload+0x17a>
  assert_param(IS_LTDC_LAYER(LayerIdx));
 8004000:	2d01      	cmp	r5, #1
 8004002:	d904      	bls.n	800400e <HAL_LTDC_SetAlpha_NoReload+0x1e>
 8004004:	f240 6197 	movw	r1, #1687	; 0x697
 8004008:	485d      	ldr	r0, [pc, #372]	; (8004180 <HAL_LTDC_SetAlpha_NoReload+0x190>)
 800400a:	f016 ff4b 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hltdc);
 800400e:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
 8004012:	2b01      	cmp	r3, #1
 8004014:	f000 80af 	beq.w	8004176 <HAL_LTDC_SetAlpha_NoReload+0x186>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8004018:	2302      	movs	r3, #2
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800401a:	6827      	ldr	r7, [r4, #0]
  pLayerCfg->Alpha = Alpha;
 800401c:	f04f 0c34 	mov.w	ip, #52	; 0x34
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8004020:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004024:	eb07 13c5 	add.w	r3, r7, r5, lsl #7
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8004028:	68f8      	ldr	r0, [r7, #12]
  pLayerCfg->Alpha = Alpha;
 800402a:	fb0c 4c05 	mla	ip, ip, r5, r4
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800402e:	f3c0 400b 	ubfx	r0, r0, #16, #12
  pLayerCfg->Alpha = Alpha;
 8004032:	f8cc 604c 	str.w	r6, [ip, #76]	; 0x4c
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8004036:	e9dc 120e 	ldrd	r1, r2, [ip, #56]	; 0x38
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800403a:	eb00 0e02 	add.w	lr, r0, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800403e:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8004042:	f101 0801 	add.w	r8, r1, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004046:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 800404a:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800404e:	68f8      	ldr	r0, [r7, #12]
 8004050:	f3c0 400b 	ubfx	r0, r0, #16, #12
 8004054:	4440      	add	r0, r8
 8004056:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 800405a:	f8dc e044 	ldr.w	lr, [ip, #68]	; 0x44
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 800405e:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004062:	68f8      	ldr	r0, [r7, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8004064:	f8d3 808c 	ldr.w	r8, [r3, #140]	; 0x8c
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004068:	f3c0 000a 	ubfx	r0, r0, #0, #11
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 800406c:	f408 4870 	and.w	r8, r8, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004070:	4486      	add	lr, r0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8004072:	f8dc 0040 	ldr.w	r0, [ip, #64]	; 0x40
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8004076:	f8c3 808c 	str.w	r8, [r3, #140]	; 0x8c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 800407a:	68ff      	ldr	r7, [r7, #12]
 800407c:	3001      	adds	r0, #1
 800407e:	f3c7 070a 	ubfx	r7, r7, #0, #11
 8004082:	4438      	add	r0, r7
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8004084:	f8dc 7050 	ldr.w	r7, [ip, #80]	; 0x50
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8004088:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 800408c:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8004090:	f89c 0068 	ldrb.w	r0, [ip, #104]	; 0x68
 8004094:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 8004098:	f89c 7069 	ldrb.w	r7, [ip, #105]	; 0x69
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 800409c:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80040a0:	f8d3 7094 	ldr.w	r7, [r3, #148]	; 0x94
 80040a4:	f027 0707 	bic.w	r7, r7, #7
 80040a8:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 80040ac:	f89c 706a 	ldrb.w	r7, [ip, #106]	; 0x6a
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80040b0:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80040b4:	f8dc 7048 	ldr.w	r7, [ip, #72]	; 0x48
 80040b8:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80040bc:	f8d3 e09c 	ldr.w	lr, [r3, #156]	; 0x9c
 80040c0:	f04f 0e00 	mov.w	lr, #0
 80040c4:	f8c3 e09c 	str.w	lr, [r3, #156]	; 0x9c
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80040c8:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 80040cc:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
 80040d0:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
 80040d4:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80040d8:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80040dc:	4829      	ldr	r0, [pc, #164]	; (8004184 <HAL_LTDC_SetAlpha_NoReload+0x194>)
 80040de:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
 80040e2:	4030      	ands	r0, r6
 80040e4:	f8c3 00a0 	str.w	r0, [r3, #160]	; 0xa0
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80040e8:	e9dc 0615 	ldrd	r0, r6, [ip, #84]	; 0x54
 80040ec:	4330      	orrs	r0, r6
 80040ee:	f8c3 00a0 	str.w	r0, [r3, #160]	; 0xa0
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80040f2:	f8dc 005c 	ldr.w	r0, [ip, #92]	; 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80040f6:	f8d3 60ac 	ldr.w	r6, [r3, #172]	; 0xac
 80040fa:	f8c3 e0ac 	str.w	lr, [r3, #172]	; 0xac
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80040fe:	f8c3 00ac 	str.w	r0, [r3, #172]	; 0xac
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8004102:	f103 0084 	add.w	r0, r3, #132	; 0x84
  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8004106:	bb2f      	cbnz	r7, 8004154 <HAL_LTDC_SetAlpha_NoReload+0x164>
    tmp = 4U;
 8004108:	2704      	movs	r7, #4
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 800410a:	1a51      	subs	r1, r2, r1
 800410c:	2234      	movs	r2, #52	; 0x34
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 800410e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004110:	fb02 4505 	mla	r5, r2, r5, r4
 8004114:	fb07 f101 	mul.w	r1, r7, r1
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8004118:	f006 26e0 	and.w	r6, r6, #3758153728	; 0xe000e000
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 800411c:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 800411e:	3103      	adds	r1, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8004120:	62c6      	str	r6, [r0, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004122:	fb07 f202 	mul.w	r2, r7, r2
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8004126:	6e6d      	ldr	r5, [r5, #100]	; 0x64
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8004128:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 800412c:	4a16      	ldr	r2, [pc, #88]	; (8004188 <HAL_LTDC_SetAlpha_NoReload+0x198>)
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 800412e:	62c1      	str	r1, [r0, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8004130:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8004132:	400a      	ands	r2, r1
  __HAL_UNLOCK(hltdc);
 8004134:	2100      	movs	r1, #0
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8004136:	6302      	str	r2, [r0, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8004138:	6305      	str	r5, [r0, #48]	; 0x30
  hltdc->State = HAL_LTDC_STATE_READY;
 800413a:	2001      	movs	r0, #1
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 800413c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8004140:	4302      	orrs	r2, r0
 8004142:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hltdc->State = HAL_LTDC_STATE_READY;
 8004146:	f884 00a1 	strb.w	r0, [r4, #161]	; 0xa1
  return HAL_OK;
 800414a:	4608      	mov	r0, r1
  __HAL_UNLOCK(hltdc);
 800414c:	f884 10a0 	strb.w	r1, [r4, #160]	; 0xa0
}
 8004150:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8004154:	2f01      	cmp	r7, #1
 8004156:	d011      	beq.n	800417c <HAL_LTDC_SetAlpha_NoReload+0x18c>
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8004158:	1ebe      	subs	r6, r7, #2
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 800415a:	2e02      	cmp	r6, #2
 800415c:	d903      	bls.n	8004166 <HAL_LTDC_SetAlpha_NoReload+0x176>
 800415e:	2f07      	cmp	r7, #7
 8004160:	d001      	beq.n	8004166 <HAL_LTDC_SetAlpha_NoReload+0x176>
    tmp = 1U;
 8004162:	2701      	movs	r7, #1
 8004164:	e7d1      	b.n	800410a <HAL_LTDC_SetAlpha_NoReload+0x11a>
    tmp = 2U;
 8004166:	2702      	movs	r7, #2
 8004168:	e7cf      	b.n	800410a <HAL_LTDC_SetAlpha_NoReload+0x11a>
  assert_param(IS_LTDC_ALPHA(Alpha));
 800416a:	f240 6196 	movw	r1, #1686	; 0x696
 800416e:	4804      	ldr	r0, [pc, #16]	; (8004180 <HAL_LTDC_SetAlpha_NoReload+0x190>)
 8004170:	f016 fe98 	bl	801aea4 <assert_failed>
 8004174:	e744      	b.n	8004000 <HAL_LTDC_SetAlpha_NoReload+0x10>
  __HAL_LOCK(hltdc);
 8004176:	2002      	movs	r0, #2
}
 8004178:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmp = 3U;
 800417c:	2703      	movs	r7, #3
 800417e:	e7c4      	b.n	800410a <HAL_LTDC_SetAlpha_NoReload+0x11a>
 8004180:	08021680 	.word	0x08021680
 8004184:	fffff8f8 	.word	0xfffff8f8
 8004188:	fffff800 	.word	0xfffff800

0800418c <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 800418c:	4b1a      	ldr	r3, [pc, #104]	; (80041f8 <HAL_PWREx_EnableOverDrive+0x6c>)
 800418e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004190:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
{
 8004194:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8004196:	641a      	str	r2, [r3, #64]	; 0x40
{
 8004198:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 800419a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800419c:	4c17      	ldr	r4, [pc, #92]	; (80041fc <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_RCC_PWR_CLK_ENABLE();
 800419e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80041a2:	9301      	str	r3, [sp, #4]
 80041a4:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 80041a6:	6823      	ldr	r3, [r4, #0]
 80041a8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80041ac:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 80041ae:	f7fc ff5f 	bl	8001070 <HAL_GetTick>
 80041b2:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80041b4:	e005      	b.n	80041c2 <HAL_PWREx_EnableOverDrive+0x36>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80041b6:	f7fc ff5b 	bl	8001070 <HAL_GetTick>
 80041ba:	1b40      	subs	r0, r0, r5
 80041bc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80041c0:	d817      	bhi.n	80041f2 <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80041c2:	6863      	ldr	r3, [r4, #4]
 80041c4:	03da      	lsls	r2, r3, #15
 80041c6:	d5f6      	bpl.n	80041b6 <HAL_PWREx_EnableOverDrive+0x2a>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80041c8:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80041ca:	4d0c      	ldr	r5, [pc, #48]	; (80041fc <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80041cc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80041d0:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 80041d2:	f7fc ff4d 	bl	8001070 <HAL_GetTick>
 80041d6:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80041d8:	e005      	b.n	80041e6 <HAL_PWREx_EnableOverDrive+0x5a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80041da:	f7fc ff49 	bl	8001070 <HAL_GetTick>
 80041de:	1b00      	subs	r0, r0, r4
 80041e0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80041e4:	d805      	bhi.n	80041f2 <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80041e6:	686b      	ldr	r3, [r5, #4]
 80041e8:	039b      	lsls	r3, r3, #14
 80041ea:	d5f6      	bpl.n	80041da <HAL_PWREx_EnableOverDrive+0x4e>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 80041ec:	2000      	movs	r0, #0
}
 80041ee:	b003      	add	sp, #12
 80041f0:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 80041f2:	2003      	movs	r0, #3
}
 80041f4:	b003      	add	sp, #12
 80041f6:	bd30      	pop	{r4, r5, pc}
 80041f8:	40023800 	.word	0x40023800
 80041fc:	40007000 	.word	0x40007000

08004200 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8004200:	2800      	cmp	r0, #0
 8004202:	f000 822b 	beq.w	800465c <HAL_RCC_OscConfig+0x45c>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8004206:	6803      	ldr	r3, [r0, #0]
 8004208:	2b0f      	cmp	r3, #15
{
 800420a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800420e:	4604      	mov	r4, r0
 8004210:	b082      	sub	sp, #8
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8004212:	f200 811c 	bhi.w	800444e <HAL_RCC_OscConfig+0x24e>

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004216:	07dd      	lsls	r5, r3, #31
 8004218:	d534      	bpl.n	8004284 <HAL_RCC_OscConfig+0x84>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 800421a:	6863      	ldr	r3, [r4, #4]
 800421c:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 8004220:	d003      	beq.n	800422a <HAL_RCC_OscConfig+0x2a>
 8004222:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8004226:	f040 816e 	bne.w	8004506 <HAL_RCC_OscConfig+0x306>
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800422a:	4aa4      	ldr	r2, [pc, #656]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 800422c:	6893      	ldr	r3, [r2, #8]
 800422e:	f003 030c 	and.w	r3, r3, #12
 8004232:	2b04      	cmp	r3, #4
 8004234:	d01d      	beq.n	8004272 <HAL_RCC_OscConfig+0x72>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004236:	6893      	ldr	r3, [r2, #8]
 8004238:	f003 030c 	and.w	r3, r3, #12
 800423c:	2b08      	cmp	r3, #8
 800423e:	d015      	beq.n	800426c <HAL_RCC_OscConfig+0x6c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004240:	6863      	ldr	r3, [r4, #4]
 8004242:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004246:	f000 8164 	beq.w	8004512 <HAL_RCC_OscConfig+0x312>
 800424a:	2b00      	cmp	r3, #0
 800424c:	f000 8195 	beq.w	800457a <HAL_RCC_OscConfig+0x37a>
 8004250:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8004254:	4b99      	ldr	r3, [pc, #612]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 8004256:	681a      	ldr	r2, [r3, #0]
 8004258:	f000 8208 	beq.w	800466c <HAL_RCC_OscConfig+0x46c>
 800425c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004260:	601a      	str	r2, [r3, #0]
 8004262:	681a      	ldr	r2, [r3, #0]
 8004264:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004268:	601a      	str	r2, [r3, #0]
 800426a:	e157      	b.n	800451c <HAL_RCC_OscConfig+0x31c>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800426c:	6853      	ldr	r3, [r2, #4]
 800426e:	0258      	lsls	r0, r3, #9
 8004270:	d5e6      	bpl.n	8004240 <HAL_RCC_OscConfig+0x40>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004272:	4b92      	ldr	r3, [pc, #584]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 8004274:	681b      	ldr	r3, [r3, #0]
 8004276:	0399      	lsls	r1, r3, #14
 8004278:	d503      	bpl.n	8004282 <HAL_RCC_OscConfig+0x82>
 800427a:	6863      	ldr	r3, [r4, #4]
 800427c:	2b00      	cmp	r3, #0
 800427e:	f000 80f8 	beq.w	8004472 <HAL_RCC_OscConfig+0x272>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004282:	6823      	ldr	r3, [r4, #0]
 8004284:	079f      	lsls	r7, r3, #30
 8004286:	d531      	bpl.n	80042ec <HAL_RCC_OscConfig+0xec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8004288:	68e3      	ldr	r3, [r4, #12]
 800428a:	2b01      	cmp	r3, #1
 800428c:	f200 80f5 	bhi.w	800447a <HAL_RCC_OscConfig+0x27a>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8004290:	6923      	ldr	r3, [r4, #16]
 8004292:	2b1f      	cmp	r3, #31
 8004294:	f200 80fa 	bhi.w	800448c <HAL_RCC_OscConfig+0x28c>

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8004298:	4b88      	ldr	r3, [pc, #544]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 800429a:	689a      	ldr	r2, [r3, #8]
 800429c:	f012 0f0c 	tst.w	r2, #12
 80042a0:	f000 80e0 	beq.w	8004464 <HAL_RCC_OscConfig+0x264>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80042a4:	689a      	ldr	r2, [r3, #8]
 80042a6:	f002 020c 	and.w	r2, r2, #12
 80042aa:	2a08      	cmp	r2, #8
 80042ac:	f000 80d6 	beq.w	800445c <HAL_RCC_OscConfig+0x25c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80042b0:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80042b2:	4d82      	ldr	r5, [pc, #520]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80042b4:	2b00      	cmp	r3, #0
 80042b6:	f000 8196 	beq.w	80045e6 <HAL_RCC_OscConfig+0x3e6>
        __HAL_RCC_HSI_ENABLE();
 80042ba:	682b      	ldr	r3, [r5, #0]
 80042bc:	f043 0301 	orr.w	r3, r3, #1
 80042c0:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80042c2:	f7fc fed5 	bl	8001070 <HAL_GetTick>
 80042c6:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80042c8:	e005      	b.n	80042d6 <HAL_RCC_OscConfig+0xd6>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80042ca:	f7fc fed1 	bl	8001070 <HAL_GetTick>
 80042ce:	1b80      	subs	r0, r0, r6
 80042d0:	2802      	cmp	r0, #2
 80042d2:	f200 814e 	bhi.w	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80042d6:	682b      	ldr	r3, [r5, #0]
 80042d8:	0798      	lsls	r0, r3, #30
 80042da:	d5f6      	bpl.n	80042ca <HAL_RCC_OscConfig+0xca>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80042dc:	682b      	ldr	r3, [r5, #0]
 80042de:	6922      	ldr	r2, [r4, #16]
 80042e0:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80042e4:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80042e8:	602b      	str	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80042ea:	6823      	ldr	r3, [r4, #0]
 80042ec:	071a      	lsls	r2, r3, #28
 80042ee:	d42a      	bmi.n	8004346 <HAL_RCC_OscConfig+0x146>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80042f0:	075e      	lsls	r6, r3, #29
 80042f2:	d544      	bpl.n	800437e <HAL_RCC_OscConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 80042f4:	68a3      	ldr	r3, [r4, #8]
 80042f6:	2b01      	cmp	r3, #1
 80042f8:	d906      	bls.n	8004308 <HAL_RCC_OscConfig+0x108>
 80042fa:	2b05      	cmp	r3, #5
 80042fc:	d004      	beq.n	8004308 <HAL_RCC_OscConfig+0x108>
 80042fe:	f240 2107 	movw	r1, #519	; 0x207
 8004302:	486f      	ldr	r0, [pc, #444]	; (80044c0 <HAL_RCC_OscConfig+0x2c0>)
 8004304:	f016 fdce 	bl	801aea4 <assert_failed>

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004308:	4b6c      	ldr	r3, [pc, #432]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 800430a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800430c:	00d5      	lsls	r5, r2, #3
 800430e:	f140 80e5 	bpl.w	80044dc <HAL_RCC_OscConfig+0x2dc>
  FlagStatus pwrclkchanged = RESET;
 8004312:	2500      	movs	r5, #0
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8004314:	4e6b      	ldr	r6, [pc, #428]	; (80044c4 <HAL_RCC_OscConfig+0x2c4>)
 8004316:	6833      	ldr	r3, [r6, #0]
 8004318:	05d8      	lsls	r0, r3, #23
 800431a:	f140 811a 	bpl.w	8004552 <HAL_RCC_OscConfig+0x352>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800431e:	68a3      	ldr	r3, [r4, #8]
 8004320:	2b01      	cmp	r3, #1
 8004322:	f000 8172 	beq.w	800460a <HAL_RCC_OscConfig+0x40a>
 8004326:	2b00      	cmp	r3, #0
 8004328:	f000 813d 	beq.w	80045a6 <HAL_RCC_OscConfig+0x3a6>
 800432c:	2b05      	cmp	r3, #5
 800432e:	4b63      	ldr	r3, [pc, #396]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 8004330:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8004332:	f000 81b5 	beq.w	80046a0 <HAL_RCC_OscConfig+0x4a0>
 8004336:	f022 0201 	bic.w	r2, r2, #1
 800433a:	671a      	str	r2, [r3, #112]	; 0x70
 800433c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800433e:	f022 0204 	bic.w	r2, r2, #4
 8004342:	671a      	str	r2, [r3, #112]	; 0x70
 8004344:	e166      	b.n	8004614 <HAL_RCC_OscConfig+0x414>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8004346:	6963      	ldr	r3, [r4, #20]
 8004348:	2b01      	cmp	r3, #1
 800434a:	f200 80bd 	bhi.w	80044c8 <HAL_RCC_OscConfig+0x2c8>
      __HAL_RCC_LSI_ENABLE();
 800434e:	4d5b      	ldr	r5, [pc, #364]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8004350:	2b00      	cmp	r3, #0
 8004352:	f000 80a1 	beq.w	8004498 <HAL_RCC_OscConfig+0x298>
      __HAL_RCC_LSI_ENABLE();
 8004356:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8004358:	f043 0301 	orr.w	r3, r3, #1
 800435c:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 800435e:	f7fc fe87 	bl	8001070 <HAL_GetTick>
 8004362:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004364:	e005      	b.n	8004372 <HAL_RCC_OscConfig+0x172>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8004366:	f7fc fe83 	bl	8001070 <HAL_GetTick>
 800436a:	1b80      	subs	r0, r0, r6
 800436c:	2802      	cmp	r0, #2
 800436e:	f200 8100 	bhi.w	8004572 <HAL_RCC_OscConfig+0x372>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004372:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8004374:	079b      	lsls	r3, r3, #30
 8004376:	d5f6      	bpl.n	8004366 <HAL_RCC_OscConfig+0x166>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004378:	6823      	ldr	r3, [r4, #0]
 800437a:	075e      	lsls	r6, r3, #29
 800437c:	d4ba      	bmi.n	80042f4 <HAL_RCC_OscConfig+0xf4>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 800437e:	69a3      	ldr	r3, [r4, #24]
 8004380:	2b02      	cmp	r3, #2
 8004382:	f200 80b6 	bhi.w	80044f2 <HAL_RCC_OscConfig+0x2f2>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8004386:	2b00      	cmp	r3, #0
 8004388:	d05d      	beq.n	8004446 <HAL_RCC_OscConfig+0x246>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800438a:	4d4c      	ldr	r5, [pc, #304]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 800438c:	68aa      	ldr	r2, [r5, #8]
 800438e:	f002 020c 	and.w	r2, r2, #12
 8004392:	2a08      	cmp	r2, #8
 8004394:	d06d      	beq.n	8004472 <HAL_RCC_OscConfig+0x272>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004396:	2b02      	cmp	r3, #2
 8004398:	f040 814f 	bne.w	800463a <HAL_RCC_OscConfig+0x43a>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800439c:	69e3      	ldr	r3, [r4, #28]
 800439e:	f433 0380 	bics.w	r3, r3, #4194304	; 0x400000
 80043a2:	f040 816b 	bne.w	800467c <HAL_RCC_OscConfig+0x47c>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 80043a6:	6a23      	ldr	r3, [r4, #32]
 80043a8:	3b02      	subs	r3, #2
 80043aa:	2b3d      	cmp	r3, #61	; 0x3d
 80043ac:	f200 8172 	bhi.w	8004694 <HAL_RCC_OscConfig+0x494>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 80043b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80043b2:	3b32      	subs	r3, #50	; 0x32
 80043b4:	f5b3 7fbf 	cmp.w	r3, #382	; 0x17e
 80043b8:	f200 8166 	bhi.w	8004688 <HAL_RCC_OscConfig+0x488>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 80043bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80043be:	2b08      	cmp	r3, #8
 80043c0:	f200 814e 	bhi.w	8004660 <HAL_RCC_OscConfig+0x460>
 80043c4:	f44f 72aa 	mov.w	r2, #340	; 0x154
 80043c8:	fa22 f303 	lsr.w	r3, r2, r3
 80043cc:	07d8      	lsls	r0, r3, #31
 80043ce:	f140 8147 	bpl.w	8004660 <HAL_RCC_OscConfig+0x460>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 80043d2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80043d4:	3b02      	subs	r3, #2
 80043d6:	2b0d      	cmp	r3, #13
 80043d8:	f200 816a 	bhi.w	80046b0 <HAL_RCC_OscConfig+0x4b0>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80043dc:	4d37      	ldr	r5, [pc, #220]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 80043de:	682b      	ldr	r3, [r5, #0]
 80043e0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80043e4:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80043e6:	f7fc fe43 	bl	8001070 <HAL_GetTick>
 80043ea:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80043ec:	e005      	b.n	80043fa <HAL_RCC_OscConfig+0x1fa>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80043ee:	f7fc fe3f 	bl	8001070 <HAL_GetTick>
 80043f2:	1b80      	subs	r0, r0, r6
 80043f4:	2802      	cmp	r0, #2
 80043f6:	f200 80bc 	bhi.w	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80043fa:	682b      	ldr	r3, [r5, #0]
 80043fc:	0199      	lsls	r1, r3, #6
 80043fe:	d4f6      	bmi.n	80043ee <HAL_RCC_OscConfig+0x1ee>
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);
#else
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004400:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8004402:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8004404:	0852      	lsrs	r2, r2, #1
 8004406:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 800440a:	3a01      	subs	r2, #1
 800440c:	430b      	orrs	r3, r1
 800440e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004410:	4c2a      	ldr	r4, [pc, #168]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004412:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8004416:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 800441a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800441e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004422:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8004424:	682b      	ldr	r3, [r5, #0]
 8004426:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800442a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800442c:	f7fc fe20 	bl	8001070 <HAL_GetTick>
 8004430:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004432:	e005      	b.n	8004440 <HAL_RCC_OscConfig+0x240>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004434:	f7fc fe1c 	bl	8001070 <HAL_GetTick>
 8004438:	1b40      	subs	r0, r0, r5
 800443a:	2802      	cmp	r0, #2
 800443c:	f200 8099 	bhi.w	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004440:	6823      	ldr	r3, [r4, #0]
 8004442:	019a      	lsls	r2, r3, #6
 8004444:	d5f6      	bpl.n	8004434 <HAL_RCC_OscConfig+0x234>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8004446:	2000      	movs	r0, #0
}
 8004448:	b002      	add	sp, #8
 800444a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 800444e:	f44f 71b2 	mov.w	r1, #356	; 0x164
 8004452:	481b      	ldr	r0, [pc, #108]	; (80044c0 <HAL_RCC_OscConfig+0x2c0>)
 8004454:	f016 fd26 	bl	801aea4 <assert_failed>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004458:	6823      	ldr	r3, [r4, #0]
 800445a:	e6dc      	b.n	8004216 <HAL_RCC_OscConfig+0x16>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800445c:	685b      	ldr	r3, [r3, #4]
 800445e:	025e      	lsls	r6, r3, #9
 8004460:	f53f af26 	bmi.w	80042b0 <HAL_RCC_OscConfig+0xb0>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004464:	4b15      	ldr	r3, [pc, #84]	; (80044bc <HAL_RCC_OscConfig+0x2bc>)
 8004466:	681b      	ldr	r3, [r3, #0]
 8004468:	079d      	lsls	r5, r3, #30
 800446a:	d565      	bpl.n	8004538 <HAL_RCC_OscConfig+0x338>
 800446c:	68e3      	ldr	r3, [r4, #12]
 800446e:	2b01      	cmp	r3, #1
 8004470:	d062      	beq.n	8004538 <HAL_RCC_OscConfig+0x338>
    return HAL_ERROR;
 8004472:	2001      	movs	r0, #1
}
 8004474:	b002      	add	sp, #8
 8004476:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 800447a:	f44f 71ce 	mov.w	r1, #412	; 0x19c
 800447e:	4810      	ldr	r0, [pc, #64]	; (80044c0 <HAL_RCC_OscConfig+0x2c0>)
 8004480:	f016 fd10 	bl	801aea4 <assert_failed>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8004484:	6923      	ldr	r3, [r4, #16]
 8004486:	2b1f      	cmp	r3, #31
 8004488:	f67f af06 	bls.w	8004298 <HAL_RCC_OscConfig+0x98>
 800448c:	f240 119d 	movw	r1, #413	; 0x19d
 8004490:	480b      	ldr	r0, [pc, #44]	; (80044c0 <HAL_RCC_OscConfig+0x2c0>)
 8004492:	f016 fd07 	bl	801aea4 <assert_failed>
 8004496:	e6ff      	b.n	8004298 <HAL_RCC_OscConfig+0x98>
      __HAL_RCC_LSI_DISABLE();
 8004498:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800449a:	f023 0301 	bic.w	r3, r3, #1
 800449e:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 80044a0:	f7fc fde6 	bl	8001070 <HAL_GetTick>
 80044a4:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80044a6:	e004      	b.n	80044b2 <HAL_RCC_OscConfig+0x2b2>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80044a8:	f7fc fde2 	bl	8001070 <HAL_GetTick>
 80044ac:	1b80      	subs	r0, r0, r6
 80044ae:	2802      	cmp	r0, #2
 80044b0:	d85f      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80044b2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80044b4:	079f      	lsls	r7, r3, #30
 80044b6:	d4f7      	bmi.n	80044a8 <HAL_RCC_OscConfig+0x2a8>
 80044b8:	e75e      	b.n	8004378 <HAL_RCC_OscConfig+0x178>
 80044ba:	bf00      	nop
 80044bc:	40023800 	.word	0x40023800
 80044c0:	080216bc 	.word	0x080216bc
 80044c4:	40007000 	.word	0x40007000
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 80044c8:	f240 11dd 	movw	r1, #477	; 0x1dd
 80044cc:	487b      	ldr	r0, [pc, #492]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 80044ce:	f016 fce9 	bl	801aea4 <assert_failed>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80044d2:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 80044d4:	4d7a      	ldr	r5, [pc, #488]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80044d6:	2b00      	cmp	r3, #0
 80044d8:	d0de      	beq.n	8004498 <HAL_RCC_OscConfig+0x298>
 80044da:	e73c      	b.n	8004356 <HAL_RCC_OscConfig+0x156>
      __HAL_RCC_PWR_CLK_ENABLE();
 80044dc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 80044de:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80044e0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80044e4:	641a      	str	r2, [r3, #64]	; 0x40
 80044e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80044e8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80044ec:	9301      	str	r3, [sp, #4]
 80044ee:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80044f0:	e710      	b.n	8004314 <HAL_RCC_OscConfig+0x114>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80044f2:	f240 214b 	movw	r1, #587	; 0x24b
 80044f6:	4871      	ldr	r0, [pc, #452]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 80044f8:	f016 fcd4 	bl	801aea4 <assert_failed>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80044fc:	69a3      	ldr	r3, [r4, #24]
 80044fe:	2b00      	cmp	r3, #0
 8004500:	f47f af43 	bne.w	800438a <HAL_RCC_OscConfig+0x18a>
 8004504:	e79f      	b.n	8004446 <HAL_RCC_OscConfig+0x246>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8004506:	f44f 71b5 	mov.w	r1, #362	; 0x16a
 800450a:	486c      	ldr	r0, [pc, #432]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 800450c:	f016 fcca 	bl	801aea4 <assert_failed>
 8004510:	e68b      	b.n	800422a <HAL_RCC_OscConfig+0x2a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004512:	4a6b      	ldr	r2, [pc, #428]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
 8004514:	6813      	ldr	r3, [r2, #0]
 8004516:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800451a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800451c:	f7fc fda8 	bl	8001070 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004520:	4e67      	ldr	r6, [pc, #412]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
        tickstart = HAL_GetTick();
 8004522:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004524:	e004      	b.n	8004530 <HAL_RCC_OscConfig+0x330>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004526:	f7fc fda3 	bl	8001070 <HAL_GetTick>
 800452a:	1b40      	subs	r0, r0, r5
 800452c:	2864      	cmp	r0, #100	; 0x64
 800452e:	d820      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004530:	6833      	ldr	r3, [r6, #0]
 8004532:	039a      	lsls	r2, r3, #14
 8004534:	d5f7      	bpl.n	8004526 <HAL_RCC_OscConfig+0x326>
 8004536:	e6a4      	b.n	8004282 <HAL_RCC_OscConfig+0x82>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004538:	4a61      	ldr	r2, [pc, #388]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
 800453a:	6921      	ldr	r1, [r4, #16]
 800453c:	6813      	ldr	r3, [r2, #0]
 800453e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8004542:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8004546:	6013      	str	r3, [r2, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004548:	6823      	ldr	r3, [r4, #0]
 800454a:	071a      	lsls	r2, r3, #28
 800454c:	f57f aed0 	bpl.w	80042f0 <HAL_RCC_OscConfig+0xf0>
 8004550:	e6f9      	b.n	8004346 <HAL_RCC_OscConfig+0x146>
      PWR->CR1 |= PWR_CR1_DBP;
 8004552:	6833      	ldr	r3, [r6, #0]
 8004554:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004558:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 800455a:	f7fc fd89 	bl	8001070 <HAL_GetTick>
 800455e:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8004560:	6833      	ldr	r3, [r6, #0]
 8004562:	05d9      	lsls	r1, r3, #23
 8004564:	f53f aedb 	bmi.w	800431e <HAL_RCC_OscConfig+0x11e>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8004568:	f7fc fd82 	bl	8001070 <HAL_GetTick>
 800456c:	1bc0      	subs	r0, r0, r7
 800456e:	2864      	cmp	r0, #100	; 0x64
 8004570:	d9f6      	bls.n	8004560 <HAL_RCC_OscConfig+0x360>
            return HAL_TIMEOUT;
 8004572:	2003      	movs	r0, #3
}
 8004574:	b002      	add	sp, #8
 8004576:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800457a:	4d51      	ldr	r5, [pc, #324]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
 800457c:	682b      	ldr	r3, [r5, #0]
 800457e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004582:	602b      	str	r3, [r5, #0]
 8004584:	682b      	ldr	r3, [r5, #0]
 8004586:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800458a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800458c:	f7fc fd70 	bl	8001070 <HAL_GetTick>
 8004590:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004592:	e004      	b.n	800459e <HAL_RCC_OscConfig+0x39e>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004594:	f7fc fd6c 	bl	8001070 <HAL_GetTick>
 8004598:	1b80      	subs	r0, r0, r6
 800459a:	2864      	cmp	r0, #100	; 0x64
 800459c:	d8e9      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800459e:	682b      	ldr	r3, [r5, #0]
 80045a0:	039b      	lsls	r3, r3, #14
 80045a2:	d4f7      	bmi.n	8004594 <HAL_RCC_OscConfig+0x394>
 80045a4:	e66d      	b.n	8004282 <HAL_RCC_OscConfig+0x82>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80045a6:	4e46      	ldr	r6, [pc, #280]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80045a8:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80045ac:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80045ae:	f023 0301 	bic.w	r3, r3, #1
 80045b2:	6733      	str	r3, [r6, #112]	; 0x70
 80045b4:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80045b6:	f023 0304 	bic.w	r3, r3, #4
 80045ba:	6733      	str	r3, [r6, #112]	; 0x70
      tickstart = HAL_GetTick();
 80045bc:	f7fc fd58 	bl	8001070 <HAL_GetTick>
 80045c0:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80045c2:	e004      	b.n	80045ce <HAL_RCC_OscConfig+0x3ce>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80045c4:	f7fc fd54 	bl	8001070 <HAL_GetTick>
 80045c8:	1bc0      	subs	r0, r0, r7
 80045ca:	4540      	cmp	r0, r8
 80045cc:	d8d1      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80045ce:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80045d0:	079b      	lsls	r3, r3, #30
 80045d2:	d4f7      	bmi.n	80045c4 <HAL_RCC_OscConfig+0x3c4>
    if(pwrclkchanged == SET)
 80045d4:	2d00      	cmp	r5, #0
 80045d6:	f43f aed2 	beq.w	800437e <HAL_RCC_OscConfig+0x17e>
      __HAL_RCC_PWR_CLK_DISABLE();
 80045da:	4a39      	ldr	r2, [pc, #228]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
 80045dc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80045de:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80045e2:	6413      	str	r3, [r2, #64]	; 0x40
 80045e4:	e6cb      	b.n	800437e <HAL_RCC_OscConfig+0x17e>
        __HAL_RCC_HSI_DISABLE();
 80045e6:	682b      	ldr	r3, [r5, #0]
 80045e8:	f023 0301 	bic.w	r3, r3, #1
 80045ec:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80045ee:	f7fc fd3f 	bl	8001070 <HAL_GetTick>
 80045f2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80045f4:	e004      	b.n	8004600 <HAL_RCC_OscConfig+0x400>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80045f6:	f7fc fd3b 	bl	8001070 <HAL_GetTick>
 80045fa:	1b80      	subs	r0, r0, r6
 80045fc:	2802      	cmp	r0, #2
 80045fe:	d8b8      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004600:	682b      	ldr	r3, [r5, #0]
 8004602:	0799      	lsls	r1, r3, #30
 8004604:	d4f7      	bmi.n	80045f6 <HAL_RCC_OscConfig+0x3f6>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004606:	6823      	ldr	r3, [r4, #0]
 8004608:	e670      	b.n	80042ec <HAL_RCC_OscConfig+0xec>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800460a:	4a2d      	ldr	r2, [pc, #180]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
 800460c:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800460e:	f043 0301 	orr.w	r3, r3, #1
 8004612:	6713      	str	r3, [r2, #112]	; 0x70
      tickstart = HAL_GetTick();
 8004614:	f7fc fd2c 	bl	8001070 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004618:	4f29      	ldr	r7, [pc, #164]	; (80046c0 <HAL_RCC_OscConfig+0x4c0>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800461a:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800461e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004620:	e004      	b.n	800462c <HAL_RCC_OscConfig+0x42c>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004622:	f7fc fd25 	bl	8001070 <HAL_GetTick>
 8004626:	1b80      	subs	r0, r0, r6
 8004628:	4540      	cmp	r0, r8
 800462a:	d8a2      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800462c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800462e:	079a      	lsls	r2, r3, #30
 8004630:	d5f7      	bpl.n	8004622 <HAL_RCC_OscConfig+0x422>
    if(pwrclkchanged == SET)
 8004632:	2d00      	cmp	r5, #0
 8004634:	f43f aea3 	beq.w	800437e <HAL_RCC_OscConfig+0x17e>
 8004638:	e7cf      	b.n	80045da <HAL_RCC_OscConfig+0x3da>
        __HAL_RCC_PLL_DISABLE();
 800463a:	682b      	ldr	r3, [r5, #0]
 800463c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004640:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8004642:	f7fc fd15 	bl	8001070 <HAL_GetTick>
 8004646:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004648:	e004      	b.n	8004654 <HAL_RCC_OscConfig+0x454>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800464a:	f7fc fd11 	bl	8001070 <HAL_GetTick>
 800464e:	1b00      	subs	r0, r0, r4
 8004650:	2802      	cmp	r0, #2
 8004652:	d88e      	bhi.n	8004572 <HAL_RCC_OscConfig+0x372>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004654:	682b      	ldr	r3, [r5, #0]
 8004656:	019b      	lsls	r3, r3, #6
 8004658:	d4f7      	bmi.n	800464a <HAL_RCC_OscConfig+0x44a>
 800465a:	e6f4      	b.n	8004446 <HAL_RCC_OscConfig+0x246>
    return HAL_ERROR;
 800465c:	2001      	movs	r0, #1
}
 800465e:	4770      	bx	lr
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 8004660:	f240 2157 	movw	r1, #599	; 0x257
 8004664:	4815      	ldr	r0, [pc, #84]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 8004666:	f016 fc1d 	bl	801aea4 <assert_failed>
 800466a:	e6b2      	b.n	80043d2 <HAL_RCC_OscConfig+0x1d2>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800466c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004670:	601a      	str	r2, [r3, #0]
 8004672:	681a      	ldr	r2, [r3, #0]
 8004674:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004678:	601a      	str	r2, [r3, #0]
 800467a:	e74f      	b.n	800451c <HAL_RCC_OscConfig+0x31c>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800467c:	f44f 7115 	mov.w	r1, #596	; 0x254
 8004680:	480e      	ldr	r0, [pc, #56]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 8004682:	f016 fc0f 	bl	801aea4 <assert_failed>
 8004686:	e68e      	b.n	80043a6 <HAL_RCC_OscConfig+0x1a6>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 8004688:	f240 2156 	movw	r1, #598	; 0x256
 800468c:	480b      	ldr	r0, [pc, #44]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 800468e:	f016 fc09 	bl	801aea4 <assert_failed>
 8004692:	e693      	b.n	80043bc <HAL_RCC_OscConfig+0x1bc>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 8004694:	f240 2155 	movw	r1, #597	; 0x255
 8004698:	4808      	ldr	r0, [pc, #32]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 800469a:	f016 fc03 	bl	801aea4 <assert_failed>
 800469e:	e687      	b.n	80043b0 <HAL_RCC_OscConfig+0x1b0>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80046a0:	f042 0204 	orr.w	r2, r2, #4
 80046a4:	671a      	str	r2, [r3, #112]	; 0x70
 80046a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80046a8:	f042 0201 	orr.w	r2, r2, #1
 80046ac:	671a      	str	r2, [r3, #112]	; 0x70
 80046ae:	e7b1      	b.n	8004614 <HAL_RCC_OscConfig+0x414>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 80046b0:	f44f 7116 	mov.w	r1, #600	; 0x258
 80046b4:	4801      	ldr	r0, [pc, #4]	; (80046bc <HAL_RCC_OscConfig+0x4bc>)
 80046b6:	f016 fbf5 	bl	801aea4 <assert_failed>
 80046ba:	e68f      	b.n	80043dc <HAL_RCC_OscConfig+0x1dc>
 80046bc:	080216bc 	.word	0x080216bc
 80046c0:	40023800 	.word	0x40023800

080046c4 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80046c4:	2800      	cmp	r0, #0
 80046c6:	f000 8117 	beq.w	80048f8 <HAL_RCC_ClockConfig+0x234>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 80046ca:	6803      	ldr	r3, [r0, #0]
 80046cc:	3b01      	subs	r3, #1
 80046ce:	2b0e      	cmp	r3, #14
{
 80046d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80046d4:	4604      	mov	r4, r0
 80046d6:	460d      	mov	r5, r1
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 80046d8:	f200 80e5 	bhi.w	80048a6 <HAL_RCC_ClockConfig+0x1e2>
  assert_param(IS_FLASH_LATENCY(FLatency));
 80046dc:	2d0f      	cmp	r5, #15
 80046de:	f200 80d2 	bhi.w	8004886 <HAL_RCC_ClockConfig+0x1c2>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80046e2:	4a96      	ldr	r2, [pc, #600]	; (800493c <HAL_RCC_ClockConfig+0x278>)
 80046e4:	6813      	ldr	r3, [r2, #0]
 80046e6:	f003 030f 	and.w	r3, r3, #15
 80046ea:	42ab      	cmp	r3, r5
 80046ec:	d36f      	bcc.n	80047ce <HAL_RCC_ClockConfig+0x10a>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80046ee:	6823      	ldr	r3, [r4, #0]
 80046f0:	0798      	lsls	r0, r3, #30
 80046f2:	d530      	bpl.n	8004756 <HAL_RCC_ClockConfig+0x92>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80046f4:	0759      	lsls	r1, r3, #29
 80046f6:	d504      	bpl.n	8004702 <HAL_RCC_ClockConfig+0x3e>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80046f8:	4991      	ldr	r1, [pc, #580]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 80046fa:	688a      	ldr	r2, [r1, #8]
 80046fc:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 8004700:	608a      	str	r2, [r1, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004702:	071a      	lsls	r2, r3, #28
 8004704:	d504      	bpl.n	8004710 <HAL_RCC_ClockConfig+0x4c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8004706:	498e      	ldr	r1, [pc, #568]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 8004708:	688a      	ldr	r2, [r1, #8]
 800470a:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 800470e:	608a      	str	r2, [r1, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8004710:	68a1      	ldr	r1, [r4, #8]
 8004712:	f021 0220 	bic.w	r2, r1, #32
 8004716:	f021 0080 	bic.w	r0, r1, #128	; 0x80
 800471a:	2a90      	cmp	r2, #144	; 0x90
 800471c:	bf18      	it	ne
 800471e:	2800      	cmpne	r0, #0
 8004720:	f021 0040 	bic.w	r0, r1, #64	; 0x40
 8004724:	bf14      	ite	ne
 8004726:	2201      	movne	r2, #1
 8004728:	2200      	moveq	r2, #0
 800472a:	29f0      	cmp	r1, #240	; 0xf0
 800472c:	bf0c      	ite	eq
 800472e:	2200      	moveq	r2, #0
 8004730:	f002 0201 	andne.w	r2, r2, #1
 8004734:	28a0      	cmp	r0, #160	; 0xa0
 8004736:	bf0c      	ite	eq
 8004738:	2200      	moveq	r2, #0
 800473a:	f002 0201 	andne.w	r2, r2, #1
 800473e:	b122      	cbz	r2, 800474a <HAL_RCC_ClockConfig+0x86>
 8004740:	f021 0210 	bic.w	r2, r1, #16
 8004744:	2ac0      	cmp	r2, #192	; 0xc0
 8004746:	f040 80e1 	bne.w	800490c <HAL_RCC_ClockConfig+0x248>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800474a:	487d      	ldr	r0, [pc, #500]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 800474c:	6882      	ldr	r2, [r0, #8]
 800474e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8004752:	4311      	orrs	r1, r2
 8004754:	6081      	str	r1, [r0, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004756:	07df      	lsls	r7, r3, #31
 8004758:	d526      	bpl.n	80047a8 <HAL_RCC_ClockConfig+0xe4>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 800475a:	6863      	ldr	r3, [r4, #4]
 800475c:	2b02      	cmp	r3, #2
 800475e:	f200 80c2 	bhi.w	80048e6 <HAL_RCC_ClockConfig+0x222>

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004762:	4a77      	ldr	r2, [pc, #476]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004764:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004766:	6812      	ldr	r2, [r2, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004768:	f000 80b7 	beq.w	80048da <HAL_RCC_ClockConfig+0x216>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800476c:	2b02      	cmp	r3, #2
 800476e:	f000 80b0 	beq.w	80048d2 <HAL_RCC_ClockConfig+0x20e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004772:	0791      	lsls	r1, r2, #30
 8004774:	d528      	bpl.n	80047c8 <HAL_RCC_ClockConfig+0x104>
      {
        return HAL_ERROR;
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004776:	4e72      	ldr	r6, [pc, #456]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004778:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800477c:	68b2      	ldr	r2, [r6, #8]
 800477e:	f022 0203 	bic.w	r2, r2, #3
 8004782:	4313      	orrs	r3, r2
 8004784:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8004786:	f7fc fc73 	bl	8001070 <HAL_GetTick>
 800478a:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800478c:	e005      	b.n	800479a <HAL_RCC_ClockConfig+0xd6>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800478e:	f7fc fc6f 	bl	8001070 <HAL_GetTick>
 8004792:	1bc0      	subs	r0, r0, r7
 8004794:	4540      	cmp	r0, r8
 8004796:	f200 80ad 	bhi.w	80048f4 <HAL_RCC_ClockConfig+0x230>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800479a:	68b3      	ldr	r3, [r6, #8]
 800479c:	6862      	ldr	r2, [r4, #4]
 800479e:	f003 030c 	and.w	r3, r3, #12
 80047a2:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80047a6:	d1f2      	bne.n	800478e <HAL_RCC_ClockConfig+0xca>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80047a8:	4a64      	ldr	r2, [pc, #400]	; (800493c <HAL_RCC_ClockConfig+0x278>)
 80047aa:	6813      	ldr	r3, [r2, #0]
 80047ac:	f003 030f 	and.w	r3, r3, #15
 80047b0:	42ab      	cmp	r3, r5
 80047b2:	d91a      	bls.n	80047ea <HAL_RCC_ClockConfig+0x126>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80047b4:	6813      	ldr	r3, [r2, #0]
 80047b6:	f023 030f 	bic.w	r3, r3, #15
 80047ba:	432b      	orrs	r3, r5
 80047bc:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80047be:	6813      	ldr	r3, [r2, #0]
 80047c0:	f003 030f 	and.w	r3, r3, #15
 80047c4:	42ab      	cmp	r3, r5
 80047c6:	d010      	beq.n	80047ea <HAL_RCC_ClockConfig+0x126>
    return HAL_ERROR;
 80047c8:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 80047ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80047ce:	6813      	ldr	r3, [r2, #0]
 80047d0:	f023 030f 	bic.w	r3, r3, #15
 80047d4:	432b      	orrs	r3, r5
 80047d6:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80047d8:	6813      	ldr	r3, [r2, #0]
 80047da:	f003 030f 	and.w	r3, r3, #15
 80047de:	42ab      	cmp	r3, r5
 80047e0:	d1f2      	bne.n	80047c8 <HAL_RCC_ClockConfig+0x104>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80047e2:	6823      	ldr	r3, [r4, #0]
 80047e4:	0798      	lsls	r0, r3, #30
 80047e6:	d485      	bmi.n	80046f4 <HAL_RCC_ClockConfig+0x30>
 80047e8:	e7b5      	b.n	8004756 <HAL_RCC_ClockConfig+0x92>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80047ea:	6823      	ldr	r3, [r4, #0]
 80047ec:	075a      	lsls	r2, r3, #29
 80047ee:	d513      	bpl.n	8004818 <HAL_RCC_ClockConfig+0x154>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 80047f0:	68e1      	ldr	r1, [r4, #12]
 80047f2:	f421 5280 	bic.w	r2, r1, #4096	; 0x1000
 80047f6:	f421 6000 	bic.w	r0, r1, #2048	; 0x800
 80047fa:	f5b0 5fa0 	cmp.w	r0, #5120	; 0x1400
 80047fe:	bf18      	it	ne
 8004800:	2a00      	cmpne	r2, #0
 8004802:	d003      	beq.n	800480c <HAL_RCC_ClockConfig+0x148>
 8004804:	f5b1 5fc0 	cmp.w	r1, #6144	; 0x1800
 8004808:	f040 8088 	bne.w	800491c <HAL_RCC_ClockConfig+0x258>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800480c:	484c      	ldr	r0, [pc, #304]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 800480e:	6882      	ldr	r2, [r0, #8]
 8004810:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8004814:	430a      	orrs	r2, r1
 8004816:	6082      	str	r2, [r0, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004818:	071b      	lsls	r3, r3, #28
 800481a:	d513      	bpl.n	8004844 <HAL_RCC_ClockConfig+0x180>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 800481c:	6922      	ldr	r2, [r4, #16]
 800481e:	f422 6100 	bic.w	r1, r2, #2048	; 0x800
 8004822:	f422 5380 	bic.w	r3, r2, #4096	; 0x1000
 8004826:	f5b1 5fa0 	cmp.w	r1, #5120	; 0x1400
 800482a:	bf18      	it	ne
 800482c:	2b00      	cmpne	r3, #0
 800482e:	d002      	beq.n	8004836 <HAL_RCC_ClockConfig+0x172>
 8004830:	f5b2 5fc0 	cmp.w	r2, #6144	; 0x1800
 8004834:	d17a      	bne.n	800492c <HAL_RCC_ClockConfig+0x268>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8004836:	4942      	ldr	r1, [pc, #264]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 8004838:	688b      	ldr	r3, [r1, #8]
 800483a:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800483e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8004842:	608b      	str	r3, [r1, #8]
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004844:	493e      	ldr	r1, [pc, #248]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 8004846:	688b      	ldr	r3, [r1, #8]
 8004848:	f003 030c 	and.w	r3, r3, #12
 800484c:	2b04      	cmp	r3, #4
 800484e:	d048      	beq.n	80048e2 <HAL_RCC_ClockConfig+0x21e>
 8004850:	2b08      	cmp	r3, #8
 8004852:	d12e      	bne.n	80048b2 <HAL_RCC_ClockConfig+0x1ee>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004854:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8004856:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004858:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800485c:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800485e:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 8004862:	d04b      	beq.n	80048fc <HAL_RCC_ClockConfig+0x238>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004864:	4837      	ldr	r0, [pc, #220]	; (8004944 <HAL_RCC_ClockConfig+0x280>)
 8004866:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800486a:	2300      	movs	r3, #0
 800486c:	fba1 0100 	umull	r0, r1, r1, r0
 8004870:	f7fc fa1a 	bl	8000ca8 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 8004874:	4b32      	ldr	r3, [pc, #200]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 8004876:	685b      	ldr	r3, [r3, #4]
 8004878:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800487c:	3301      	adds	r3, #1
 800487e:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 8004880:	fbb0 f3f3 	udiv	r3, r0, r3
    {
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
 8004884:	e016      	b.n	80048b4 <HAL_RCC_ClockConfig+0x1f0>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8004886:	f240 21cb 	movw	r1, #715	; 0x2cb
 800488a:	482f      	ldr	r0, [pc, #188]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 800488c:	f016 fb0a 	bl	801aea4 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8004890:	4b2a      	ldr	r3, [pc, #168]	; (800493c <HAL_RCC_ClockConfig+0x278>)
      return HAL_ERROR;
 8004892:	2001      	movs	r0, #1
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8004894:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004896:	6819      	ldr	r1, [r3, #0]
 8004898:	f021 010f 	bic.w	r1, r1, #15
 800489c:	430d      	orrs	r5, r1
 800489e:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80048a0:	681b      	ldr	r3, [r3, #0]
}
 80048a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 80048a6:	f240 21ca 	movw	r1, #714	; 0x2ca
 80048aa:	4827      	ldr	r0, [pc, #156]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 80048ac:	f016 fafa 	bl	801aea4 <assert_failed>
 80048b0:	e714      	b.n	80046dc <HAL_RCC_ClockConfig+0x18>
      sysclockfreq = HSI_VALUE;
 80048b2:	4b26      	ldr	r3, [pc, #152]	; (800494c <HAL_RCC_ClockConfig+0x288>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80048b4:	4a22      	ldr	r2, [pc, #136]	; (8004940 <HAL_RCC_ClockConfig+0x27c>)
 80048b6:	4826      	ldr	r0, [pc, #152]	; (8004950 <HAL_RCC_ClockConfig+0x28c>)
 80048b8:	6892      	ldr	r2, [r2, #8]
 80048ba:	4926      	ldr	r1, [pc, #152]	; (8004954 <HAL_RCC_ClockConfig+0x290>)
 80048bc:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80048c0:	5c82      	ldrb	r2, [r0, r2]
  HAL_InitTick (TICK_INT_PRIORITY);
 80048c2:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80048c4:	40d3      	lsrs	r3, r2
 80048c6:	600b      	str	r3, [r1, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80048c8:	f7fc fb90 	bl	8000fec <HAL_InitTick>
  return HAL_OK;
 80048cc:	2000      	movs	r0, #0
}
 80048ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80048d2:	0190      	lsls	r0, r2, #6
 80048d4:	f53f af4f 	bmi.w	8004776 <HAL_RCC_ClockConfig+0xb2>
 80048d8:	e776      	b.n	80047c8 <HAL_RCC_ClockConfig+0x104>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80048da:	0396      	lsls	r6, r2, #14
 80048dc:	f53f af4b 	bmi.w	8004776 <HAL_RCC_ClockConfig+0xb2>
 80048e0:	e772      	b.n	80047c8 <HAL_RCC_ClockConfig+0x104>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80048e2:	4b18      	ldr	r3, [pc, #96]	; (8004944 <HAL_RCC_ClockConfig+0x280>)
 80048e4:	e7e6      	b.n	80048b4 <HAL_RCC_ClockConfig+0x1f0>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 80048e6:	f240 21f6 	movw	r1, #758	; 0x2f6
 80048ea:	4817      	ldr	r0, [pc, #92]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 80048ec:	f016 fada 	bl	801aea4 <assert_failed>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80048f0:	6863      	ldr	r3, [r4, #4]
 80048f2:	e736      	b.n	8004762 <HAL_RCC_ClockConfig+0x9e>
        return HAL_TIMEOUT;
 80048f4:	2003      	movs	r0, #3
 80048f6:	e768      	b.n	80047ca <HAL_RCC_ClockConfig+0x106>
    return HAL_ERROR;
 80048f8:	2001      	movs	r0, #1
}
 80048fa:	4770      	bx	lr
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80048fc:	4813      	ldr	r0, [pc, #76]	; (800494c <HAL_RCC_ClockConfig+0x288>)
 80048fe:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8004902:	fba1 0100 	umull	r0, r1, r1, r0
 8004906:	f7fc f9cf 	bl	8000ca8 <__aeabi_uldivmod>
 800490a:	e7b3      	b.n	8004874 <HAL_RCC_ClockConfig+0x1b0>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 800490c:	f240 21ef 	movw	r1, #751	; 0x2ef
 8004910:	480d      	ldr	r0, [pc, #52]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 8004912:	f016 fac7 	bl	801aea4 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8004916:	68a1      	ldr	r1, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004918:	6823      	ldr	r3, [r4, #0]
 800491a:	e716      	b.n	800474a <HAL_RCC_ClockConfig+0x86>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 800491c:	f240 3133 	movw	r1, #819	; 0x333
 8004920:	4809      	ldr	r0, [pc, #36]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 8004922:	f016 fabf 	bl	801aea4 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004926:	68e1      	ldr	r1, [r4, #12]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004928:	6823      	ldr	r3, [r4, #0]
 800492a:	e76f      	b.n	800480c <HAL_RCC_ClockConfig+0x148>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 800492c:	f240 313a 	movw	r1, #826	; 0x33a
 8004930:	4805      	ldr	r0, [pc, #20]	; (8004948 <HAL_RCC_ClockConfig+0x284>)
 8004932:	f016 fab7 	bl	801aea4 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8004936:	6922      	ldr	r2, [r4, #16]
 8004938:	e77d      	b.n	8004836 <HAL_RCC_ClockConfig+0x172>
 800493a:	bf00      	nop
 800493c:	40023c00 	.word	0x40023c00
 8004940:	40023800 	.word	0x40023800
 8004944:	017d7840 	.word	0x017d7840
 8004948:	080216bc 	.word	0x080216bc
 800494c:	00f42400 	.word	0x00f42400
 8004950:	08026f08 	.word	0x08026f08
 8004954:	20000078 	.word	0x20000078

08004958 <HAL_RCCEx_PeriphCLKConfig>:
  uint32_t tmpreg1 = 0;
  uint32_t plli2sused = 0;
  uint32_t pllsaiused = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 8004958:	4a59      	ldr	r2, [pc, #356]	; (8004ac0 <HAL_RCCEx_PeriphCLKConfig+0x168>)
 800495a:	6803      	ldr	r3, [r0, #0]
 800495c:	401a      	ands	r2, r3
{
 800495e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004962:	4604      	mov	r4, r0
 8004964:	b083      	sub	sp, #12
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 8004966:	2a00      	cmp	r2, #0
 8004968:	f000 8306 	beq.w	8004f78 <HAL_RCCEx_PeriphCLKConfig+0x620>

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800496c:	f013 0601 	ands.w	r6, r3, #1
 8004970:	d00f      	beq.n	8004992 <HAL_RCCEx_PeriphCLKConfig+0x3a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
 8004972:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8004974:	f436 0200 	bics.w	r2, r6, #8388608	; 0x800000
 8004978:	f040 8309 	bne.w	8004f8e <HAL_RCCEx_PeriphCLKConfig+0x636>

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800497c:	4a51      	ldr	r2, [pc, #324]	; (8004ac4 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 800497e:	6891      	ldr	r1, [r2, #8]
 8004980:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 8004984:	6091      	str	r1, [r2, #8]
 8004986:	6891      	ldr	r1, [r2, #8]
 8004988:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 800498a:	fab6 f686 	clz	r6, r6
 800498e:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8004990:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8004992:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8004996:	d017      	beq.n	80049c8 <HAL_RCCEx_PeriphCLKConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
 8004998:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 800499a:	f435 1280 	bics.w	r2, r5, #1048576	; 0x100000
 800499e:	d003      	beq.n	80049a8 <HAL_RCCEx_PeriphCLKConfig+0x50>
 80049a0:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 80049a4:	f040 8301 	bne.w	8004faa <HAL_RCCEx_PeriphCLKConfig+0x652>

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80049a8:	4946      	ldr	r1, [pc, #280]	; (8004ac4 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 80049aa:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80049ae:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 80049b2:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80049b6:	ea42 0205 	orr.w	r2, r2, r5
 80049ba:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 80049be:	f000 82e1 	beq.w	8004f84 <HAL_RCCEx_PeriphCLKConfig+0x62c>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 80049c2:	fab5 f585 	clz	r5, r5
 80049c6:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 80049c8:	02d9      	lsls	r1, r3, #11
 80049ca:	d517      	bpl.n	80049fc <HAL_RCCEx_PeriphCLKConfig+0xa4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
 80049cc:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80049ce:	f431 0280 	bics.w	r2, r1, #4194304	; 0x400000
 80049d2:	d003      	beq.n	80049dc <HAL_RCCEx_PeriphCLKConfig+0x84>
 80049d4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80049d8:	f040 82e0 	bne.w	8004f9c <HAL_RCCEx_PeriphCLKConfig+0x644>

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 80049dc:	4839      	ldr	r0, [pc, #228]	; (8004ac4 <HAL_RCCEx_PeriphCLKConfig+0x16c>)

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 80049de:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 80049e2:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 80049e6:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 80049ea:	ea42 0201 	orr.w	r2, r2, r1
 80049ee:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 80049f2:	f000 82ca 	beq.w	8004f8a <HAL_RCCEx_PeriphCLKConfig+0x632>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 80049f6:	2900      	cmp	r1, #0
 80049f8:	bf08      	it	eq
 80049fa:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 80049fc:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8004a00:	bf18      	it	ne
 8004a02:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004a04:	069a      	lsls	r2, r3, #26
 8004a06:	f140 8099 	bpl.w	8004b3c <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 8004a0a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004a0c:	482e      	ldr	r0, [pc, #184]	; (8004ac8 <HAL_RCCEx_PeriphCLKConfig+0x170>)
 8004a0e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8004a12:	bf18      	it	ne
 8004a14:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
 8004a18:	f422 27a0 	bic.w	r7, r2, #327680	; 0x50000
 8004a1c:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8004a20:	bf14      	ite	ne
 8004a22:	2301      	movne	r3, #1
 8004a24:	2300      	moveq	r3, #0
 8004a26:	4287      	cmp	r7, r0
 8004a28:	bf0c      	ite	eq
 8004a2a:	2300      	moveq	r3, #0
 8004a2c:	f003 0301 	andne.w	r3, r3, #1
 8004a30:	f422 2710 	bic.w	r7, r2, #589824	; 0x90000
 8004a34:	f500 3000 	add.w	r0, r0, #131072	; 0x20000
 8004a38:	4287      	cmp	r7, r0
 8004a3a:	bf0c      	ite	eq
 8004a3c:	2300      	moveq	r3, #0
 8004a3e:	f003 0301 	andne.w	r3, r3, #1
 8004a42:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
 8004a46:	f422 1788 	bic.w	r7, r2, #1114112	; 0x110000
 8004a4a:	4281      	cmp	r1, r0
 8004a4c:	bf0c      	ite	eq
 8004a4e:	2300      	moveq	r3, #0
 8004a50:	f003 0301 	andne.w	r3, r3, #1
 8004a54:	f500 20c0 	add.w	r0, r0, #393216	; 0x60000
 8004a58:	4287      	cmp	r7, r0
 8004a5a:	bf0c      	ite	eq
 8004a5c:	2300      	moveq	r3, #0
 8004a5e:	f003 0301 	andne.w	r3, r3, #1
 8004a62:	f500 3000 	add.w	r0, r0, #131072	; 0x20000
 8004a66:	4281      	cmp	r1, r0
 8004a68:	bf0c      	ite	eq
 8004a6a:	2300      	moveq	r3, #0
 8004a6c:	f003 0301 	andne.w	r3, r3, #1
 8004a70:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
 8004a74:	4281      	cmp	r1, r0
 8004a76:	bf0c      	ite	eq
 8004a78:	2300      	moveq	r3, #0
 8004a7a:	f003 0301 	andne.w	r3, r3, #1
 8004a7e:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
 8004a82:	4281      	cmp	r1, r0
 8004a84:	bf0c      	ite	eq
 8004a86:	2300      	moveq	r3, #0
 8004a88:	f003 0301 	andne.w	r3, r3, #1
 8004a8c:	b12b      	cbz	r3, 8004a9a <HAL_RCCEx_PeriphCLKConfig+0x142>
 8004a8e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004a92:	4b0e      	ldr	r3, [pc, #56]	; (8004acc <HAL_RCCEx_PeriphCLKConfig+0x174>)
 8004a94:	429a      	cmp	r2, r3
 8004a96:	f040 83ed 	bne.w	8005274 <HAL_RCCEx_PeriphCLKConfig+0x91c>

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004a9a:	4b0a      	ldr	r3, [pc, #40]	; (8004ac4 <HAL_RCCEx_PeriphCLKConfig+0x16c>)

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8004a9c:	4f0c      	ldr	r7, [pc, #48]	; (8004ad0 <HAL_RCCEx_PeriphCLKConfig+0x178>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8004a9e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004aa0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004aa4:	641a      	str	r2, [r3, #64]	; 0x40
 8004aa6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004aa8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004aac:	9301      	str	r3, [sp, #4]
 8004aae:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8004ab0:	683b      	ldr	r3, [r7, #0]
 8004ab2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004ab6:	603b      	str	r3, [r7, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004ab8:	f7fc fada 	bl	8001070 <HAL_GetTick>
 8004abc:	4680      	mov	r8, r0

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004abe:	e010      	b.n	8004ae2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
 8004ac0:	01fffff9 	.word	0x01fffff9
 8004ac4:	40023800 	.word	0x40023800
 8004ac8:	00020300 	.word	0x00020300
 8004acc:	001c0300 	.word	0x001c0300
 8004ad0:	40007000 	.word	0x40007000
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004ad4:	f7fc facc 	bl	8001070 <HAL_GetTick>
 8004ad8:	eba0 0008 	sub.w	r0, r0, r8
 8004adc:	2864      	cmp	r0, #100	; 0x64
 8004ade:	f200 81d5 	bhi.w	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x534>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004ae2:	683b      	ldr	r3, [r7, #0]
 8004ae4:	05db      	lsls	r3, r3, #23
 8004ae6:	d5f5      	bpl.n	8004ad4 <HAL_RCCEx_PeriphCLKConfig+0x17c>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004ae8:	4fab      	ldr	r7, [pc, #684]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004aea:	6b23      	ldr	r3, [r4, #48]	; 0x30
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004aec:	6f3a      	ldr	r2, [r7, #112]	; 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004aee:	f403 7140 	and.w	r1, r3, #768	; 0x300
 8004af2:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 8004af6:	d011      	beq.n	8004b1c <HAL_RCCEx_PeriphCLKConfig+0x1c4>
 8004af8:	4291      	cmp	r1, r2
 8004afa:	d00f      	beq.n	8004b1c <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004afc:	6f3a      	ldr	r2, [r7, #112]	; 0x70

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004afe:	6f38      	ldr	r0, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004b00:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8004b04:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8004b08:	6738      	str	r0, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004b0a:	6f38      	ldr	r0, [r7, #112]	; 0x70
 8004b0c:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 8004b10:	6738      	str	r0, [r7, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
 8004b12:	673a      	str	r2, [r7, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8004b14:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8004b16:	07d0      	lsls	r0, r2, #31
 8004b18:	f100 8324 	bmi.w	8005164 <HAL_RCCEx_PeriphCLKConfig+0x80c>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004b1c:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8004b20:	f000 8269 	beq.w	8004ff6 <HAL_RCCEx_PeriphCLKConfig+0x69e>
 8004b24:	499c      	ldr	r1, [pc, #624]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004b26:	688a      	ldr	r2, [r1, #8]
 8004b28:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8004b2c:	608a      	str	r2, [r1, #8]
 8004b2e:	4a9a      	ldr	r2, [pc, #616]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004b30:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8004b34:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8004b36:	430b      	orrs	r3, r1
 8004b38:	6713      	str	r3, [r2, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8004b3a:	6823      	ldr	r3, [r4, #0]
 8004b3c:	06da      	lsls	r2, r3, #27
 8004b3e:	d510      	bpl.n	8004b62 <HAL_RCCEx_PeriphCLKConfig+0x20a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 8004b40:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8004b42:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
 8004b46:	f040 8284 	bne.w	8005052 <HAL_RCCEx_PeriphCLKConfig+0x6fa>

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8004b4a:	4a93      	ldr	r2, [pc, #588]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004b4c:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
 8004b50:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 8004b54:	f8c2 008c 	str.w	r0, [r2, #140]	; 0x8c
 8004b58:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8004b5c:	4339      	orrs	r1, r7
 8004b5e:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004b62:	045f      	lsls	r7, r3, #17
 8004b64:	d50f      	bpl.n	8004b86 <HAL_RCCEx_PeriphCLKConfig+0x22e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 8004b66:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8004b68:	f431 3280 	bics.w	r2, r1, #65536	; 0x10000
 8004b6c:	d003      	beq.n	8004b76 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8004b6e:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 8004b72:	f040 8221 	bne.w	8004fb8 <HAL_RCCEx_PeriphCLKConfig+0x660>

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004b76:	4888      	ldr	r0, [pc, #544]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004b78:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004b7c:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8004b80:	430a      	orrs	r2, r1
 8004b82:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004b86:	0418      	lsls	r0, r3, #16
 8004b88:	d50f      	bpl.n	8004baa <HAL_RCCEx_PeriphCLKConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
 8004b8a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 8004b8c:	f431 2280 	bics.w	r2, r1, #262144	; 0x40000
 8004b90:	d003      	beq.n	8004b9a <HAL_RCCEx_PeriphCLKConfig+0x242>
 8004b92:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
 8004b96:	f040 8216 	bne.w	8004fc6 <HAL_RCCEx_PeriphCLKConfig+0x66e>

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004b9a:	487f      	ldr	r0, [pc, #508]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004b9c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004ba0:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8004ba4:	430a      	orrs	r2, r1
 8004ba6:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004baa:	03d9      	lsls	r1, r3, #15
 8004bac:	d50f      	bpl.n	8004bce <HAL_RCCEx_PeriphCLKConfig+0x276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
 8004bae:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8004bb0:	f431 1280 	bics.w	r2, r1, #1048576	; 0x100000
 8004bb4:	d003      	beq.n	8004bbe <HAL_RCCEx_PeriphCLKConfig+0x266>
 8004bb6:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8004bba:	f040 820c 	bne.w	8004fd6 <HAL_RCCEx_PeriphCLKConfig+0x67e>

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8004bbe:	4876      	ldr	r0, [pc, #472]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004bc0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004bc4:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8004bc8:	430a      	orrs	r2, r1
 8004bca:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004bce:	039a      	lsls	r2, r3, #14
 8004bd0:	d50f      	bpl.n	8004bf2 <HAL_RCCEx_PeriphCLKConfig+0x29a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8004bd2:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8004bd4:	f431 0280 	bics.w	r2, r1, #4194304	; 0x400000
 8004bd8:	d003      	beq.n	8004be2 <HAL_RCCEx_PeriphCLKConfig+0x28a>
 8004bda:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8004bde:	f040 8202 	bne.w	8004fe6 <HAL_RCCEx_PeriphCLKConfig+0x68e>

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004be2:	486d      	ldr	r0, [pc, #436]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004be4:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004be8:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8004bec:	430a      	orrs	r2, r1
 8004bee:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004bf2:	065f      	lsls	r7, r3, #25
 8004bf4:	d50b      	bpl.n	8004c0e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 8004bf6:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8004bf8:	2903      	cmp	r1, #3
 8004bfa:	f200 8249 	bhi.w	8005090 <HAL_RCCEx_PeriphCLKConfig+0x738>

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8004bfe:	4866      	ldr	r0, [pc, #408]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c00:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c04:	f022 0203 	bic.w	r2, r2, #3
 8004c08:	430a      	orrs	r2, r1
 8004c0a:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004c0e:	0618      	lsls	r0, r3, #24
 8004c10:	d50c      	bpl.n	8004c2c <HAL_RCCEx_PeriphCLKConfig+0x2d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
 8004c12:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8004c14:	f031 020c 	bics.w	r2, r1, #12
 8004c18:	f040 8260 	bne.w	80050dc <HAL_RCCEx_PeriphCLKConfig+0x784>

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8004c1c:	485e      	ldr	r0, [pc, #376]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c1e:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c22:	f022 020c 	bic.w	r2, r2, #12
 8004c26:	430a      	orrs	r2, r1
 8004c28:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8004c2c:	05d9      	lsls	r1, r3, #23
 8004c2e:	d50c      	bpl.n	8004c4a <HAL_RCCEx_PeriphCLKConfig+0x2f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
 8004c30:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8004c32:	f031 0230 	bics.w	r2, r1, #48	; 0x30
 8004c36:	f040 825f 	bne.w	80050f8 <HAL_RCCEx_PeriphCLKConfig+0x7a0>

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8004c3a:	4857      	ldr	r0, [pc, #348]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c3c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c40:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004c44:	430a      	orrs	r2, r1
 8004c46:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8004c4a:	059a      	lsls	r2, r3, #22
 8004c4c:	d50c      	bpl.n	8004c68 <HAL_RCCEx_PeriphCLKConfig+0x310>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
 8004c4e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8004c50:	f031 02c0 	bics.w	r2, r1, #192	; 0xc0
 8004c54:	f040 8258 	bne.w	8005108 <HAL_RCCEx_PeriphCLKConfig+0x7b0>

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8004c58:	484f      	ldr	r0, [pc, #316]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c5a:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c5e:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8004c62:	430a      	orrs	r2, r1
 8004c64:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8004c68:	055f      	lsls	r7, r3, #21
 8004c6a:	d50c      	bpl.n	8004c86 <HAL_RCCEx_PeriphCLKConfig+0x32e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
 8004c6c:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8004c6e:	f431 7240 	bics.w	r2, r1, #768	; 0x300
 8004c72:	f040 8251 	bne.w	8005118 <HAL_RCCEx_PeriphCLKConfig+0x7c0>

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8004c76:	4848      	ldr	r0, [pc, #288]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c78:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c7c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8004c80:	430a      	orrs	r2, r1
 8004c82:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8004c86:	0518      	lsls	r0, r3, #20
 8004c88:	d50c      	bpl.n	8004ca4 <HAL_RCCEx_PeriphCLKConfig+0x34c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
 8004c8a:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8004c8c:	f431 6240 	bics.w	r2, r1, #3072	; 0xc00
 8004c90:	f040 824a 	bne.w	8005128 <HAL_RCCEx_PeriphCLKConfig+0x7d0>

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8004c94:	4840      	ldr	r0, [pc, #256]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004c96:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004c9a:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8004c9e:	430a      	orrs	r2, r1
 8004ca0:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8004ca4:	04d9      	lsls	r1, r3, #19
 8004ca6:	d50c      	bpl.n	8004cc2 <HAL_RCCEx_PeriphCLKConfig+0x36a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
 8004ca8:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8004caa:	f431 5240 	bics.w	r2, r1, #12288	; 0x3000
 8004cae:	f040 81fd 	bne.w	80050ac <HAL_RCCEx_PeriphCLKConfig+0x754>

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8004cb2:	4839      	ldr	r0, [pc, #228]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004cb4:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004cb8:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8004cbc:	430a      	orrs	r2, r1
 8004cbe:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8004cc2:	049a      	lsls	r2, r3, #18
 8004cc4:	d50c      	bpl.n	8004ce0 <HAL_RCCEx_PeriphCLKConfig+0x388>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
 8004cc6:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8004cc8:	f431 4240 	bics.w	r2, r1, #49152	; 0xc000
 8004ccc:	f040 81f6 	bne.w	80050bc <HAL_RCCEx_PeriphCLKConfig+0x764>

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8004cd0:	4831      	ldr	r0, [pc, #196]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004cd2:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004cd6:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8004cda:	430a      	orrs	r2, r1
 8004cdc:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8004ce0:	025f      	lsls	r7, r3, #9
 8004ce2:	d50c      	bpl.n	8004cfe <HAL_RCCEx_PeriphCLKConfig+0x3a6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 8004ce4:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8004ce6:	f031 6280 	bics.w	r2, r1, #67108864	; 0x4000000
 8004cea:	f040 81c1 	bne.w	8005070 <HAL_RCCEx_PeriphCLKConfig+0x718>

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8004cee:	482a      	ldr	r0, [pc, #168]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004cf0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004cf4:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8004cf8:	430a      	orrs	r2, r1
 8004cfa:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8004cfe:	0298      	lsls	r0, r3, #10
 8004d00:	d510      	bpl.n	8004d24 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
 8004d02:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8004d04:	f031 6200 	bics.w	r2, r1, #134217728	; 0x8000000
 8004d08:	f040 81ba 	bne.w	8005080 <HAL_RCCEx_PeriphCLKConfig+0x728>

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8004d0c:	4822      	ldr	r0, [pc, #136]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 8004d0e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8004d12:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
      pllsaiused = 1;
 8004d16:	bf08      	it	eq
 8004d18:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8004d1a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
 8004d1e:	430a      	orrs	r2, r1
 8004d20:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 8004d24:	f013 0f08 	tst.w	r3, #8
 8004d28:	bf18      	it	ne
 8004d2a:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8004d2c:	0359      	lsls	r1, r3, #13
 8004d2e:	d50c      	bpl.n	8004d4a <HAL_RCCEx_PeriphCLKConfig+0x3f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
 8004d30:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8004d32:	f031 7240 	bics.w	r2, r1, #50331648	; 0x3000000
 8004d36:	f040 81c9 	bne.w	80050cc <HAL_RCCEx_PeriphCLKConfig+0x774>

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004d3a:	4817      	ldr	r0, [pc, #92]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004d3c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004d40:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8004d44:	430a      	orrs	r2, r1
 8004d46:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8004d4a:	021a      	lsls	r2, r3, #8
 8004d4c:	d50d      	bpl.n	8004d6a <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
 8004d4e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8004d52:	f032 5380 	bics.w	r3, r2, #268435456	; 0x10000000
 8004d56:	f040 8183 	bne.w	8005060 <HAL_RCCEx_PeriphCLKConfig+0x708>

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8004d5a:	490f      	ldr	r1, [pc, #60]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004d5c:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 8004d60:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004d64:	4313      	orrs	r3, r2
 8004d66:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8004d6a:	2e01      	cmp	r6, #1
 8004d6c:	f000 8092 	beq.w	8004e94 <HAL_RCCEx_PeriphCLKConfig+0x53c>
 8004d70:	6823      	ldr	r3, [r4, #0]
 8004d72:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8004d76:	f000 808d 	beq.w	8004e94 <HAL_RCCEx_PeriphCLKConfig+0x53c>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8004d7a:	2d01      	cmp	r5, #1
 8004d7c:	d003      	beq.n	8004d86 <HAL_RCCEx_PeriphCLKConfig+0x42e>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8004d7e:	2000      	movs	r0, #0
}
 8004d80:	b003      	add	sp, #12
 8004d82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PLLSAI_DISABLE();
 8004d86:	4d04      	ldr	r5, [pc, #16]	; (8004d98 <HAL_RCCEx_PeriphCLKConfig+0x440>)
 8004d88:	682b      	ldr	r3, [r5, #0]
 8004d8a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004d8e:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8004d90:	f7fc f96e 	bl	8001070 <HAL_GetTick>
 8004d94:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8004d96:	e006      	b.n	8004da6 <HAL_RCCEx_PeriphCLKConfig+0x44e>
 8004d98:	40023800 	.word	0x40023800
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8004d9c:	f7fc f968 	bl	8001070 <HAL_GetTick>
 8004da0:	1b80      	subs	r0, r0, r6
 8004da2:	2864      	cmp	r0, #100	; 0x64
 8004da4:	d872      	bhi.n	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x534>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8004da6:	682b      	ldr	r3, [r5, #0]
 8004da8:	009f      	lsls	r7, r3, #2
 8004daa:	d4f7      	bmi.n	8004d9c <HAL_RCCEx_PeriphCLKConfig+0x444>
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
 8004dac:	6963      	ldr	r3, [r4, #20]
 8004dae:	3b32      	subs	r3, #50	; 0x32
 8004db0:	f5b3 7fbf 	cmp.w	r3, #382	; 0x17e
 8004db4:	f200 81fd 	bhi.w	80051b2 <HAL_RCCEx_PeriphCLKConfig+0x85a>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8004db8:	6823      	ldr	r3, [r4, #0]
 8004dba:	031d      	lsls	r5, r3, #12
 8004dbc:	f100 81e6 	bmi.w	800518c <HAL_RCCEx_PeriphCLKConfig+0x834>
 8004dc0:	02d8      	lsls	r0, r3, #11
 8004dc2:	d526      	bpl.n	8004e12 <HAL_RCCEx_PeriphCLKConfig+0x4ba>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8004dc4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004dc6:	bb22      	cbnz	r2, 8004e12 <HAL_RCCEx_PeriphCLKConfig+0x4ba>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
 8004dc8:	69a3      	ldr	r3, [r4, #24]
 8004dca:	3b02      	subs	r3, #2
 8004dcc:	2b0d      	cmp	r3, #13
 8004dce:	f200 823c 	bhi.w	800524a <HAL_RCCEx_PeriphCLKConfig+0x8f2>
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
 8004dd2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004dd4:	1e59      	subs	r1, r3, #1
 8004dd6:	291f      	cmp	r1, #31
 8004dd8:	f200 822f 	bhi.w	800523a <HAL_RCCEx_PeriphCLKConfig+0x8e2>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8004ddc:	4ab0      	ldr	r2, [pc, #704]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004dde:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8004de2:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8004de6:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8004dea:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8004dee:	4303      	orrs	r3, r0
 8004df0:	6960      	ldr	r0, [r4, #20]
 8004df2:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8004df6:	69a0      	ldr	r0, [r4, #24]
 8004df8:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8004dfc:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8004e00:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8004e04:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8004e08:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8004e0c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8004e10:	6823      	ldr	r3, [r4, #0]
 8004e12:	0299      	lsls	r1, r3, #10
 8004e14:	d504      	bpl.n	8004e20 <HAL_RCCEx_PeriphCLKConfig+0x4c8>
 8004e16:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8004e18:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8004e1c:	f000 81f2 	beq.w	8005204 <HAL_RCCEx_PeriphCLKConfig+0x8ac>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8004e20:	071a      	lsls	r2, r3, #28
 8004e22:	d522      	bpl.n	8004e6a <HAL_RCCEx_PeriphCLKConfig+0x512>
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
 8004e24:	69e3      	ldr	r3, [r4, #28]
 8004e26:	3b02      	subs	r3, #2
 8004e28:	2b05      	cmp	r3, #5
 8004e2a:	f200 8200 	bhi.w	800522e <HAL_RCCEx_PeriphCLKConfig+0x8d6>
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
 8004e2e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004e30:	f430 3340 	bics.w	r3, r0, #196608	; 0x30000
 8004e34:	f040 820f 	bne.w	8005256 <HAL_RCCEx_PeriphCLKConfig+0x8fe>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8004e38:	4a99      	ldr	r2, [pc, #612]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8004e3a:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8004e3c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8004e40:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8004e44:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8004e48:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8004e4c:	430b      	orrs	r3, r1
 8004e4e:	69e1      	ldr	r1, [r4, #28]
 8004e50:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8004e54:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8004e58:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8004e5c:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8004e60:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8004e64:	4303      	orrs	r3, r0
 8004e66:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 8004e6a:	4c8d      	ldr	r4, [pc, #564]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004e6c:	6823      	ldr	r3, [r4, #0]
 8004e6e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004e72:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8004e74:	f7fc f8fc 	bl	8001070 <HAL_GetTick>
 8004e78:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8004e7a:	6823      	ldr	r3, [r4, #0]
 8004e7c:	009b      	lsls	r3, r3, #2
 8004e7e:	f53f af7e 	bmi.w	8004d7e <HAL_RCCEx_PeriphCLKConfig+0x426>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8004e82:	f7fc f8f5 	bl	8001070 <HAL_GetTick>
 8004e86:	1b40      	subs	r0, r0, r5
 8004e88:	2864      	cmp	r0, #100	; 0x64
 8004e8a:	d9f6      	bls.n	8004e7a <HAL_RCCEx_PeriphCLKConfig+0x522>
        return HAL_TIMEOUT;
 8004e8c:	2003      	movs	r0, #3
}
 8004e8e:	b003      	add	sp, #12
 8004e90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8004e94:	4e82      	ldr	r6, [pc, #520]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004e96:	6833      	ldr	r3, [r6, #0]
 8004e98:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8004e9c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8004e9e:	f7fc f8e7 	bl	8001070 <HAL_GetTick>
 8004ea2:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004ea4:	e004      	b.n	8004eb0 <HAL_RCCEx_PeriphCLKConfig+0x558>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004ea6:	f7fc f8e3 	bl	8001070 <HAL_GetTick>
 8004eaa:	1bc0      	subs	r0, r0, r7
 8004eac:	2864      	cmp	r0, #100	; 0x64
 8004eae:	d8ed      	bhi.n	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x534>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004eb0:	6833      	ldr	r3, [r6, #0]
 8004eb2:	011b      	lsls	r3, r3, #4
 8004eb4:	d4f7      	bmi.n	8004ea6 <HAL_RCCEx_PeriphCLKConfig+0x54e>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
 8004eb6:	6863      	ldr	r3, [r4, #4]
 8004eb8:	3b32      	subs	r3, #50	; 0x32
 8004eba:	f5b3 7fbf 	cmp.w	r3, #382	; 0x17e
 8004ebe:	f200 8115 	bhi.w	80050ec <HAL_RCCEx_PeriphCLKConfig+0x794>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8004ec2:	6823      	ldr	r3, [r4, #0]
 8004ec4:	07df      	lsls	r7, r3, #31
 8004ec6:	d503      	bpl.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x578>
 8004ec8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004eca:	2a00      	cmp	r2, #0
 8004ecc:	f000 8134 	beq.w	8005138 <HAL_RCCEx_PeriphCLKConfig+0x7e0>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8004ed0:	031e      	lsls	r6, r3, #12
 8004ed2:	d504      	bpl.n	8004ede <HAL_RCCEx_PeriphCLKConfig+0x586>
 8004ed4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8004ed6:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8004eda:	f000 8095 	beq.w	8005008 <HAL_RCCEx_PeriphCLKConfig+0x6b0>
 8004ede:	02d8      	lsls	r0, r3, #11
 8004ee0:	d504      	bpl.n	8004eec <HAL_RCCEx_PeriphCLKConfig+0x594>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8004ee2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004ee4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 8004ee8:	f000 808e 	beq.w	8005008 <HAL_RCCEx_PeriphCLKConfig+0x6b0>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8004eec:	01d9      	lsls	r1, r3, #7
 8004eee:	d514      	bpl.n	8004f1a <HAL_RCCEx_PeriphCLKConfig+0x5c2>
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
 8004ef0:	6927      	ldr	r7, [r4, #16]
 8004ef2:	2f03      	cmp	r7, #3
 8004ef4:	f200 8176 	bhi.w	80051e4 <HAL_RCCEx_PeriphCLKConfig+0x88c>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8004ef8:	4969      	ldr	r1, [pc, #420]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8004efa:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8004efc:	f8d1 2084 	ldr.w	r2, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8004f00:	f8d1 6084 	ldr.w	r6, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8004f04:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8004f08:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8004f0c:	4332      	orrs	r2, r6
 8004f0e:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8004f12:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8004f16:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8004f1a:	019a      	lsls	r2, r3, #6
 8004f1c:	d51a      	bpl.n	8004f54 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
 8004f1e:	6923      	ldr	r3, [r4, #16]
 8004f20:	2b03      	cmp	r3, #3
 8004f22:	f200 8159 	bhi.w	80051d8 <HAL_RCCEx_PeriphCLKConfig+0x880>
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
 8004f26:	68a3      	ldr	r3, [r4, #8]
 8004f28:	3b02      	subs	r3, #2
 8004f2a:	2b05      	cmp	r3, #5
 8004f2c:	f200 814e 	bhi.w	80051cc <HAL_RCCEx_PeriphCLKConfig+0x874>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
 8004f30:	68e2      	ldr	r2, [r4, #12]
 8004f32:	1e93      	subs	r3, r2, #2
 8004f34:	2b0d      	cmp	r3, #13
 8004f36:	f200 8142 	bhi.w	80051be <HAL_RCCEx_PeriphCLKConfig+0x866>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8004f3a:	6923      	ldr	r3, [r4, #16]
 8004f3c:	6861      	ldr	r1, [r4, #4]
 8004f3e:	041b      	lsls	r3, r3, #16
 8004f40:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8004f44:	68a1      	ldr	r1, [r4, #8]
 8004f46:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8004f4a:	4955      	ldr	r1, [pc, #340]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004f4c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004f50:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8004f54:	4e52      	ldr	r6, [pc, #328]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004f56:	6833      	ldr	r3, [r6, #0]
 8004f58:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8004f5c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8004f5e:	f7fc f887 	bl	8001070 <HAL_GetTick>
 8004f62:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004f64:	e004      	b.n	8004f70 <HAL_RCCEx_PeriphCLKConfig+0x618>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004f66:	f7fc f883 	bl	8001070 <HAL_GetTick>
 8004f6a:	1bc0      	subs	r0, r0, r7
 8004f6c:	2864      	cmp	r0, #100	; 0x64
 8004f6e:	d88d      	bhi.n	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x534>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004f70:	6833      	ldr	r3, [r6, #0]
 8004f72:	011b      	lsls	r3, r3, #4
 8004f74:	d5f7      	bpl.n	8004f66 <HAL_RCCEx_PeriphCLKConfig+0x60e>
 8004f76:	e700      	b.n	8004d7a <HAL_RCCEx_PeriphCLKConfig+0x422>
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 8004f78:	2174      	movs	r1, #116	; 0x74
 8004f7a:	484a      	ldr	r0, [pc, #296]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004f7c:	f015 ff92 	bl	801aea4 <assert_failed>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8004f80:	6823      	ldr	r3, [r4, #0]
 8004f82:	e4f3      	b.n	800496c <HAL_RCCEx_PeriphCLKConfig+0x14>
  uint32_t pllsaiused = 0;
 8004f84:	2500      	movs	r5, #0
      plli2sused = 1;
 8004f86:	2601      	movs	r6, #1
 8004f88:	e51e      	b.n	80049c8 <HAL_RCCEx_PeriphCLKConfig+0x70>
      plli2sused = 1;
 8004f8a:	2601      	movs	r6, #1
 8004f8c:	e536      	b.n	80049fc <HAL_RCCEx_PeriphCLKConfig+0xa4>
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
 8004f8e:	217a      	movs	r1, #122	; 0x7a
 8004f90:	4844      	ldr	r0, [pc, #272]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004f92:	f015 ff87 	bl	801aea4 <assert_failed>
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8004f96:	6b66      	ldr	r6, [r4, #52]	; 0x34
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8004f98:	6823      	ldr	r3, [r4, #0]
 8004f9a:	e4ef      	b.n	800497c <HAL_RCCEx_PeriphCLKConfig+0x24>
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
 8004f9c:	219e      	movs	r1, #158	; 0x9e
 8004f9e:	4841      	ldr	r0, [pc, #260]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fa0:	f015 ff80 	bl	801aea4 <assert_failed>
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8004fa4:	6c21      	ldr	r1, [r4, #64]	; 0x40
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8004fa6:	6823      	ldr	r3, [r4, #0]
 8004fa8:	e518      	b.n	80049dc <HAL_RCCEx_PeriphCLKConfig+0x84>
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
 8004faa:	218a      	movs	r1, #138	; 0x8a
 8004fac:	483d      	ldr	r0, [pc, #244]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fae:	f015 ff79 	bl	801aea4 <assert_failed>
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8004fb2:	6be5      	ldr	r5, [r4, #60]	; 0x3c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8004fb4:	6823      	ldr	r3, [r4, #0]
 8004fb6:	e4f7      	b.n	80049a8 <HAL_RCCEx_PeriphCLKConfig+0x50>
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 8004fb8:	21fd      	movs	r1, #253	; 0xfd
 8004fba:	483a      	ldr	r0, [pc, #232]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fbc:	f015 ff72 	bl	801aea4 <assert_failed>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004fc0:	6e61      	ldr	r1, [r4, #100]	; 0x64
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004fc2:	6823      	ldr	r3, [r4, #0]
 8004fc4:	e5d7      	b.n	8004b76 <HAL_RCCEx_PeriphCLKConfig+0x21e>
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
 8004fc6:	f240 1107 	movw	r1, #263	; 0x107
 8004fca:	4836      	ldr	r0, [pc, #216]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fcc:	f015 ff6a 	bl	801aea4 <assert_failed>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004fd0:	6ea1      	ldr	r1, [r4, #104]	; 0x68
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004fd2:	6823      	ldr	r3, [r4, #0]
 8004fd4:	e5e1      	b.n	8004b9a <HAL_RCCEx_PeriphCLKConfig+0x242>
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
 8004fd6:	f240 1111 	movw	r1, #273	; 0x111
 8004fda:	4832      	ldr	r0, [pc, #200]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fdc:	f015 ff62 	bl	801aea4 <assert_failed>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8004fe0:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004fe2:	6823      	ldr	r3, [r4, #0]
 8004fe4:	e5eb      	b.n	8004bbe <HAL_RCCEx_PeriphCLKConfig+0x266>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8004fe6:	f240 111b 	movw	r1, #283	; 0x11b
 8004fea:	482e      	ldr	r0, [pc, #184]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8004fec:	f015 ff5a 	bl	801aea4 <assert_failed>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004ff0:	6f21      	ldr	r1, [r4, #112]	; 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004ff2:	6823      	ldr	r3, [r4, #0]
 8004ff4:	e5f5      	b.n	8004be2 <HAL_RCCEx_PeriphCLKConfig+0x28a>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004ff6:	482a      	ldr	r0, [pc, #168]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 8004ff8:	492b      	ldr	r1, [pc, #172]	; (80050a8 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8004ffa:	6882      	ldr	r2, [r0, #8]
 8004ffc:	4019      	ands	r1, r3
 8004ffe:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8005002:	430a      	orrs	r2, r1
 8005004:	6082      	str	r2, [r0, #8]
 8005006:	e592      	b.n	8004b2e <HAL_RCCEx_PeriphCLKConfig+0x1d6>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
 8005008:	68e3      	ldr	r3, [r4, #12]
 800500a:	3b02      	subs	r3, #2
 800500c:	2b0d      	cmp	r3, #13
 800500e:	f200 80ca 	bhi.w	80051a6 <HAL_RCCEx_PeriphCLKConfig+0x84e>
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
 8005012:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005014:	1e59      	subs	r1, r3, #1
 8005016:	291f      	cmp	r1, #31
 8005018:	f200 80bd 	bhi.w	8005196 <HAL_RCCEx_PeriphCLKConfig+0x83e>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800501c:	4a20      	ldr	r2, [pc, #128]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x748>)
 800501e:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8005022:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8005026:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800502a:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 800502e:	4303      	orrs	r3, r0
 8005030:	6860      	ldr	r0, [r4, #4]
 8005032:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8005036:	68e0      	ldr	r0, [r4, #12]
 8005038:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800503c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8005040:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8005044:	f023 031f 	bic.w	r3, r3, #31
 8005048:	430b      	orrs	r3, r1
 800504a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800504e:	6823      	ldr	r3, [r4, #0]
 8005050:	e74c      	b.n	8004eec <HAL_RCCEx_PeriphCLKConfig+0x594>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 8005052:	21f3      	movs	r1, #243	; 0xf3
 8005054:	4813      	ldr	r0, [pc, #76]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8005056:	f015 ff25 	bl	801aea4 <assert_failed>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800505a:	6ba7      	ldr	r7, [r4, #56]	; 0x38
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800505c:	6823      	ldr	r3, [r4, #0]
 800505e:	e574      	b.n	8004b4a <HAL_RCCEx_PeriphCLKConfig+0x1f2>
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
 8005060:	f240 11a1 	movw	r1, #417	; 0x1a1
 8005064:	480f      	ldr	r0, [pc, #60]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8005066:	f015 ff1d 	bl	801aea4 <assert_failed>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800506a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800506e:	e674      	b.n	8004d5a <HAL_RCCEx_PeriphCLKConfig+0x402>
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 8005070:	f240 1175 	movw	r1, #373	; 0x175
 8005074:	480b      	ldr	r0, [pc, #44]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8005076:	f015 ff15 	bl	801aea4 <assert_failed>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800507a:	6fa1      	ldr	r1, [r4, #120]	; 0x78
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 800507c:	6823      	ldr	r3, [r4, #0]
 800507e:	e636      	b.n	8004cee <HAL_RCCEx_PeriphCLKConfig+0x396>
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
 8005080:	f240 117f 	movw	r1, #383	; 0x17f
 8005084:	4807      	ldr	r0, [pc, #28]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8005086:	f015 ff0d 	bl	801aea4 <assert_failed>
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800508a:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800508c:	6823      	ldr	r3, [r4, #0]
 800508e:	e63d      	b.n	8004d0c <HAL_RCCEx_PeriphCLKConfig+0x3b4>
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 8005090:	f240 1125 	movw	r1, #293	; 0x125
 8005094:	4803      	ldr	r0, [pc, #12]	; (80050a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>)
 8005096:	f015 ff05 	bl	801aea4 <assert_failed>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800509a:	6c61      	ldr	r1, [r4, #68]	; 0x44
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800509c:	6823      	ldr	r3, [r4, #0]
 800509e:	e5ae      	b.n	8004bfe <HAL_RCCEx_PeriphCLKConfig+0x2a6>
 80050a0:	40023800 	.word	0x40023800
 80050a4:	080216f4 	.word	0x080216f4
 80050a8:	0ffffcff 	.word	0x0ffffcff
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
 80050ac:	f240 1161 	movw	r1, #353	; 0x161
 80050b0:	4873      	ldr	r0, [pc, #460]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050b2:	f015 fef7 	bl	801aea4 <assert_failed>
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 80050b6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 80050b8:	6823      	ldr	r3, [r4, #0]
 80050ba:	e5fa      	b.n	8004cb2 <HAL_RCCEx_PeriphCLKConfig+0x35a>
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
 80050bc:	f240 116b 	movw	r1, #363	; 0x16b
 80050c0:	486f      	ldr	r0, [pc, #444]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050c2:	f015 feef 	bl	801aea4 <assert_failed>
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 80050c6:	6e21      	ldr	r1, [r4, #96]	; 0x60
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 80050c8:	6823      	ldr	r3, [r4, #0]
 80050ca:	e601      	b.n	8004cd0 <HAL_RCCEx_PeriphCLKConfig+0x378>
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
 80050cc:	f240 1197 	movw	r1, #407	; 0x197
 80050d0:	486b      	ldr	r0, [pc, #428]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050d2:	f015 fee7 	bl	801aea4 <assert_failed>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80050d6:	6f61      	ldr	r1, [r4, #116]	; 0x74
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 80050d8:	6823      	ldr	r3, [r4, #0]
 80050da:	e62e      	b.n	8004d3a <HAL_RCCEx_PeriphCLKConfig+0x3e2>
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
 80050dc:	f240 112f 	movw	r1, #303	; 0x12f
 80050e0:	4867      	ldr	r0, [pc, #412]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050e2:	f015 fedf 	bl	801aea4 <assert_failed>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80050e6:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80050e8:	6823      	ldr	r3, [r4, #0]
 80050ea:	e597      	b.n	8004c1c <HAL_RCCEx_PeriphCLKConfig+0x2c4>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
 80050ec:	f44f 71ee 	mov.w	r1, #476	; 0x1dc
 80050f0:	4863      	ldr	r0, [pc, #396]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050f2:	f015 fed7 	bl	801aea4 <assert_failed>
 80050f6:	e6e4      	b.n	8004ec2 <HAL_RCCEx_PeriphCLKConfig+0x56a>
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
 80050f8:	f240 1139 	movw	r1, #313	; 0x139
 80050fc:	4860      	ldr	r0, [pc, #384]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80050fe:	f015 fed1 	bl	801aea4 <assert_failed>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8005102:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8005104:	6823      	ldr	r3, [r4, #0]
 8005106:	e598      	b.n	8004c3a <HAL_RCCEx_PeriphCLKConfig+0x2e2>
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
 8005108:	f240 1143 	movw	r1, #323	; 0x143
 800510c:	485c      	ldr	r0, [pc, #368]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 800510e:	f015 fec9 	bl	801aea4 <assert_failed>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8005112:	6d21      	ldr	r1, [r4, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8005114:	6823      	ldr	r3, [r4, #0]
 8005116:	e59f      	b.n	8004c58 <HAL_RCCEx_PeriphCLKConfig+0x300>
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
 8005118:	f240 114d 	movw	r1, #333	; 0x14d
 800511c:	4858      	ldr	r0, [pc, #352]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 800511e:	f015 fec1 	bl	801aea4 <assert_failed>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8005122:	6d61      	ldr	r1, [r4, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8005124:	6823      	ldr	r3, [r4, #0]
 8005126:	e5a6      	b.n	8004c76 <HAL_RCCEx_PeriphCLKConfig+0x31e>
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
 8005128:	f240 1157 	movw	r1, #343	; 0x157
 800512c:	4854      	ldr	r0, [pc, #336]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 800512e:	f015 feb9 	bl	801aea4 <assert_failed>
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8005132:	6da1      	ldr	r1, [r4, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8005134:	6823      	ldr	r3, [r4, #0]
 8005136:	e5ad      	b.n	8004c94 <HAL_RCCEx_PeriphCLKConfig+0x33c>
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
 8005138:	68a7      	ldr	r7, [r4, #8]
 800513a:	1eba      	subs	r2, r7, #2
 800513c:	2a05      	cmp	r2, #5
 800513e:	d859      	bhi.n	80051f4 <HAL_RCCEx_PeriphCLKConfig+0x89c>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8005140:	4950      	ldr	r1, [pc, #320]	; (8005284 <HAL_RCCEx_PeriphCLKConfig+0x92c>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8005142:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8005144:	f8d1 2084 	ldr.w	r2, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8005148:	f8d1 6084 	ldr.w	r6, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800514c:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8005150:	f006 6670 	and.w	r6, r6, #251658240	; 0xf000000
 8005154:	4332      	orrs	r2, r6
 8005156:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 800515a:	ea42 7207 	orr.w	r2, r2, r7, lsl #28
 800515e:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
 8005162:	e6b5      	b.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x578>
        tickstart = HAL_GetTick();
 8005164:	f7fb ff84 	bl	8001070 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8005168:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 800516c:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800516e:	e006      	b.n	800517e <HAL_RCCEx_PeriphCLKConfig+0x826>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8005170:	f7fb ff7e 	bl	8001070 <HAL_GetTick>
 8005174:	eba0 0008 	sub.w	r0, r0, r8
 8005178:	4548      	cmp	r0, r9
 800517a:	f63f ae87 	bhi.w	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x534>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800517e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8005180:	0799      	lsls	r1, r3, #30
 8005182:	d5f5      	bpl.n	8005170 <HAL_RCCEx_PeriphCLKConfig+0x818>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8005184:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005186:	f403 7140 	and.w	r1, r3, #768	; 0x300
 800518a:	e4c7      	b.n	8004b1c <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800518c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800518e:	2a00      	cmp	r2, #0
 8005190:	f43f ae1a 	beq.w	8004dc8 <HAL_RCCEx_PeriphCLKConfig+0x470>
 8005194:	e614      	b.n	8004dc0 <HAL_RCCEx_PeriphCLKConfig+0x468>
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
 8005196:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800519a:	4839      	ldr	r0, [pc, #228]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 800519c:	f015 fe82 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80051a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80051a2:	1e59      	subs	r1, r3, #1
 80051a4:	e73a      	b.n	800501c <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
 80051a6:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
 80051aa:	4835      	ldr	r0, [pc, #212]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051ac:	f015 fe7a 	bl	801aea4 <assert_failed>
 80051b0:	e72f      	b.n	8005012 <HAL_RCCEx_PeriphCLKConfig+0x6ba>
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
 80051b2:	f240 2146 	movw	r1, #582	; 0x246
 80051b6:	4832      	ldr	r0, [pc, #200]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051b8:	f015 fe74 	bl	801aea4 <assert_failed>
 80051bc:	e5fc      	b.n	8004db8 <HAL_RCCEx_PeriphCLKConfig+0x460>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
 80051be:	f44f 7106 	mov.w	r1, #536	; 0x218
 80051c2:	482f      	ldr	r0, [pc, #188]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051c4:	f015 fe6e 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80051c8:	68e2      	ldr	r2, [r4, #12]
 80051ca:	e6b6      	b.n	8004f3a <HAL_RCCEx_PeriphCLKConfig+0x5e2>
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
 80051cc:	f240 2117 	movw	r1, #535	; 0x217
 80051d0:	482b      	ldr	r0, [pc, #172]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051d2:	f015 fe67 	bl	801aea4 <assert_failed>
 80051d6:	e6ab      	b.n	8004f30 <HAL_RCCEx_PeriphCLKConfig+0x5d8>
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
 80051d8:	f240 2116 	movw	r1, #534	; 0x216
 80051dc:	4828      	ldr	r0, [pc, #160]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051de:	f015 fe61 	bl	801aea4 <assert_failed>
 80051e2:	e6a0      	b.n	8004f26 <HAL_RCCEx_PeriphCLKConfig+0x5ce>
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
 80051e4:	f240 2107 	movw	r1, #519	; 0x207
 80051e8:	4825      	ldr	r0, [pc, #148]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051ea:	f015 fe5b 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 80051ee:	6927      	ldr	r7, [r4, #16]
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80051f0:	6823      	ldr	r3, [r4, #0]
 80051f2:	e681      	b.n	8004ef8 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
 80051f4:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
 80051f8:	4821      	ldr	r0, [pc, #132]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 80051fa:	f015 fe53 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 80051fe:	68a7      	ldr	r7, [r4, #8]
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8005200:	6823      	ldr	r3, [r4, #0]
 8005202:	e79d      	b.n	8005140 <HAL_RCCEx_PeriphCLKConfig+0x7e8>
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
 8005204:	6a20      	ldr	r0, [r4, #32]
 8005206:	2803      	cmp	r0, #3
 8005208:	d82c      	bhi.n	8005264 <HAL_RCCEx_PeriphCLKConfig+0x90c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800520a:	491e      	ldr	r1, [pc, #120]	; (8005284 <HAL_RCCEx_PeriphCLKConfig+0x92c>)
 800520c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8005210:	f8d1 5088 	ldr.w	r5, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8005214:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8005218:	f005 45e0 	and.w	r5, r5, #1879048192	; 0x70000000
 800521c:	432a      	orrs	r2, r5
 800521e:	6965      	ldr	r5, [r4, #20]
 8005220:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8005224:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8005228:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
 800522c:	e5f8      	b.n	8004e20 <HAL_RCCEx_PeriphCLKConfig+0x4c8>
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
 800522e:	f240 2171 	movw	r1, #625	; 0x271
 8005232:	4813      	ldr	r0, [pc, #76]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005234:	f015 fe36 	bl	801aea4 <assert_failed>
 8005238:	e5f9      	b.n	8004e2e <HAL_RCCEx_PeriphCLKConfig+0x4d6>
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
 800523a:	f240 214f 	movw	r1, #591	; 0x24f
 800523e:	4810      	ldr	r0, [pc, #64]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005240:	f015 fe30 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8005244:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005246:	1e59      	subs	r1, r3, #1
 8005248:	e5c8      	b.n	8004ddc <HAL_RCCEx_PeriphCLKConfig+0x484>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
 800524a:	f240 214d 	movw	r1, #589	; 0x24d
 800524e:	480c      	ldr	r0, [pc, #48]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005250:	f015 fe28 	bl	801aea4 <assert_failed>
 8005254:	e5bd      	b.n	8004dd2 <HAL_RCCEx_PeriphCLKConfig+0x47a>
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
 8005256:	480a      	ldr	r0, [pc, #40]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005258:	f240 2172 	movw	r1, #626	; 0x272
 800525c:	f015 fe22 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8005260:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005262:	e5e9      	b.n	8004e38 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
 8005264:	4806      	ldr	r0, [pc, #24]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005266:	f240 2162 	movw	r1, #610	; 0x262
 800526a:	f015 fe1b 	bl	801aea4 <assert_failed>
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 800526e:	6a20      	ldr	r0, [r4, #32]
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8005270:	6823      	ldr	r3, [r4, #0]
 8005272:	e7ca      	b.n	800520a <HAL_RCCEx_PeriphCLKConfig+0x8b2>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 8005274:	21b9      	movs	r1, #185	; 0xb9
 8005276:	4802      	ldr	r0, [pc, #8]	; (8005280 <HAL_RCCEx_PeriphCLKConfig+0x928>)
 8005278:	f015 fe14 	bl	801aea4 <assert_failed>
 800527c:	e40d      	b.n	8004a9a <HAL_RCCEx_PeriphCLKConfig+0x142>
 800527e:	bf00      	nop
 8005280:	080216f4 	.word	0x080216f4
 8005284:	40023800 	.word	0x40023800

08005288 <HAL_RCCEx_GetPeriphCLKConfig>:
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48;
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the PLLI2S Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 8005288:	4b53      	ldr	r3, [pc, #332]	; (80053d8 <HAL_RCCEx_GetPeriphCLKConfig+0x150>)
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
 800528a:	4a54      	ldr	r2, [pc, #336]	; (80053dc <HAL_RCCEx_GetPeriphCLKConfig+0x154>)
 800528c:	6002      	str	r2, [r0, #0]
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 800528e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8005292:	f3c2 1288 	ubfx	r2, r2, #6, #9
 8005296:	6042      	str	r2, [r0, #4]
  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8005298:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800529c:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80052a0:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 80052a2:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80052a6:	f3c2 6203 	ubfx	r2, r2, #24, #4
 80052aa:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80052ac:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80052b0:	f3c2 7202 	ubfx	r2, r2, #28, #3
 80052b4:	6082      	str	r2, [r0, #8]

  /* Get the PLLSAI Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
 80052b6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80052ba:	f3c2 1288 	ubfx	r2, r2, #6, #9
 80052be:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80052c0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80052c4:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80052c8:	6202      	str	r2, [r0, #32]
  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80052ca:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80052ce:	f3c2 6203 	ubfx	r2, r2, #24, #4
 80052d2:	6182      	str	r2, [r0, #24]
  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 80052d4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80052d8:	f3c2 7202 	ubfx	r2, r2, #28, #3
 80052dc:	61c2      	str	r2, [r0, #28]

  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/
  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);
 80052de:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80052e2:	f002 021f 	and.w	r2, r2, #31
 80052e6:	6242      	str	r2, [r0, #36]	; 0x24
  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);
 80052e8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80052ec:	f3c2 2204 	ubfx	r2, r2, #8, #5
 80052f0:	6282      	str	r2, [r0, #40]	; 0x28
  PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> RCC_DCKCFGR1_PLLSAIDIVR_Pos);
 80052f2:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80052f6:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80052fa:	62c2      	str	r2, [r0, #44]	; 0x2c

  /* Get the SAI1 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
 80052fc:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8005300:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8005304:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Get the SAI2 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
 8005306:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800530a:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 800530e:	6402      	str	r2, [r0, #64]	; 0x40

  /* Get the I2S clock configuration ------------------------------------------*/
  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();
 8005310:	689a      	ldr	r2, [r3, #8]
 8005312:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 8005316:	6342      	str	r2, [r0, #52]	; 0x34

  /* Get the I2C1 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
 8005318:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800531c:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8005320:	6642      	str	r2, [r0, #100]	; 0x64

  /* Get the I2C2 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
 8005322:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005326:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 800532a:	6682      	str	r2, [r0, #104]	; 0x68

  /* Get the I2C3 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
 800532c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005330:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8005334:	66c2      	str	r2, [r0, #108]	; 0x6c

  /* Get the I2C4 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
 8005336:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800533a:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 800533e:	6702      	str	r2, [r0, #112]	; 0x70

  /* Get the USART1 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
 8005340:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005344:	f002 0203 	and.w	r2, r2, #3
 8005348:	6442      	str	r2, [r0, #68]	; 0x44

  /* Get the USART2 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
 800534a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800534e:	f002 020c 	and.w	r2, r2, #12
 8005352:	6482      	str	r2, [r0, #72]	; 0x48

  /* Get the USART3 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
 8005354:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005358:	f002 0230 	and.w	r2, r2, #48	; 0x30
 800535c:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Get the UART4 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
 800535e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005362:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8005366:	6502      	str	r2, [r0, #80]	; 0x50

  /* Get the UART5 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
 8005368:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800536c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8005370:	6542      	str	r2, [r0, #84]	; 0x54

  /* Get the USART6 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
 8005372:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005376:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 800537a:	6582      	str	r2, [r0, #88]	; 0x58

  /* Get the UART7 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
 800537c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005380:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8005384:	65c2      	str	r2, [r0, #92]	; 0x5c

  /* Get the UART8 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
 8005386:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800538a:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 800538e:	6602      	str	r2, [r0, #96]	; 0x60

  /* Get the LPTIM1 clock configuration ------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
 8005390:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005394:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
 8005398:	6742      	str	r2, [r0, #116]	; 0x74

  /* Get the CEC clock configuration -----------------------------------------------*/
  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
 800539a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800539e:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 80053a2:	6782      	str	r2, [r0, #120]	; 0x78

  /* Get the CK48 clock configuration -----------------------------------------------*/
  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();
 80053a4:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80053a8:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 80053ac:	67c2      	str	r2, [r0, #124]	; 0x7c

  /* Get the SDMMC1 clock configuration -----------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
 80053ae:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80053b2:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80053b6:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
  /* Get the DFSDM AUDIO clock configuration -----------------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the RTC Clock configuration -----------------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 80053ba:	6899      	ldr	r1, [r3, #8]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 80053bc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 80053be:	f401 11f8 	and.w	r1, r1, #2031616	; 0x1f0000
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 80053c2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80053c6:	430a      	orrs	r2, r1
 80053c8:	6302      	str	r2, [r0, #48]	; 0x30

  /* Get the TIM Prescaler configuration --------------------------------------------*/
  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)
 80053ca:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
 80053ce:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80053d2:	6383      	str	r3, [r0, #56]	; 0x38
  }
}
 80053d4:	4770      	bx	lr
 80053d6:	bf00      	nop
 80053d8:	40023800 	.word	0x40023800
 80053dc:	00fffff1 	.word	0x00fffff1

080053e0 <HAL_RCCEx_GetPeriphCLKFreq>:
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 80053e0:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 80053e4:	d02f      	beq.n	8005446 <HAL_RCCEx_GetPeriphCLKFreq+0x66>
        break;
      }
    }
  }

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
 80053e6:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 80053ea:	d12a      	bne.n	8005442 <HAL_RCCEx_GetPeriphCLKFreq+0x62>
  {
    saiclocksource = RCC->DCKCFGR1;
 80053ec:	4a2c      	ldr	r2, [pc, #176]	; (80054a0 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>)
 80053ee:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
 80053f2:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
    switch (saiclocksource)
 80053f6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80053fa:	d031      	beq.n	8005460 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
 80053fc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8005400:	d02c      	beq.n	800545c <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
 8005402:	b9f3      	cbnz	r3, 8005442 <HAL_RCCEx_GetPeriphCLKFreq+0x62>
    {
    case 0: /* PLLSAI is the clock source for SAI*/
      {
        /* Configure the PLLSAI division factor */
        /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005404:	6853      	ldr	r3, [r2, #4]
        {
          /* In Case the PLL Source is HSI (Internal Clock) */
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005406:	6851      	ldr	r1, [r2, #4]
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005408:	025a      	lsls	r2, r3, #9
          /* In Case the PLL Source is HSE (External Clock) */
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
        }
        /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
        /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 800540a:	4b25      	ldr	r3, [pc, #148]	; (80054a0 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>)
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 800540c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005410:	bf54      	ite	pl
 8005412:	4824      	ldrpl	r0, [pc, #144]	; (80054a4 <HAL_RCCEx_GetPeriphCLKFreq+0xc4>)
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8005414:	4824      	ldrmi	r0, [pc, #144]	; (80054a8 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 8005416:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 800541a:	fbb0 f1f1 	udiv	r1, r0, r1
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 800541e:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 8005422:	f3c2 6203 	ubfx	r2, r2, #24, #4

        /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 8005426:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 800542a:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 800542e:	f3c3 2304 	ubfx	r3, r3, #8, #5
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 8005432:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 8005436:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 8005438:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 800543c:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 8005440:	4770      	bx	lr
    switch (saiclocksource)
 8005442:	2000      	movs	r0, #0
      }
    }
  }

  return frequency;
}
 8005444:	4770      	bx	lr
    saiclocksource = RCC->DCKCFGR1;
 8005446:	4a16      	ldr	r2, [pc, #88]	; (80054a0 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>)
 8005448:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
 800544c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
    switch (saiclocksource)
 8005450:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005454:	d004      	beq.n	8005460 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
 8005456:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800545a:	d1d2      	bne.n	8005402 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
        frequency = EXTERNAL_CLOCK_VALUE;
 800545c:	4813      	ldr	r0, [pc, #76]	; (80054ac <HAL_RCCEx_GetPeriphCLKFreq+0xcc>)
 800545e:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005460:	6853      	ldr	r3, [r2, #4]
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005462:	6851      	ldr	r1, [r2, #4]
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005464:	025b      	lsls	r3, r3, #9
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8005466:	4b0e      	ldr	r3, [pc, #56]	; (80054a0 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>)
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8005468:	f001 013f 	and.w	r1, r1, #63	; 0x3f
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 800546c:	bf54      	ite	pl
 800546e:	480d      	ldrpl	r0, [pc, #52]	; (80054a4 <HAL_RCCEx_GetPeriphCLKFreq+0xc4>)
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8005470:	480d      	ldrmi	r0, [pc, #52]	; (80054a8 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8005472:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8005476:	fbb0 f1f1 	udiv	r1, r0, r1
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 800547a:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 800547e:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 8005482:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8005486:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 800548a:	f003 031f 	and.w	r3, r3, #31
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 800548e:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 8005492:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8005494:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 8005498:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 800549c:	4770      	bx	lr
 800549e:	bf00      	nop
 80054a0:	40023800 	.word	0x40023800
 80054a4:	00f42400 	.word	0x00f42400
 80054a8:	017d7840 	.word	0x017d7840
 80054ac:	00bb8000 	.word	0x00bb8000

080054b0 <HAL_SAI_Init>:
  uint32_t tmpregisterGCR = 0;
  uint32_t ckstr_bits = 0;
  uint32_t syncen_bits = 0;

  /* Check the SAI handle allocation */
  if(hsai == NULL)
 80054b0:	2800      	cmp	r0, #0
 80054b2:	f000 827f 	beq.w	80059b4 <HAL_SAI_Init+0x504>
  {
    return HAL_ERROR;
  }

  /* check the instance */
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 80054b6:	6802      	ldr	r2, [r0, #0]
 80054b8:	49ae      	ldr	r1, [pc, #696]	; (8005774 <HAL_SAI_Init+0x2c4>)
{
 80054ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 80054bc:	4bae      	ldr	r3, [pc, #696]	; (8005778 <HAL_SAI_Init+0x2c8>)
 80054be:	4604      	mov	r4, r0
 80054c0:	48ae      	ldr	r0, [pc, #696]	; (800577c <HAL_SAI_Init+0x2cc>)
 80054c2:	429a      	cmp	r2, r3
 80054c4:	bf18      	it	ne
 80054c6:	4282      	cmpne	r2, r0
 80054c8:	bf14      	ite	ne
 80054ca:	2301      	movne	r3, #1
 80054cc:	2300      	moveq	r3, #0
 80054ce:	428a      	cmp	r2, r1
 80054d0:	bf0c      	ite	eq
 80054d2:	2300      	moveq	r3, #0
 80054d4:	f003 0301 	andne.w	r3, r3, #1
 80054d8:	b11b      	cbz	r3, 80054e2 <HAL_SAI_Init+0x32>
 80054da:	4ba9      	ldr	r3, [pc, #676]	; (8005780 <HAL_SAI_Init+0x2d0>)
 80054dc:	429a      	cmp	r2, r3
 80054de:	f040 8232 	bne.w	8005946 <HAL_SAI_Init+0x496>

  /* Check the SAI Block parameters */
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 80054e2:	69e2      	ldr	r2, [r4, #28]
 80054e4:	f64b 3180 	movw	r1, #48000	; 0xbb80
 80054e8:	4ba6      	ldr	r3, [pc, #664]	; (8005784 <HAL_SAI_Init+0x2d4>)
 80054ea:	48a7      	ldr	r0, [pc, #668]	; (8005788 <HAL_SAI_Init+0x2d8>)
 80054ec:	429a      	cmp	r2, r3
 80054ee:	bf18      	it	ne
 80054f0:	4282      	cmpne	r2, r0
 80054f2:	f64a 4044 	movw	r0, #44100	; 0xac44
 80054f6:	bf14      	ite	ne
 80054f8:	2301      	movne	r3, #1
 80054fa:	2300      	moveq	r3, #0
 80054fc:	428a      	cmp	r2, r1
 80054fe:	bf0c      	ite	eq
 8005500:	2300      	moveq	r3, #0
 8005502:	f003 0301 	andne.w	r3, r3, #1
 8005506:	f245 6122 	movw	r1, #22050	; 0x5622
 800550a:	4282      	cmp	r2, r0
 800550c:	bf0c      	ite	eq
 800550e:	2300      	moveq	r3, #0
 8005510:	f003 0301 	andne.w	r3, r3, #1
 8005514:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
 8005518:	bf0c      	ite	eq
 800551a:	2300      	moveq	r3, #0
 800551c:	f003 0301 	andne.w	r3, r3, #1
 8005520:	428a      	cmp	r2, r1
 8005522:	bf0c      	ite	eq
 8005524:	2300      	moveq	r3, #0
 8005526:	f003 0301 	andne.w	r3, r3, #1
 800552a:	f642 3111 	movw	r1, #11025	; 0x2b11
 800552e:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
 8005532:	bf0c      	ite	eq
 8005534:	2300      	moveq	r3, #0
 8005536:	f003 0301 	andne.w	r3, r3, #1
 800553a:	428a      	cmp	r2, r1
 800553c:	bf0c      	ite	eq
 800553e:	2300      	moveq	r3, #0
 8005540:	f003 0301 	andne.w	r3, r3, #1
 8005544:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
 8005548:	bf0c      	ite	eq
 800554a:	2300      	moveq	r3, #0
 800554c:	f003 0301 	andne.w	r3, r3, #1
 8005550:	b113      	cbz	r3, 8005558 <HAL_SAI_Init+0xa8>
 8005552:	2a00      	cmp	r2, #0
 8005554:	f040 8230 	bne.w	80059b8 <HAL_SAI_Init+0x508>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
 8005558:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800555a:	f033 0204 	bics.w	r2, r3, #4
 800555e:	d002      	beq.n	8005566 <HAL_SAI_Init+0xb6>
 8005560:	2b08      	cmp	r3, #8
 8005562:	f040 817e 	bne.w	8005862 <HAL_SAI_Init+0x3b2>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 8005566:	6863      	ldr	r3, [r4, #4]
 8005568:	2b03      	cmp	r3, #3
 800556a:	f200 8183 	bhi.w	8005874 <HAL_SAI_Init+0x3c4>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800556e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005570:	f023 0220 	bic.w	r2, r3, #32
 8005574:	2a80      	cmp	r2, #128	; 0x80
 8005576:	d004      	beq.n	8005582 <HAL_SAI_Init+0xd2>
 8005578:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800557c:	2b40      	cmp	r3, #64	; 0x40
 800557e:	f040 81ee 	bne.w	800595e <HAL_SAI_Init+0x4ae>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 8005582:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005584:	f433 7380 	bics.w	r3, r3, #256	; 0x100
 8005588:	f040 81a7 	bne.w	80058da <HAL_SAI_Init+0x42a>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
 800558c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800558e:	2b01      	cmp	r3, #1
 8005590:	f200 80b9 	bhi.w	8005706 <HAL_SAI_Init+0x256>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 8005594:	68a3      	ldr	r3, [r4, #8]
 8005596:	2b03      	cmp	r3, #3
 8005598:	f200 80be 	bhi.w	8005718 <HAL_SAI_Init+0x268>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 800559c:	6923      	ldr	r3, [r4, #16]
 800559e:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
 80055a2:	f040 80c3 	bne.w	800572c <HAL_SAI_Init+0x27c>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 80055a6:	6963      	ldr	r3, [r4, #20]
 80055a8:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 80055ac:	f040 80c8 	bne.w	8005740 <HAL_SAI_Init+0x290>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 80055b0:	69a3      	ldr	r3, [r4, #24]
 80055b2:	2b04      	cmp	r3, #4
 80055b4:	f200 80cd 	bhi.w	8005752 <HAL_SAI_Init+0x2a2>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 80055b8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80055ba:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 80055be:	f040 80d2 	bne.w	8005766 <HAL_SAI_Init+0x2b6>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 80055c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80055c4:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 80055c8:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 80055cc:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
 80055d0:	bf18      	it	ne
 80055d2:	2a00      	cmpne	r2, #0
 80055d4:	d003      	beq.n	80055de <HAL_SAI_Init+0x12e>
 80055d6:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 80055da:	f040 81ba 	bne.w	8005952 <HAL_SAI_Init+0x4a2>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 80055de:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80055e0:	f033 0310 	bics.w	r3, r3, #16
 80055e4:	f040 81a9 	bne.w	800593a <HAL_SAI_Init+0x48a>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 80055e8:	68e3      	ldr	r3, [r4, #12]
 80055ea:	2b02      	cmp	r3, #2
 80055ec:	f200 819f 	bhi.w	800592e <HAL_SAI_Init+0x47e>

  /* Check the SAI Block Frame parameters */
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 80055f0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80055f2:	3b08      	subs	r3, #8
 80055f4:	2bf8      	cmp	r3, #248	; 0xf8
 80055f6:	f200 8194 	bhi.w	8005922 <HAL_SAI_Init+0x472>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 80055fa:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80055fc:	3b01      	subs	r3, #1
 80055fe:	2b7f      	cmp	r3, #127	; 0x7f
 8005600:	f200 8189 	bhi.w	8005916 <HAL_SAI_Init+0x466>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 8005604:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005606:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
 800560a:	f040 817e 	bne.w	800590a <HAL_SAI_Init+0x45a>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 800560e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8005610:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 8005614:	f040 8173 	bne.w	80058fe <HAL_SAI_Init+0x44e>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 8005618:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800561a:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
 800561e:	f040 8168 	bne.w	80058f2 <HAL_SAI_Init+0x442>

  /* Check the SAI Block Slot parameters */
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 8005622:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8005624:	2b18      	cmp	r3, #24
 8005626:	f200 815e 	bhi.w	80058e6 <HAL_SAI_Init+0x436>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
 800562a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800562c:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 8005630:	d002      	beq.n	8005638 <HAL_SAI_Init+0x188>
 8005632:	2b80      	cmp	r3, #128	; 0x80
 8005634:	f040 8124 	bne.w	8005880 <HAL_SAI_Init+0x3d0>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 8005638:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800563a:	3b01      	subs	r3, #1
 800563c:	2b0f      	cmp	r3, #15
 800563e:	f200 8129 	bhi.w	8005894 <HAL_SAI_Init+0x3e4>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 8005642:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8005644:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005648:	f080 812e 	bcs.w	80058a8 <HAL_SAI_Init+0x3f8>

  if(hsai->State == HAL_SAI_STATE_RESET)
 800564c:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 8005650:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005654:	2b00      	cmp	r3, #0
 8005656:	f000 8133 	beq.w	80058c0 <HAL_SAI_Init+0x410>
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 800565a:	4b4c      	ldr	r3, [pc, #304]	; (800578c <HAL_SAI_Init+0x2dc>)
  hsai->State = HAL_SAI_STATE_BUSY;
 800565c:	2002      	movs	r0, #2
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 800565e:	494c      	ldr	r1, [pc, #304]	; (8005790 <HAL_SAI_Init+0x2e0>)
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 8005660:	6822      	ldr	r2, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005662:	681b      	ldr	r3, [r3, #0]
  hsai->State = HAL_SAI_STATE_BUSY;
 8005664:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005668:	fba1 1303 	umull	r1, r3, r1, r3
  __HAL_SAI_DISABLE(hsai);
 800566c:	6811      	ldr	r1, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 800566e:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8005670:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005674:	4083      	lsls	r3, r0
  __HAL_SAI_DISABLE(hsai);
 8005676:	6011      	str	r1, [r2, #0]
 8005678:	e002      	b.n	8005680 <HAL_SAI_Init+0x1d0>
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
      status = HAL_TIMEOUT;
      break;
    }
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 800567a:	6811      	ldr	r1, [r2, #0]
 800567c:	03ce      	lsls	r6, r1, #15
 800567e:	d507      	bpl.n	8005690 <HAL_SAI_Init+0x1e0>
    if (count-- == 0)
 8005680:	3b01      	subs	r3, #1
 8005682:	d2fa      	bcs.n	800567a <HAL_SAI_Init+0x1ca>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8005684:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8005688:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800568c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  switch(hsai->Init.SynchroExt)
 8005690:	68e3      	ldr	r3, [r4, #12]
 8005692:	2b01      	cmp	r3, #1
 8005694:	f000 811e 	beq.w	80058d4 <HAL_SAI_Init+0x424>
 8005698:	2b02      	cmp	r3, #2
 800569a:	bf15      	itete	ne
 800569c:	2001      	movne	r0, #1
 800569e:	2021      	moveq	r0, #33	; 0x21
 80056a0:	2100      	movne	r1, #0
 80056a2:	2120      	moveq	r1, #32
  switch(hsai->Init.Synchro)
 80056a4:	68a3      	ldr	r3, [r4, #8]
 80056a6:	2b02      	cmp	r3, #2
 80056a8:	f000 8111 	beq.w	80058ce <HAL_SAI_Init+0x41e>
 80056ac:	2b03      	cmp	r3, #3
 80056ae:	f000 810d 	beq.w	80058cc <HAL_SAI_Init+0x41c>
 80056b2:	2b01      	cmp	r3, #1
 80056b4:	bf14      	ite	ne
 80056b6:	2500      	movne	r5, #0
 80056b8:	f44f 6580 	moveq.w	r5, #1024	; 0x400
  if((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 80056bc:	4b2e      	ldr	r3, [pc, #184]	; (8005778 <HAL_SAI_Init+0x2c8>)
 80056be:	429a      	cmp	r2, r3
 80056c0:	d06c      	beq.n	800579c <HAL_SAI_Init+0x2ec>
 80056c2:	3320      	adds	r3, #32
 80056c4:	429a      	cmp	r2, r3
 80056c6:	d069      	beq.n	800579c <HAL_SAI_Init+0x2ec>
    SAI2->GCR = tmpregisterGCR;
 80056c8:	4b32      	ldr	r3, [pc, #200]	; (8005794 <HAL_SAI_Init+0x2e4>)
 80056ca:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
  if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 80056ce:	69e3      	ldr	r3, [r4, #28]
 80056d0:	2b00      	cmp	r3, #0
 80056d2:	d06a      	beq.n	80057aa <HAL_SAI_Init+0x2fa>
    if((hsai->Instance == SAI2_Block_A ) || (hsai->Instance == SAI2_Block_B ))
 80056d4:	4b27      	ldr	r3, [pc, #156]	; (8005774 <HAL_SAI_Init+0x2c4>)
 80056d6:	429a      	cmp	r2, r3
 80056d8:	f000 8152 	beq.w	8005980 <HAL_SAI_Init+0x4d0>
 80056dc:	3320      	adds	r3, #32
 80056de:	1ad3      	subs	r3, r2, r3
 80056e0:	fab3 f383 	clz	r3, r3
 80056e4:	095b      	lsrs	r3, r3, #5
 80056e6:	2b00      	cmp	r3, #0
 80056e8:	f040 814a 	bne.w	8005980 <HAL_SAI_Init+0x4d0>
    hsai->Init.Mckdiv = tmpval / 10;
 80056ec:	4619      	mov	r1, r3
 80056ee:	6223      	str	r3, [r4, #32]
  if((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 80056f0:	6863      	ldr	r3, [r4, #4]
 80056f2:	f033 0002 	bics.w	r0, r3, #2
 80056f6:	d05e      	beq.n	80057b6 <HAL_SAI_Init+0x306>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 80056f8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80056fa:	2801      	cmp	r0, #1
 80056fc:	bf14      	ite	ne
 80056fe:	2000      	movne	r0, #0
 8005700:	f44f 7000 	moveq.w	r0, #512	; 0x200
 8005704:	e05c      	b.n	80057c0 <HAL_SAI_Init+0x310>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
 8005706:	f44f 71bc 	mov.w	r1, #376	; 0x178
 800570a:	4823      	ldr	r0, [pc, #140]	; (8005798 <HAL_SAI_Init+0x2e8>)
 800570c:	f015 fbca 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 8005710:	68a3      	ldr	r3, [r4, #8]
 8005712:	2b03      	cmp	r3, #3
 8005714:	f67f af42 	bls.w	800559c <HAL_SAI_Init+0xec>
 8005718:	f240 1179 	movw	r1, #377	; 0x179
 800571c:	481e      	ldr	r0, [pc, #120]	; (8005798 <HAL_SAI_Init+0x2e8>)
 800571e:	f015 fbc1 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 8005722:	6923      	ldr	r3, [r4, #16]
 8005724:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
 8005728:	f43f af3d 	beq.w	80055a6 <HAL_SAI_Init+0xf6>
 800572c:	f44f 71bd 	mov.w	r1, #378	; 0x17a
 8005730:	4819      	ldr	r0, [pc, #100]	; (8005798 <HAL_SAI_Init+0x2e8>)
 8005732:	f015 fbb7 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 8005736:	6963      	ldr	r3, [r4, #20]
 8005738:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 800573c:	f43f af38 	beq.w	80055b0 <HAL_SAI_Init+0x100>
 8005740:	f240 117b 	movw	r1, #379	; 0x17b
 8005744:	4814      	ldr	r0, [pc, #80]	; (8005798 <HAL_SAI_Init+0x2e8>)
 8005746:	f015 fbad 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 800574a:	69a3      	ldr	r3, [r4, #24]
 800574c:	2b04      	cmp	r3, #4
 800574e:	f67f af33 	bls.w	80055b8 <HAL_SAI_Init+0x108>
 8005752:	f44f 71be 	mov.w	r1, #380	; 0x17c
 8005756:	4810      	ldr	r0, [pc, #64]	; (8005798 <HAL_SAI_Init+0x2e8>)
 8005758:	f015 fba4 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 800575c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800575e:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8005762:	f43f af2e 	beq.w	80055c2 <HAL_SAI_Init+0x112>
 8005766:	f240 117d 	movw	r1, #381	; 0x17d
 800576a:	480b      	ldr	r0, [pc, #44]	; (8005798 <HAL_SAI_Init+0x2e8>)
 800576c:	f015 fb9a 	bl	801aea4 <assert_failed>
 8005770:	e727      	b.n	80055c2 <HAL_SAI_Init+0x112>
 8005772:	bf00      	nop
 8005774:	40015c04 	.word	0x40015c04
 8005778:	40015804 	.word	0x40015804
 800577c:	40015824 	.word	0x40015824
 8005780:	40015c24 	.word	0x40015c24
 8005784:	0002ee00 	.word	0x0002ee00
 8005788:	00017700 	.word	0x00017700
 800578c:	20000078 	.word	0x20000078
 8005790:	95cbec1b 	.word	0x95cbec1b
 8005794:	40015000 	.word	0x40015000
 8005798:	08021730 	.word	0x08021730
    SAI1->GCR = tmpregisterGCR;
 800579c:	4b89      	ldr	r3, [pc, #548]	; (80059c4 <HAL_SAI_Init+0x514>)
 800579e:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
  if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 80057a2:	69e3      	ldr	r3, [r4, #28]
 80057a4:	2b00      	cmp	r3, #0
 80057a6:	f040 80e0 	bne.w	800596a <HAL_SAI_Init+0x4ba>
                        hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 80057aa:	6a23      	ldr	r3, [r4, #32]
 80057ac:	0519      	lsls	r1, r3, #20
  if((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 80057ae:	6863      	ldr	r3, [r4, #4]
 80057b0:	f033 0002 	bics.w	r0, r3, #2
 80057b4:	d1a0      	bne.n	80056f8 <HAL_SAI_Init+0x248>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 80057b6:	6be6      	ldr	r6, [r4, #60]	; 0x3c
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 80057b8:	2e01      	cmp	r6, #1
 80057ba:	bf18      	it	ne
 80057bc:	f44f 7000 	movne.w	r0, #512	; 0x200
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057c0:	6b26      	ldr	r6, [r4, #48]	; 0x30
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80057c2:	6817      	ldr	r7, [r2, #0]
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057c4:	4333      	orrs	r3, r6
 80057c6:	6b66      	ldr	r6, [r4, #52]	; 0x34
 80057c8:	4333      	orrs	r3, r6
                        hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 80057ca:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 80057cc:	4333      	orrs	r3, r6
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057ce:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80057d0:	4333      	orrs	r3, r6
 80057d2:	6926      	ldr	r6, [r4, #16]
 80057d4:	4333      	orrs	r3, r6
 80057d6:	6966      	ldr	r6, [r4, #20]
 80057d8:	4333      	orrs	r3, r6
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80057da:	4e7b      	ldr	r6, [pc, #492]	; (80059c8 <HAL_SAI_Init+0x518>)
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057dc:	432b      	orrs	r3, r5
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80057de:	403e      	ands	r6, r7
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80057e0:	4d7a      	ldr	r5, [pc, #488]	; (80059cc <HAL_SAI_Init+0x51c>)
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057e2:	430b      	orrs	r3, r1
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80057e4:	69a1      	ldr	r1, [r4, #24]
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80057e6:	6016      	str	r6, [r2, #0]
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057e8:	6816      	ldr	r6, [r2, #0]
 80057ea:	4333      	orrs	r3, r6
 80057ec:	4303      	orrs	r3, r0
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80057ee:	4878      	ldr	r0, [pc, #480]	; (80059d0 <HAL_SAI_Init+0x520>)
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80057f0:	6013      	str	r3, [r2, #0]
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80057f2:	6853      	ldr	r3, [r2, #4]
 80057f4:	401d      	ands	r5, r3
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80057f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80057f8:	4319      	orrs	r1, r3
 80057fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80057fc:	6055      	str	r5, [r2, #4]
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80057fe:	4319      	orrs	r1, r3
 8005800:	6855      	ldr	r5, [r2, #4]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8005802:	6d23      	ldr	r3, [r4, #80]	; 0x50
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8005804:	4329      	orrs	r1, r5
 8005806:	6051      	str	r1, [r2, #4]
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8005808:	6891      	ldr	r1, [r2, #8]
 800580a:	4008      	ands	r0, r1
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 800580c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800580e:	430b      	orrs	r3, r1
 8005810:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8005812:	6090      	str	r0, [r2, #8]
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8005814:	f24f 0020 	movw	r0, #61472	; 0xf020
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8005818:	430b      	orrs	r3, r1
 800581a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800581c:	6895      	ldr	r5, [r2, #8]
 800581e:	3901      	subs	r1, #1
 8005820:	430b      	orrs	r3, r1
                          ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
 8005822:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8005824:	3901      	subs	r1, #1
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8005826:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800582a:	432b      	orrs	r3, r5
 800582c:	6093      	str	r3, [r2, #8]
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 800582e:	68d1      	ldr	r1, [r2, #12]
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8005830:	e9d4 3515 	ldrd	r3, r5, [r4, #84]	; 0x54
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8005834:	4001      	ands	r1, r0
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8005836:	432b      	orrs	r3, r5
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8005838:	60d1      	str	r1, [r2, #12]
                          | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 800583a:	6e21      	ldr	r1, [r4, #96]	; 0x60
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 800583c:	68d0      	ldr	r0, [r2, #12]
 800583e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                          | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 8005842:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8005844:	3901      	subs	r1, #1
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8005846:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800584a:	2100      	movs	r1, #0
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 800584c:	4303      	orrs	r3, r0
  return HAL_OK;
 800584e:	4608      	mov	r0, r1
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8005850:	60d3      	str	r3, [r2, #12]
  hsai->State= HAL_SAI_STATE_READY;
 8005852:	2301      	movs	r3, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8005854:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
  __HAL_UNLOCK(hsai);
 8005858:	f884 107c 	strb.w	r1, [r4, #124]	; 0x7c
  hsai->State= HAL_SAI_STATE_READY;
 800585c:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
}
 8005860:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
 8005862:	f44f 71ba 	mov.w	r1, #372	; 0x174
 8005866:	485b      	ldr	r0, [pc, #364]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005868:	f015 fb1c 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 800586c:	6863      	ldr	r3, [r4, #4]
 800586e:	2b03      	cmp	r3, #3
 8005870:	f67f ae7d 	bls.w	800556e <HAL_SAI_Init+0xbe>
 8005874:	f240 1175 	movw	r1, #373	; 0x175
 8005878:	4856      	ldr	r0, [pc, #344]	; (80059d4 <HAL_SAI_Init+0x524>)
 800587a:	f015 fb13 	bl	801aea4 <assert_failed>
 800587e:	e676      	b.n	800556e <HAL_SAI_Init+0xbe>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
 8005880:	f240 118b 	movw	r1, #395	; 0x18b
 8005884:	4853      	ldr	r0, [pc, #332]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005886:	f015 fb0d 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 800588a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800588c:	3b01      	subs	r3, #1
 800588e:	2b0f      	cmp	r3, #15
 8005890:	f67f aed7 	bls.w	8005642 <HAL_SAI_Init+0x192>
 8005894:	f44f 71c6 	mov.w	r1, #396	; 0x18c
 8005898:	484e      	ldr	r0, [pc, #312]	; (80059d4 <HAL_SAI_Init+0x524>)
 800589a:	f015 fb03 	bl	801aea4 <assert_failed>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 800589e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80058a0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80058a4:	f4ff aed2 	bcc.w	800564c <HAL_SAI_Init+0x19c>
 80058a8:	f240 118d 	movw	r1, #397	; 0x18d
 80058ac:	4849      	ldr	r0, [pc, #292]	; (80059d4 <HAL_SAI_Init+0x524>)
 80058ae:	f015 faf9 	bl	801aea4 <assert_failed>
  if(hsai->State == HAL_SAI_STATE_RESET)
 80058b2:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 80058b6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80058ba:	2b00      	cmp	r3, #0
 80058bc:	f47f aecd 	bne.w	800565a <HAL_SAI_Init+0x1aa>
    HAL_SAI_MspInit(hsai);
 80058c0:	4620      	mov	r0, r4
    hsai->Lock = HAL_UNLOCKED;
 80058c2:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    HAL_SAI_MspInit(hsai);
 80058c6:	f017 f8bb 	bl	801ca40 <HAL_SAI_MspInit>
 80058ca:	e6c6      	b.n	800565a <HAL_SAI_Init+0x1aa>
        tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 80058cc:	4601      	mov	r1, r0
        syncen_bits = SAI_xCR1_SYNCEN_1;
 80058ce:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80058d2:	e6f3      	b.n	80056bc <HAL_SAI_Init+0x20c>
  switch(hsai->Init.SynchroExt)
 80058d4:	2011      	movs	r0, #17
 80058d6:	2110      	movs	r1, #16
 80058d8:	e6e4      	b.n	80056a4 <HAL_SAI_Init+0x1f4>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 80058da:	f240 1177 	movw	r1, #375	; 0x177
 80058de:	483d      	ldr	r0, [pc, #244]	; (80059d4 <HAL_SAI_Init+0x524>)
 80058e0:	f015 fae0 	bl	801aea4 <assert_failed>
 80058e4:	e652      	b.n	800558c <HAL_SAI_Init+0xdc>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 80058e6:	f44f 71c5 	mov.w	r1, #394	; 0x18a
 80058ea:	483a      	ldr	r0, [pc, #232]	; (80059d4 <HAL_SAI_Init+0x524>)
 80058ec:	f015 fada 	bl	801aea4 <assert_failed>
 80058f0:	e69b      	b.n	800562a <HAL_SAI_Init+0x17a>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 80058f2:	f240 1187 	movw	r1, #391	; 0x187
 80058f6:	4837      	ldr	r0, [pc, #220]	; (80059d4 <HAL_SAI_Init+0x524>)
 80058f8:	f015 fad4 	bl	801aea4 <assert_failed>
 80058fc:	e691      	b.n	8005622 <HAL_SAI_Init+0x172>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 80058fe:	f44f 71c3 	mov.w	r1, #390	; 0x186
 8005902:	4834      	ldr	r0, [pc, #208]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005904:	f015 face 	bl	801aea4 <assert_failed>
 8005908:	e686      	b.n	8005618 <HAL_SAI_Init+0x168>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 800590a:	f240 1185 	movw	r1, #389	; 0x185
 800590e:	4831      	ldr	r0, [pc, #196]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005910:	f015 fac8 	bl	801aea4 <assert_failed>
 8005914:	e67b      	b.n	800560e <HAL_SAI_Init+0x15e>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 8005916:	f44f 71c2 	mov.w	r1, #388	; 0x184
 800591a:	482e      	ldr	r0, [pc, #184]	; (80059d4 <HAL_SAI_Init+0x524>)
 800591c:	f015 fac2 	bl	801aea4 <assert_failed>
 8005920:	e670      	b.n	8005604 <HAL_SAI_Init+0x154>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 8005922:	f240 1183 	movw	r1, #387	; 0x183
 8005926:	482b      	ldr	r0, [pc, #172]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005928:	f015 fabc 	bl	801aea4 <assert_failed>
 800592c:	e665      	b.n	80055fa <HAL_SAI_Init+0x14a>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 800592e:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8005932:	4828      	ldr	r0, [pc, #160]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005934:	f015 fab6 	bl	801aea4 <assert_failed>
 8005938:	e65a      	b.n	80055f0 <HAL_SAI_Init+0x140>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 800593a:	f240 117f 	movw	r1, #383	; 0x17f
 800593e:	4825      	ldr	r0, [pc, #148]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005940:	f015 fab0 	bl	801aea4 <assert_failed>
 8005944:	e650      	b.n	80055e8 <HAL_SAI_Init+0x138>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 8005946:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800594a:	4822      	ldr	r0, [pc, #136]	; (80059d4 <HAL_SAI_Init+0x524>)
 800594c:	f015 faaa 	bl	801aea4 <assert_failed>
 8005950:	e5c7      	b.n	80054e2 <HAL_SAI_Init+0x32>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 8005952:	f44f 71bf 	mov.w	r1, #382	; 0x17e
 8005956:	481f      	ldr	r0, [pc, #124]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005958:	f015 faa4 	bl	801aea4 <assert_failed>
 800595c:	e63f      	b.n	80055de <HAL_SAI_Init+0x12e>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800595e:	f44f 71bb 	mov.w	r1, #374	; 0x176
 8005962:	481c      	ldr	r0, [pc, #112]	; (80059d4 <HAL_SAI_Init+0x524>)
 8005964:	f015 fa9e 	bl	801aea4 <assert_failed>
 8005968:	e60b      	b.n	8005582 <HAL_SAI_Init+0xd2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 800596a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800596e:	f7ff fd37 	bl	80053e0 <HAL_RCCEx_GetPeriphCLKFreq>
    if((hsai->Instance == SAI2_Block_A ) || (hsai->Instance == SAI2_Block_B ))
 8005972:	6822      	ldr	r2, [r4, #0]
 8005974:	4b18      	ldr	r3, [pc, #96]	; (80059d8 <HAL_SAI_Init+0x528>)
 8005976:	429a      	cmp	r2, r3
 8005978:	d002      	beq.n	8005980 <HAL_SAI_Init+0x4d0>
 800597a:	3320      	adds	r3, #32
 800597c:	429a      	cmp	r2, r3
 800597e:	d104      	bne.n	800598a <HAL_SAI_Init+0x4da>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 8005980:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005984:	f7ff fd2c 	bl	80053e0 <HAL_RCCEx_GetPeriphCLKFreq>
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8005988:	6822      	ldr	r2, [r4, #0]
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 800598a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800598e:	69e1      	ldr	r1, [r4, #28]
 8005990:	0043      	lsls	r3, r0, #1
    hsai->Init.Mckdiv = tmpval / 10;
 8005992:	4812      	ldr	r0, [pc, #72]	; (80059dc <HAL_SAI_Init+0x52c>)
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 8005994:	0249      	lsls	r1, r1, #9
 8005996:	fbb3 f3f1 	udiv	r3, r3, r1
    hsai->Init.Mckdiv = tmpval / 10;
 800599a:	fba0 1003 	umull	r1, r0, r0, r3
 800599e:	08c0      	lsrs	r0, r0, #3
    if((tmpval % 10) > 8)
 80059a0:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 80059a4:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 80059a8:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv+= 1;
 80059aa:	bf08      	it	eq
 80059ac:	3001      	addeq	r0, #1
                        hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 80059ae:	0501      	lsls	r1, r0, #20
      hsai->Init.Mckdiv+= 1;
 80059b0:	6220      	str	r0, [r4, #32]
 80059b2:	e6fc      	b.n	80057ae <HAL_SAI_Init+0x2fe>
    return HAL_ERROR;
 80059b4:	2001      	movs	r0, #1
}
 80059b6:	4770      	bx	lr
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 80059b8:	f240 1173 	movw	r1, #371	; 0x173
 80059bc:	4805      	ldr	r0, [pc, #20]	; (80059d4 <HAL_SAI_Init+0x524>)
 80059be:	f015 fa71 	bl	801aea4 <assert_failed>
 80059c2:	e5c9      	b.n	8005558 <HAL_SAI_Init+0xa8>
 80059c4:	40015000 	.word	0x40015000
 80059c8:	ff05c010 	.word	0xff05c010
 80059cc:	ffff1ff0 	.word	0xffff1ff0
 80059d0:	fff88000 	.word	0xfff88000
 80059d4:	08021730 	.word	0x08021730
 80059d8:	40015c04 	.word	0x40015c04
 80059dc:	cccccccd 	.word	0xcccccccd

080059e0 <HAL_SAI_DMAPause>:
  __HAL_LOCK(hsai);
 80059e0:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 80059e4:	2a01      	cmp	r2, #1
 80059e6:	d00d      	beq.n	8005a04 <HAL_SAI_DMAPause+0x24>
 80059e8:	4603      	mov	r3, r0
  __HAL_UNLOCK(hsai);
 80059ea:	2100      	movs	r1, #0
{
 80059ec:	b410      	push	{r4}
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80059ee:	6804      	ldr	r4, [r0, #0]
  return HAL_OK;
 80059f0:	4608      	mov	r0, r1
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80059f2:	6822      	ldr	r2, [r4, #0]
 80059f4:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80059f8:	6022      	str	r2, [r4, #0]
  __HAL_UNLOCK(hsai);
 80059fa:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
}
 80059fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005a02:	4770      	bx	lr
  __HAL_LOCK(hsai);
 8005a04:	2002      	movs	r0, #2
}
 8005a06:	4770      	bx	lr

08005a08 <HAL_SAI_DMAResume>:
  __HAL_LOCK(hsai);
 8005a08:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
{
 8005a0c:	4603      	mov	r3, r0
  __HAL_LOCK(hsai);
 8005a0e:	2a01      	cmp	r2, #1
 8005a10:	d010      	beq.n	8005a34 <HAL_SAI_DMAResume+0x2c>
  hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8005a12:	6802      	ldr	r2, [r0, #0]
 8005a14:	6811      	ldr	r1, [r2, #0]
 8005a16:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 8005a1a:	6011      	str	r1, [r2, #0]
  if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
 8005a1c:	6811      	ldr	r1, [r2, #0]
 8005a1e:	03c9      	lsls	r1, r1, #15
 8005a20:	d403      	bmi.n	8005a2a <HAL_SAI_DMAResume+0x22>
    __HAL_SAI_ENABLE(hsai);
 8005a22:	6811      	ldr	r1, [r2, #0]
 8005a24:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8005a28:	6011      	str	r1, [r2, #0]
  __HAL_UNLOCK(hsai);
 8005a2a:	2200      	movs	r2, #0
  return HAL_OK;
 8005a2c:	4610      	mov	r0, r2
  __HAL_UNLOCK(hsai);
 8005a2e:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
  return HAL_OK;
 8005a32:	4770      	bx	lr
  __HAL_LOCK(hsai);
 8005a34:	2002      	movs	r0, #2
}
 8005a36:	4770      	bx	lr

08005a38 <HAL_SAI_DMAStop>:
{
 8005a38:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hsai);
 8005a3a:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8005a3e:	2b01      	cmp	r3, #1
 8005a40:	d058      	beq.n	8005af4 <HAL_SAI_DMAStop+0xbc>
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005a42:	6802      	ldr	r2, [r0, #0]
 8005a44:	4604      	mov	r4, r0
  __HAL_LOCK(hsai);
 8005a46:	2501      	movs	r5, #1
  if((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 8005a48:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  __HAL_LOCK(hsai);
 8005a4a:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005a4e:	6813      	ldr	r3, [r2, #0]
 8005a50:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8005a54:	6013      	str	r3, [r2, #0]
  if((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 8005a56:	b118      	cbz	r0, 8005a60 <HAL_SAI_DMAStop+0x28>
 8005a58:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 8005a5c:	2b12      	cmp	r3, #18
 8005a5e:	d03a      	beq.n	8005ad6 <HAL_SAI_DMAStop+0x9e>
  HAL_StatusTypeDef status = HAL_OK;
 8005a60:	2500      	movs	r5, #0
  if((hsai->hdmarx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_RX))
 8005a62:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8005a64:	b118      	cbz	r0, 8005a6e <HAL_SAI_DMAStop+0x36>
 8005a66:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 8005a6a:	2b22      	cmp	r3, #34	; 0x22
 8005a6c:	d023      	beq.n	8005ab6 <HAL_SAI_DMAStop+0x7e>
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005a6e:	4b23      	ldr	r3, [pc, #140]	; (8005afc <HAL_SAI_DMAStop+0xc4>)
 8005a70:	4a23      	ldr	r2, [pc, #140]	; (8005b00 <HAL_SAI_DMAStop+0xc8>)
  __HAL_SAI_DISABLE(hsai);
 8005a72:	6821      	ldr	r1, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005a74:	681b      	ldr	r3, [r3, #0]
 8005a76:	fba2 2303 	umull	r2, r3, r2, r3
  __HAL_SAI_DISABLE(hsai);
 8005a7a:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005a7c:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8005a7e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005a82:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 8005a84:	600a      	str	r2, [r1, #0]
 8005a86:	e002      	b.n	8005a8e <HAL_SAI_DMAStop+0x56>
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8005a88:	680a      	ldr	r2, [r1, #0]
 8005a8a:	03d2      	lsls	r2, r2, #15
 8005a8c:	d507      	bpl.n	8005a9e <HAL_SAI_DMAStop+0x66>
    if (count-- == 0)
 8005a8e:	3b01      	subs	r3, #1
 8005a90:	d2fa      	bcs.n	8005a88 <HAL_SAI_DMAStop+0x50>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8005a92:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8005a96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005a9a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8005a9e:	684b      	ldr	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 8005aa0:	2201      	movs	r2, #1
}
 8005aa2:	4628      	mov	r0, r5
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8005aa4:	f043 0308 	orr.w	r3, r3, #8
 8005aa8:	604b      	str	r3, [r1, #4]
  __HAL_UNLOCK(hsai);
 8005aaa:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
 8005aac:	f884 207d 	strb.w	r2, [r4, #125]	; 0x7d
  __HAL_UNLOCK(hsai);
 8005ab0:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 8005ab4:	bd38      	pop	{r3, r4, r5, pc}
    if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
 8005ab6:	f7fb fe61 	bl	800177c <HAL_DMA_Abort>
 8005aba:	2800      	cmp	r0, #0
 8005abc:	d0d7      	beq.n	8005a6e <HAL_SAI_DMAStop+0x36>
      if(hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 8005abe:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8005ac0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005ac2:	2b80      	cmp	r3, #128	; 0x80
 8005ac4:	d0d3      	beq.n	8005a6e <HAL_SAI_DMAStop+0x36>
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005ac6:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        status = HAL_ERROR;
 8005aca:	2501      	movs	r5, #1
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005acc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005ad0:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8005ad4:	e7cb      	b.n	8005a6e <HAL_SAI_DMAStop+0x36>
    if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
 8005ad6:	f7fb fe51 	bl	800177c <HAL_DMA_Abort>
 8005ada:	2800      	cmp	r0, #0
 8005adc:	d0c0      	beq.n	8005a60 <HAL_SAI_DMAStop+0x28>
      if(hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 8005ade:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8005ae0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005ae2:	2b80      	cmp	r3, #128	; 0x80
 8005ae4:	d0bc      	beq.n	8005a60 <HAL_SAI_DMAStop+0x28>
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005ae6:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8005aea:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005aee:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8005af2:	e7b6      	b.n	8005a62 <HAL_SAI_DMAStop+0x2a>
  __HAL_LOCK(hsai);
 8005af4:	2502      	movs	r5, #2
}
 8005af6:	4628      	mov	r0, r5
 8005af8:	bd38      	pop	{r3, r4, r5, pc}
 8005afa:	bf00      	nop
 8005afc:	20000078 	.word	0x20000078
 8005b00:	95cbec1b 	.word	0x95cbec1b

08005b04 <HAL_SAI_Transmit_DMA>:
{
 8005b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((pData == NULL) || (Size == 0))
 8005b06:	2900      	cmp	r1, #0
 8005b08:	d04c      	beq.n	8005ba4 <HAL_SAI_Transmit_DMA+0xa0>
 8005b0a:	fab2 f582 	clz	r5, r2
 8005b0e:	096d      	lsrs	r5, r5, #5
 8005b10:	2a00      	cmp	r2, #0
 8005b12:	d047      	beq.n	8005ba4 <HAL_SAI_Transmit_DMA+0xa0>
 8005b14:	4604      	mov	r4, r0
  if(hsai->State == HAL_SAI_STATE_READY)
 8005b16:	f890 007d 	ldrb.w	r0, [r0, #125]	; 0x7d
 8005b1a:	2801      	cmp	r0, #1
 8005b1c:	b2c6      	uxtb	r6, r0
 8005b1e:	d13e      	bne.n	8005b9e <HAL_SAI_Transmit_DMA+0x9a>
    __HAL_LOCK(hsai);
 8005b20:	f894 007c 	ldrb.w	r0, [r4, #124]	; 0x7c
 8005b24:	2801      	cmp	r0, #1
 8005b26:	d03a      	beq.n	8005b9e <HAL_SAI_Transmit_DMA+0x9a>
    hsai->XferSize = Size;
 8005b28:	462b      	mov	r3, r5
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 8005b2a:	2712      	movs	r7, #18
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8005b2c:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    hsai->XferSize = Size;
 8005b30:	f362 030f 	bfi	r3, r2, #0, #16
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 8005b34:	f884 707d 	strb.w	r7, [r4, #125]	; 0x7d
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8005b38:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    hsai->XferSize = Size;
 8005b3a:	f362 431f 	bfi	r3, r2, #16, #16
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8005b3e:	4f21      	ldr	r7, [pc, #132]	; (8005bc4 <HAL_SAI_Transmit_DMA+0xc0>)
    hsai->pBuffPtr = pData;
 8005b40:	6661      	str	r1, [r4, #100]	; 0x64
    hsai->XferSize = Size;
 8005b42:	66a3      	str	r3, [r4, #104]	; 0x68
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8005b44:	4613      	mov	r3, r2
    __HAL_LOCK(hsai);
 8005b46:	f884 607c 	strb.w	r6, [r4, #124]	; 0x7c
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8005b4a:	6822      	ldr	r2, [r4, #0]
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8005b4c:	6407      	str	r7, [r0, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 8005b4e:	4f1e      	ldr	r7, [pc, #120]	; (8005bc8 <HAL_SAI_Transmit_DMA+0xc4>)
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8005b50:	321c      	adds	r2, #28
    hsai->hdmatx->XferAbortCallback = NULL;
 8005b52:	6505      	str	r5, [r0, #80]	; 0x50
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 8005b54:	63c7      	str	r7, [r0, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 8005b56:	4f1d      	ldr	r7, [pc, #116]	; (8005bcc <HAL_SAI_Transmit_DMA+0xc8>)
 8005b58:	64c7      	str	r7, [r0, #76]	; 0x4c
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8005b5a:	f7fb fdb3 	bl	80016c4 <HAL_DMA_Start_IT>
 8005b5e:	bb20      	cbnz	r0, 8005baa <HAL_SAI_Transmit_DMA+0xa6>
    if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
 8005b60:	6823      	ldr	r3, [r4, #0]
 8005b62:	681a      	ldr	r2, [r3, #0]
 8005b64:	03d2      	lsls	r2, r2, #15
 8005b66:	d403      	bmi.n	8005b70 <HAL_SAI_Transmit_DMA+0x6c>
      __HAL_SAI_ENABLE(hsai);
 8005b68:	681a      	ldr	r2, [r3, #0]
 8005b6a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8005b6e:	601a      	str	r2, [r3, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005b70:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8005b72:	2a08      	cmp	r2, #8
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005b74:	6862      	ldr	r2, [r4, #4]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005b76:	d01c      	beq.n	8005bb2 <HAL_SAI_Transmit_DMA+0xae>
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005b78:	2105      	movs	r1, #5
 8005b7a:	2061      	movs	r0, #97	; 0x61
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8005b7c:	3a02      	subs	r2, #2
    tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
 8005b7e:	2a01      	cmp	r2, #1
 8005b80:	bf98      	it	ls
 8005b82:	4601      	movls	r1, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8005b84:	691a      	ldr	r2, [r3, #16]
    __HAL_UNLOCK(hsai);
 8005b86:	2000      	movs	r0, #0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8005b88:	430a      	orrs	r2, r1
    return HAL_OK;
 8005b8a:	4606      	mov	r6, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8005b8c:	611a      	str	r2, [r3, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8005b8e:	681a      	ldr	r2, [r3, #0]
 8005b90:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8005b94:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
 8005b96:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
}
 8005b9a:	4630      	mov	r0, r6
 8005b9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8005b9e:	2602      	movs	r6, #2
}
 8005ba0:	4630      	mov	r0, r6
 8005ba2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 8005ba4:	2601      	movs	r6, #1
}
 8005ba6:	4630      	mov	r0, r6
 8005ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005baa:	4630      	mov	r0, r6
      __HAL_UNLOCK(hsai);
 8005bac:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
}
 8005bb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005bb2:	f022 0102 	bic.w	r1, r2, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005bb6:	2901      	cmp	r1, #1
 8005bb8:	bf0b      	itete	eq
 8005bba:	2115      	moveq	r1, #21
 8005bbc:	2105      	movne	r1, #5
 8005bbe:	2071      	moveq	r0, #113	; 0x71
 8005bc0:	2061      	movne	r0, #97	; 0x61
 8005bc2:	e7db      	b.n	8005b7c <HAL_SAI_Transmit_DMA+0x78>
 8005bc4:	08005c35 	.word	0x08005c35
 8005bc8:	08005bd1 	.word	0x08005bd1
 8005bcc:	08005c41 	.word	0x08005c41

08005bd0 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 8005bd0:	b508      	push	{r3, lr}
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8005bd2:	6803      	ldr	r3, [r0, #0]
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;
 8005bd4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8005bd6:	681b      	ldr	r3, [r3, #0]
 8005bd8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8005bdc:	d119      	bne.n	8005c12 <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8005bde:	6802      	ldr	r2, [r0, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005be0:	6b01      	ldr	r1, [r0, #48]	; 0x30
    hsai->XferCount = 0;
 8005be2:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8005be6:	6813      	ldr	r3, [r2, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005be8:	2908      	cmp	r1, #8
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8005bea:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8005bee:	6013      	str	r3, [r2, #0]
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005bf0:	6843      	ldr	r3, [r0, #4]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005bf2:	d011      	beq.n	8005c18 <SAI_DMATxCplt+0x48>
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005bf4:	f06f 0c61 	mvn.w	ip, #97	; 0x61
 8005bf8:	f06f 0105 	mvn.w	r1, #5
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8005bfc:	3b02      	subs	r3, #2
 8005bfe:	2b01      	cmp	r3, #1
 8005c00:	bf98      	it	ls
 8005c02:	4661      	movls	r1, ip

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8005c04:	6913      	ldr	r3, [r2, #16]

    hsai->State= HAL_SAI_STATE_READY;
 8005c06:	f04f 0c01 	mov.w	ip, #1
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8005c0a:	400b      	ands	r3, r1
 8005c0c:	6113      	str	r3, [r2, #16]
    hsai->State= HAL_SAI_STATE_READY;
 8005c0e:	f880 c07d 	strb.w	ip, [r0, #125]	; 0x7d
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
 8005c12:	f017 f913 	bl	801ce3c <HAL_SAI_TxCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 8005c16:	bd08      	pop	{r3, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8005c18:	f023 0102 	bic.w	r1, r3, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8005c1c:	2901      	cmp	r1, #1
 8005c1e:	bf0b      	itete	eq
 8005c20:	f06f 0c71 	mvneq.w	ip, #113	; 0x71
 8005c24:	f06f 0c61 	mvnne.w	ip, #97	; 0x61
 8005c28:	f06f 0115 	mvneq.w	r1, #21
 8005c2c:	f06f 0105 	mvnne.w	r1, #5
 8005c30:	e7e4      	b.n	8005bfc <SAI_DMATxCplt+0x2c>
 8005c32:	bf00      	nop

08005c34 <SAI_DMATxHalfCplt>:
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
 8005c34:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 8005c36:	b508      	push	{r3, lr}
  HAL_SAI_TxHalfCpltCallback(hsai);
 8005c38:	f017 f942 	bl	801cec0 <HAL_SAI_TxHalfCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 8005c3c:	bd08      	pop	{r3, pc}
 8005c3e:	bf00      	nop

08005c40 <SAI_DMAError>:
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
  SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8005c40:	6b80      	ldr	r0, [r0, #56]	; 0x38

  /* Set SAI error code */
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005c42:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  if((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 8005c46:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005c48:	f043 0380 	orr.w	r3, r3, #128	; 0x80
{
 8005c4c:	b510      	push	{r4, lr}
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8005c4e:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  if((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 8005c52:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8005c54:	2b01      	cmp	r3, #1
 8005c56:	d006      	beq.n	8005c66 <SAI_DMAError+0x26>
 8005c58:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005c5a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005c5c:	2b01      	cmp	r3, #1
 8005c5e:	d002      	beq.n	8005c66 <SAI_DMAError+0x26>
  }
  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
 8005c60:	f017 f96e 	bl	801cf40 <HAL_SAI_ErrorCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 8005c64:	bd10      	pop	{r4, pc}
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005c66:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c68:	4b11      	ldr	r3, [pc, #68]	; (8005cb0 <SAI_DMAError+0x70>)
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005c6a:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c6c:	681b      	ldr	r3, [r3, #0]
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005c6e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c72:	4c10      	ldr	r4, [pc, #64]	; (8005cb4 <SAI_DMAError+0x74>)
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8005c74:	600a      	str	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c76:	fba4 4303 	umull	r4, r3, r4, r3
  __HAL_SAI_DISABLE(hsai);
 8005c7a:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c7c:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8005c7e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8005c82:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 8005c84:	600a      	str	r2, [r1, #0]
 8005c86:	e002      	b.n	8005c8e <SAI_DMAError+0x4e>
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8005c88:	680a      	ldr	r2, [r1, #0]
 8005c8a:	03d2      	lsls	r2, r2, #15
 8005c8c:	d507      	bpl.n	8005c9e <SAI_DMAError+0x5e>
    if (count-- == 0)
 8005c8e:	3b01      	subs	r3, #1
 8005c90:	d2fa      	bcs.n	8005c88 <SAI_DMAError+0x48>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8005c92:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8005c96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005c9a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_READY;
 8005c9e:	2201      	movs	r2, #1
    hsai->XferCount = 0U;
 8005ca0:	2300      	movs	r3, #0
    hsai->State = HAL_SAI_STATE_READY;
 8005ca2:	f880 207d 	strb.w	r2, [r0, #125]	; 0x7d
    hsai->XferCount = 0U;
 8005ca6:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
  HAL_SAI_ErrorCallback(hsai);
 8005caa:	f017 f949 	bl	801cf40 <HAL_SAI_ErrorCallback>
}
 8005cae:	bd10      	pop	{r4, pc}
 8005cb0:	20000078 	.word	0x20000078
 8005cb4:	95cbec1b 	.word	0x95cbec1b

08005cb8 <HAL_SAI_GetState>:
  return hsai->State;
 8005cb8:	f890 007d 	ldrb.w	r0, [r0, #125]	; 0x7d
}
 8005cbc:	4770      	bx	lr
 8005cbe:	bf00      	nop

08005cc0 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 8005cc0:	b1f0      	cbz	r0, 8005d00 <HAL_SDRAM_Init+0x40>
{   
 8005cc2:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8005cc4:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8005cc8:	4604      	mov	r4, r0
 8005cca:	460d      	mov	r5, r1
 8005ccc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005cd0:	b18b      	cbz	r3, 8005cf6 <HAL_SDRAM_Init+0x36>
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8005cd2:	4621      	mov	r1, r4
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8005cd4:	2302      	movs	r3, #2
 8005cd6:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8005cda:	f851 0b04 	ldr.w	r0, [r1], #4
 8005cde:	f001 fa83 	bl	80071e8 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 8005ce2:	6862      	ldr	r2, [r4, #4]
 8005ce4:	4629      	mov	r1, r5
 8005ce6:	6820      	ldr	r0, [r4, #0]
 8005ce8:	f001 fb44 	bl	8007374 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8005cec:	2301      	movs	r3, #1
  
  return HAL_OK;
 8005cee:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 8005cf0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8005cf4:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 8005cf6:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 8005cfa:	f014 f839 	bl	8019d70 <HAL_SDRAM_MspInit>
 8005cfe:	e7e8      	b.n	8005cd2 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 8005d00:	2001      	movs	r0, #1
}
 8005d02:	4770      	bx	lr

08005d04 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8005d04:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8005d06:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
 8005d0a:	4604      	mov	r4, r0
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8005d0c:	2b02      	cmp	r3, #2
 8005d0e:	b2d8      	uxtb	r0, r3
 8005d10:	d00e      	beq.n	8005d30 <HAL_SDRAM_SendCommand+0x2c>
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8005d12:	2302      	movs	r3, #2
 8005d14:	460d      	mov	r5, r1
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8005d16:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8005d18:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8005d1c:	f001 fbd2 	bl	80074c4 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8005d20:	682b      	ldr	r3, [r5, #0]
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  
  return HAL_OK;  
 8005d22:	2000      	movs	r0, #0
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8005d24:	2b02      	cmp	r3, #2
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 8005d26:	bf0c      	ite	eq
 8005d28:	2305      	moveq	r3, #5
    hsdram->State = HAL_SDRAM_STATE_READY;
 8005d2a:	2301      	movne	r3, #1
 8005d2c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8005d30:	bd38      	pop	{r3, r4, r5, pc}
 8005d32:	bf00      	nop

08005d34 <HAL_SDRAM_ProgramRefreshRate>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8005d34:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8005d38:	2b02      	cmp	r3, #2
 8005d3a:	d00c      	beq.n	8005d56 <HAL_SDRAM_ProgramRefreshRate+0x22>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8005d3c:	2302      	movs	r3, #2
{
 8005d3e:	b510      	push	{r4, lr}
 8005d40:	4604      	mov	r4, r0
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8005d42:	6800      	ldr	r0, [r0, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8005d44:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8005d48:	f001 fc0e 	bl	8007568 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8005d4c:	2301      	movs	r3, #1
  
  return HAL_OK;   
 8005d4e:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 8005d50:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8005d54:	bd10      	pop	{r4, pc}
 8005d56:	b2d8      	uxtb	r0, r3
 8005d58:	4770      	bx	lr
 8005d5a:	bf00      	nop

08005d5c <SPI_EndRxTxTransaction.constprop.0>:
  * @param  hspi SPI handle
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
 8005d5c:	b538      	push	{r3, r4, r5, lr}
 8005d5e:	4604      	mov	r4, r0
 8005d60:	460d      	mov	r5, r1
 8005d62:	e004      	b.n	8005d6e <SPI_EndRxTxTransaction.constprop.0+0x12>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8005d64:	f7fb f984 	bl	8001070 <HAL_GetTick>
 8005d68:	1b40      	subs	r0, r0, r5
 8005d6a:	2863      	cmp	r0, #99	; 0x63
 8005d6c:	d81b      	bhi.n	8005da6 <SPI_EndRxTxTransaction.constprop.0+0x4a>
  while ((hspi->Instance->SR & Fifo) != State)
 8005d6e:	6823      	ldr	r3, [r4, #0]
 8005d70:	689a      	ldr	r2, [r3, #8]
 8005d72:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
 8005d76:	d1f5      	bne.n	8005d64 <SPI_EndRxTxTransaction.constprop.0+0x8>
 8005d78:	e005      	b.n	8005d86 <SPI_EndRxTxTransaction.constprop.0+0x2a>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8005d7a:	f7fb f979 	bl	8001070 <HAL_GetTick>
 8005d7e:	1b40      	subs	r0, r0, r5
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005d80:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8005d82:	2863      	cmp	r0, #99	; 0x63
 8005d84:	d810      	bhi.n	8005da8 <SPI_EndRxTxTransaction.constprop.0+0x4c>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8005d86:	689a      	ldr	r2, [r3, #8]
 8005d88:	0612      	lsls	r2, r2, #24
 8005d8a:	d4f6      	bmi.n	8005d7a <SPI_EndRxTxTransaction.constprop.0+0x1e>
 8005d8c:	e006      	b.n	8005d9c <SPI_EndRxTxTransaction.constprop.0+0x40>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8005d8e:	7b1b      	ldrb	r3, [r3, #12]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8005d90:	f7fb f96e 	bl	8001070 <HAL_GetTick>
 8005d94:	1b40      	subs	r0, r0, r5
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005d96:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8005d98:	2863      	cmp	r0, #99	; 0x63
 8005d9a:	d805      	bhi.n	8005da8 <SPI_EndRxTxTransaction.constprop.0+0x4c>
  while ((hspi->Instance->SR & Fifo) != State)
 8005d9c:	6898      	ldr	r0, [r3, #8]
 8005d9e:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 8005da2:	d1f4      	bne.n	8005d8e <SPI_EndRxTxTransaction.constprop.0+0x32>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 8005da4:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005da6:	6823      	ldr	r3, [r4, #0]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005da8:	6861      	ldr	r1, [r4, #4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005daa:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005dac:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005db0:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8005db4:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005db6:	d017      	beq.n	8005de8 <SPI_EndRxTxTransaction.constprop.0+0x8c>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8005db8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8005dba:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8005dbe:	d107      	bne.n	8005dd0 <SPI_EndRxTxTransaction.constprop.0+0x74>
          SPI_RESET_CRC(hspi);
 8005dc0:	681a      	ldr	r2, [r3, #0]
 8005dc2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8005dc6:	601a      	str	r2, [r3, #0]
 8005dc8:	681a      	ldr	r2, [r3, #0]
 8005dca:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8005dce:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8005dd0:	2301      	movs	r3, #1
        __HAL_UNLOCK(hspi);
 8005dd2:	2200      	movs	r2, #0
    return HAL_TIMEOUT;
 8005dd4:	2003      	movs	r0, #3
        hspi->State = HAL_SPI_STATE_READY;
 8005dd6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8005dda:	6e23      	ldr	r3, [r4, #96]	; 0x60
        __HAL_UNLOCK(hspi);
 8005ddc:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8005de0:	f043 0320 	orr.w	r3, r3, #32
 8005de4:	6623      	str	r3, [r4, #96]	; 0x60
}
 8005de6:	bd38      	pop	{r3, r4, r5, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005de8:	68a2      	ldr	r2, [r4, #8]
 8005dea:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8005dee:	d002      	beq.n	8005df6 <SPI_EndRxTxTransaction.constprop.0+0x9a>
 8005df0:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8005df4:	d1e0      	bne.n	8005db8 <SPI_EndRxTxTransaction.constprop.0+0x5c>
          __HAL_SPI_DISABLE(hspi);
 8005df6:	681a      	ldr	r2, [r3, #0]
 8005df8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005dfc:	601a      	str	r2, [r3, #0]
 8005dfe:	e7db      	b.n	8005db8 <SPI_EndRxTxTransaction.constprop.0+0x5c>

08005e00 <HAL_SPI_Init>:
  if (hspi == NULL)
 8005e00:	2800      	cmp	r0, #0
 8005e02:	f000 8108 	beq.w	8006016 <HAL_SPI_Init+0x216>
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
 8005e06:	6802      	ldr	r2, [r0, #0]
 8005e08:	4b8d      	ldr	r3, [pc, #564]	; (8006040 <HAL_SPI_Init+0x240>)
 8005e0a:	498e      	ldr	r1, [pc, #568]	; (8006044 <HAL_SPI_Init+0x244>)
{
 8005e0c:	b570      	push	{r4, r5, r6, lr}
 8005e0e:	4604      	mov	r4, r0
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
 8005e10:	488d      	ldr	r0, [pc, #564]	; (8006048 <HAL_SPI_Init+0x248>)
 8005e12:	429a      	cmp	r2, r3
 8005e14:	bf18      	it	ne
 8005e16:	4282      	cmpne	r2, r0
 8005e18:	f500 407c 	add.w	r0, r0, #64512	; 0xfc00
 8005e1c:	bf14      	ite	ne
 8005e1e:	2301      	movne	r3, #1
 8005e20:	2300      	moveq	r3, #0
 8005e22:	428a      	cmp	r2, r1
 8005e24:	bf0c      	ite	eq
 8005e26:	2300      	moveq	r3, #0
 8005e28:	f003 0301 	andne.w	r3, r3, #1
 8005e2c:	f501 318a 	add.w	r1, r1, #70656	; 0x11400
 8005e30:	4282      	cmp	r2, r0
 8005e32:	bf0c      	ite	eq
 8005e34:	2300      	moveq	r3, #0
 8005e36:	f003 0301 	andne.w	r3, r3, #1
 8005e3a:	428a      	cmp	r2, r1
 8005e3c:	bf0c      	ite	eq
 8005e3e:	2300      	moveq	r3, #0
 8005e40:	f003 0301 	andne.w	r3, r3, #1
 8005e44:	b11b      	cbz	r3, 8005e4e <HAL_SPI_Init+0x4e>
 8005e46:	4b81      	ldr	r3, [pc, #516]	; (800604c <HAL_SPI_Init+0x24c>)
 8005e48:	429a      	cmp	r2, r3
 8005e4a:	f040 80de 	bne.w	800600a <HAL_SPI_Init+0x20a>
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 8005e4e:	6863      	ldr	r3, [r4, #4]
 8005e50:	b11b      	cbz	r3, 8005e5a <HAL_SPI_Init+0x5a>
 8005e52:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8005e56:	f040 80a1 	bne.w	8005f9c <HAL_SPI_Init+0x19c>
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
 8005e5a:	68a3      	ldr	r3, [r4, #8]
 8005e5c:	f433 6280 	bics.w	r2, r3, #1024	; 0x400
 8005e60:	d003      	beq.n	8005e6a <HAL_SPI_Init+0x6a>
 8005e62:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005e66:	f040 80b8 	bne.w	8005fda <HAL_SPI_Init+0x1da>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 8005e6a:	68e2      	ldr	r2, [r4, #12]
 8005e6c:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
 8005e70:	f422 7040 	bic.w	r0, r2, #768	; 0x300
 8005e74:	f422 6110 	bic.w	r1, r2, #2304	; 0x900
 8005e78:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8005e7c:	bf18      	it	ne
 8005e7e:	f5b0 6f00 	cmpne.w	r0, #2048	; 0x800
 8005e82:	bf14      	ite	ne
 8005e84:	2301      	movne	r3, #1
 8005e86:	2300      	moveq	r3, #0
 8005e88:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8005e8c:	bf0c      	ite	eq
 8005e8e:	2300      	moveq	r3, #0
 8005e90:	f003 0301 	andne.w	r3, r3, #1
 8005e94:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8005e98:	bf0c      	ite	eq
 8005e9a:	2300      	moveq	r3, #0
 8005e9c:	f003 0301 	andne.w	r3, r3, #1
 8005ea0:	b12b      	cbz	r3, 8005eae <HAL_SPI_Init+0xae>
 8005ea2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8005ea6:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8005eaa:	f040 80c2 	bne.w	8006032 <HAL_SPI_Init+0x232>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 8005eae:	69a3      	ldr	r3, [r4, #24]
 8005eb0:	f433 7200 	bics.w	r2, r3, #512	; 0x200
 8005eb4:	d002      	beq.n	8005ebc <HAL_SPI_Init+0xbc>
 8005eb6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005eba:	d17e      	bne.n	8005fba <HAL_SPI_Init+0x1ba>
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
 8005ebc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005ebe:	f033 0308 	bics.w	r3, r3, #8
 8005ec2:	f040 8084 	bne.w	8005fce <HAL_SPI_Init+0x1ce>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 8005ec6:	69e3      	ldr	r3, [r4, #28]
 8005ec8:	f023 0318 	bic.w	r3, r3, #24
 8005ecc:	2b20      	cmp	r3, #32
 8005ece:	d002      	beq.n	8005ed6 <HAL_SPI_Init+0xd6>
 8005ed0:	2b00      	cmp	r3, #0
 8005ed2:	f040 80a8 	bne.w	8006026 <HAL_SPI_Init+0x226>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 8005ed6:	6a23      	ldr	r3, [r4, #32]
 8005ed8:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 8005edc:	f040 8089 	bne.w	8005ff2 <HAL_SPI_Init+0x1f2>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 8005ee0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005ee2:	f033 0210 	bics.w	r2, r3, #16
 8005ee6:	d15f      	bne.n	8005fa8 <HAL_SPI_Init+0x1a8>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8005ee8:	b943      	cbnz	r3, 8005efc <HAL_SPI_Init+0xfc>
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 8005eea:	6923      	ldr	r3, [r4, #16]
 8005eec:	f033 0302 	bics.w	r3, r3, #2
 8005ef0:	f040 8093 	bne.w	800601a <HAL_SPI_Init+0x21a>
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 8005ef4:	6963      	ldr	r3, [r4, #20]
 8005ef6:	2b01      	cmp	r3, #1
 8005ef8:	f200 8081 	bhi.w	8005ffe <HAL_SPI_Init+0x1fe>
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005efc:	2200      	movs	r2, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8005efe:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005f02:	62a2      	str	r2, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8005f04:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005f08:	2b00      	cmp	r3, #0
 8005f0a:	d06c      	beq.n	8005fe6 <HAL_SPI_Init+0x1e6>
  __HAL_SPI_DISABLE(hspi);
 8005f0c:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8005f0e:	2302      	movs	r3, #2
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8005f10:	68e2      	ldr	r2, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 8005f12:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 8005f16:	680b      	ldr	r3, [r1, #0]
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8005f18:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 8005f1c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8005f20:	bf8c      	ite	hi
 8005f22:	f04f 0c00 	movhi.w	ip, #0
 8005f26:	f44f 5c80 	movls.w	ip, #4096	; 0x1000
  __HAL_SPI_DISABLE(hspi);
 8005f2a:	600b      	str	r3, [r1, #0]
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8005f2c:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
 8005f30:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8005f34:	d12f      	bne.n	8005f96 <HAL_SPI_Init+0x196>
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f36:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8005f38:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005f3a:	b92b      	cbnz	r3, 8005f48 <HAL_SPI_Init+0x148>
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8005f3c:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8005f40:	bf8c      	ite	hi
 8005f42:	2302      	movhi	r3, #2
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8005f44:	2301      	movls	r3, #1
 8005f46:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f48:	e9d4 3501 	ldrd	r3, r5, [r4, #4]
 8005f4c:	432b      	orrs	r3, r5
 8005f4e:	6925      	ldr	r5, [r4, #16]
 8005f50:	432b      	orrs	r3, r5
 8005f52:	6965      	ldr	r5, [r4, #20]
 8005f54:	432b      	orrs	r3, r5
 8005f56:	e9d4 5606 	ldrd	r5, r6, [r4, #24]
 8005f5a:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8005f5c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8005f5e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f62:	f405 7500 	and.w	r5, r5, #512	; 0x200
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8005f66:	4332      	orrs	r2, r6
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f68:	6a26      	ldr	r6, [r4, #32]
 8005f6a:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8005f6c:	6b66      	ldr	r6, [r4, #52]	; 0x34
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f6e:	432b      	orrs	r3, r5
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8005f70:	4332      	orrs	r2, r6
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f72:	4303      	orrs	r3, r0
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8005f74:	2000      	movs	r0, #0
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8005f76:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8005f78:	f00e 0304 	and.w	r3, lr, #4
 8005f7c:	431a      	orrs	r2, r3
 8005f7e:	ea42 020c 	orr.w	r2, r2, ip
 8005f82:	604a      	str	r2, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8005f84:	69cb      	ldr	r3, [r1, #28]
 8005f86:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005f8a:	61cb      	str	r3, [r1, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 8005f8c:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8005f8e:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8005f90:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
}
 8005f94:	bd70      	pop	{r4, r5, r6, pc}
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005f96:	2000      	movs	r0, #0
 8005f98:	62a0      	str	r0, [r4, #40]	; 0x28
 8005f9a:	e7cd      	b.n	8005f38 <HAL_SPI_Init+0x138>
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 8005f9c:	f240 1145 	movw	r1, #325	; 0x145
 8005fa0:	482b      	ldr	r0, [pc, #172]	; (8006050 <HAL_SPI_Init+0x250>)
 8005fa2:	f014 ff7f 	bl	801aea4 <assert_failed>
 8005fa6:	e758      	b.n	8005e5a <HAL_SPI_Init+0x5a>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 8005fa8:	f44f 71a6 	mov.w	r1, #332	; 0x14c
 8005fac:	4828      	ldr	r0, [pc, #160]	; (8006050 <HAL_SPI_Init+0x250>)
 8005fae:	f014 ff79 	bl	801aea4 <assert_failed>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8005fb2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005fb4:	2b00      	cmp	r3, #0
 8005fb6:	d1a1      	bne.n	8005efc <HAL_SPI_Init+0xfc>
 8005fb8:	e797      	b.n	8005eea <HAL_SPI_Init+0xea>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 8005fba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005fbe:	4824      	ldr	r0, [pc, #144]	; (8006050 <HAL_SPI_Init+0x250>)
 8005fc0:	f014 ff70 	bl	801aea4 <assert_failed>
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
 8005fc4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005fc6:	f033 0308 	bics.w	r3, r3, #8
 8005fca:	f43f af7c 	beq.w	8005ec6 <HAL_SPI_Init+0xc6>
 8005fce:	f240 1149 	movw	r1, #329	; 0x149
 8005fd2:	481f      	ldr	r0, [pc, #124]	; (8006050 <HAL_SPI_Init+0x250>)
 8005fd4:	f014 ff66 	bl	801aea4 <assert_failed>
 8005fd8:	e775      	b.n	8005ec6 <HAL_SPI_Init+0xc6>
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
 8005fda:	f44f 71a3 	mov.w	r1, #326	; 0x146
 8005fde:	481c      	ldr	r0, [pc, #112]	; (8006050 <HAL_SPI_Init+0x250>)
 8005fe0:	f014 ff60 	bl	801aea4 <assert_failed>
 8005fe4:	e741      	b.n	8005e6a <HAL_SPI_Init+0x6a>
    HAL_SPI_MspInit(hspi);
 8005fe6:	4620      	mov	r0, r4
    hspi->Lock = HAL_UNLOCKED;
 8005fe8:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 8005fec:	f016 fde8 	bl	801cbc0 <HAL_SPI_MspInit>
 8005ff0:	e78c      	b.n	8005f0c <HAL_SPI_Init+0x10c>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 8005ff2:	f240 114b 	movw	r1, #331	; 0x14b
 8005ff6:	4816      	ldr	r0, [pc, #88]	; (8006050 <HAL_SPI_Init+0x250>)
 8005ff8:	f014 ff54 	bl	801aea4 <assert_failed>
 8005ffc:	e770      	b.n	8005ee0 <HAL_SPI_Init+0xe0>
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 8005ffe:	f44f 71a8 	mov.w	r1, #336	; 0x150
 8006002:	4813      	ldr	r0, [pc, #76]	; (8006050 <HAL_SPI_Init+0x250>)
 8006004:	f014 ff4e 	bl	801aea4 <assert_failed>
 8006008:	e778      	b.n	8005efc <HAL_SPI_Init+0xfc>
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
 800600a:	f44f 71a2 	mov.w	r1, #324	; 0x144
 800600e:	4810      	ldr	r0, [pc, #64]	; (8006050 <HAL_SPI_Init+0x250>)
 8006010:	f014 ff48 	bl	801aea4 <assert_failed>
 8006014:	e71b      	b.n	8005e4e <HAL_SPI_Init+0x4e>
    return HAL_ERROR;
 8006016:	2001      	movs	r0, #1
}
 8006018:	4770      	bx	lr
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 800601a:	f240 114f 	movw	r1, #335	; 0x14f
 800601e:	480c      	ldr	r0, [pc, #48]	; (8006050 <HAL_SPI_Init+0x250>)
 8006020:	f014 ff40 	bl	801aea4 <assert_failed>
 8006024:	e766      	b.n	8005ef4 <HAL_SPI_Init+0xf4>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 8006026:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 800602a:	4809      	ldr	r0, [pc, #36]	; (8006050 <HAL_SPI_Init+0x250>)
 800602c:	f014 ff3a 	bl	801aea4 <assert_failed>
 8006030:	e751      	b.n	8005ed6 <HAL_SPI_Init+0xd6>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 8006032:	f240 1147 	movw	r1, #327	; 0x147
 8006036:	4806      	ldr	r0, [pc, #24]	; (8006050 <HAL_SPI_Init+0x250>)
 8006038:	f014 ff34 	bl	801aea4 <assert_failed>
 800603c:	e737      	b.n	8005eae <HAL_SPI_Init+0xae>
 800603e:	bf00      	nop
 8006040:	40013000 	.word	0x40013000
 8006044:	40003c00 	.word	0x40003c00
 8006048:	40003800 	.word	0x40003800
 800604c:	40015400 	.word	0x40015400
 8006050:	08021768 	.word	0x08021768

08006054 <HAL_SPI_TransmitReceive_IT>:
{
 8006054:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006056:	461d      	mov	r5, r3
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
 8006058:	6883      	ldr	r3, [r0, #8]
{
 800605a:	4604      	mov	r4, r0
 800605c:	460f      	mov	r7, r1
 800605e:	4616      	mov	r6, r2
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
 8006060:	2b00      	cmp	r3, #0
 8006062:	d14b      	bne.n	80060fc <HAL_SPI_TransmitReceive_IT+0xa8>
  __HAL_LOCK(hspi);
 8006064:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8006068:	2b01      	cmp	r3, #1
 800606a:	d050      	beq.n	800610e <HAL_SPI_TransmitReceive_IT+0xba>
 800606c:	2301      	movs	r3, #1
 800606e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  tmp_state           = hspi->State;
 8006072:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8006076:	2b01      	cmp	r3, #1
  tmp_state           = hspi->State;
 8006078:	b2da      	uxtb	r2, r3
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 800607a:	d00d      	beq.n	8006098 <HAL_SPI_TransmitReceive_IT+0x44>
 800607c:	6863      	ldr	r3, [r4, #4]
 800607e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8006082:	d004      	beq.n	800608e <HAL_SPI_TransmitReceive_IT+0x3a>
    errorcode = HAL_BUSY;
 8006084:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 8006086:	2300      	movs	r3, #0
 8006088:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 800608c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 800608e:	68a3      	ldr	r3, [r4, #8]
 8006090:	2b00      	cmp	r3, #0
 8006092:	d1f7      	bne.n	8006084 <HAL_SPI_TransmitReceive_IT+0x30>
 8006094:	2a04      	cmp	r2, #4
 8006096:	d1f5      	bne.n	8006084 <HAL_SPI_TransmitReceive_IT+0x30>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8006098:	2d00      	cmp	r5, #0
 800609a:	bf18      	it	ne
 800609c:	2e00      	cmpne	r6, #0
 800609e:	d02b      	beq.n	80060f8 <HAL_SPI_TransmitReceive_IT+0xa4>
 80060a0:	b357      	cbz	r7, 80060f8 <HAL_SPI_TransmitReceive_IT+0xa4>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80060a2:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 80060a6:	2b04      	cmp	r3, #4
 80060a8:	d002      	beq.n	80060b0 <HAL_SPI_TransmitReceive_IT+0x5c>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80060aa:	2305      	movs	r3, #5
 80060ac:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80060b0:	68e3      	ldr	r3, [r4, #12]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80060b2:	2200      	movs	r2, #0
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80060b4:	63a7      	str	r7, [r4, #56]	; 0x38
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80060b6:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80060ba:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->TxXferSize  = Size;
 80060bc:	87a5      	strh	r5, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 80060be:	87e5      	strh	r5, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80060c0:	6426      	str	r6, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 80060c2:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 80060c6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80060ca:	d924      	bls.n	8006116 <HAL_SPI_TransmitReceive_IT+0xc2>
    hspi->RxISR     = SPI_2linesRxISR_16BIT;
 80060cc:	4a18      	ldr	r2, [pc, #96]	; (8006130 <HAL_SPI_TransmitReceive_IT+0xdc>)
    hspi->TxISR     = SPI_2linesTxISR_16BIT;
 80060ce:	4b19      	ldr	r3, [pc, #100]	; (8006134 <HAL_SPI_TransmitReceive_IT+0xe0>)
 80060d0:	e9c4 2313 	strd	r2, r3, [r4, #76]	; 0x4c
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80060d4:	6823      	ldr	r3, [r4, #0]
 80060d6:	685a      	ldr	r2, [r3, #4]
 80060d8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80060dc:	605a      	str	r2, [r3, #4]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80060de:	685a      	ldr	r2, [r3, #4]
 80060e0:	f042 02e0 	orr.w	r2, r2, #224	; 0xe0
 80060e4:	605a      	str	r2, [r3, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80060e6:	6818      	ldr	r0, [r3, #0]
 80060e8:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 80060ec:	d111      	bne.n	8006112 <HAL_SPI_TransmitReceive_IT+0xbe>
    __HAL_SPI_ENABLE(hspi);
 80060ee:	681a      	ldr	r2, [r3, #0]
 80060f0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80060f4:	601a      	str	r2, [r3, #0]
 80060f6:	e7c6      	b.n	8006086 <HAL_SPI_TransmitReceive_IT+0x32>
    errorcode = HAL_ERROR;
 80060f8:	2001      	movs	r0, #1
 80060fa:	e7c4      	b.n	8006086 <HAL_SPI_TransmitReceive_IT+0x32>
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
 80060fc:	f240 619a 	movw	r1, #1690	; 0x69a
 8006100:	480d      	ldr	r0, [pc, #52]	; (8006138 <HAL_SPI_TransmitReceive_IT+0xe4>)
 8006102:	f014 fecf 	bl	801aea4 <assert_failed>
  __HAL_LOCK(hspi);
 8006106:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800610a:	2b01      	cmp	r3, #1
 800610c:	d1ae      	bne.n	800606c <HAL_SPI_TransmitReceive_IT+0x18>
 800610e:	2002      	movs	r0, #2
}
 8006110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef    errorcode = HAL_OK;
 8006112:	2000      	movs	r0, #0
 8006114:	e7b7      	b.n	8006086 <HAL_SPI_TransmitReceive_IT+0x32>
    hspi->RxISR     = SPI_2linesRxISR_8BIT;
 8006116:	4a09      	ldr	r2, [pc, #36]	; (800613c <HAL_SPI_TransmitReceive_IT+0xe8>)
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (Size >= 2U))
 8006118:	2d01      	cmp	r5, #1
    hspi->TxISR     = SPI_2linesTxISR_8BIT;
 800611a:	4b09      	ldr	r3, [pc, #36]	; (8006140 <HAL_SPI_TransmitReceive_IT+0xec>)
 800611c:	e9c4 2313 	strd	r2, r3, [r4, #76]	; 0x4c
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (Size >= 2U))
 8006120:	d1d8      	bne.n	80060d4 <HAL_SPI_TransmitReceive_IT+0x80>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006122:	6823      	ldr	r3, [r4, #0]
 8006124:	685a      	ldr	r2, [r3, #4]
 8006126:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800612a:	605a      	str	r2, [r3, #4]
 800612c:	e7d7      	b.n	80060de <HAL_SPI_TransmitReceive_IT+0x8a>
 800612e:	bf00      	nop
 8006130:	080063dd 	.word	0x080063dd
 8006134:	08006359 	.word	0x08006359
 8006138:	08021768 	.word	0x08021768
 800613c:	0800614d 	.word	0x0800614d
 8006140:	08006465 	.word	0x08006465

08006144 <HAL_SPI_RxCpltCallback>:
 8006144:	4770      	bx	lr
 8006146:	bf00      	nop

08006148 <HAL_SPI_ErrorCallback>:
 8006148:	4770      	bx	lr
 800614a:	bf00      	nop

0800614c <SPI_2linesRxISR_8BIT>:
  if (hspi->RxXferCount > 1U)
 800614c:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8006150:	b29b      	uxth	r3, r3
 8006152:	2b01      	cmp	r3, #1
{
 8006154:	b510      	push	{r4, lr}
 8006156:	4604      	mov	r4, r0
  if (hspi->RxXferCount > 1U)
 8006158:	d922      	bls.n	80061a0 <SPI_2linesRxISR_8BIT+0x54>
    *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
 800615a:	6801      	ldr	r1, [r0, #0]
 800615c:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800615e:	68cb      	ldr	r3, [r1, #12]
 8006160:	f822 3b02 	strh.w	r3, [r2], #2
    hspi->RxXferCount -= 2U;
 8006164:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
    hspi->pRxBuffPtr += sizeof(uint16_t);
 8006168:	6402      	str	r2, [r0, #64]	; 0x40
    hspi->RxXferCount -= 2U;
 800616a:	3b02      	subs	r3, #2
 800616c:	b29b      	uxth	r3, r3
 800616e:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
    if (hspi->RxXferCount == 1U)
 8006172:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8006176:	b29b      	uxth	r3, r3
 8006178:	2b01      	cmp	r3, #1
 800617a:	d00c      	beq.n	8006196 <SPI_2linesRxISR_8BIT+0x4a>
  if (hspi->RxXferCount == 0U)
 800617c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8006180:	b29b      	uxth	r3, r3
 8006182:	b93b      	cbnz	r3, 8006194 <SPI_2linesRxISR_8BIT+0x48>
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 8006184:	6822      	ldr	r2, [r4, #0]
 8006186:	6853      	ldr	r3, [r2, #4]
 8006188:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 800618c:	6053      	str	r3, [r2, #4]
    if (hspi->TxXferCount == 0U)
 800618e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8006190:	b29b      	uxth	r3, r3
 8006192:	b19b      	cbz	r3, 80061bc <SPI_2linesRxISR_8BIT+0x70>
}
 8006194:	bd10      	pop	{r4, pc}
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006196:	684b      	ldr	r3, [r1, #4]
 8006198:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800619c:	604b      	str	r3, [r1, #4]
 800619e:	e7ed      	b.n	800617c <SPI_2linesRxISR_8BIT+0x30>
    *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
 80061a0:	6802      	ldr	r2, [r0, #0]
 80061a2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80061a4:	7b12      	ldrb	r2, [r2, #12]
 80061a6:	701a      	strb	r2, [r3, #0]
    hspi->RxXferCount--;
 80061a8:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
    hspi->pRxBuffPtr++;
 80061ac:	6c02      	ldr	r2, [r0, #64]	; 0x40
    hspi->RxXferCount--;
 80061ae:	3b01      	subs	r3, #1
    hspi->pRxBuffPtr++;
 80061b0:	3201      	adds	r2, #1
    hspi->RxXferCount--;
 80061b2:	b29b      	uxth	r3, r3
    hspi->pRxBuffPtr++;
 80061b4:	6402      	str	r2, [r0, #64]	; 0x40
    hspi->RxXferCount--;
 80061b6:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
 80061ba:	e7df      	b.n	800617c <SPI_2linesRxISR_8BIT+0x30>
static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
{
  uint32_t tickstart;

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 80061bc:	f7fa ff58 	bl	8001070 <HAL_GetTick>

  /* Disable ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80061c0:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 80061c2:	4601      	mov	r1, r0

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80061c4:	4620      	mov	r0, r4
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80061c6:	6853      	ldr	r3, [r2, #4]
 80061c8:	f023 0320 	bic.w	r3, r3, #32
 80061cc:	6053      	str	r3, [r2, #4]
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80061ce:	f7ff fdc5 	bl	8005d5c <SPI_EndRxTxTransaction.constprop.0>
 80061d2:	b118      	cbz	r0, 80061dc <SPI_2linesRxISR_8BIT+0x90>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80061d4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80061d6:	f043 0320 	orr.w	r3, r3, #32
 80061da:	6623      	str	r3, [r4, #96]	; 0x60
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }
  else
  {
#endif /* USE_SPI_CRC */
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 80061dc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80061de:	b95b      	cbnz	r3, 80061f8 <SPI_2linesRxISR_8BIT+0xac>
    {
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80061e0:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
        hspi->State = HAL_SPI_STATE_READY;
        /* Call user Rx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
        hspi->RxCpltCallback(hspi);
#else
        HAL_SPI_RxCpltCallback(hspi);
 80061e4:	4620      	mov	r0, r4
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80061e6:	2b04      	cmp	r3, #4
        hspi->State = HAL_SPI_STATE_READY;
 80061e8:	f04f 0301 	mov.w	r3, #1
 80061ec:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80061f0:	d009      	beq.n	8006206 <SPI_2linesRxISR_8BIT+0xba>
        hspi->State = HAL_SPI_STATE_READY;
        /* Call user TxRx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
        hspi->TxRxCpltCallback(hspi);
#else
        HAL_SPI_TxRxCpltCallback(hspi);
 80061f2:	f017 fc77 	bl	801dae4 <HAL_SPI_TxRxCpltCallback>
}
 80061f6:	bd10      	pop	{r4, pc}
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    else
    {
      hspi->State = HAL_SPI_STATE_READY;
 80061f8:	2301      	movs	r3, #1
      /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 80061fa:	4620      	mov	r0, r4
      hspi->State = HAL_SPI_STATE_READY;
 80061fc:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 8006200:	f7ff ffa2 	bl	8006148 <HAL_SPI_ErrorCallback>
}
 8006204:	bd10      	pop	{r4, pc}
        HAL_SPI_RxCpltCallback(hspi);
 8006206:	f7ff ff9d 	bl	8006144 <HAL_SPI_RxCpltCallback>
}
 800620a:	bd10      	pop	{r4, pc}

0800620c <HAL_SPI_IRQHandler>:
  uint32_t itsource = hspi->Instance->CR2;
 800620c:	6802      	ldr	r2, [r0, #0]
 800620e:	6851      	ldr	r1, [r2, #4]
  uint32_t itflag   = hspi->Instance->SR;
 8006210:	6893      	ldr	r3, [r2, #8]
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8006212:	f013 0f40 	tst.w	r3, #64	; 0x40
{
 8006216:	b530      	push	{r4, r5, lr}
 8006218:	4604      	mov	r4, r0
 800621a:	b085      	sub	sp, #20
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 800621c:	f3c3 1580 	ubfx	r5, r3, #6, #1
 8006220:	d105      	bne.n	800622e <HAL_SPI_IRQHandler+0x22>
 8006222:	f013 0f01 	tst.w	r3, #1
 8006226:	d002      	beq.n	800622e <HAL_SPI_IRQHandler+0x22>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8006228:	f011 0f40 	tst.w	r1, #64	; 0x40
 800622c:	d17a      	bne.n	8006324 <HAL_SPI_IRQHandler+0x118>
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 800622e:	0798      	lsls	r0, r3, #30
 8006230:	d501      	bpl.n	8006236 <HAL_SPI_IRQHandler+0x2a>
 8006232:	0608      	lsls	r0, r1, #24
 8006234:	d470      	bmi.n	8006318 <HAL_SPI_IRQHandler+0x10c>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8006236:	f013 0f20 	tst.w	r3, #32
 800623a:	f3c3 1040 	ubfx	r0, r3, #5, #1
 800623e:	d049      	beq.n	80062d4 <HAL_SPI_IRQHandler+0xc8>
 8006240:	0688      	lsls	r0, r1, #26
 8006242:	d545      	bpl.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8006244:	b175      	cbz	r5, 8006264 <HAL_SPI_IRQHandler+0x58>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8006246:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 800624a:	2803      	cmp	r0, #3
 800624c:	d06c      	beq.n	8006328 <HAL_SPI_IRQHandler+0x11c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 800624e:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8006250:	f040 0004 	orr.w	r0, r0, #4
 8006254:	6620      	str	r0, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8006256:	2000      	movs	r0, #0
 8006258:	9000      	str	r0, [sp, #0]
 800625a:	68d0      	ldr	r0, [r2, #12]
 800625c:	9000      	str	r0, [sp, #0]
 800625e:	6890      	ldr	r0, [r2, #8]
 8006260:	9000      	str	r0, [sp, #0]
 8006262:	9800      	ldr	r0, [sp, #0]
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8006264:	6e20      	ldr	r0, [r4, #96]	; 0x60
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8006266:	f3c3 2300 	ubfx	r3, r3, #8, #1
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 800626a:	f040 0001 	orr.w	r0, r0, #1
 800626e:	6620      	str	r0, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8006270:	2000      	movs	r0, #0
 8006272:	9002      	str	r0, [sp, #8]
 8006274:	6890      	ldr	r0, [r2, #8]
 8006276:	9002      	str	r0, [sp, #8]
 8006278:	6810      	ldr	r0, [r2, #0]
 800627a:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800627e:	6010      	str	r0, [r2, #0]
 8006280:	9802      	ldr	r0, [sp, #8]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 8006282:	2b00      	cmp	r3, #0
 8006284:	d13e      	bne.n	8006304 <HAL_SPI_IRQHandler+0xf8>
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8006286:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8006288:	b313      	cbz	r3, 80062d0 <HAL_SPI_IRQHandler+0xc4>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800628a:	6853      	ldr	r3, [r2, #4]
      hspi->State = HAL_SPI_STATE_READY;
 800628c:	2001      	movs	r0, #1
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800628e:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8006292:	6053      	str	r3, [r2, #4]
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8006294:	078b      	lsls	r3, r1, #30
      hspi->State = HAL_SPI_STATE_READY;
 8006296:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 800629a:	d04d      	beq.n	8006338 <HAL_SPI_IRQHandler+0x12c>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 800629c:	6853      	ldr	r3, [r2, #4]
        if (hspi->hdmarx != NULL)
 800629e:	6da0      	ldr	r0, [r4, #88]	; 0x58
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 80062a0:	f023 0303 	bic.w	r3, r3, #3
 80062a4:	6053      	str	r3, [r2, #4]
        if (hspi->hdmarx != NULL)
 80062a6:	b140      	cbz	r0, 80062ba <HAL_SPI_IRQHandler+0xae>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 80062a8:	4b25      	ldr	r3, [pc, #148]	; (8006340 <HAL_SPI_IRQHandler+0x134>)
 80062aa:	6503      	str	r3, [r0, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 80062ac:	f7fb faae 	bl	800180c <HAL_DMA_Abort_IT>
 80062b0:	b118      	cbz	r0, 80062ba <HAL_SPI_IRQHandler+0xae>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 80062b2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80062b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80062b8:	6623      	str	r3, [r4, #96]	; 0x60
        if (hspi->hdmatx != NULL)
 80062ba:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80062bc:	b140      	cbz	r0, 80062d0 <HAL_SPI_IRQHandler+0xc4>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 80062be:	4b20      	ldr	r3, [pc, #128]	; (8006340 <HAL_SPI_IRQHandler+0x134>)
 80062c0:	6503      	str	r3, [r0, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 80062c2:	f7fb faa3 	bl	800180c <HAL_DMA_Abort_IT>
 80062c6:	b118      	cbz	r0, 80062d0 <HAL_SPI_IRQHandler+0xc4>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 80062c8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80062ca:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80062ce:	6623      	str	r3, [r4, #96]	; 0x60
}
 80062d0:	b005      	add	sp, #20
 80062d2:	bd30      	pop	{r4, r5, pc}
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 80062d4:	b195      	cbz	r5, 80062fc <HAL_SPI_IRQHandler+0xf0>
 80062d6:	068d      	lsls	r5, r1, #26
 80062d8:	d5fa      	bpl.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 80062da:	f894 505d 	ldrb.w	r5, [r4, #93]	; 0x5d
 80062de:	2d03      	cmp	r5, #3
 80062e0:	d022      	beq.n	8006328 <HAL_SPI_IRQHandler+0x11c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80062e2:	6e25      	ldr	r5, [r4, #96]	; 0x60
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 80062e4:	f3c3 2300 	ubfx	r3, r3, #8, #1
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80062e8:	f045 0504 	orr.w	r5, r5, #4
 80062ec:	6625      	str	r5, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80062ee:	9000      	str	r0, [sp, #0]
 80062f0:	68d0      	ldr	r0, [r2, #12]
 80062f2:	9000      	str	r0, [sp, #0]
 80062f4:	6890      	ldr	r0, [r2, #8]
 80062f6:	9000      	str	r0, [sp, #0]
 80062f8:	9800      	ldr	r0, [sp, #0]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 80062fa:	e7c2      	b.n	8006282 <HAL_SPI_IRQHandler+0x76>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 80062fc:	05dd      	lsls	r5, r3, #23
 80062fe:	d5e7      	bpl.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
 8006300:	068b      	lsls	r3, r1, #26
 8006302:	d5e5      	bpl.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8006304:	6e23      	ldr	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8006306:	2000      	movs	r0, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8006308:	f043 0308 	orr.w	r3, r3, #8
 800630c:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800630e:	9003      	str	r0, [sp, #12]
 8006310:	6893      	ldr	r3, [r2, #8]
 8006312:	9303      	str	r3, [sp, #12]
 8006314:	9b03      	ldr	r3, [sp, #12]
 8006316:	e7b6      	b.n	8006286 <HAL_SPI_IRQHandler+0x7a>
    hspi->TxISR(hspi);
 8006318:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800631a:	4620      	mov	r0, r4
}
 800631c:	b005      	add	sp, #20
 800631e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    hspi->TxISR(hspi);
 8006322:	4718      	bx	r3
    hspi->RxISR(hspi);
 8006324:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8006326:	e7f9      	b.n	800631c <HAL_SPI_IRQHandler+0x110>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8006328:	2300      	movs	r3, #0
 800632a:	9301      	str	r3, [sp, #4]
 800632c:	68d3      	ldr	r3, [r2, #12]
 800632e:	9301      	str	r3, [sp, #4]
 8006330:	6893      	ldr	r3, [r2, #8]
 8006332:	9301      	str	r3, [sp, #4]
 8006334:	9b01      	ldr	r3, [sp, #4]
        return;
 8006336:	e7cb      	b.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
        HAL_SPI_ErrorCallback(hspi);
 8006338:	4620      	mov	r0, r4
 800633a:	f7ff ff05 	bl	8006148 <HAL_SPI_ErrorCallback>
 800633e:	e7c7      	b.n	80062d0 <HAL_SPI_IRQHandler+0xc4>
 8006340:	08006345 	.word	0x08006345

08006344 <SPI_DMAAbortOnError>:
{
 8006344:	b508      	push	{r3, lr}
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8006346:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8006348:	2300      	movs	r3, #0
 800634a:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  hspi->TxXferCount = 0U;
 800634e:	87c3      	strh	r3, [r0, #62]	; 0x3e
  HAL_SPI_ErrorCallback(hspi);
 8006350:	f7ff fefa 	bl	8006148 <HAL_SPI_ErrorCallback>
}
 8006354:	bd08      	pop	{r3, pc}
 8006356:	bf00      	nop

08006358 <SPI_2linesTxISR_16BIT>:
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8006358:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800635a:	6801      	ldr	r1, [r0, #0]
 800635c:	f832 3b02 	ldrh.w	r3, [r2], #2
 8006360:	60cb      	str	r3, [r1, #12]
  hspi->TxXferCount--;
 8006362:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
  hspi->pTxBuffPtr += sizeof(uint16_t);
 8006364:	6382      	str	r2, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 8006366:	3b01      	subs	r3, #1
 8006368:	b29b      	uxth	r3, r3
 800636a:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 800636c:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800636e:	b29b      	uxth	r3, r3
 8006370:	b953      	cbnz	r3, 8006388 <SPI_2linesTxISR_16BIT+0x30>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 8006372:	684b      	ldr	r3, [r1, #4]
 8006374:	f023 0380 	bic.w	r3, r3, #128	; 0x80
{
 8006378:	b510      	push	{r4, lr}
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 800637a:	604b      	str	r3, [r1, #4]
    if (hspi->RxXferCount == 0U)
 800637c:	4604      	mov	r4, r0
 800637e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8006382:	b29b      	uxth	r3, r3
 8006384:	b10b      	cbz	r3, 800638a <SPI_2linesTxISR_16BIT+0x32>
}
 8006386:	bd10      	pop	{r4, pc}
 8006388:	4770      	bx	lr
  tickstart = HAL_GetTick();
 800638a:	f7fa fe71 	bl	8001070 <HAL_GetTick>
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800638e:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 8006390:	4601      	mov	r1, r0
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8006392:	4620      	mov	r0, r4
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8006394:	6853      	ldr	r3, [r2, #4]
 8006396:	f023 0320 	bic.w	r3, r3, #32
 800639a:	6053      	str	r3, [r2, #4]
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800639c:	f7ff fcde 	bl	8005d5c <SPI_EndRxTxTransaction.constprop.0>
 80063a0:	b118      	cbz	r0, 80063aa <SPI_2linesTxISR_16BIT+0x52>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80063a2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80063a4:	f043 0320 	orr.w	r3, r3, #32
 80063a8:	6623      	str	r3, [r4, #96]	; 0x60
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 80063aa:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80063ac:	b95b      	cbnz	r3, 80063c6 <SPI_2linesTxISR_16BIT+0x6e>
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80063ae:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_RxCpltCallback(hspi);
 80063b2:	4620      	mov	r0, r4
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80063b4:	2b04      	cmp	r3, #4
        hspi->State = HAL_SPI_STATE_READY;
 80063b6:	f04f 0301 	mov.w	r3, #1
 80063ba:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80063be:	d009      	beq.n	80063d4 <SPI_2linesTxISR_16BIT+0x7c>
        HAL_SPI_TxRxCpltCallback(hspi);
 80063c0:	f017 fb90 	bl	801dae4 <HAL_SPI_TxRxCpltCallback>
}
 80063c4:	bd10      	pop	{r4, pc}
      hspi->State = HAL_SPI_STATE_READY;
 80063c6:	2301      	movs	r3, #1
      HAL_SPI_ErrorCallback(hspi);
 80063c8:	4620      	mov	r0, r4
      hspi->State = HAL_SPI_STATE_READY;
 80063ca:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 80063ce:	f7ff febb 	bl	8006148 <HAL_SPI_ErrorCallback>
}
 80063d2:	bd10      	pop	{r4, pc}
        HAL_SPI_RxCpltCallback(hspi);
 80063d4:	f7ff feb6 	bl	8006144 <HAL_SPI_RxCpltCallback>
}
 80063d8:	bd10      	pop	{r4, pc}
 80063da:	bf00      	nop

080063dc <SPI_2linesRxISR_16BIT>:
  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
 80063dc:	6801      	ldr	r1, [r0, #0]
 80063de:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80063e0:	68cb      	ldr	r3, [r1, #12]
 80063e2:	f822 3b02 	strh.w	r3, [r2], #2
  hspi->RxXferCount--;
 80063e6:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
  hspi->pRxBuffPtr += sizeof(uint16_t);
 80063ea:	6402      	str	r2, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 80063ec:	3b01      	subs	r3, #1
 80063ee:	b29b      	uxth	r3, r3
 80063f0:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  if (hspi->RxXferCount == 0U)
 80063f4:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 80063f8:	b29b      	uxth	r3, r3
 80063fa:	b94b      	cbnz	r3, 8006410 <SPI_2linesRxISR_16BIT+0x34>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 80063fc:	684b      	ldr	r3, [r1, #4]
 80063fe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
{
 8006402:	b510      	push	{r4, lr}
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 8006404:	604b      	str	r3, [r1, #4]
    if (hspi->TxXferCount == 0U)
 8006406:	4604      	mov	r4, r0
 8006408:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800640a:	b29b      	uxth	r3, r3
 800640c:	b10b      	cbz	r3, 8006412 <SPI_2linesRxISR_16BIT+0x36>
}
 800640e:	bd10      	pop	{r4, pc}
 8006410:	4770      	bx	lr
  tickstart = HAL_GetTick();
 8006412:	f7fa fe2d 	bl	8001070 <HAL_GetTick>
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8006416:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 8006418:	4601      	mov	r1, r0
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800641a:	4620      	mov	r0, r4
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800641c:	6853      	ldr	r3, [r2, #4]
 800641e:	f023 0320 	bic.w	r3, r3, #32
 8006422:	6053      	str	r3, [r2, #4]
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8006424:	f7ff fc9a 	bl	8005d5c <SPI_EndRxTxTransaction.constprop.0>
 8006428:	b118      	cbz	r0, 8006432 <SPI_2linesRxISR_16BIT+0x56>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800642a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800642c:	f043 0320 	orr.w	r3, r3, #32
 8006430:	6623      	str	r3, [r4, #96]	; 0x60
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 8006432:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8006434:	b95b      	cbnz	r3, 800644e <SPI_2linesRxISR_16BIT+0x72>
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8006436:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_RxCpltCallback(hspi);
 800643a:	4620      	mov	r0, r4
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 800643c:	2b04      	cmp	r3, #4
        hspi->State = HAL_SPI_STATE_READY;
 800643e:	f04f 0301 	mov.w	r3, #1
 8006442:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8006446:	d009      	beq.n	800645c <SPI_2linesRxISR_16BIT+0x80>
        HAL_SPI_TxRxCpltCallback(hspi);
 8006448:	f017 fb4c 	bl	801dae4 <HAL_SPI_TxRxCpltCallback>
}
 800644c:	bd10      	pop	{r4, pc}
      hspi->State = HAL_SPI_STATE_READY;
 800644e:	2301      	movs	r3, #1
      HAL_SPI_ErrorCallback(hspi);
 8006450:	4620      	mov	r0, r4
      hspi->State = HAL_SPI_STATE_READY;
 8006452:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 8006456:	f7ff fe77 	bl	8006148 <HAL_SPI_ErrorCallback>
}
 800645a:	bd10      	pop	{r4, pc}
        HAL_SPI_RxCpltCallback(hspi);
 800645c:	f7ff fe72 	bl	8006144 <HAL_SPI_RxCpltCallback>
}
 8006460:	bd10      	pop	{r4, pc}
 8006462:	bf00      	nop

08006464 <SPI_2linesTxISR_8BIT>:
  if (hspi->TxXferCount >= 2U)
 8006464:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8006466:	6b82      	ldr	r2, [r0, #56]	; 0x38
  if (hspi->TxXferCount >= 2U)
 8006468:	b29b      	uxth	r3, r3
 800646a:	2b01      	cmp	r3, #1
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800646c:	6803      	ldr	r3, [r0, #0]
{
 800646e:	b510      	push	{r4, lr}
 8006470:	4604      	mov	r4, r0
  if (hspi->TxXferCount >= 2U)
 8006472:	d914      	bls.n	800649e <SPI_2linesTxISR_8BIT+0x3a>
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8006474:	f832 1b02 	ldrh.w	r1, [r2], #2
 8006478:	60d9      	str	r1, [r3, #12]
    hspi->TxXferCount -= 2U;
 800647a:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    hspi->pTxBuffPtr += sizeof(uint16_t);
 800647c:	6382      	str	r2, [r0, #56]	; 0x38
    hspi->TxXferCount -= 2U;
 800647e:	3b02      	subs	r3, #2
 8006480:	b29b      	uxth	r3, r3
 8006482:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 8006484:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8006486:	b29b      	uxth	r3, r3
 8006488:	b943      	cbnz	r3, 800649c <SPI_2linesTxISR_8BIT+0x38>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 800648a:	6822      	ldr	r2, [r4, #0]
 800648c:	6853      	ldr	r3, [r2, #4]
 800648e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006492:	6053      	str	r3, [r2, #4]
    if (hspi->RxXferCount == 0U)
 8006494:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8006498:	b29b      	uxth	r3, r3
 800649a:	b153      	cbz	r3, 80064b2 <SPI_2linesTxISR_8BIT+0x4e>
}
 800649c:	bd10      	pop	{r4, pc}
    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800649e:	7812      	ldrb	r2, [r2, #0]
 80064a0:	731a      	strb	r2, [r3, #12]
    hspi->TxXferCount--;
 80064a2:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    hspi->pTxBuffPtr++;
 80064a4:	6b82      	ldr	r2, [r0, #56]	; 0x38
    hspi->TxXferCount--;
 80064a6:	3b01      	subs	r3, #1
    hspi->pTxBuffPtr++;
 80064a8:	3201      	adds	r2, #1
    hspi->TxXferCount--;
 80064aa:	b29b      	uxth	r3, r3
    hspi->pTxBuffPtr++;
 80064ac:	6382      	str	r2, [r0, #56]	; 0x38
    hspi->TxXferCount--;
 80064ae:	87c3      	strh	r3, [r0, #62]	; 0x3e
 80064b0:	e7e8      	b.n	8006484 <SPI_2linesTxISR_8BIT+0x20>
  tickstart = HAL_GetTick();
 80064b2:	f7fa fddd 	bl	8001070 <HAL_GetTick>
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80064b6:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 80064b8:	4601      	mov	r1, r0
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80064ba:	4620      	mov	r0, r4
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80064bc:	6853      	ldr	r3, [r2, #4]
 80064be:	f023 0320 	bic.w	r3, r3, #32
 80064c2:	6053      	str	r3, [r2, #4]
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80064c4:	f7ff fc4a 	bl	8005d5c <SPI_EndRxTxTransaction.constprop.0>
 80064c8:	b118      	cbz	r0, 80064d2 <SPI_2linesTxISR_8BIT+0x6e>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80064ca:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80064cc:	f043 0320 	orr.w	r3, r3, #32
 80064d0:	6623      	str	r3, [r4, #96]	; 0x60
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 80064d2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80064d4:	b95b      	cbnz	r3, 80064ee <SPI_2linesTxISR_8BIT+0x8a>
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80064d6:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_RxCpltCallback(hspi);
 80064da:	4620      	mov	r0, r4
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80064dc:	2b04      	cmp	r3, #4
        hspi->State = HAL_SPI_STATE_READY;
 80064de:	f04f 0301 	mov.w	r3, #1
 80064e2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80064e6:	d009      	beq.n	80064fc <SPI_2linesTxISR_8BIT+0x98>
        HAL_SPI_TxRxCpltCallback(hspi);
 80064e8:	f017 fafc 	bl	801dae4 <HAL_SPI_TxRxCpltCallback>
}
 80064ec:	bd10      	pop	{r4, pc}
      hspi->State = HAL_SPI_STATE_READY;
 80064ee:	2301      	movs	r3, #1
      HAL_SPI_ErrorCallback(hspi);
 80064f0:	4620      	mov	r0, r4
      hspi->State = HAL_SPI_STATE_READY;
 80064f2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 80064f6:	f7ff fe27 	bl	8006148 <HAL_SPI_ErrorCallback>
}
 80064fa:	bd10      	pop	{r4, pc}
        HAL_SPI_RxCpltCallback(hspi);
 80064fc:	f7ff fe22 	bl	8006144 <HAL_SPI_RxCpltCallback>
}
 8006500:	bd10      	pop	{r4, pc}
 8006502:	bf00      	nop

08006504 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8006504:	2800      	cmp	r0, #0
 8006506:	f000 8113 	beq.w	8006730 <HAL_TIM_Base_Init+0x22c>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800650a:	6802      	ldr	r2, [r0, #0]
 800650c:	4b8d      	ldr	r3, [pc, #564]	; (8006744 <HAL_TIM_Base_Init+0x240>)
 800650e:	498e      	ldr	r1, [pc, #568]	; (8006748 <HAL_TIM_Base_Init+0x244>)
 8006510:	429a      	cmp	r2, r3
 8006512:	bf18      	it	ne
 8006514:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
{
 8006518:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800651a:	bf14      	ite	ne
 800651c:	2301      	movne	r3, #1
 800651e:	2300      	moveq	r3, #0
 8006520:	4604      	mov	r4, r0
 8006522:	488a      	ldr	r0, [pc, #552]	; (800674c <HAL_TIM_Base_Init+0x248>)
 8006524:	4282      	cmp	r2, r0
 8006526:	bf0c      	ite	eq
 8006528:	2300      	moveq	r3, #0
 800652a:	f003 0301 	andne.w	r3, r3, #1
 800652e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8006532:	428a      	cmp	r2, r1
 8006534:	bf0c      	ite	eq
 8006536:	2300      	moveq	r3, #0
 8006538:	f003 0301 	andne.w	r3, r3, #1
 800653c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8006540:	4282      	cmp	r2, r0
 8006542:	bf0c      	ite	eq
 8006544:	2300      	moveq	r3, #0
 8006546:	f003 0301 	andne.w	r3, r3, #1
 800654a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800654e:	428a      	cmp	r2, r1
 8006550:	bf0c      	ite	eq
 8006552:	2300      	moveq	r3, #0
 8006554:	f003 0301 	andne.w	r3, r3, #1
 8006558:	f501 4174 	add.w	r1, r1, #62464	; 0xf400
 800655c:	4282      	cmp	r2, r0
 800655e:	bf0c      	ite	eq
 8006560:	2300      	moveq	r3, #0
 8006562:	f003 0301 	andne.w	r3, r3, #1
 8006566:	f500 3096 	add.w	r0, r0, #76800	; 0x12c00
 800656a:	428a      	cmp	r2, r1
 800656c:	bf0c      	ite	eq
 800656e:	2300      	moveq	r3, #0
 8006570:	f003 0301 	andne.w	r3, r3, #1
 8006574:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
 8006578:	4282      	cmp	r2, r0
 800657a:	bf0c      	ite	eq
 800657c:	2300      	moveq	r3, #0
 800657e:	f003 0301 	andne.w	r3, r3, #1
 8006582:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8006586:	428a      	cmp	r2, r1
 8006588:	bf0c      	ite	eq
 800658a:	2300      	moveq	r3, #0
 800658c:	f003 0301 	andne.w	r3, r3, #1
 8006590:	f5a1 3196 	sub.w	r1, r1, #76800	; 0x12c00
 8006594:	4282      	cmp	r2, r0
 8006596:	bf0c      	ite	eq
 8006598:	2300      	moveq	r3, #0
 800659a:	f003 0301 	andne.w	r3, r3, #1
 800659e:	428a      	cmp	r2, r1
 80065a0:	bf0c      	ite	eq
 80065a2:	2300      	moveq	r3, #0
 80065a4:	f003 0301 	andne.w	r3, r3, #1
 80065a8:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80065ac:	428a      	cmp	r2, r1
 80065ae:	bf0c      	ite	eq
 80065b0:	2300      	moveq	r3, #0
 80065b2:	f003 0301 	andne.w	r3, r3, #1
 80065b6:	b11b      	cbz	r3, 80065c0 <HAL_TIM_Base_Init+0xbc>
 80065b8:	4b65      	ldr	r3, [pc, #404]	; (8006750 <HAL_TIM_Base_Init+0x24c>)
 80065ba:	429a      	cmp	r2, r3
 80065bc:	f040 80bc 	bne.w	8006738 <HAL_TIM_Base_Init+0x234>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 80065c0:	68a3      	ldr	r3, [r4, #8]
 80065c2:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 80065c6:	f023 0210 	bic.w	r2, r3, #16
 80065ca:	2920      	cmp	r1, #32
 80065cc:	bf18      	it	ne
 80065ce:	2a00      	cmpne	r2, #0
 80065d0:	d002      	beq.n	80065d8 <HAL_TIM_Base_Init+0xd4>
 80065d2:	2b40      	cmp	r3, #64	; 0x40
 80065d4:	f040 809c 	bne.w	8006710 <HAL_TIM_Base_Init+0x20c>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 80065d8:	6923      	ldr	r3, [r4, #16]
 80065da:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 80065de:	d002      	beq.n	80065e6 <HAL_TIM_Base_Init+0xe2>
 80065e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80065e4:	d16d      	bne.n	80066c2 <HAL_TIM_Base_Init+0x1be>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 80065e6:	69a3      	ldr	r3, [r4, #24]
 80065e8:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 80065ec:	d172      	bne.n	80066d4 <HAL_TIM_Base_Init+0x1d0>

  if (htim->State == HAL_TIM_STATE_RESET)
 80065ee:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80065f2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80065f6:	2b00      	cmp	r3, #0
 80065f8:	d077      	beq.n	80066ea <HAL_TIM_Base_Init+0x1e6>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80065fa:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80065fc:	2302      	movs	r3, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80065fe:	4951      	ldr	r1, [pc, #324]	; (8006744 <HAL_TIM_Base_Init+0x240>)
 8006600:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->State = HAL_TIM_STATE_BUSY;
 8006604:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006608:	eba2 0101 	sub.w	r1, r2, r1
  tmpcr1 = TIMx->CR1;
 800660c:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800660e:	fab1 f181 	clz	r1, r1
 8006612:	ea4f 1151 	mov.w	r1, r1, lsr #5
 8006616:	d036      	beq.n	8006686 <HAL_TIM_Base_Init+0x182>
 8006618:	2900      	cmp	r1, #0
 800661a:	d134      	bne.n	8006686 <HAL_TIM_Base_Init+0x182>
 800661c:	4d4b      	ldr	r5, [pc, #300]	; (800674c <HAL_TIM_Base_Init+0x248>)
 800661e:	484a      	ldr	r0, [pc, #296]	; (8006748 <HAL_TIM_Base_Init+0x244>)
 8006620:	4282      	cmp	r2, r0
 8006622:	bf18      	it	ne
 8006624:	42aa      	cmpne	r2, r5
 8006626:	d069      	beq.n	80066fc <HAL_TIM_Base_Init+0x1f8>
 8006628:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
 800662c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8006630:	1b55      	subs	r5, r2, r5
 8006632:	4282      	cmp	r2, r0
 8006634:	fab5 f585 	clz	r5, r5
 8006638:	ea4f 1555 	mov.w	r5, r5, lsr #5
 800663c:	d06e      	beq.n	800671c <HAL_TIM_Base_Init+0x218>
 800663e:	2d00      	cmp	r5, #0
 8006640:	d16c      	bne.n	800671c <HAL_TIM_Base_Init+0x218>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8006642:	4d44      	ldr	r5, [pc, #272]	; (8006754 <HAL_TIM_Base_Init+0x250>)
 8006644:	4844      	ldr	r0, [pc, #272]	; (8006758 <HAL_TIM_Base_Init+0x254>)
 8006646:	4282      	cmp	r2, r0
 8006648:	bf18      	it	ne
 800664a:	42aa      	cmpne	r2, r5
 800664c:	bf0c      	ite	eq
 800664e:	2501      	moveq	r5, #1
 8006650:	2500      	movne	r5, #0
 8006652:	d06f      	beq.n	8006734 <HAL_TIM_Base_Init+0x230>
 8006654:	4e41      	ldr	r6, [pc, #260]	; (800675c <HAL_TIM_Base_Init+0x258>)
 8006656:	f5a0 3096 	sub.w	r0, r0, #76800	; 0x12c00
 800665a:	4282      	cmp	r2, r0
 800665c:	bf18      	it	ne
 800665e:	42b2      	cmpne	r2, r6
 8006660:	d01a      	beq.n	8006698 <HAL_TIM_Base_Init+0x194>
 8006662:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8006666:	4282      	cmp	r2, r0
 8006668:	d064      	beq.n	8006734 <HAL_TIM_Base_Init+0x230>
 800666a:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800666e:	4282      	cmp	r2, r0
 8006670:	d060      	beq.n	8006734 <HAL_TIM_Base_Init+0x230>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006672:	69a0      	ldr	r0, [r4, #24]
 8006674:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006678:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800667a:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800667c:	6013      	str	r3, [r2, #0]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800667e:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006680:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8006682:	6293      	str	r3, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8006684:	e017      	b.n	80066b6 <HAL_TIM_Base_Init+0x1b2>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006686:	4d36      	ldr	r5, [pc, #216]	; (8006760 <HAL_TIM_Base_Init+0x25c>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006688:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800668c:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800668e:	1b55      	subs	r5, r2, r5
    tmpcr1 |= Structure->CounterMode;
 8006690:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006692:	fab5 f585 	clz	r5, r5
 8006696:	096d      	lsrs	r5, r5, #5
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006698:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800669a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800669e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80066a0:	69a0      	ldr	r0, [r4, #24]
 80066a2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80066a6:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 80066a8:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80066aa:	68e3      	ldr	r3, [r4, #12]
 80066ac:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80066ae:	6863      	ldr	r3, [r4, #4]
 80066b0:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80066b2:	bb01      	cbnz	r1, 80066f6 <HAL_TIM_Base_Init+0x1f2>
 80066b4:	b9fd      	cbnz	r5, 80066f6 <HAL_TIM_Base_Init+0x1f2>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80066b6:	2301      	movs	r3, #1
  return HAL_OK;
 80066b8:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 80066ba:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 80066bc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 80066c0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 80066c2:	f240 110f 	movw	r1, #271	; 0x10f
 80066c6:	4827      	ldr	r0, [pc, #156]	; (8006764 <HAL_TIM_Base_Init+0x260>)
 80066c8:	f014 fbec 	bl	801aea4 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 80066cc:	69a3      	ldr	r3, [r4, #24]
 80066ce:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 80066d2:	d08c      	beq.n	80065ee <HAL_TIM_Base_Init+0xea>
 80066d4:	f44f 7188 	mov.w	r1, #272	; 0x110
 80066d8:	4822      	ldr	r0, [pc, #136]	; (8006764 <HAL_TIM_Base_Init+0x260>)
 80066da:	f014 fbe3 	bl	801aea4 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 80066de:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80066e2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80066e6:	2b00      	cmp	r3, #0
 80066e8:	d187      	bne.n	80065fa <HAL_TIM_Base_Init+0xf6>
    HAL_TIM_Base_MspInit(htim);
 80066ea:	4620      	mov	r0, r4
    htim->Lock = HAL_UNLOCKED;
 80066ec:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80066f0:	f017 ffc6 	bl	801e680 <HAL_TIM_Base_MspInit>
 80066f4:	e781      	b.n	80065fa <HAL_TIM_Base_Init+0xf6>
    TIMx->RCR = Structure->RepetitionCounter;
 80066f6:	6963      	ldr	r3, [r4, #20]
 80066f8:	6313      	str	r3, [r2, #48]	; 0x30
 80066fa:	e7dc      	b.n	80066b6 <HAL_TIM_Base_Init+0x1b2>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80066fc:	4d18      	ldr	r5, [pc, #96]	; (8006760 <HAL_TIM_Base_Init+0x25c>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80066fe:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8006702:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006704:	1b55      	subs	r5, r2, r5
    tmpcr1 |= Structure->CounterMode;
 8006706:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006708:	fab5 f585 	clz	r5, r5
 800670c:	096d      	lsrs	r5, r5, #5
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800670e:	e7c3      	b.n	8006698 <HAL_TIM_Base_Init+0x194>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 8006710:	f44f 7187 	mov.w	r1, #270	; 0x10e
 8006714:	4813      	ldr	r0, [pc, #76]	; (8006764 <HAL_TIM_Base_Init+0x260>)
 8006716:	f014 fbc5 	bl	801aea4 <assert_failed>
 800671a:	e75d      	b.n	80065d8 <HAL_TIM_Base_Init+0xd4>
    tmpcr1 |= Structure->CounterMode;
 800671c:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800671e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8006722:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006724:	4810      	ldr	r0, [pc, #64]	; (8006768 <HAL_TIM_Base_Init+0x264>)
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8006726:	4282      	cmp	r2, r0
 8006728:	d0b6      	beq.n	8006698 <HAL_TIM_Base_Init+0x194>
 800672a:	2d00      	cmp	r5, #0
 800672c:	d1b4      	bne.n	8006698 <HAL_TIM_Base_Init+0x194>
 800672e:	e788      	b.n	8006642 <HAL_TIM_Base_Init+0x13e>
    return HAL_ERROR;
 8006730:	2001      	movs	r0, #1
}
 8006732:	4770      	bx	lr
 8006734:	2500      	movs	r5, #0
 8006736:	e7af      	b.n	8006698 <HAL_TIM_Base_Init+0x194>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006738:	f240 110d 	movw	r1, #269	; 0x10d
 800673c:	4809      	ldr	r0, [pc, #36]	; (8006764 <HAL_TIM_Base_Init+0x260>)
 800673e:	f014 fbb1 	bl	801aea4 <assert_failed>
 8006742:	e73d      	b.n	80065c0 <HAL_TIM_Base_Init+0xbc>
 8006744:	40010000 	.word	0x40010000
 8006748:	40000800 	.word	0x40000800
 800674c:	40000400 	.word	0x40000400
 8006750:	40002000 	.word	0x40002000
 8006754:	40014000 	.word	0x40014000
 8006758:	40014400 	.word	0x40014400
 800675c:	40014800 	.word	0x40014800
 8006760:	40010400 	.word	0x40010400
 8006764:	080217a0 	.word	0x080217a0
 8006768:	40000c00 	.word	0x40000c00

0800676c <HAL_TIM_Base_Start_IT>:
{
 800676c:	b538      	push	{r3, r4, r5, lr}
 800676e:	4604      	mov	r4, r0
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006770:	4b37      	ldr	r3, [pc, #220]	; (8006850 <HAL_TIM_Base_Start_IT+0xe4>)
 8006772:	4d38      	ldr	r5, [pc, #224]	; (8006854 <HAL_TIM_Base_Start_IT+0xe8>)
 8006774:	6822      	ldr	r2, [r4, #0]
 8006776:	4938      	ldr	r1, [pc, #224]	; (8006858 <HAL_TIM_Base_Start_IT+0xec>)
 8006778:	429a      	cmp	r2, r3
 800677a:	bf18      	it	ne
 800677c:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006780:	4836      	ldr	r0, [pc, #216]	; (800685c <HAL_TIM_Base_Start_IT+0xf0>)
 8006782:	bf14      	ite	ne
 8006784:	2301      	movne	r3, #1
 8006786:	2300      	moveq	r3, #0
 8006788:	42aa      	cmp	r2, r5
 800678a:	bf0c      	ite	eq
 800678c:	2300      	moveq	r3, #0
 800678e:	f003 0301 	andne.w	r3, r3, #1
 8006792:	428a      	cmp	r2, r1
 8006794:	bf0c      	ite	eq
 8006796:	2300      	moveq	r3, #0
 8006798:	f003 0301 	andne.w	r3, r3, #1
 800679c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80067a0:	4282      	cmp	r2, r0
 80067a2:	bf0c      	ite	eq
 80067a4:	2300      	moveq	r3, #0
 80067a6:	f003 0301 	andne.w	r3, r3, #1
 80067aa:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 80067ae:	428a      	cmp	r2, r1
 80067b0:	bf0c      	ite	eq
 80067b2:	2300      	moveq	r3, #0
 80067b4:	f003 0301 	andne.w	r3, r3, #1
 80067b8:	f501 4174 	add.w	r1, r1, #62464	; 0xf400
 80067bc:	4282      	cmp	r2, r0
 80067be:	bf0c      	ite	eq
 80067c0:	2300      	moveq	r3, #0
 80067c2:	f003 0301 	andne.w	r3, r3, #1
 80067c6:	f500 3096 	add.w	r0, r0, #76800	; 0x12c00
 80067ca:	428a      	cmp	r2, r1
 80067cc:	bf0c      	ite	eq
 80067ce:	2300      	moveq	r3, #0
 80067d0:	f003 0301 	andne.w	r3, r3, #1
 80067d4:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
 80067d8:	4282      	cmp	r2, r0
 80067da:	bf0c      	ite	eq
 80067dc:	2300      	moveq	r3, #0
 80067de:	f003 0301 	andne.w	r3, r3, #1
 80067e2:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 80067e6:	428a      	cmp	r2, r1
 80067e8:	bf0c      	ite	eq
 80067ea:	2300      	moveq	r3, #0
 80067ec:	f003 0301 	andne.w	r3, r3, #1
 80067f0:	f5a1 3196 	sub.w	r1, r1, #76800	; 0x12c00
 80067f4:	4282      	cmp	r2, r0
 80067f6:	bf0c      	ite	eq
 80067f8:	2300      	moveq	r3, #0
 80067fa:	f003 0301 	andne.w	r3, r3, #1
 80067fe:	428a      	cmp	r2, r1
 8006800:	bf0c      	ite	eq
 8006802:	2300      	moveq	r3, #0
 8006804:	f003 0301 	andne.w	r3, r3, #1
 8006808:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800680c:	428a      	cmp	r2, r1
 800680e:	bf0c      	ite	eq
 8006810:	2300      	moveq	r3, #0
 8006812:	f003 0301 	andne.w	r3, r3, #1
 8006816:	b113      	cbz	r3, 800681e <HAL_TIM_Base_Start_IT+0xb2>
 8006818:	4b11      	ldr	r3, [pc, #68]	; (8006860 <HAL_TIM_Base_Start_IT+0xf4>)
 800681a:	429a      	cmp	r2, r3
 800681c:	d111      	bne.n	8006842 <HAL_TIM_Base_Start_IT+0xd6>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800681e:	68d1      	ldr	r1, [r2, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006820:	4b10      	ldr	r3, [pc, #64]	; (8006864 <HAL_TIM_Base_Start_IT+0xf8>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8006822:	f041 0101 	orr.w	r1, r1, #1
 8006826:	60d1      	str	r1, [r2, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006828:	6891      	ldr	r1, [r2, #8]
 800682a:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800682c:	2b06      	cmp	r3, #6
 800682e:	d006      	beq.n	800683e <HAL_TIM_Base_Start_IT+0xd2>
 8006830:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006834:	d003      	beq.n	800683e <HAL_TIM_Base_Start_IT+0xd2>
    __HAL_TIM_ENABLE(htim);
 8006836:	6813      	ldr	r3, [r2, #0]
 8006838:	f043 0301 	orr.w	r3, r3, #1
 800683c:	6013      	str	r3, [r2, #0]
}
 800683e:	2000      	movs	r0, #0
 8006840:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006842:	f44f 71da 	mov.w	r1, #436	; 0x1b4
 8006846:	4808      	ldr	r0, [pc, #32]	; (8006868 <HAL_TIM_Base_Start_IT+0xfc>)
 8006848:	f014 fb2c 	bl	801aea4 <assert_failed>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800684c:	6822      	ldr	r2, [r4, #0]
 800684e:	e7e6      	b.n	800681e <HAL_TIM_Base_Start_IT+0xb2>
 8006850:	40010000 	.word	0x40010000
 8006854:	40000400 	.word	0x40000400
 8006858:	40000800 	.word	0x40000800
 800685c:	40000c00 	.word	0x40000c00
 8006860:	40002000 	.word	0x40002000
 8006864:	00010007 	.word	0x00010007
 8006868:	080217a0 	.word	0x080217a0

0800686c <HAL_TIM_Base_Stop_IT>:
{
 800686c:	b538      	push	{r3, r4, r5, lr}
 800686e:	4604      	mov	r4, r0
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006870:	4b38      	ldr	r3, [pc, #224]	; (8006954 <HAL_TIM_Base_Stop_IT+0xe8>)
 8006872:	4d39      	ldr	r5, [pc, #228]	; (8006958 <HAL_TIM_Base_Stop_IT+0xec>)
 8006874:	6822      	ldr	r2, [r4, #0]
 8006876:	4939      	ldr	r1, [pc, #228]	; (800695c <HAL_TIM_Base_Stop_IT+0xf0>)
 8006878:	429a      	cmp	r2, r3
 800687a:	bf18      	it	ne
 800687c:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006880:	4837      	ldr	r0, [pc, #220]	; (8006960 <HAL_TIM_Base_Stop_IT+0xf4>)
 8006882:	bf14      	ite	ne
 8006884:	2301      	movne	r3, #1
 8006886:	2300      	moveq	r3, #0
 8006888:	42aa      	cmp	r2, r5
 800688a:	bf0c      	ite	eq
 800688c:	2300      	moveq	r3, #0
 800688e:	f003 0301 	andne.w	r3, r3, #1
 8006892:	428a      	cmp	r2, r1
 8006894:	bf0c      	ite	eq
 8006896:	2300      	moveq	r3, #0
 8006898:	f003 0301 	andne.w	r3, r3, #1
 800689c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80068a0:	4282      	cmp	r2, r0
 80068a2:	bf0c      	ite	eq
 80068a4:	2300      	moveq	r3, #0
 80068a6:	f003 0301 	andne.w	r3, r3, #1
 80068aa:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 80068ae:	428a      	cmp	r2, r1
 80068b0:	bf0c      	ite	eq
 80068b2:	2300      	moveq	r3, #0
 80068b4:	f003 0301 	andne.w	r3, r3, #1
 80068b8:	f501 4174 	add.w	r1, r1, #62464	; 0xf400
 80068bc:	4282      	cmp	r2, r0
 80068be:	bf0c      	ite	eq
 80068c0:	2300      	moveq	r3, #0
 80068c2:	f003 0301 	andne.w	r3, r3, #1
 80068c6:	f500 3096 	add.w	r0, r0, #76800	; 0x12c00
 80068ca:	428a      	cmp	r2, r1
 80068cc:	bf0c      	ite	eq
 80068ce:	2300      	moveq	r3, #0
 80068d0:	f003 0301 	andne.w	r3, r3, #1
 80068d4:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
 80068d8:	4282      	cmp	r2, r0
 80068da:	bf0c      	ite	eq
 80068dc:	2300      	moveq	r3, #0
 80068de:	f003 0301 	andne.w	r3, r3, #1
 80068e2:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 80068e6:	428a      	cmp	r2, r1
 80068e8:	bf0c      	ite	eq
 80068ea:	2300      	moveq	r3, #0
 80068ec:	f003 0301 	andne.w	r3, r3, #1
 80068f0:	f5a1 3196 	sub.w	r1, r1, #76800	; 0x12c00
 80068f4:	4282      	cmp	r2, r0
 80068f6:	bf0c      	ite	eq
 80068f8:	2300      	moveq	r3, #0
 80068fa:	f003 0301 	andne.w	r3, r3, #1
 80068fe:	428a      	cmp	r2, r1
 8006900:	bf0c      	ite	eq
 8006902:	2300      	moveq	r3, #0
 8006904:	f003 0301 	andne.w	r3, r3, #1
 8006908:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800690c:	428a      	cmp	r2, r1
 800690e:	bf0c      	ite	eq
 8006910:	2300      	moveq	r3, #0
 8006912:	f003 0301 	andne.w	r3, r3, #1
 8006916:	b113      	cbz	r3, 800691e <HAL_TIM_Base_Stop_IT+0xb2>
 8006918:	4b12      	ldr	r3, [pc, #72]	; (8006964 <HAL_TIM_Base_Stop_IT+0xf8>)
 800691a:	429a      	cmp	r2, r3
 800691c:	d113      	bne.n	8006946 <HAL_TIM_Base_Stop_IT+0xda>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 800691e:	68d3      	ldr	r3, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 8006920:	f241 1111 	movw	r1, #4369	; 0x1111
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8006924:	f023 0301 	bic.w	r3, r3, #1
 8006928:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 800692a:	6a13      	ldr	r3, [r2, #32]
 800692c:	420b      	tst	r3, r1
 800692e:	d108      	bne.n	8006942 <HAL_TIM_Base_Stop_IT+0xd6>
 8006930:	6a11      	ldr	r1, [r2, #32]
 8006932:	f240 4344 	movw	r3, #1092	; 0x444
 8006936:	4219      	tst	r1, r3
 8006938:	d103      	bne.n	8006942 <HAL_TIM_Base_Stop_IT+0xd6>
 800693a:	6813      	ldr	r3, [r2, #0]
 800693c:	f023 0301 	bic.w	r3, r3, #1
 8006940:	6013      	str	r3, [r2, #0]
}
 8006942:	2000      	movs	r0, #0
 8006944:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006946:	f44f 71e6 	mov.w	r1, #460	; 0x1cc
 800694a:	4807      	ldr	r0, [pc, #28]	; (8006968 <HAL_TIM_Base_Stop_IT+0xfc>)
 800694c:	f014 faaa 	bl	801aea4 <assert_failed>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8006950:	6822      	ldr	r2, [r4, #0]
 8006952:	e7e4      	b.n	800691e <HAL_TIM_Base_Stop_IT+0xb2>
 8006954:	40010000 	.word	0x40010000
 8006958:	40000400 	.word	0x40000400
 800695c:	40000800 	.word	0x40000800
 8006960:	40000c00 	.word	0x40000c00
 8006964:	40002000 	.word	0x40002000
 8006968:	080217a0 	.word	0x080217a0

0800696c <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 800696c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8006970:	2b01      	cmp	r3, #1
 8006972:	f000 814e 	beq.w	8006c12 <HAL_TIM_ConfigClockSource+0x2a6>
 8006976:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8006978:	2302      	movs	r3, #2
{
 800697a:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 800697c:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 8006980:	460d      	mov	r5, r1
 8006982:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 8006986:	4604      	mov	r4, r0
 8006988:	680b      	ldr	r3, [r1, #0]
 800698a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800698e:	bf18      	it	ne
 8006990:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
 8006994:	bf14      	ite	ne
 8006996:	2201      	movne	r2, #1
 8006998:	2200      	moveq	r2, #0
 800699a:	f033 0130 	bics.w	r1, r3, #48	; 0x30
 800699e:	f002 0201 	and.w	r2, r2, #1
 80069a2:	bf08      	it	eq
 80069a4:	2200      	moveq	r2, #0
 80069a6:	b112      	cbz	r2, 80069ae <HAL_TIM_ConfigClockSource+0x42>
 80069a8:	2940      	cmp	r1, #64	; 0x40
 80069aa:	f040 8269 	bne.w	8006e80 <HAL_TIM_ConfigClockSource+0x514>
  tmpsmcr = htim->Instance->SMCR;
 80069ae:	6822      	ldr	r2, [r4, #0]
  switch (sClockSourceConfig->ClockSource)
 80069b0:	2b60      	cmp	r3, #96	; 0x60
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80069b2:	4999      	ldr	r1, [pc, #612]	; (8006c18 <HAL_TIM_ConfigClockSource+0x2ac>)
  tmpsmcr = htim->Instance->SMCR;
 80069b4:	6890      	ldr	r0, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80069b6:	ea01 0100 	and.w	r1, r1, r0
  htim->Instance->SMCR = tmpsmcr;
 80069ba:	6091      	str	r1, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
 80069bc:	f000 8136 	beq.w	8006c2c <HAL_TIM_ConfigClockSource+0x2c0>
 80069c0:	d854      	bhi.n	8006a6c <HAL_TIM_ConfigClockSource+0x100>
 80069c2:	2b40      	cmp	r3, #64	; 0x40
 80069c4:	f000 81da 	beq.w	8006d7c <HAL_TIM_ConfigClockSource+0x410>
 80069c8:	f240 80ef 	bls.w	8006baa <HAL_TIM_ConfigClockSource+0x23e>
 80069cc:	2b50      	cmp	r3, #80	; 0x50
 80069ce:	d145      	bne.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 80069d0:	4b92      	ldr	r3, [pc, #584]	; (8006c1c <HAL_TIM_ConfigClockSource+0x2b0>)
 80069d2:	4993      	ldr	r1, [pc, #588]	; (8006c20 <HAL_TIM_ConfigClockSource+0x2b4>)
 80069d4:	429a      	cmp	r2, r3
 80069d6:	bf18      	it	ne
 80069d8:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 80069dc:	bf14      	ite	ne
 80069de:	2301      	movne	r3, #1
 80069e0:	2300      	moveq	r3, #0
 80069e2:	428a      	cmp	r2, r1
 80069e4:	bf0c      	ite	eq
 80069e6:	2300      	moveq	r3, #0
 80069e8:	f003 0301 	andne.w	r3, r3, #1
 80069ec:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80069f0:	428a      	cmp	r2, r1
 80069f2:	bf0c      	ite	eq
 80069f4:	2300      	moveq	r3, #0
 80069f6:	f003 0301 	andne.w	r3, r3, #1
 80069fa:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80069fe:	428a      	cmp	r2, r1
 8006a00:	bf0c      	ite	eq
 8006a02:	2300      	moveq	r3, #0
 8006a04:	f003 0301 	andne.w	r3, r3, #1
 8006a08:	b11b      	cbz	r3, 8006a12 <HAL_TIM_ConfigClockSource+0xa6>
 8006a0a:	4b86      	ldr	r3, [pc, #536]	; (8006c24 <HAL_TIM_ConfigClockSource+0x2b8>)
 8006a0c:	429a      	cmp	r2, r3
 8006a0e:	f040 8225 	bne.w	8006e5c <HAL_TIM_ConfigClockSource+0x4f0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006a12:	686b      	ldr	r3, [r5, #4]
 8006a14:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006a18:	bf18      	it	ne
 8006a1a:	2b0a      	cmpne	r3, #10
 8006a1c:	d003      	beq.n	8006a26 <HAL_TIM_ConfigClockSource+0xba>
 8006a1e:	f033 0302 	bics.w	r3, r3, #2
 8006a22:	f040 8201 	bne.w	8006e28 <HAL_TIM_ConfigClockSource+0x4bc>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006a26:	68ee      	ldr	r6, [r5, #12]
 8006a28:	2e0f      	cmp	r6, #15
 8006a2a:	f200 823e 	bhi.w	8006eaa <HAL_TIM_ConfigClockSource+0x53e>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006a2e:	6823      	ldr	r3, [r4, #0]
 8006a30:	6869      	ldr	r1, [r5, #4]
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8006a32:	6a18      	ldr	r0, [r3, #32]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4U);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8006a34:	f020 000a 	bic.w	r0, r0, #10
  tmpccer |= TIM_ICPolarity;
 8006a38:	4301      	orrs	r1, r0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8006a3a:	6a18      	ldr	r0, [r3, #32]
 8006a3c:	f020 0001 	bic.w	r0, r0, #1
 8006a40:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8006a42:	699a      	ldr	r2, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8006a44:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8006a48:	ea42 1206 	orr.w	r2, r2, r6, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8006a4c:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8006a4e:	6219      	str	r1, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8006a50:	689a      	ldr	r2, [r3, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8006a52:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8006a56:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8006a5a:	609a      	str	r2, [r3, #8]
  __HAL_UNLOCK(htim);
 8006a5c:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8006a5e:	2201      	movs	r2, #1
  return HAL_OK;
 8006a60:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 8006a62:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8006a66:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8006a6a:	bd70      	pop	{r4, r5, r6, pc}
  switch (sClockSourceConfig->ClockSource)
 8006a6c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8006a70:	f000 8124 	beq.w	8006cbc <HAL_TIM_ConfigClockSource+0x350>
 8006a74:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006a78:	d143      	bne.n	8006b02 <HAL_TIM_ConfigClockSource+0x196>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 8006a7a:	4b68      	ldr	r3, [pc, #416]	; (8006c1c <HAL_TIM_ConfigClockSource+0x2b0>)
 8006a7c:	4968      	ldr	r1, [pc, #416]	; (8006c20 <HAL_TIM_ConfigClockSource+0x2b4>)
 8006a7e:	429a      	cmp	r2, r3
 8006a80:	bf18      	it	ne
 8006a82:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006a86:	bf14      	ite	ne
 8006a88:	2301      	movne	r3, #1
 8006a8a:	2300      	moveq	r3, #0
 8006a8c:	428a      	cmp	r2, r1
 8006a8e:	bf0c      	ite	eq
 8006a90:	2300      	moveq	r3, #0
 8006a92:	f003 0301 	andne.w	r3, r3, #1
 8006a96:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006a9a:	428a      	cmp	r2, r1
 8006a9c:	bf0c      	ite	eq
 8006a9e:	2300      	moveq	r3, #0
 8006aa0:	f003 0301 	andne.w	r3, r3, #1
 8006aa4:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006aa8:	428a      	cmp	r2, r1
 8006aaa:	bf0c      	ite	eq
 8006aac:	2300      	moveq	r3, #0
 8006aae:	f003 0301 	andne.w	r3, r3, #1
 8006ab2:	b11b      	cbz	r3, 8006abc <HAL_TIM_ConfigClockSource+0x150>
 8006ab4:	4b5b      	ldr	r3, [pc, #364]	; (8006c24 <HAL_TIM_ConfigClockSource+0x2b8>)
 8006ab6:	429a      	cmp	r2, r3
 8006ab8:	f040 81c2 	bne.w	8006e40 <HAL_TIM_ConfigClockSource+0x4d4>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 8006abc:	68ab      	ldr	r3, [r5, #8]
 8006abe:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 8006ac2:	f040 8207 	bne.w	8006ed4 <HAL_TIM_ConfigClockSource+0x568>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006ac6:	686b      	ldr	r3, [r5, #4]
 8006ac8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006acc:	bf18      	it	ne
 8006ace:	2b0a      	cmpne	r3, #10
 8006ad0:	d003      	beq.n	8006ada <HAL_TIM_ConfigClockSource+0x16e>
 8006ad2:	f033 0302 	bics.w	r3, r3, #2
 8006ad6:	f040 81a1 	bne.w	8006e1c <HAL_TIM_ConfigClockSource+0x4b0>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006ada:	68e8      	ldr	r0, [r5, #12]
 8006adc:	280f      	cmp	r0, #15
 8006ade:	f200 81eb 	bhi.w	8006eb8 <HAL_TIM_ConfigClockSource+0x54c>
      TIM_ETR_SetConfig(htim->Instance,
 8006ae2:	6822      	ldr	r2, [r4, #0]
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8006ae4:	e9d5 5301 	ldrd	r5, r3, [r5, #4]
 8006ae8:	6891      	ldr	r1, [r2, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8006aea:	432b      	orrs	r3, r5
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8006aec:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 8006af0:	430b      	orrs	r3, r1
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8006af2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8006af6:	6093      	str	r3, [r2, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8006af8:	6893      	ldr	r3, [r2, #8]
 8006afa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006afe:	6093      	str	r3, [r2, #8]
      break;
 8006b00:	e7ac      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
  switch (sClockSourceConfig->ClockSource)
 8006b02:	2b70      	cmp	r3, #112	; 0x70
 8006b04:	d1aa      	bne.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 8006b06:	4b45      	ldr	r3, [pc, #276]	; (8006c1c <HAL_TIM_ConfigClockSource+0x2b0>)
 8006b08:	4945      	ldr	r1, [pc, #276]	; (8006c20 <HAL_TIM_ConfigClockSource+0x2b4>)
 8006b0a:	429a      	cmp	r2, r3
 8006b0c:	bf18      	it	ne
 8006b0e:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006b12:	bf14      	ite	ne
 8006b14:	2301      	movne	r3, #1
 8006b16:	2300      	moveq	r3, #0
 8006b18:	428a      	cmp	r2, r1
 8006b1a:	bf0c      	ite	eq
 8006b1c:	2300      	moveq	r3, #0
 8006b1e:	f003 0301 	andne.w	r3, r3, #1
 8006b22:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006b26:	428a      	cmp	r2, r1
 8006b28:	bf0c      	ite	eq
 8006b2a:	2300      	moveq	r3, #0
 8006b2c:	f003 0301 	andne.w	r3, r3, #1
 8006b30:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006b34:	428a      	cmp	r2, r1
 8006b36:	bf0c      	ite	eq
 8006b38:	2300      	moveq	r3, #0
 8006b3a:	f003 0301 	andne.w	r3, r3, #1
 8006b3e:	f501 4178 	add.w	r1, r1, #63488	; 0xf800
 8006b42:	428a      	cmp	r2, r1
 8006b44:	bf0c      	ite	eq
 8006b46:	2300      	moveq	r3, #0
 8006b48:	f003 0301 	andne.w	r3, r3, #1
 8006b4c:	f501 5170 	add.w	r1, r1, #15360	; 0x3c00
 8006b50:	428a      	cmp	r2, r1
 8006b52:	bf0c      	ite	eq
 8006b54:	2300      	moveq	r3, #0
 8006b56:	f003 0301 	andne.w	r3, r3, #1
 8006b5a:	b11b      	cbz	r3, 8006b64 <HAL_TIM_ConfigClockSource+0x1f8>
 8006b5c:	4b32      	ldr	r3, [pc, #200]	; (8006c28 <HAL_TIM_ConfigClockSource+0x2bc>)
 8006b5e:	429a      	cmp	r2, r3
 8006b60:	f040 81c4 	bne.w	8006eec <HAL_TIM_ConfigClockSource+0x580>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 8006b64:	68ab      	ldr	r3, [r5, #8]
 8006b66:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 8006b6a:	f040 81b9 	bne.w	8006ee0 <HAL_TIM_ConfigClockSource+0x574>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006b6e:	686b      	ldr	r3, [r5, #4]
 8006b70:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006b74:	bf18      	it	ne
 8006b76:	2b0a      	cmpne	r3, #10
 8006b78:	d003      	beq.n	8006b82 <HAL_TIM_ConfigClockSource+0x216>
 8006b7a:	f033 0302 	bics.w	r3, r3, #2
 8006b7e:	f040 8159 	bne.w	8006e34 <HAL_TIM_ConfigClockSource+0x4c8>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006b82:	68e8      	ldr	r0, [r5, #12]
 8006b84:	280f      	cmp	r0, #15
 8006b86:	f200 8182 	bhi.w	8006e8e <HAL_TIM_ConfigClockSource+0x522>
      TIM_ETR_SetConfig(htim->Instance,
 8006b8a:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 8006b8c:	e9d5 5301 	ldrd	r5, r3, [r5, #4]
 8006b90:	6891      	ldr	r1, [r2, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8006b92:	432b      	orrs	r3, r5
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8006b94:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 8006b98:	430b      	orrs	r3, r1
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8006b9a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  TIMx->SMCR = tmpsmcr;
 8006b9e:	6093      	str	r3, [r2, #8]
      tmpsmcr = htim->Instance->SMCR;
 8006ba0:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8006ba2:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 8006ba6:	6093      	str	r3, [r2, #8]
      break;
 8006ba8:	e758      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
  switch (sClockSourceConfig->ClockSource)
 8006baa:	2b20      	cmp	r3, #32
 8006bac:	d003      	beq.n	8006bb6 <HAL_TIM_ConfigClockSource+0x24a>
 8006bae:	d92b      	bls.n	8006c08 <HAL_TIM_ConfigClockSource+0x29c>
 8006bb0:	2b30      	cmp	r3, #48	; 0x30
 8006bb2:	f47f af53 	bne.w	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 8006bb6:	4919      	ldr	r1, [pc, #100]	; (8006c1c <HAL_TIM_ConfigClockSource+0x2b0>)
 8006bb8:	4819      	ldr	r0, [pc, #100]	; (8006c20 <HAL_TIM_ConfigClockSource+0x2b4>)
 8006bba:	428a      	cmp	r2, r1
 8006bbc:	bf18      	it	ne
 8006bbe:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006bc2:	bf14      	ite	ne
 8006bc4:	2101      	movne	r1, #1
 8006bc6:	2100      	moveq	r1, #0
 8006bc8:	4282      	cmp	r2, r0
 8006bca:	bf0c      	ite	eq
 8006bcc:	2100      	moveq	r1, #0
 8006bce:	f001 0101 	andne.w	r1, r1, #1
 8006bd2:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8006bd6:	4282      	cmp	r2, r0
 8006bd8:	bf0c      	ite	eq
 8006bda:	2100      	moveq	r1, #0
 8006bdc:	f001 0101 	andne.w	r1, r1, #1
 8006be0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8006be4:	4282      	cmp	r2, r0
 8006be6:	bf0c      	ite	eq
 8006be8:	2100      	moveq	r1, #0
 8006bea:	f001 0101 	andne.w	r1, r1, #1
 8006bee:	b119      	cbz	r1, 8006bf8 <HAL_TIM_ConfigClockSource+0x28c>
 8006bf0:	490c      	ldr	r1, [pc, #48]	; (8006c24 <HAL_TIM_ConfigClockSource+0x2b8>)
 8006bf2:	428a      	cmp	r2, r1
 8006bf4:	f040 812a 	bne.w	8006e4c <HAL_TIM_ConfigClockSource+0x4e0>
  tmpsmcr = TIMx->SMCR;
 8006bf8:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8006bfa:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8006bfe:	430b      	orrs	r3, r1
 8006c00:	f043 0307 	orr.w	r3, r3, #7
  TIMx->SMCR = tmpsmcr;
 8006c04:	6093      	str	r3, [r2, #8]
}
 8006c06:	e729      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
  switch (sClockSourceConfig->ClockSource)
 8006c08:	f033 0110 	bics.w	r1, r3, #16
 8006c0c:	f47f af26 	bne.w	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
 8006c10:	e7d1      	b.n	8006bb6 <HAL_TIM_ConfigClockSource+0x24a>
  __HAL_LOCK(htim);
 8006c12:	2002      	movs	r0, #2
}
 8006c14:	4770      	bx	lr
 8006c16:	bf00      	nop
 8006c18:	fffe0088 	.word	0xfffe0088
 8006c1c:	40010000 	.word	0x40010000
 8006c20:	40000400 	.word	0x40000400
 8006c24:	40010400 	.word	0x40010400
 8006c28:	40001800 	.word	0x40001800
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 8006c2c:	4bb2      	ldr	r3, [pc, #712]	; (8006ef8 <HAL_TIM_ConfigClockSource+0x58c>)
 8006c2e:	49b3      	ldr	r1, [pc, #716]	; (8006efc <HAL_TIM_ConfigClockSource+0x590>)
 8006c30:	429a      	cmp	r2, r3
 8006c32:	bf18      	it	ne
 8006c34:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006c38:	bf14      	ite	ne
 8006c3a:	2301      	movne	r3, #1
 8006c3c:	2300      	moveq	r3, #0
 8006c3e:	428a      	cmp	r2, r1
 8006c40:	bf0c      	ite	eq
 8006c42:	2300      	moveq	r3, #0
 8006c44:	f003 0301 	andne.w	r3, r3, #1
 8006c48:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006c4c:	428a      	cmp	r2, r1
 8006c4e:	bf0c      	ite	eq
 8006c50:	2300      	moveq	r3, #0
 8006c52:	f003 0301 	andne.w	r3, r3, #1
 8006c56:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006c5a:	428a      	cmp	r2, r1
 8006c5c:	bf0c      	ite	eq
 8006c5e:	2300      	moveq	r3, #0
 8006c60:	f003 0301 	andne.w	r3, r3, #1
 8006c64:	b11b      	cbz	r3, 8006c6e <HAL_TIM_ConfigClockSource+0x302>
 8006c66:	4ba6      	ldr	r3, [pc, #664]	; (8006f00 <HAL_TIM_ConfigClockSource+0x594>)
 8006c68:	429a      	cmp	r2, r3
 8006c6a:	f040 8103 	bne.w	8006e74 <HAL_TIM_ConfigClockSource+0x508>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006c6e:	686b      	ldr	r3, [r5, #4]
 8006c70:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006c74:	bf18      	it	ne
 8006c76:	2b0a      	cmpne	r3, #10
 8006c78:	d003      	beq.n	8006c82 <HAL_TIM_ConfigClockSource+0x316>
 8006c7a:	f033 0302 	bics.w	r3, r3, #2
 8006c7e:	f040 80c7 	bne.w	8006e10 <HAL_TIM_ConfigClockSource+0x4a4>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006c82:	68ee      	ldr	r6, [r5, #12]
 8006c84:	2e0f      	cmp	r6, #15
 8006c86:	f200 8109 	bhi.w	8006e9c <HAL_TIM_ConfigClockSource+0x530>
      TIM_TI2_ConfigInputStage(htim->Instance,
 8006c8a:	6823      	ldr	r3, [r4, #0]
 8006c8c:	686d      	ldr	r5, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8006c8e:	6a18      	ldr	r0, [r3, #32]
 8006c90:	f020 0010 	bic.w	r0, r0, #16
 8006c94:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8006c96:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 8006c98:	6a1a      	ldr	r2, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8006c9a:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8006c9e:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8006ca2:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 8006ca6:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 8006caa:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8006cac:	621a      	str	r2, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8006cae:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8006cb0:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8006cb4:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 8006cb8:	609a      	str	r2, [r3, #8]
}
 8006cba:	e6cf      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 8006cbc:	4b8e      	ldr	r3, [pc, #568]	; (8006ef8 <HAL_TIM_ConfigClockSource+0x58c>)
 8006cbe:	488f      	ldr	r0, [pc, #572]	; (8006efc <HAL_TIM_ConfigClockSource+0x590>)
 8006cc0:	429a      	cmp	r2, r3
 8006cc2:	bf18      	it	ne
 8006cc4:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006cc8:	498e      	ldr	r1, [pc, #568]	; (8006f04 <HAL_TIM_ConfigClockSource+0x598>)
 8006cca:	bf14      	ite	ne
 8006ccc:	2301      	movne	r3, #1
 8006cce:	2300      	moveq	r3, #0
 8006cd0:	4282      	cmp	r2, r0
 8006cd2:	bf0c      	ite	eq
 8006cd4:	2300      	moveq	r3, #0
 8006cd6:	f003 0301 	andne.w	r3, r3, #1
 8006cda:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8006cde:	428a      	cmp	r2, r1
 8006ce0:	bf0c      	ite	eq
 8006ce2:	2300      	moveq	r3, #0
 8006ce4:	f003 0301 	andne.w	r3, r3, #1
 8006ce8:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8006cec:	4282      	cmp	r2, r0
 8006cee:	bf0c      	ite	eq
 8006cf0:	2300      	moveq	r3, #0
 8006cf2:	f003 0301 	andne.w	r3, r3, #1
 8006cf6:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8006cfa:	428a      	cmp	r2, r1
 8006cfc:	bf0c      	ite	eq
 8006cfe:	2300      	moveq	r3, #0
 8006d00:	f003 0301 	andne.w	r3, r3, #1
 8006d04:	f501 4174 	add.w	r1, r1, #62464	; 0xf400
 8006d08:	4282      	cmp	r2, r0
 8006d0a:	bf0c      	ite	eq
 8006d0c:	2300      	moveq	r3, #0
 8006d0e:	f003 0301 	andne.w	r3, r3, #1
 8006d12:	f500 3096 	add.w	r0, r0, #76800	; 0x12c00
 8006d16:	428a      	cmp	r2, r1
 8006d18:	bf0c      	ite	eq
 8006d1a:	2300      	moveq	r3, #0
 8006d1c:	f003 0301 	andne.w	r3, r3, #1
 8006d20:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
 8006d24:	4282      	cmp	r2, r0
 8006d26:	bf0c      	ite	eq
 8006d28:	2300      	moveq	r3, #0
 8006d2a:	f003 0301 	andne.w	r3, r3, #1
 8006d2e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8006d32:	428a      	cmp	r2, r1
 8006d34:	bf0c      	ite	eq
 8006d36:	2300      	moveq	r3, #0
 8006d38:	f003 0301 	andne.w	r3, r3, #1
 8006d3c:	f5a1 3196 	sub.w	r1, r1, #76800	; 0x12c00
 8006d40:	4282      	cmp	r2, r0
 8006d42:	bf0c      	ite	eq
 8006d44:	2300      	moveq	r3, #0
 8006d46:	f003 0301 	andne.w	r3, r3, #1
 8006d4a:	428a      	cmp	r2, r1
 8006d4c:	bf0c      	ite	eq
 8006d4e:	2300      	moveq	r3, #0
 8006d50:	f003 0301 	andne.w	r3, r3, #1
 8006d54:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006d58:	428a      	cmp	r2, r1
 8006d5a:	bf0c      	ite	eq
 8006d5c:	2300      	moveq	r3, #0
 8006d5e:	f003 0301 	andne.w	r3, r3, #1
 8006d62:	2b00      	cmp	r3, #0
 8006d64:	f43f ae7a 	beq.w	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
 8006d68:	4b67      	ldr	r3, [pc, #412]	; (8006f08 <HAL_TIM_ConfigClockSource+0x59c>)
 8006d6a:	429a      	cmp	r2, r3
 8006d6c:	f43f ae76 	beq.w	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
 8006d70:	f241 2102 	movw	r1, #4610	; 0x1202
 8006d74:	4865      	ldr	r0, [pc, #404]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006d76:	f014 f895 	bl	801aea4 <assert_failed>
 8006d7a:	e66f      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 8006d7c:	4b5e      	ldr	r3, [pc, #376]	; (8006ef8 <HAL_TIM_ConfigClockSource+0x58c>)
 8006d7e:	495f      	ldr	r1, [pc, #380]	; (8006efc <HAL_TIM_ConfigClockSource+0x590>)
 8006d80:	429a      	cmp	r2, r3
 8006d82:	bf18      	it	ne
 8006d84:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 8006d88:	bf14      	ite	ne
 8006d8a:	2301      	movne	r3, #1
 8006d8c:	2300      	moveq	r3, #0
 8006d8e:	428a      	cmp	r2, r1
 8006d90:	bf0c      	ite	eq
 8006d92:	2300      	moveq	r3, #0
 8006d94:	f003 0301 	andne.w	r3, r3, #1
 8006d98:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006d9c:	428a      	cmp	r2, r1
 8006d9e:	bf0c      	ite	eq
 8006da0:	2300      	moveq	r3, #0
 8006da2:	f003 0301 	andne.w	r3, r3, #1
 8006da6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8006daa:	428a      	cmp	r2, r1
 8006dac:	bf0c      	ite	eq
 8006dae:	2300      	moveq	r3, #0
 8006db0:	f003 0301 	andne.w	r3, r3, #1
 8006db4:	b113      	cbz	r3, 8006dbc <HAL_TIM_ConfigClockSource+0x450>
 8006db6:	4b52      	ldr	r3, [pc, #328]	; (8006f00 <HAL_TIM_ConfigClockSource+0x594>)
 8006db8:	429a      	cmp	r2, r3
 8006dba:	d155      	bne.n	8006e68 <HAL_TIM_ConfigClockSource+0x4fc>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006dbc:	686b      	ldr	r3, [r5, #4]
 8006dbe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006dc2:	bf18      	it	ne
 8006dc4:	2b0a      	cmpne	r3, #10
 8006dc6:	d002      	beq.n	8006dce <HAL_TIM_ConfigClockSource+0x462>
 8006dc8:	f033 0302 	bics.w	r3, r3, #2
 8006dcc:	d11a      	bne.n	8006e04 <HAL_TIM_ConfigClockSource+0x498>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006dce:	68ee      	ldr	r6, [r5, #12]
 8006dd0:	2e0f      	cmp	r6, #15
 8006dd2:	d878      	bhi.n	8006ec6 <HAL_TIM_ConfigClockSource+0x55a>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006dd4:	6823      	ldr	r3, [r4, #0]
 8006dd6:	6869      	ldr	r1, [r5, #4]
  tmpccer = TIMx->CCER;
 8006dd8:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8006dda:	f020 000a 	bic.w	r0, r0, #10
  tmpccer |= TIM_ICPolarity;
 8006dde:	4301      	orrs	r1, r0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8006de0:	6a18      	ldr	r0, [r3, #32]
 8006de2:	f020 0001 	bic.w	r0, r0, #1
 8006de6:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8006de8:	699a      	ldr	r2, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8006dea:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8006dee:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8006df2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8006df4:	6219      	str	r1, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8006df6:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8006df8:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8006dfc:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8006e00:	609a      	str	r2, [r3, #8]
}
 8006e02:	e62b      	b.n	8006a5c <HAL_TIM_ConfigClockSource+0xf0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006e04:	f241 2158 	movw	r1, #4696	; 0x1258
 8006e08:	4840      	ldr	r0, [pc, #256]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e0a:	f014 f84b 	bl	801aea4 <assert_failed>
 8006e0e:	e7de      	b.n	8006dce <HAL_TIM_ConfigClockSource+0x462>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006e10:	f241 2148 	movw	r1, #4680	; 0x1248
 8006e14:	483d      	ldr	r0, [pc, #244]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e16:	f014 f845 	bl	801aea4 <assert_failed>
 8006e1a:	e732      	b.n	8006c82 <HAL_TIM_ConfigClockSource+0x316>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006e1c:	f241 2125 	movw	r1, #4645	; 0x1225
 8006e20:	483a      	ldr	r0, [pc, #232]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e22:	f014 f83f 	bl	801aea4 <assert_failed>
 8006e26:	e658      	b.n	8006ada <HAL_TIM_ConfigClockSource+0x16e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006e28:	f241 2138 	movw	r1, #4664	; 0x1238
 8006e2c:	4837      	ldr	r0, [pc, #220]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e2e:	f014 f839 	bl	801aea4 <assert_failed>
 8006e32:	e5f8      	b.n	8006a26 <HAL_TIM_ConfigClockSource+0xba>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 8006e34:	f241 210d 	movw	r1, #4621	; 0x120d
 8006e38:	4834      	ldr	r0, [pc, #208]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e3a:	f014 f833 	bl	801aea4 <assert_failed>
 8006e3e:	e6a0      	b.n	8006b82 <HAL_TIM_ConfigClockSource+0x216>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 8006e40:	f241 2121 	movw	r1, #4641	; 0x1221
 8006e44:	4831      	ldr	r0, [pc, #196]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e46:	f014 f82d 	bl	801aea4 <assert_failed>
 8006e4a:	e637      	b.n	8006abc <HAL_TIM_ConfigClockSource+0x150>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 8006e4c:	f241 2168 	movw	r1, #4712	; 0x1268
 8006e50:	482e      	ldr	r0, [pc, #184]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e52:	f014 f827 	bl	801aea4 <assert_failed>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 8006e56:	6822      	ldr	r2, [r4, #0]
 8006e58:	682b      	ldr	r3, [r5, #0]
 8006e5a:	e6cd      	b.n	8006bf8 <HAL_TIM_ConfigClockSource+0x28c>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 8006e5c:	f241 2135 	movw	r1, #4661	; 0x1235
 8006e60:	482a      	ldr	r0, [pc, #168]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e62:	f014 f81f 	bl	801aea4 <assert_failed>
 8006e66:	e5d4      	b.n	8006a12 <HAL_TIM_ConfigClockSource+0xa6>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 8006e68:	f241 2155 	movw	r1, #4693	; 0x1255
 8006e6c:	4827      	ldr	r0, [pc, #156]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e6e:	f014 f819 	bl	801aea4 <assert_failed>
 8006e72:	e7a3      	b.n	8006dbc <HAL_TIM_ConfigClockSource+0x450>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 8006e74:	f241 2145 	movw	r1, #4677	; 0x1245
 8006e78:	4824      	ldr	r0, [pc, #144]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e7a:	f014 f813 	bl	801aea4 <assert_failed>
 8006e7e:	e6f6      	b.n	8006c6e <HAL_TIM_ConfigClockSource+0x302>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 8006e80:	f241 11f6 	movw	r1, #4598	; 0x11f6
 8006e84:	4821      	ldr	r0, [pc, #132]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e86:	f014 f80d 	bl	801aea4 <assert_failed>
  switch (sClockSourceConfig->ClockSource)
 8006e8a:	682b      	ldr	r3, [r5, #0]
 8006e8c:	e58f      	b.n	80069ae <HAL_TIM_ConfigClockSource+0x42>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006e8e:	481f      	ldr	r0, [pc, #124]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006e90:	f241 210e 	movw	r1, #4622	; 0x120e
 8006e94:	f014 f806 	bl	801aea4 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 8006e98:	68e8      	ldr	r0, [r5, #12]
 8006e9a:	e676      	b.n	8006b8a <HAL_TIM_ConfigClockSource+0x21e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006e9c:	f241 2149 	movw	r1, #4681	; 0x1249
 8006ea0:	481a      	ldr	r0, [pc, #104]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006ea2:	f013 ffff 	bl	801aea4 <assert_failed>
      TIM_TI2_ConfigInputStage(htim->Instance,
 8006ea6:	68ee      	ldr	r6, [r5, #12]
 8006ea8:	e6ef      	b.n	8006c8a <HAL_TIM_ConfigClockSource+0x31e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006eaa:	f241 2139 	movw	r1, #4665	; 0x1239
 8006eae:	4817      	ldr	r0, [pc, #92]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006eb0:	f013 fff8 	bl	801aea4 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006eb4:	68ee      	ldr	r6, [r5, #12]
 8006eb6:	e5ba      	b.n	8006a2e <HAL_TIM_ConfigClockSource+0xc2>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006eb8:	4814      	ldr	r0, [pc, #80]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006eba:	f241 2126 	movw	r1, #4646	; 0x1226
 8006ebe:	f013 fff1 	bl	801aea4 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 8006ec2:	68e8      	ldr	r0, [r5, #12]
 8006ec4:	e60d      	b.n	8006ae2 <HAL_TIM_ConfigClockSource+0x176>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 8006ec6:	f241 2159 	movw	r1, #4697	; 0x1259
 8006eca:	4810      	ldr	r0, [pc, #64]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006ecc:	f013 ffea 	bl	801aea4 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006ed0:	68ee      	ldr	r6, [r5, #12]
 8006ed2:	e77f      	b.n	8006dd4 <HAL_TIM_ConfigClockSource+0x468>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 8006ed4:	f241 2124 	movw	r1, #4644	; 0x1224
 8006ed8:	480c      	ldr	r0, [pc, #48]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006eda:	f013 ffe3 	bl	801aea4 <assert_failed>
 8006ede:	e5f2      	b.n	8006ac6 <HAL_TIM_ConfigClockSource+0x15a>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 8006ee0:	f241 210c 	movw	r1, #4620	; 0x120c
 8006ee4:	4809      	ldr	r0, [pc, #36]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006ee6:	f013 ffdd 	bl	801aea4 <assert_failed>
 8006eea:	e640      	b.n	8006b6e <HAL_TIM_ConfigClockSource+0x202>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 8006eec:	f241 2109 	movw	r1, #4617	; 0x1209
 8006ef0:	4806      	ldr	r0, [pc, #24]	; (8006f0c <HAL_TIM_ConfigClockSource+0x5a0>)
 8006ef2:	f013 ffd7 	bl	801aea4 <assert_failed>
 8006ef6:	e635      	b.n	8006b64 <HAL_TIM_ConfigClockSource+0x1f8>
 8006ef8:	40010000 	.word	0x40010000
 8006efc:	40000400 	.word	0x40000400
 8006f00:	40010400 	.word	0x40010400
 8006f04:	40000800 	.word	0x40000800
 8006f08:	40002000 	.word	0x40002000
 8006f0c:	080217a0 	.word	0x080217a0

08006f10 <HAL_TIM_PeriodElapsedCallback>:
 8006f10:	4770      	bx	lr
 8006f12:	bf00      	nop

08006f14 <HAL_TIM_OC_DelayElapsedCallback>:
 8006f14:	4770      	bx	lr
 8006f16:	bf00      	nop

08006f18 <HAL_TIM_IC_CaptureCallback>:
 8006f18:	4770      	bx	lr
 8006f1a:	bf00      	nop

08006f1c <HAL_TIM_PWM_PulseFinishedCallback>:
 8006f1c:	4770      	bx	lr
 8006f1e:	bf00      	nop

08006f20 <HAL_TIM_TriggerCallback>:
 8006f20:	4770      	bx	lr
 8006f22:	bf00      	nop

08006f24 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8006f24:	6803      	ldr	r3, [r0, #0]
 8006f26:	691a      	ldr	r2, [r3, #16]
 8006f28:	0791      	lsls	r1, r2, #30
{
 8006f2a:	b510      	push	{r4, lr}
 8006f2c:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8006f2e:	d502      	bpl.n	8006f36 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8006f30:	68da      	ldr	r2, [r3, #12]
 8006f32:	0792      	lsls	r2, r2, #30
 8006f34:	d468      	bmi.n	8007008 <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8006f36:	691a      	ldr	r2, [r3, #16]
 8006f38:	0752      	lsls	r2, r2, #29
 8006f3a:	d502      	bpl.n	8006f42 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8006f3c:	68da      	ldr	r2, [r3, #12]
 8006f3e:	0750      	lsls	r0, r2, #29
 8006f40:	d44f      	bmi.n	8006fe2 <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8006f42:	691a      	ldr	r2, [r3, #16]
 8006f44:	0711      	lsls	r1, r2, #28
 8006f46:	d502      	bpl.n	8006f4e <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8006f48:	68da      	ldr	r2, [r3, #12]
 8006f4a:	0712      	lsls	r2, r2, #28
 8006f4c:	d437      	bmi.n	8006fbe <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8006f4e:	691a      	ldr	r2, [r3, #16]
 8006f50:	06d0      	lsls	r0, r2, #27
 8006f52:	d502      	bpl.n	8006f5a <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8006f54:	68da      	ldr	r2, [r3, #12]
 8006f56:	06d1      	lsls	r1, r2, #27
 8006f58:	d41e      	bmi.n	8006f98 <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8006f5a:	691a      	ldr	r2, [r3, #16]
 8006f5c:	07d2      	lsls	r2, r2, #31
 8006f5e:	d502      	bpl.n	8006f66 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8006f60:	68da      	ldr	r2, [r3, #12]
 8006f62:	07d0      	lsls	r0, r2, #31
 8006f64:	d469      	bmi.n	800703a <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8006f66:	691a      	ldr	r2, [r3, #16]
 8006f68:	0611      	lsls	r1, r2, #24
 8006f6a:	d502      	bpl.n	8006f72 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8006f6c:	68da      	ldr	r2, [r3, #12]
 8006f6e:	0612      	lsls	r2, r2, #24
 8006f70:	d46b      	bmi.n	800704a <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8006f72:	691a      	ldr	r2, [r3, #16]
 8006f74:	05d0      	lsls	r0, r2, #23
 8006f76:	d502      	bpl.n	8006f7e <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8006f78:	68da      	ldr	r2, [r3, #12]
 8006f7a:	0611      	lsls	r1, r2, #24
 8006f7c:	d46d      	bmi.n	800705a <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8006f7e:	691a      	ldr	r2, [r3, #16]
 8006f80:	0652      	lsls	r2, r2, #25
 8006f82:	d502      	bpl.n	8006f8a <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8006f84:	68da      	ldr	r2, [r3, #12]
 8006f86:	0650      	lsls	r0, r2, #25
 8006f88:	d46f      	bmi.n	800706a <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8006f8a:	691a      	ldr	r2, [r3, #16]
 8006f8c:	0691      	lsls	r1, r2, #26
 8006f8e:	d502      	bpl.n	8006f96 <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8006f90:	68da      	ldr	r2, [r3, #12]
 8006f92:	0692      	lsls	r2, r2, #26
 8006f94:	d449      	bmi.n	800702a <HAL_TIM_IRQHandler+0x106>
}
 8006f96:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8006f98:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8006f9c:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 8006f9e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8006fa0:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8006fa2:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8006fa4:	69db      	ldr	r3, [r3, #28]
 8006fa6:	f413 7f40 	tst.w	r3, #768	; 0x300
 8006faa:	d16f      	bne.n	800708c <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006fac:	f7ff ffb2 	bl	8006f14 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006fb0:	4620      	mov	r0, r4
 8006fb2:	f7ff ffb3 	bl	8006f1c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006fb6:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8006fb8:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006fba:	7722      	strb	r2, [r4, #28]
 8006fbc:	e7cd      	b.n	8006f5a <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8006fbe:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8006fc2:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 8006fc4:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8006fc6:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8006fc8:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8006fca:	69db      	ldr	r3, [r3, #28]
 8006fcc:	079b      	lsls	r3, r3, #30
 8006fce:	d15a      	bne.n	8007086 <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006fd0:	f7ff ffa0 	bl	8006f14 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006fd4:	4620      	mov	r0, r4
 8006fd6:	f7ff ffa1 	bl	8006f1c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006fda:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8006fdc:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006fde:	7722      	strb	r2, [r4, #28]
 8006fe0:	e7b5      	b.n	8006f4e <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8006fe2:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8006fe6:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 8006fe8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8006fea:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8006fec:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8006fee:	699b      	ldr	r3, [r3, #24]
 8006ff0:	f413 7f40 	tst.w	r3, #768	; 0x300
 8006ff4:	d144      	bne.n	8007080 <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006ff6:	f7ff ff8d 	bl	8006f14 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006ffa:	4620      	mov	r0, r4
 8006ffc:	f7ff ff8e 	bl	8006f1c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007000:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8007002:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007004:	7722      	strb	r2, [r4, #28]
 8007006:	e79c      	b.n	8006f42 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007008:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800700c:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800700e:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8007010:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8007012:	699b      	ldr	r3, [r3, #24]
 8007014:	0799      	lsls	r1, r3, #30
 8007016:	d130      	bne.n	800707a <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8007018:	f7ff ff7c 	bl	8006f14 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800701c:	4620      	mov	r0, r4
 800701e:	f7ff ff7d 	bl	8006f1c <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007022:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007024:	6823      	ldr	r3, [r4, #0]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007026:	7722      	strb	r2, [r4, #28]
 8007028:	e785      	b.n	8006f36 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800702a:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 800702e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8007030:	611a      	str	r2, [r3, #16]
}
 8007032:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8007036:	f000 b8d1 	b.w	80071dc <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800703a:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 800703e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8007040:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8007042:	f7ff ff65 	bl	8006f10 <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007046:	6823      	ldr	r3, [r4, #0]
 8007048:	e78d      	b.n	8006f66 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800704a:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 800704e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8007050:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8007052:	f000 f8c5 	bl	80071e0 <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8007056:	6823      	ldr	r3, [r4, #0]
 8007058:	e78b      	b.n	8006f72 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800705a:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 800705e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8007060:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8007062:	f000 f8bf 	bl	80071e4 <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8007066:	6823      	ldr	r3, [r4, #0]
 8007068:	e789      	b.n	8006f7e <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800706a:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 800706e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8007070:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8007072:	f7ff ff55 	bl	8006f20 <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8007076:	6823      	ldr	r3, [r4, #0]
 8007078:	e787      	b.n	8006f8a <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 800707a:	f7ff ff4d 	bl	8006f18 <HAL_TIM_IC_CaptureCallback>
 800707e:	e7d0      	b.n	8007022 <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 8007080:	f7ff ff4a 	bl	8006f18 <HAL_TIM_IC_CaptureCallback>
 8007084:	e7bc      	b.n	8007000 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 8007086:	f7ff ff47 	bl	8006f18 <HAL_TIM_IC_CaptureCallback>
 800708a:	e7a6      	b.n	8006fda <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 800708c:	f7ff ff44 	bl	8006f18 <HAL_TIM_IC_CaptureCallback>
 8007090:	e791      	b.n	8006fb6 <HAL_TIM_IRQHandler+0x92>
 8007092:	bf00      	nop

08007094 <HAL_TIMEx_MasterConfigSynchronization>:
{
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
 8007094:	6802      	ldr	r2, [r0, #0]
{
 8007096:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
 8007098:	4b4a      	ldr	r3, [pc, #296]	; (80071c4 <HAL_TIMEx_MasterConfigSynchronization+0x130>)
{
 800709a:	460d      	mov	r5, r1
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
 800709c:	4f4a      	ldr	r7, [pc, #296]	; (80071c8 <HAL_TIMEx_MasterConfigSynchronization+0x134>)
{
 800709e:	4604      	mov	r4, r0
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
 80070a0:	429a      	cmp	r2, r3
 80070a2:	bf18      	it	ne
 80070a4:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 80070a8:	4e48      	ldr	r6, [pc, #288]	; (80071cc <HAL_TIMEx_MasterConfigSynchronization+0x138>)
 80070aa:	4949      	ldr	r1, [pc, #292]	; (80071d0 <HAL_TIMEx_MasterConfigSynchronization+0x13c>)
 80070ac:	bf14      	ite	ne
 80070ae:	2301      	movne	r3, #1
 80070b0:	2300      	moveq	r3, #0
 80070b2:	42ba      	cmp	r2, r7
 80070b4:	bf0c      	ite	eq
 80070b6:	2300      	moveq	r3, #0
 80070b8:	f003 0301 	andne.w	r3, r3, #1
 80070bc:	42b2      	cmp	r2, r6
 80070be:	bf0c      	ite	eq
 80070c0:	2300      	moveq	r3, #0
 80070c2:	f003 0301 	andne.w	r3, r3, #1
 80070c6:	428a      	cmp	r2, r1
 80070c8:	bf0c      	ite	eq
 80070ca:	2300      	moveq	r3, #0
 80070cc:	f003 0301 	andne.w	r3, r3, #1
 80070d0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80070d4:	428a      	cmp	r2, r1
 80070d6:	bf0c      	ite	eq
 80070d8:	2300      	moveq	r3, #0
 80070da:	f003 0301 	andne.w	r3, r3, #1
 80070de:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80070e2:	428a      	cmp	r2, r1
 80070e4:	bf0c      	ite	eq
 80070e6:	2300      	moveq	r3, #0
 80070e8:	f003 0301 	andne.w	r3, r3, #1
 80070ec:	b113      	cbz	r3, 80070f4 <HAL_TIMEx_MasterConfigSynchronization+0x60>
 80070ee:	4b39      	ldr	r3, [pc, #228]	; (80071d4 <HAL_TIMEx_MasterConfigSynchronization+0x140>)
 80070f0:	429a      	cmp	r2, r3
 80070f2:	d153      	bne.n	800719c <HAL_TIMEx_MasterConfigSynchronization+0x108>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 80070f4:	682b      	ldr	r3, [r5, #0]
 80070f6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80070fa:	2b40      	cmp	r3, #64	; 0x40
 80070fc:	d001      	beq.n	8007102 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80070fe:	2b00      	cmp	r3, #0
 8007100:	d152      	bne.n	80071a8 <HAL_TIMEx_MasterConfigSynchronization+0x114>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 8007102:	68ab      	ldr	r3, [r5, #8]
 8007104:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 8007108:	d13d      	bne.n	8007186 <HAL_TIMEx_MasterConfigSynchronization+0xf2>

  /* Check input state */
  __HAL_LOCK(htim);
 800710a:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800710e:	2b01      	cmp	r3, #1
 8007110:	d042      	beq.n	8007198 <HAL_TIMEx_MasterConfigSynchronization+0x104>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8007112:	2202      	movs	r2, #2

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8007114:	6823      	ldr	r3, [r4, #0]
  __HAL_LOCK(htim);
 8007116:	2101      	movs	r1, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8007118:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800711c:	4a29      	ldr	r2, [pc, #164]	; (80071c4 <HAL_TIMEx_MasterConfigSynchronization+0x130>)
  __HAL_LOCK(htim);
 800711e:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8007122:	4293      	cmp	r3, r2
  tmpcr2 = htim->Instance->CR2;
 8007124:	685e      	ldr	r6, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 8007126:	689f      	ldr	r7, [r3, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8007128:	d015      	beq.n	8007156 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800712a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800712e:	4293      	cmp	r3, r2
 8007130:	d011      	beq.n	8007156 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8007132:	682a      	ldr	r2, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 8007134:	f026 0670 	bic.w	r6, r6, #112	; 0x70

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 8007138:	f027 0780 	bic.w	r7, r7, #128	; 0x80

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800713c:	2101      	movs	r1, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800713e:	4316      	orrs	r6, r2
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8007140:	68aa      	ldr	r2, [r5, #8]
 8007142:	4317      	orrs	r7, r2

  __HAL_UNLOCK(htim);
 8007144:	2200      	movs	r2, #0
  htim->Instance->CR2 = tmpcr2;
 8007146:	605e      	str	r6, [r3, #4]

  return HAL_OK;
 8007148:	4610      	mov	r0, r2
  htim->Instance->SMCR = tmpsmcr;
 800714a:	609f      	str	r7, [r3, #8]
  htim->State = HAL_TIM_STATE_READY;
 800714c:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8007150:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
}
 8007154:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 8007156:	6868      	ldr	r0, [r5, #4]
 8007158:	f420 1240 	bic.w	r2, r0, #3145728	; 0x300000
 800715c:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 8007160:	bf18      	it	ne
 8007162:	2a00      	cmpne	r2, #0
 8007164:	bf14      	ite	ne
 8007166:	2101      	movne	r1, #1
 8007168:	2100      	moveq	r1, #0
 800716a:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800716e:	bf0c      	ite	eq
 8007170:	2100      	moveq	r1, #0
 8007172:	f001 0101 	andne.w	r1, r1, #1
 8007176:	b111      	cbz	r1, 800717e <HAL_TIMEx_MasterConfigSynchronization+0xea>
 8007178:	f5b2 0f40 	cmp.w	r2, #12582912	; 0xc00000
 800717c:	d11a      	bne.n	80071b4 <HAL_TIMEx_MasterConfigSynchronization+0x120>
    tmpcr2 &= ~TIM_CR2_MMS2;
 800717e:	f426 0670 	bic.w	r6, r6, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8007182:	4306      	orrs	r6, r0
 8007184:	e7d5      	b.n	8007132 <HAL_TIMEx_MasterConfigSynchronization+0x9e>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 8007186:	f240 6165 	movw	r1, #1637	; 0x665
 800718a:	4813      	ldr	r0, [pc, #76]	; (80071d8 <HAL_TIMEx_MasterConfigSynchronization+0x144>)
 800718c:	f013 fe8a 	bl	801aea4 <assert_failed>
  __HAL_LOCK(htim);
 8007190:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8007194:	2b01      	cmp	r3, #1
 8007196:	d1bc      	bne.n	8007112 <HAL_TIMEx_MasterConfigSynchronization+0x7e>
 8007198:	2002      	movs	r0, #2
}
 800719a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
 800719c:	f240 6163 	movw	r1, #1635	; 0x663
 80071a0:	480d      	ldr	r0, [pc, #52]	; (80071d8 <HAL_TIMEx_MasterConfigSynchronization+0x144>)
 80071a2:	f013 fe7f 	bl	801aea4 <assert_failed>
 80071a6:	e7a5      	b.n	80070f4 <HAL_TIMEx_MasterConfigSynchronization+0x60>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 80071a8:	f240 6164 	movw	r1, #1636	; 0x664
 80071ac:	480a      	ldr	r0, [pc, #40]	; (80071d8 <HAL_TIMEx_MasterConfigSynchronization+0x144>)
 80071ae:	f013 fe79 	bl	801aea4 <assert_failed>
 80071b2:	e7a6      	b.n	8007102 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 80071b4:	4808      	ldr	r0, [pc, #32]	; (80071d8 <HAL_TIMEx_MasterConfigSynchronization+0x144>)
 80071b6:	f240 6177 	movw	r1, #1655	; 0x677
 80071ba:	f013 fe73 	bl	801aea4 <assert_failed>
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80071be:	6868      	ldr	r0, [r5, #4]
  htim->Instance->CR2 = tmpcr2;
 80071c0:	6823      	ldr	r3, [r4, #0]
 80071c2:	e7dc      	b.n	800717e <HAL_TIMEx_MasterConfigSynchronization+0xea>
 80071c4:	40010000 	.word	0x40010000
 80071c8:	40000400 	.word	0x40000400
 80071cc:	40000800 	.word	0x40000800
 80071d0:	40000c00 	.word	0x40000c00
 80071d4:	40010400 	.word	0x40010400
 80071d8:	080217d8 	.word	0x080217d8

080071dc <HAL_TIMEx_CommutCallback>:
 80071dc:	4770      	bx	lr
 80071de:	bf00      	nop

080071e0 <HAL_TIMEx_BreakCallback>:
 80071e0:	4770      	bx	lr
 80071e2:	bf00      	nop

080071e4 <HAL_TIMEx_Break2Callback>:
 80071e4:	4770      	bx	lr
 80071e6:	bf00      	nop

080071e8 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 80071e8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpr1 = 0;
  uint32_t tmpr2 = 0;
    
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 80071ea:	4b5f      	ldr	r3, [pc, #380]	; (8007368 <FMC_SDRAM_Init+0x180>)
{
 80071ec:	4605      	mov	r5, r0
 80071ee:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 80071f0:	4298      	cmp	r0, r3
 80071f2:	d004      	beq.n	80071fe <FMC_SDRAM_Init+0x16>
 80071f4:	f44f 713b 	mov.w	r1, #748	; 0x2ec
 80071f8:	485c      	ldr	r0, [pc, #368]	; (800736c <FMC_SDRAM_Init+0x184>)
 80071fa:	f013 fe53 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
 80071fe:	6823      	ldr	r3, [r4, #0]
 8007200:	2b01      	cmp	r3, #1
 8007202:	d904      	bls.n	800720e <FMC_SDRAM_Init+0x26>
 8007204:	f240 21ed 	movw	r1, #749	; 0x2ed
 8007208:	4858      	ldr	r0, [pc, #352]	; (800736c <FMC_SDRAM_Init+0x184>)
 800720a:	f013 fe4b 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800720e:	6863      	ldr	r3, [r4, #4]
 8007210:	2b03      	cmp	r3, #3
 8007212:	f200 80a3 	bhi.w	800735c <FMC_SDRAM_Init+0x174>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 8007216:	68a3      	ldr	r3, [r4, #8]
 8007218:	f033 0204 	bics.w	r2, r3, #4
 800721c:	d002      	beq.n	8007224 <FMC_SDRAM_Init+0x3c>
 800721e:	2b08      	cmp	r3, #8
 8007220:	f040 8096 	bne.w	8007350 <FMC_SDRAM_Init+0x168>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 8007224:	68e3      	ldr	r3, [r4, #12]
 8007226:	f033 0210 	bics.w	r2, r3, #16
 800722a:	d001      	beq.n	8007230 <FMC_SDRAM_Init+0x48>
 800722c:	2b20      	cmp	r3, #32
 800722e:	d17f      	bne.n	8007330 <FMC_SDRAM_Init+0x148>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 8007230:	6923      	ldr	r3, [r4, #16]
 8007232:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 8007236:	f040 8085 	bne.w	8007344 <FMC_SDRAM_Init+0x15c>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 800723a:	6963      	ldr	r3, [r4, #20]
 800723c:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007240:	2a80      	cmp	r2, #128	; 0x80
 8007242:	d002      	beq.n	800724a <FMC_SDRAM_Init+0x62>
 8007244:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007248:	d163      	bne.n	8007312 <FMC_SDRAM_Init+0x12a>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800724a:	69a3      	ldr	r3, [r4, #24]
 800724c:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8007250:	d168      	bne.n	8007324 <FMC_SDRAM_Init+0x13c>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 8007252:	69e3      	ldr	r3, [r4, #28]
 8007254:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 8007258:	d002      	beq.n	8007260 <FMC_SDRAM_Init+0x78>
 800725a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800725e:	d149      	bne.n	80072f4 <FMC_SDRAM_Init+0x10c>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 8007260:	6a23      	ldr	r3, [r4, #32]
 8007262:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8007266:	d14e      	bne.n	8007306 <FMC_SDRAM_Init+0x11e>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   
 8007268:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800726a:	f431 5300 	bics.w	r3, r1, #8192	; 0x2000
 800726e:	d002      	beq.n	8007276 <FMC_SDRAM_Init+0x8e>
 8007270:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8007274:	d119      	bne.n	80072aa <FMC_SDRAM_Init+0xc2>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8007276:	6823      	ldr	r3, [r4, #0]
 8007278:	2b01      	cmp	r3, #1
 800727a:	d01f      	beq.n	80072bc <FMC_SDRAM_Init+0xd4>
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800727c:	6828      	ldr	r0, [r5, #0]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800727e:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
 8007282:	4313      	orrs	r3, r2
 8007284:	68e2      	ldr	r2, [r4, #12]
 8007286:	4313      	orrs	r3, r2
 8007288:	6922      	ldr	r2, [r4, #16]
 800728a:	4313      	orrs	r3, r2
 800728c:	6962      	ldr	r2, [r4, #20]
 800728e:	4313      	orrs	r3, r2
 8007290:	69a2      	ldr	r2, [r4, #24]
 8007292:	4313      	orrs	r3, r2
 8007294:	69e2      	ldr	r2, [r4, #28]
 8007296:	4313      	orrs	r3, r2
 8007298:	6a22      	ldr	r2, [r4, #32]
 800729a:	4313      	orrs	r3, r2
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800729c:	4a34      	ldr	r2, [pc, #208]	; (8007370 <FMC_SDRAM_Init+0x188>)
 800729e:	4002      	ands	r2, r0
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 80072a0:	2000      	movs	r0, #0
 80072a2:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80072a4:	430b      	orrs	r3, r1
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 80072a6:	602b      	str	r3, [r5, #0]
}
 80072a8:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   
 80072aa:	f240 21f6 	movw	r1, #758	; 0x2f6
 80072ae:	482f      	ldr	r0, [pc, #188]	; (800736c <FMC_SDRAM_Init+0x184>)
 80072b0:	f013 fdf8 	bl	801aea4 <assert_failed>
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 80072b4:	6823      	ldr	r3, [r4, #0]
                        Init->ReadPipeDelay
 80072b6:	6a61      	ldr	r1, [r4, #36]	; 0x24
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 80072b8:	2b01      	cmp	r3, #1
 80072ba:	d1df      	bne.n	800727c <FMC_SDRAM_Init+0x94>
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 80072bc:	682b      	ldr	r3, [r5, #0]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 80072be:	69e0      	ldr	r0, [r4, #28]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 80072c0:	f423 4cf8 	bic.w	ip, r3, #31744	; 0x7c00
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80072c4:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 80072c8:	4313      	orrs	r3, r2
                       Init->RowBitsNumber       |\
 80072ca:	68e2      	ldr	r2, [r4, #12]
 80072cc:	4313      	orrs	r3, r2
                       Init->MemoryDataWidth     |\
 80072ce:	6922      	ldr	r2, [r4, #16]
 80072d0:	4313      	orrs	r3, r2
 80072d2:	6a22      	ldr	r2, [r4, #32]
 80072d4:	4310      	orrs	r0, r2
                       Init->InternalBankNumber  |\
 80072d6:	6962      	ldr	r2, [r4, #20]
 80072d8:	ea40 000c 	orr.w	r0, r0, ip
 80072dc:	4313      	orrs	r3, r2
                       Init->CASLatency          |\
 80072de:	69a2      	ldr	r2, [r4, #24]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 80072e0:	4301      	orrs	r1, r0
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 80072e2:	6868      	ldr	r0, [r5, #4]
                       Init->CASLatency          |\
 80072e4:	4313      	orrs	r3, r2
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 80072e6:	4a22      	ldr	r2, [pc, #136]	; (8007370 <FMC_SDRAM_Init+0x188>)
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 80072e8:	6029      	str	r1, [r5, #0]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 80072ea:	4002      	ands	r2, r0
}
 80072ec:	2000      	movs	r0, #0
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80072ee:	4313      	orrs	r3, r2
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 80072f0:	606b      	str	r3, [r5, #4]
}
 80072f2:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 80072f4:	f44f 713d 	mov.w	r1, #756	; 0x2f4
 80072f8:	481c      	ldr	r0, [pc, #112]	; (800736c <FMC_SDRAM_Init+0x184>)
 80072fa:	f013 fdd3 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 80072fe:	6a23      	ldr	r3, [r4, #32]
 8007300:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8007304:	d0b0      	beq.n	8007268 <FMC_SDRAM_Init+0x80>
 8007306:	f240 21f5 	movw	r1, #757	; 0x2f5
 800730a:	4818      	ldr	r0, [pc, #96]	; (800736c <FMC_SDRAM_Init+0x184>)
 800730c:	f013 fdca 	bl	801aea4 <assert_failed>
 8007310:	e7aa      	b.n	8007268 <FMC_SDRAM_Init+0x80>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 8007312:	f240 21f2 	movw	r1, #754	; 0x2f2
 8007316:	4815      	ldr	r0, [pc, #84]	; (800736c <FMC_SDRAM_Init+0x184>)
 8007318:	f013 fdc4 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800731c:	69a3      	ldr	r3, [r4, #24]
 800731e:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8007322:	d096      	beq.n	8007252 <FMC_SDRAM_Init+0x6a>
 8007324:	f240 21f3 	movw	r1, #755	; 0x2f3
 8007328:	4810      	ldr	r0, [pc, #64]	; (800736c <FMC_SDRAM_Init+0x184>)
 800732a:	f013 fdbb 	bl	801aea4 <assert_failed>
 800732e:	e790      	b.n	8007252 <FMC_SDRAM_Init+0x6a>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 8007330:	f44f 713c 	mov.w	r1, #752	; 0x2f0
 8007334:	480d      	ldr	r0, [pc, #52]	; (800736c <FMC_SDRAM_Init+0x184>)
 8007336:	f013 fdb5 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 800733a:	6923      	ldr	r3, [r4, #16]
 800733c:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 8007340:	f43f af7b 	beq.w	800723a <FMC_SDRAM_Init+0x52>
 8007344:	f240 21f1 	movw	r1, #753	; 0x2f1
 8007348:	4808      	ldr	r0, [pc, #32]	; (800736c <FMC_SDRAM_Init+0x184>)
 800734a:	f013 fdab 	bl	801aea4 <assert_failed>
 800734e:	e774      	b.n	800723a <FMC_SDRAM_Init+0x52>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 8007350:	f240 21ef 	movw	r1, #751	; 0x2ef
 8007354:	4805      	ldr	r0, [pc, #20]	; (800736c <FMC_SDRAM_Init+0x184>)
 8007356:	f013 fda5 	bl	801aea4 <assert_failed>
 800735a:	e763      	b.n	8007224 <FMC_SDRAM_Init+0x3c>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800735c:	f240 21ee 	movw	r1, #750	; 0x2ee
 8007360:	4802      	ldr	r0, [pc, #8]	; (800736c <FMC_SDRAM_Init+0x184>)
 8007362:	f013 fd9f 	bl	801aea4 <assert_failed>
 8007366:	e756      	b.n	8007216 <FMC_SDRAM_Init+0x2e>
 8007368:	a0000140 	.word	0xa0000140
 800736c:	08021814 	.word	0x08021814
 8007370:	ffff8000 	.word	0xffff8000

08007374 <FMC_SDRAM_Timing_Init>:
{
  uint32_t tmpr1 = 0;
  uint32_t tmpr2 = 0;
    
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 8007374:	4b50      	ldr	r3, [pc, #320]	; (80074b8 <FMC_SDRAM_Timing_Init+0x144>)
 8007376:	4298      	cmp	r0, r3
{
 8007378:	b570      	push	{r4, r5, r6, lr}
 800737a:	4605      	mov	r5, r0
 800737c:	460c      	mov	r4, r1
 800737e:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 8007380:	d004      	beq.n	800738c <FMC_SDRAM_Timing_Init+0x18>
 8007382:	f240 313d 	movw	r1, #829	; 0x33d
 8007386:	484d      	ldr	r0, [pc, #308]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 8007388:	f013 fd8c 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 800738c:	6823      	ldr	r3, [r4, #0]
 800738e:	3b01      	subs	r3, #1
 8007390:	2b0f      	cmp	r3, #15
 8007392:	f200 808a 	bhi.w	80074aa <FMC_SDRAM_Timing_Init+0x136>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 8007396:	6863      	ldr	r3, [r4, #4]
 8007398:	3b01      	subs	r3, #1
 800739a:	2b0f      	cmp	r3, #15
 800739c:	d87f      	bhi.n	800749e <FMC_SDRAM_Timing_Init+0x12a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 800739e:	68a3      	ldr	r3, [r4, #8]
 80073a0:	3b01      	subs	r3, #1
 80073a2:	2b0f      	cmp	r3, #15
 80073a4:	d875      	bhi.n	8007492 <FMC_SDRAM_Timing_Init+0x11e>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 80073a6:	68e3      	ldr	r3, [r4, #12]
 80073a8:	3b01      	subs	r3, #1
 80073aa:	2b0f      	cmp	r3, #15
 80073ac:	d86b      	bhi.n	8007486 <FMC_SDRAM_Timing_Init+0x112>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 80073ae:	6923      	ldr	r3, [r4, #16]
 80073b0:	3b01      	subs	r3, #1
 80073b2:	2b0f      	cmp	r3, #15
 80073b4:	d861      	bhi.n	800747a <FMC_SDRAM_Timing_Init+0x106>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 80073b6:	6963      	ldr	r3, [r4, #20]
 80073b8:	3b01      	subs	r3, #1
 80073ba:	2b0f      	cmp	r3, #15
 80073bc:	d857      	bhi.n	800746e <FMC_SDRAM_Timing_Init+0xfa>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 80073be:	69a3      	ldr	r3, [r4, #24]
 80073c0:	3b01      	subs	r3, #1
 80073c2:	2b0f      	cmp	r3, #15
 80073c4:	d84d      	bhi.n	8007462 <FMC_SDRAM_Timing_Init+0xee>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 80073c6:	2e01      	cmp	r6, #1
 80073c8:	d825      	bhi.n	8007416 <FMC_SDRAM_Timing_Init+0xa2>
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 80073ca:	d129      	bne.n	8007420 <FMC_SDRAM_Timing_Init+0xac>
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
                        (((Timing->RPDelay)-1) << 20)); 
 80073cc:	6962      	ldr	r2, [r4, #20]
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 80073ce:	68e1      	ldr	r1, [r4, #12]
                        (((Timing->RPDelay)-1) << 20)); 
 80073d0:	3a01      	subs	r2, #1
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 80073d2:	3901      	subs	r1, #1
                        (((Timing->RPDelay)-1) << 20)); 
 80073d4:	0512      	lsls	r2, r2, #20
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 80073d6:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 80073da:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80073de:	6821      	ldr	r1, [r4, #0]
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 80073e0:	3b01      	subs	r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 80073e2:	1e46      	subs	r6, r0, #1
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80073e4:	3901      	subs	r1, #1
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 80073e6:	68a8      	ldr	r0, [r5, #8]
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 80073e8:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 80073ea:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
 80073ee:	6926      	ldr	r6, [r4, #16]
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 80073f0:	430b      	orrs	r3, r1
                       (((Timing->RCDDelay)-1) << 24));   
 80073f2:	69a1      	ldr	r1, [r4, #24]
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
 80073f4:	1e74      	subs	r4, r6, #1
                       (((Timing->RCDDelay)-1) << 24));   
 80073f6:	3901      	subs	r1, #1
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 80073f8:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80073fc:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 8007400:	68e9      	ldr	r1, [r5, #12]
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8007402:	f001 4170 	and.w	r1, r1, #4026531840	; 0xf0000000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007406:	430b      	orrs	r3, r1
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8007408:	492d      	ldr	r1, [pc, #180]	; (80074c0 <FMC_SDRAM_Timing_Init+0x14c>)
 800740a:	4001      	ands	r1, r0
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 800740c:	2000      	movs	r0, #0
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800740e:	430a      	orrs	r2, r1
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8007410:	60aa      	str	r2, [r5, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8007412:	60eb      	str	r3, [r5, #12]
}
 8007414:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 8007416:	f240 3145 	movw	r1, #837	; 0x345
 800741a:	4828      	ldr	r0, [pc, #160]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 800741c:	f013 fd42 	bl	801aea4 <assert_failed>
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007420:	6821      	ldr	r1, [r4, #0]
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8007422:	68aa      	ldr	r2, [r5, #8]
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007424:	3901      	subs	r1, #1
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8007426:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800742a:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800742e:	3b01      	subs	r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8007430:	3801      	subs	r0, #1
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8007432:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8007434:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8007438:	430b      	orrs	r3, r1
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 800743a:	68e1      	ldr	r1, [r4, #12]
 800743c:	3901      	subs	r1, #1
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800743e:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8007442:	6921      	ldr	r1, [r4, #16]
 8007444:	3901      	subs	r1, #1
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 8007446:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                       (((Timing->RCDDelay)-1) << 24));
 800744a:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
                       (((Timing->RPDelay)-1) << 20)             |\
 800744e:	3801      	subs	r0, #1
                       (((Timing->RCDDelay)-1) << 24));
 8007450:	3901      	subs	r1, #1
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8007452:	ea43 5300 	orr.w	r3, r3, r0, lsl #20
}
 8007456:	2000      	movs	r0, #0
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007458:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800745c:	4313      	orrs	r3, r2
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 800745e:	60ab      	str	r3, [r5, #8]
}
 8007460:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 8007462:	f44f 7151 	mov.w	r1, #836	; 0x344
 8007466:	4815      	ldr	r0, [pc, #84]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 8007468:	f013 fd1c 	bl	801aea4 <assert_failed>
 800746c:	e7ab      	b.n	80073c6 <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 800746e:	f240 3143 	movw	r1, #835	; 0x343
 8007472:	4812      	ldr	r0, [pc, #72]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 8007474:	f013 fd16 	bl	801aea4 <assert_failed>
 8007478:	e7a1      	b.n	80073be <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 800747a:	f240 3142 	movw	r1, #834	; 0x342
 800747e:	480f      	ldr	r0, [pc, #60]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 8007480:	f013 fd10 	bl	801aea4 <assert_failed>
 8007484:	e797      	b.n	80073b6 <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 8007486:	f240 3141 	movw	r1, #833	; 0x341
 800748a:	480c      	ldr	r0, [pc, #48]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 800748c:	f013 fd0a 	bl	801aea4 <assert_failed>
 8007490:	e78d      	b.n	80073ae <FMC_SDRAM_Timing_Init+0x3a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 8007492:	f44f 7150 	mov.w	r1, #832	; 0x340
 8007496:	4809      	ldr	r0, [pc, #36]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 8007498:	f013 fd04 	bl	801aea4 <assert_failed>
 800749c:	e783      	b.n	80073a6 <FMC_SDRAM_Timing_Init+0x32>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 800749e:	f240 313f 	movw	r1, #831	; 0x33f
 80074a2:	4806      	ldr	r0, [pc, #24]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 80074a4:	f013 fcfe 	bl	801aea4 <assert_failed>
 80074a8:	e779      	b.n	800739e <FMC_SDRAM_Timing_Init+0x2a>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 80074aa:	f240 313e 	movw	r1, #830	; 0x33e
 80074ae:	4803      	ldr	r0, [pc, #12]	; (80074bc <FMC_SDRAM_Timing_Init+0x148>)
 80074b0:	f013 fcf8 	bl	801aea4 <assert_failed>
 80074b4:	e76f      	b.n	8007396 <FMC_SDRAM_Timing_Init+0x22>
 80074b6:	bf00      	nop
 80074b8:	a0000140 	.word	0xa0000140
 80074bc:	08021814 	.word	0x08021814
 80074c0:	ff0f0fff 	.word	0xff0f0fff

080074c4 <FMC_SDRAM_SendCommand>:
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  __IO uint32_t tmpr = 0;
  
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 80074c4:	4b26      	ldr	r3, [pc, #152]	; (8007560 <FMC_SDRAM_SendCommand+0x9c>)
  __IO uint32_t tmpr = 0;
 80074c6:	2200      	movs	r2, #0
{
 80074c8:	b530      	push	{r4, r5, lr}
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 80074ca:	4298      	cmp	r0, r3
{
 80074cc:	b083      	sub	sp, #12
 80074ce:	4605      	mov	r5, r0
 80074d0:	460c      	mov	r4, r1
  __IO uint32_t tmpr = 0;
 80074d2:	9201      	str	r2, [sp, #4]
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 80074d4:	d004      	beq.n	80074e0 <FMC_SDRAM_SendCommand+0x1c>
 80074d6:	f44f 7174 	mov.w	r1, #976	; 0x3d0
 80074da:	4822      	ldr	r0, [pc, #136]	; (8007564 <FMC_SDRAM_SendCommand+0xa0>)
 80074dc:	f013 fce2 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 80074e0:	6823      	ldr	r3, [r4, #0]
 80074e2:	2b06      	cmp	r3, #6
 80074e4:	d836      	bhi.n	8007554 <FMC_SDRAM_SendCommand+0x90>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 80074e6:	6863      	ldr	r3, [r4, #4]
 80074e8:	f023 0210 	bic.w	r2, r3, #16
 80074ec:	2a08      	cmp	r2, #8
 80074ee:	d001      	beq.n	80074f4 <FMC_SDRAM_SendCommand+0x30>
 80074f0:	2b10      	cmp	r3, #16
 80074f2:	d116      	bne.n	8007522 <FMC_SDRAM_SendCommand+0x5e>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 80074f4:	68a3      	ldr	r3, [r4, #8]
 80074f6:	3b01      	subs	r3, #1
 80074f8:	2b0f      	cmp	r3, #15
 80074fa:	d81b      	bhi.n	8007534 <FMC_SDRAM_SendCommand+0x70>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  
 80074fc:	68e1      	ldr	r1, [r4, #12]
 80074fe:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 8007502:	d220      	bcs.n	8007546 <FMC_SDRAM_SendCommand+0x82>

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8007504:	68a2      	ldr	r2, [r4, #8]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8007506:	e9d4 3000 	ldrd	r3, r0, [r4]
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 800750a:	3a01      	subs	r2, #1
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800750c:	4303      	orrs	r3, r0
                    );
    
  Device->SDCMR = tmpr;
  
  return HAL_OK;  
}
 800750e:	2000      	movs	r0, #0
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8007510:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 8007514:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
 8007518:	9301      	str	r3, [sp, #4]
  Device->SDCMR = tmpr;
 800751a:	9b01      	ldr	r3, [sp, #4]
 800751c:	612b      	str	r3, [r5, #16]
}
 800751e:	b003      	add	sp, #12
 8007520:	bd30      	pop	{r4, r5, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 8007522:	f240 31d2 	movw	r1, #978	; 0x3d2
 8007526:	480f      	ldr	r0, [pc, #60]	; (8007564 <FMC_SDRAM_SendCommand+0xa0>)
 8007528:	f013 fcbc 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 800752c:	68a3      	ldr	r3, [r4, #8]
 800752e:	3b01      	subs	r3, #1
 8007530:	2b0f      	cmp	r3, #15
 8007532:	d9e3      	bls.n	80074fc <FMC_SDRAM_SendCommand+0x38>
 8007534:	f240 31d3 	movw	r1, #979	; 0x3d3
 8007538:	480a      	ldr	r0, [pc, #40]	; (8007564 <FMC_SDRAM_SendCommand+0xa0>)
 800753a:	f013 fcb3 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  
 800753e:	68e1      	ldr	r1, [r4, #12]
 8007540:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 8007544:	d3de      	bcc.n	8007504 <FMC_SDRAM_SendCommand+0x40>
 8007546:	f44f 7175 	mov.w	r1, #980	; 0x3d4
 800754a:	4806      	ldr	r0, [pc, #24]	; (8007564 <FMC_SDRAM_SendCommand+0xa0>)
 800754c:	f013 fcaa 	bl	801aea4 <assert_failed>
                    ((Command->ModeRegisterDefinition) << 9)
 8007550:	68e1      	ldr	r1, [r4, #12]
 8007552:	e7d7      	b.n	8007504 <FMC_SDRAM_SendCommand+0x40>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 8007554:	f240 31d1 	movw	r1, #977	; 0x3d1
 8007558:	4802      	ldr	r0, [pc, #8]	; (8007564 <FMC_SDRAM_SendCommand+0xa0>)
 800755a:	f013 fca3 	bl	801aea4 <assert_failed>
 800755e:	e7c2      	b.n	80074e6 <FMC_SDRAM_SendCommand+0x22>
 8007560:	a0000140 	.word	0xa0000140
 8007564:	08021814 	.word	0x08021814

08007568 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 8007568:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800756a:	4b0c      	ldr	r3, [pc, #48]	; (800759c <FMC_SDRAM_ProgramRefreshRate+0x34>)
{
 800756c:	4604      	mov	r4, r0
 800756e:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 8007570:	4298      	cmp	r0, r3
 8007572:	d004      	beq.n	800757e <FMC_SDRAM_ProgramRefreshRate+0x16>
 8007574:	f240 31eb 	movw	r1, #1003	; 0x3eb
 8007578:	4809      	ldr	r0, [pc, #36]	; (80075a0 <FMC_SDRAM_ProgramRefreshRate+0x38>)
 800757a:	f013 fc93 	bl	801aea4 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
 800757e:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 8007582:	d205      	bcs.n	8007590 <FMC_SDRAM_ProgramRefreshRate+0x28>
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 8007584:	6961      	ldr	r1, [r4, #20]
  
  return HAL_OK;   
}
 8007586:	2000      	movs	r0, #0
  Device->SDRTR |= (RefreshRate<<1);
 8007588:	ea41 0545 	orr.w	r5, r1, r5, lsl #1
 800758c:	6165      	str	r5, [r4, #20]
}
 800758e:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
 8007590:	f44f 717b 	mov.w	r1, #1004	; 0x3ec
 8007594:	4802      	ldr	r0, [pc, #8]	; (80075a0 <FMC_SDRAM_ProgramRefreshRate+0x38>)
 8007596:	f013 fc85 	bl	801aea4 <assert_failed>
 800759a:	e7f3      	b.n	8007584 <FMC_SDRAM_ProgramRefreshRate+0x1c>
 800759c:	a0000140 	.word	0xa0000140
 80075a0:	08021814 	.word	0x08021814

080075a4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80075a4:	b084      	sub	sp, #16
 80075a6:	4684      	mov	ip, r0
 80075a8:	b500      	push	{lr}
 80075aa:	b083      	sub	sp, #12
 80075ac:	f10d 0e14 	add.w	lr, sp, #20
 80075b0:	e88e 000e 	stmia.w	lr, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80075b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80075b6:	2b01      	cmp	r3, #1
 80075b8:	d133      	bne.n	8007622 <USB_CoreInit+0x7e>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80075ba:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80075bc:	f1a3 1342 	sub.w	r3, r3, #4325442	; 0x420042
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPI_UTMI_SEL;
#endif /* defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) || defined(STM32F732xx) || defined(STM32F733xx) */

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 80075c0:	9911      	ldr	r1, [sp, #68]	; 0x44
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80075c2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    if (cfg.use_external_vbus == 1U)
 80075c6:	2901      	cmp	r1, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80075c8:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80075ca:	68c2      	ldr	r2, [r0, #12]
 80075cc:	ea03 0302 	and.w	r3, r3, r2
 80075d0:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80075d2:	68c3      	ldr	r3, [r0, #12]
 80075d4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80075d8:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80075da:	d068      	beq.n	80076ae <USB_CoreInit+0x10a>
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  __IO uint32_t count = 0U;
 80075dc:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    count++;

    if (count > 200000U)
 80075de:	4a36      	ldr	r2, [pc, #216]	; (80076b8 <USB_CoreInit+0x114>)
  __IO uint32_t count = 0U;
 80075e0:	9300      	str	r3, [sp, #0]
 80075e2:	e003      	b.n	80075ec <USB_CoreInit+0x48>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80075e4:	f8dc 3010 	ldr.w	r3, [ip, #16]
 80075e8:	2b00      	cmp	r3, #0
 80075ea:	db34      	blt.n	8007656 <USB_CoreInit+0xb2>
    count++;
 80075ec:	9b00      	ldr	r3, [sp, #0]
 80075ee:	3301      	adds	r3, #1
 80075f0:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 80075f2:	9b00      	ldr	r3, [sp, #0]
 80075f4:	4293      	cmp	r3, r2
 80075f6:	d9f5      	bls.n	80075e4 <USB_CoreInit+0x40>
      return HAL_TIMEOUT;
 80075f8:	2003      	movs	r0, #3
  if (cfg.dma_enable == 1U)
 80075fa:	9b08      	ldr	r3, [sp, #32]
 80075fc:	2b01      	cmp	r3, #1
 80075fe:	d10b      	bne.n	8007618 <USB_CoreInit+0x74>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8007600:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8007604:	f043 0306 	orr.w	r3, r3, #6
 8007608:	f8cc 3008 	str.w	r3, [ip, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800760c:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8007610:	f043 0320 	orr.w	r3, r3, #32
 8007614:	f8cc 3008 	str.w	r3, [ip, #8]
}
 8007618:	b003      	add	sp, #12
 800761a:	f85d eb04 	ldr.w	lr, [sp], #4
 800761e:	b004      	add	sp, #16
 8007620:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8007622:	68c3      	ldr	r3, [r0, #12]
  __IO uint32_t count = 0U;
 8007624:	2100      	movs	r1, #0
    if (count > 200000U)
 8007626:	4a24      	ldr	r2, [pc, #144]	; (80076b8 <USB_CoreInit+0x114>)
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8007628:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800762c:	60c3      	str	r3, [r0, #12]
  __IO uint32_t count = 0U;
 800762e:	9101      	str	r1, [sp, #4]
 8007630:	e003      	b.n	800763a <USB_CoreInit+0x96>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007632:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8007636:	2b00      	cmp	r3, #0
 8007638:	db23      	blt.n	8007682 <USB_CoreInit+0xde>
    count++;
 800763a:	9b01      	ldr	r3, [sp, #4]
 800763c:	3301      	adds	r3, #1
 800763e:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8007640:	9b01      	ldr	r3, [sp, #4]
 8007642:	4293      	cmp	r3, r2
 8007644:	d9f5      	bls.n	8007632 <USB_CoreInit+0x8e>
      return HAL_TIMEOUT;
 8007646:	2003      	movs	r0, #3
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8007648:	f8dc 3038 	ldr.w	r3, [ip, #56]	; 0x38
 800764c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8007650:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
 8007654:	e7d1      	b.n	80075fa <USB_CoreInit+0x56>

  /* Core Soft Reset */
  count = 0U;
 8007656:	2300      	movs	r3, #0

  do
  {
    count++;

    if (count > 200000U)
 8007658:	4a17      	ldr	r2, [pc, #92]	; (80076b8 <USB_CoreInit+0x114>)
  count = 0U;
 800765a:	9300      	str	r3, [sp, #0]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800765c:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8007660:	f043 0301 	orr.w	r3, r3, #1
 8007664:	f8cc 3010 	str.w	r3, [ip, #16]
 8007668:	e004      	b.n	8007674 <USB_CoreInit+0xd0>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800766a:	f8dc 0010 	ldr.w	r0, [ip, #16]
 800766e:	f010 0001 	ands.w	r0, r0, #1
 8007672:	d0c2      	beq.n	80075fa <USB_CoreInit+0x56>
    count++;
 8007674:	9b00      	ldr	r3, [sp, #0]
 8007676:	3301      	adds	r3, #1
 8007678:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 800767a:	9b00      	ldr	r3, [sp, #0]
 800767c:	4293      	cmp	r3, r2
 800767e:	d9f4      	bls.n	800766a <USB_CoreInit+0xc6>
 8007680:	e7ba      	b.n	80075f8 <USB_CoreInit+0x54>
  count = 0U;
 8007682:	2300      	movs	r3, #0
    if (count > 200000U)
 8007684:	4a0c      	ldr	r2, [pc, #48]	; (80076b8 <USB_CoreInit+0x114>)
  count = 0U;
 8007686:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8007688:	f8dc 3010 	ldr.w	r3, [ip, #16]
 800768c:	f043 0301 	orr.w	r3, r3, #1
 8007690:	f8cc 3010 	str.w	r3, [ip, #16]
 8007694:	e004      	b.n	80076a0 <USB_CoreInit+0xfc>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8007696:	f8dc 0010 	ldr.w	r0, [ip, #16]
 800769a:	f010 0001 	ands.w	r0, r0, #1
 800769e:	d0d3      	beq.n	8007648 <USB_CoreInit+0xa4>
    count++;
 80076a0:	9b01      	ldr	r3, [sp, #4]
 80076a2:	3301      	adds	r3, #1
 80076a4:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80076a6:	9b01      	ldr	r3, [sp, #4]
 80076a8:	4293      	cmp	r3, r2
 80076aa:	d9f4      	bls.n	8007696 <USB_CoreInit+0xf2>
 80076ac:	e7cb      	b.n	8007646 <USB_CoreInit+0xa2>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80076ae:	68c3      	ldr	r3, [r0, #12]
 80076b0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80076b4:	60c3      	str	r3, [r0, #12]
 80076b6:	e791      	b.n	80075dc <USB_CoreInit+0x38>
 80076b8:	00030d40 	.word	0x00030d40

080076bc <USB_EnableGlobalInt>:
{
 80076bc:	4603      	mov	r3, r0
}
 80076be:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80076c0:	689a      	ldr	r2, [r3, #8]
 80076c2:	f042 0201 	orr.w	r2, r2, #1
 80076c6:	609a      	str	r2, [r3, #8]
}
 80076c8:	4770      	bx	lr
 80076ca:	bf00      	nop

080076cc <USB_DisableGlobalInt>:
{
 80076cc:	4603      	mov	r3, r0
}
 80076ce:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80076d0:	689a      	ldr	r2, [r3, #8]
 80076d2:	f022 0201 	bic.w	r2, r2, #1
 80076d6:	609a      	str	r2, [r3, #8]
}
 80076d8:	4770      	bx	lr
 80076da:	bf00      	nop

080076dc <USB_SetCurrentMode>:
{
 80076dc:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80076de:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80076e0:	2901      	cmp	r1, #1
{
 80076e2:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80076e4:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80076e8:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80076ea:	d017      	beq.n	800771c <USB_SetCurrentMode+0x40>
  else if (mode == USB_DEVICE_MODE)
 80076ec:	b9a1      	cbnz	r1, 8007718 <USB_SetCurrentMode+0x3c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 80076ee:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 80076f0:	460c      	mov	r4, r1
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 80076f2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80076f6:	60c3      	str	r3, [r0, #12]
 80076f8:	e001      	b.n	80076fe <USB_SetCurrentMode+0x22>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 80076fa:	2c32      	cmp	r4, #50	; 0x32
 80076fc:	d00c      	beq.n	8007718 <USB_SetCurrentMode+0x3c>
      HAL_Delay(1U);
 80076fe:	2001      	movs	r0, #1
      ms++;
 8007700:	4404      	add	r4, r0
      HAL_Delay(1U);
 8007702:	f7f9 fcbb 	bl	800107c <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8007706:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8007708:	07db      	lsls	r3, r3, #31
 800770a:	d4f6      	bmi.n	80076fa <USB_SetCurrentMode+0x1e>
    return HAL_ERROR;
 800770c:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 8007710:	fab0 f080 	clz	r0, r0
 8007714:	0940      	lsrs	r0, r0, #5
}
 8007716:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8007718:	2001      	movs	r0, #1
}
 800771a:	bd38      	pop	{r3, r4, r5, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800771c:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 800771e:	2400      	movs	r4, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8007720:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8007724:	60c3      	str	r3, [r0, #12]
 8007726:	e001      	b.n	800772c <USB_SetCurrentMode+0x50>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8007728:	2c32      	cmp	r4, #50	; 0x32
 800772a:	d0f5      	beq.n	8007718 <USB_SetCurrentMode+0x3c>
      HAL_Delay(1U);
 800772c:	2001      	movs	r0, #1
      ms++;
 800772e:	4404      	add	r4, r0
      HAL_Delay(1U);
 8007730:	f7f9 fca4 	bl	800107c <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8007734:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8007736:	07da      	lsls	r2, r3, #31
 8007738:	d5f6      	bpl.n	8007728 <USB_SetCurrentMode+0x4c>
    return HAL_ERROR;
 800773a:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 800773e:	fab0 f080 	clz	r0, r0
 8007742:	0940      	lsrs	r0, r0, #5
 8007744:	e7e7      	b.n	8007716 <USB_SetCurrentMode+0x3a>
 8007746:	bf00      	nop

08007748 <USB_FlushTxFifo>:
{
 8007748:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800774a:	2300      	movs	r3, #0
    if (count > 200000U)
 800774c:	4a12      	ldr	r2, [pc, #72]	; (8007798 <USB_FlushTxFifo+0x50>)
  __IO uint32_t count = 0U;
 800774e:	9301      	str	r3, [sp, #4]
 8007750:	e002      	b.n	8007758 <USB_FlushTxFifo+0x10>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007752:	6903      	ldr	r3, [r0, #16]
 8007754:	2b00      	cmp	r3, #0
 8007756:	db08      	blt.n	800776a <USB_FlushTxFifo+0x22>
    count++;
 8007758:	9b01      	ldr	r3, [sp, #4]
 800775a:	3301      	adds	r3, #1
 800775c:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 800775e:	9b01      	ldr	r3, [sp, #4]
 8007760:	4293      	cmp	r3, r2
 8007762:	d9f6      	bls.n	8007752 <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 8007764:	2003      	movs	r0, #3
}
 8007766:	b002      	add	sp, #8
 8007768:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800776a:	0189      	lsls	r1, r1, #6
  count = 0U;
 800776c:	2300      	movs	r3, #0
    if (count > 200000U)
 800776e:	4a0a      	ldr	r2, [pc, #40]	; (8007798 <USB_FlushTxFifo+0x50>)
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8007770:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 8007774:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8007776:	6101      	str	r1, [r0, #16]
 8007778:	e003      	b.n	8007782 <USB_FlushTxFifo+0x3a>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800777a:	6903      	ldr	r3, [r0, #16]
 800777c:	f013 0320 	ands.w	r3, r3, #32
 8007780:	d006      	beq.n	8007790 <USB_FlushTxFifo+0x48>
    count++;
 8007782:	9b01      	ldr	r3, [sp, #4]
 8007784:	3301      	adds	r3, #1
 8007786:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8007788:	9b01      	ldr	r3, [sp, #4]
 800778a:	4293      	cmp	r3, r2
 800778c:	d9f5      	bls.n	800777a <USB_FlushTxFifo+0x32>
 800778e:	e7e9      	b.n	8007764 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 8007790:	4618      	mov	r0, r3
}
 8007792:	b002      	add	sp, #8
 8007794:	4770      	bx	lr
 8007796:	bf00      	nop
 8007798:	00030d40 	.word	0x00030d40

0800779c <USB_FlushRxFifo>:
{
 800779c:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800779e:	2300      	movs	r3, #0
    if (count > 200000U)
 80077a0:	4a11      	ldr	r2, [pc, #68]	; (80077e8 <USB_FlushRxFifo+0x4c>)
  __IO uint32_t count = 0U;
 80077a2:	9301      	str	r3, [sp, #4]
 80077a4:	e002      	b.n	80077ac <USB_FlushRxFifo+0x10>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80077a6:	6903      	ldr	r3, [r0, #16]
 80077a8:	2b00      	cmp	r3, #0
 80077aa:	db08      	blt.n	80077be <USB_FlushRxFifo+0x22>
    count++;
 80077ac:	9b01      	ldr	r3, [sp, #4]
 80077ae:	3301      	adds	r3, #1
 80077b0:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80077b2:	9b01      	ldr	r3, [sp, #4]
 80077b4:	4293      	cmp	r3, r2
 80077b6:	d9f6      	bls.n	80077a6 <USB_FlushRxFifo+0xa>
      return HAL_TIMEOUT;
 80077b8:	2003      	movs	r0, #3
}
 80077ba:	b002      	add	sp, #8
 80077bc:	4770      	bx	lr
  count = 0U;
 80077be:	2100      	movs	r1, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80077c0:	2310      	movs	r3, #16
    if (count > 200000U)
 80077c2:	4a09      	ldr	r2, [pc, #36]	; (80077e8 <USB_FlushRxFifo+0x4c>)
  count = 0U;
 80077c4:	9101      	str	r1, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80077c6:	6103      	str	r3, [r0, #16]
 80077c8:	e003      	b.n	80077d2 <USB_FlushRxFifo+0x36>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80077ca:	6903      	ldr	r3, [r0, #16]
 80077cc:	f013 0310 	ands.w	r3, r3, #16
 80077d0:	d006      	beq.n	80077e0 <USB_FlushRxFifo+0x44>
    count++;
 80077d2:	9b01      	ldr	r3, [sp, #4]
 80077d4:	3301      	adds	r3, #1
 80077d6:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80077d8:	9b01      	ldr	r3, [sp, #4]
 80077da:	4293      	cmp	r3, r2
 80077dc:	d9f5      	bls.n	80077ca <USB_FlushRxFifo+0x2e>
 80077de:	e7eb      	b.n	80077b8 <USB_FlushRxFifo+0x1c>
  return HAL_OK;
 80077e0:	4618      	mov	r0, r3
}
 80077e2:	b002      	add	sp, #8
 80077e4:	4770      	bx	lr
 80077e6:	bf00      	nop
 80077e8:	00030d40 	.word	0x00030d40

080077ec <USB_ReadPacket>:
  for (i = 0U; i < count32b; i++)
 80077ec:	ea5f 0c92 	movs.w	ip, r2, lsr #2
{
 80077f0:	b570      	push	{r4, r5, r6, lr}
 80077f2:	4605      	mov	r5, r0
  uint16_t remaining_bytes = len % 4U;
 80077f4:	f002 0603 	and.w	r6, r2, #3
  for (i = 0U; i < count32b; i++)
 80077f8:	d01c      	beq.n	8007834 <USB_ReadPacket+0x48>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 80077fa:	f500 5e80 	add.w	lr, r0, #4096	; 0x1000
  uint8_t *pDest = dest;
 80077fe:	460a      	mov	r2, r1
  for (i = 0U; i < count32b; i++)
 8007800:	2300      	movs	r3, #0
 8007802:	3301      	adds	r3, #1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8007804:	f8de 4000 	ldr.w	r4, [lr]
  for (i = 0U; i < count32b; i++)
 8007808:	459c      	cmp	ip, r3
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 800780a:	f842 4b04 	str.w	r4, [r2], #4
  for (i = 0U; i < count32b; i++)
 800780e:	d1f8      	bne.n	8007802 <USB_ReadPacket+0x16>
    pDest++;
 8007810:	eb01 008c 	add.w	r0, r1, ip, lsl #2
  if (remaining_bytes != 0U)
 8007814:	b16e      	cbz	r6, 8007832 <USB_ReadPacket+0x46>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8007816:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
      remaining_bytes--;
 800781a:	1e73      	subs	r3, r6, #1
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 800781c:	682a      	ldr	r2, [r5, #0]
      remaining_bytes--;
 800781e:	b29b      	uxth	r3, r3
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8007820:	7002      	strb	r2, [r0, #0]
    } while (remaining_bytes != 0U);
 8007822:	b12b      	cbz	r3, 8007830 <USB_ReadPacket+0x44>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8007824:	0a11      	lsrs	r1, r2, #8
    } while (remaining_bytes != 0U);
 8007826:	2b01      	cmp	r3, #1
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8007828:	7041      	strb	r1, [r0, #1]
    } while (remaining_bytes != 0U);
 800782a:	d001      	beq.n	8007830 <USB_ReadPacket+0x44>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 800782c:	0c12      	lsrs	r2, r2, #16
 800782e:	7082      	strb	r2, [r0, #2]
      pDest++;
 8007830:	4430      	add	r0, r6
}
 8007832:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *pDest = dest;
 8007834:	4608      	mov	r0, r1
 8007836:	e7ed      	b.n	8007814 <USB_ReadPacket+0x28>

08007838 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8007838:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 800783a:	6980      	ldr	r0, [r0, #24]
}
 800783c:	4010      	ands	r0, r2
 800783e:	4770      	bx	lr

08007840 <USB_ReadChInterrupts>:
  tmpreg = USBx_HC(chnum)->HCINT;
 8007840:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8007844:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
  tmpreg &= USBx_HC(chnum)->HCINTMSK;
 8007848:	f8d1 350c 	ldr.w	r3, [r1, #1292]	; 0x50c
}
 800784c:	4018      	ands	r0, r3
 800784e:	4770      	bx	lr

08007850 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8007850:	6940      	ldr	r0, [r0, #20]
}
 8007852:	f000 0001 	and.w	r0, r0, #1
 8007856:	4770      	bx	lr

08007858 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8007858:	b084      	sub	sp, #16
 800785a:	4684      	mov	ip, r0
 800785c:	b430      	push	{r4, r5}
 800785e:	b082      	sub	sp, #8
 8007860:	ac05      	add	r4, sp, #20
 8007862:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8007866:	2300      	movs	r3, #0
 8007868:	4611      	mov	r1, r2
 800786a:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 800786e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8007870:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8007874:	6383      	str	r3, [r0, #56]	; 0x38

  if ((USBx->CID & (0x1U << 8)) != 0U)
 8007876:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8007878:	05dd      	lsls	r5, r3, #23
 800787a:	d565      	bpl.n	8007948 <USB_HostInit+0xf0>
  {
    if (cfg.speed == USBH_FSLS_SPEED)
 800787c:	9b07      	ldr	r3, [sp, #28]
 800787e:	2b01      	cmp	r3, #1
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 8007880:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
    if (cfg.speed == USBH_FSLS_SPEED)
 8007884:	f000 808a 	beq.w	800799c <USB_HostInit+0x144>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8007888:	f023 0304 	bic.w	r3, r3, #4
 800788c:	f8cc 3400 	str.w	r3, [ip, #1024]	; 0x400
  __IO uint32_t count = 0U;
 8007890:	2300      	movs	r3, #0
    if (count > 200000U)
 8007892:	4a45      	ldr	r2, [pc, #276]	; (80079a8 <USB_HostInit+0x150>)
  __IO uint32_t count = 0U;
 8007894:	9300      	str	r3, [sp, #0]
 8007896:	e003      	b.n	80078a0 <USB_HostInit+0x48>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007898:	f8dc 3010 	ldr.w	r3, [ip, #16]
 800789c:	2b00      	cmp	r3, #0
 800789e:	db69      	blt.n	8007974 <USB_HostInit+0x11c>
    count++;
 80078a0:	9b00      	ldr	r3, [sp, #0]
 80078a2:	3301      	adds	r3, #1
 80078a4:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 80078a6:	9b00      	ldr	r3, [sp, #0]
 80078a8:	4293      	cmp	r3, r2
 80078aa:	d9f5      	bls.n	8007898 <USB_HostInit+0x40>
  }

  /* Make sure the FIFOs are flushed. */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
  {
    ret = HAL_ERROR;
 80078ac:	2001      	movs	r0, #1
  __IO uint32_t count = 0U;
 80078ae:	2300      	movs	r3, #0
    if (count > 200000U)
 80078b0:	4a3d      	ldr	r2, [pc, #244]	; (80079a8 <USB_HostInit+0x150>)
  __IO uint32_t count = 0U;
 80078b2:	9301      	str	r3, [sp, #4]
 80078b4:	e003      	b.n	80078be <USB_HostInit+0x66>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80078b6:	f8dc 3010 	ldr.w	r3, [ip, #16]
 80078ba:	2b00      	cmp	r3, #0
 80078bc:	db47      	blt.n	800794e <USB_HostInit+0xf6>
    count++;
 80078be:	9b01      	ldr	r3, [sp, #4]
 80078c0:	3301      	adds	r3, #1
 80078c2:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80078c4:	9b01      	ldr	r3, [sp, #4]
 80078c6:	4293      	cmp	r3, r2
 80078c8:	d9f5      	bls.n	80078b6 <USB_HostInit+0x5e>
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
  {
    ret = HAL_ERROR;
 80078ca:	2001      	movs	r0, #1
  }

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 80078cc:	b159      	cbz	r1, 80078e6 <USB_HostInit+0x8e>
 80078ce:	2200      	movs	r2, #0
 80078d0:	f50c 63a0 	add.w	r3, ip, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 80078d4:	f04f 35ff 	mov.w	r5, #4294967295
    USBx_HC(i)->HCINTMSK = 0U;
 80078d8:	4614      	mov	r4, r2
  for (i = 0U; i < cfg.Host_channels; i++)
 80078da:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 80078dc:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 80078de:	60dc      	str	r4, [r3, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 80078e0:	3320      	adds	r3, #32
 80078e2:	4291      	cmp	r1, r2
 80078e4:	d1f9      	bne.n	80078da <USB_HostInit+0x82>

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFFU;
 80078e6:	f04f 33ff 	mov.w	r3, #4294967295
  USBx->GINTMSK = 0U;
 80078ea:	2200      	movs	r2, #0
 80078ec:	f8cc 2018 	str.w	r2, [ip, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
 80078f0:	f8cc 3014 	str.w	r3, [ip, #20]

  if ((USBx->CID & (0x1U << 8)) != 0U)
 80078f4:	f8dc 303c 	ldr.w	r3, [ip, #60]	; 0x3c
 80078f8:	05db      	lsls	r3, r3, #23
 80078fa:	d51b      	bpl.n	8007934 <USB_HostInit+0xdc>
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x200U;
 80078fc:	f44f 7100 	mov.w	r1, #512	; 0x200
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 8007900:	4a2a      	ldr	r2, [pc, #168]	; (80079ac <USB_HostInit+0x154>)
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 8007902:	4b2b      	ldr	r3, [pc, #172]	; (80079b0 <USB_HostInit+0x158>)
    USBx->GRXFSIZ  = 0x200U;
 8007904:	f8cc 1024 	str.w	r1, [ip, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 8007908:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800790c:	f8cc 3100 	str.w	r3, [ip, #256]	; 0x100
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
  }

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8007910:	9b08      	ldr	r3, [sp, #32]
 8007912:	b92b      	cbnz	r3, 8007920 <USB_HostInit+0xc8>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8007914:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8007918:	f043 0310 	orr.w	r3, r3, #16
 800791c:	f8cc 3018 	str.w	r3, [ip, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 8007920:	f8dc 2018 	ldr.w	r2, [ip, #24]
 8007924:	4b23      	ldr	r3, [pc, #140]	; (80079b4 <USB_HostInit+0x15c>)
 8007926:	4313      	orrs	r3, r2
 8007928:	f8cc 3018 	str.w	r3, [ip, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return ret;
}
 800792c:	b002      	add	sp, #8
 800792e:	bc30      	pop	{r4, r5}
 8007930:	b004      	add	sp, #16
 8007932:	4770      	bx	lr
    USBx->GRXFSIZ  = 0x80U;
 8007934:	2180      	movs	r1, #128	; 0x80
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 8007936:	4a20      	ldr	r2, [pc, #128]	; (80079b8 <USB_HostInit+0x160>)
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 8007938:	4b20      	ldr	r3, [pc, #128]	; (80079bc <USB_HostInit+0x164>)
    USBx->GRXFSIZ  = 0x80U;
 800793a:	f8cc 1024 	str.w	r1, [ip, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 800793e:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 8007942:	f8cc 3100 	str.w	r3, [ip, #256]	; 0x100
 8007946:	e7e3      	b.n	8007910 <USB_HostInit+0xb8>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8007948:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
 800794c:	e79c      	b.n	8007888 <USB_HostInit+0x30>
  count = 0U;
 800794e:	2200      	movs	r2, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8007950:	2310      	movs	r3, #16
  count = 0U;
 8007952:	9201      	str	r2, [sp, #4]
    if (count > 200000U)
 8007954:	4a14      	ldr	r2, [pc, #80]	; (80079a8 <USB_HostInit+0x150>)
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8007956:	f8cc 3010 	str.w	r3, [ip, #16]
 800795a:	e003      	b.n	8007964 <USB_HostInit+0x10c>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800795c:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8007960:	06dc      	lsls	r4, r3, #27
 8007962:	d5b3      	bpl.n	80078cc <USB_HostInit+0x74>
    count++;
 8007964:	9b01      	ldr	r3, [sp, #4]
 8007966:	3301      	adds	r3, #1
 8007968:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 800796a:	9b01      	ldr	r3, [sp, #4]
 800796c:	4293      	cmp	r3, r2
 800796e:	d9f5      	bls.n	800795c <USB_HostInit+0x104>
    ret = HAL_ERROR;
 8007970:	2001      	movs	r0, #1
 8007972:	e7ab      	b.n	80078cc <USB_HostInit+0x74>
  count = 0U;
 8007974:	2000      	movs	r0, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8007976:	f44f 6384 	mov.w	r3, #1056	; 0x420
    if (count > 200000U)
 800797a:	4a0b      	ldr	r2, [pc, #44]	; (80079a8 <USB_HostInit+0x150>)
  count = 0U;
 800797c:	9000      	str	r0, [sp, #0]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800797e:	f8cc 3010 	str.w	r3, [ip, #16]
 8007982:	e004      	b.n	800798e <USB_HostInit+0x136>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8007984:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8007988:	f010 0020 	ands.w	r0, r0, #32
 800798c:	d08f      	beq.n	80078ae <USB_HostInit+0x56>
    count++;
 800798e:	9b00      	ldr	r3, [sp, #0]
 8007990:	3301      	adds	r3, #1
 8007992:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 8007994:	9b00      	ldr	r3, [sp, #0]
 8007996:	4293      	cmp	r3, r2
 8007998:	d9f4      	bls.n	8007984 <USB_HostInit+0x12c>
 800799a:	e787      	b.n	80078ac <USB_HostInit+0x54>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800799c:	f043 0304 	orr.w	r3, r3, #4
 80079a0:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
 80079a4:	e774      	b.n	8007890 <USB_HostInit+0x38>
 80079a6:	bf00      	nop
 80079a8:	00030d40 	.word	0x00030d40
 80079ac:	01000200 	.word	0x01000200
 80079b0:	00e00300 	.word	0x00e00300
 80079b4:	a3200008 	.word	0xa3200008
 80079b8:	00600080 	.word	0x00600080
 80079bc:	004000e0 	.word	0x004000e0

080079c0 <USB_InitFSLSPClkSel>:
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 80079c0:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 80079c4:	f001 0303 	and.w	r3, r1, #3

  if (freq == HCFG_48_MHZ)
 80079c8:	2901      	cmp	r1, #1
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 80079ca:	f500 6c80 	add.w	ip, r0, #1024	; 0x400
 80079ce:	f022 0203 	bic.w	r2, r2, #3
 80079d2:	f8c0 2400 	str.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 80079d6:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
 80079da:	ea43 0302 	orr.w	r3, r3, r2
 80079de:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  if (freq == HCFG_48_MHZ)
 80079e2:	d009      	beq.n	80079f8 <USB_InitFSLSPClkSel+0x38>
  {
    USBx_HOST->HFIR = 48000U;
  }
  else if (freq == HCFG_6_MHZ)
 80079e4:	2902      	cmp	r1, #2
 80079e6:	d001      	beq.n	80079ec <USB_InitFSLSPClkSel+0x2c>
  {
    /* ... */
  }

  return HAL_OK;
}
 80079e8:	2000      	movs	r0, #0
 80079ea:	4770      	bx	lr
    USBx_HOST->HFIR = 6000U;
 80079ec:	f241 7370 	movw	r3, #6000	; 0x1770
}
 80079f0:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 6000U;
 80079f2:	f8cc 3004 	str.w	r3, [ip, #4]
}
 80079f6:	4770      	bx	lr
    USBx_HOST->HFIR = 48000U;
 80079f8:	f64b 3380 	movw	r3, #48000	; 0xbb80
}
 80079fc:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 48000U;
 80079fe:	f8cc 3004 	str.w	r3, [ip, #4]
}
 8007a02:	4770      	bx	lr

08007a04 <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
{
 8007a04:	b530      	push	{r4, r5, lr}
 8007a06:	4604      	mov	r4, r0
 8007a08:	b083      	sub	sp, #12
  uint32_t USBx_BASE = (uint32_t)USBx;

  __IO uint32_t hprt0 = 0U;
 8007a0a:	2500      	movs	r5, #0

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
  HAL_Delay(100U);                                 /* See Note #1 */
 8007a0c:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
 8007a0e:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
 8007a10:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 8007a14:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8007a16:	9b01      	ldr	r3, [sp, #4]
 8007a18:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8007a1c:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 8007a1e:	9b01      	ldr	r3, [sp, #4]
 8007a20:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007a24:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
 8007a28:	f7f9 fb28 	bl	800107c <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8007a2c:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
 8007a2e:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8007a30:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007a34:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
 8007a38:	f7f9 fb20 	bl	800107c <HAL_Delay>

  return HAL_OK;
}
 8007a3c:	4628      	mov	r0, r5
 8007a3e:	b003      	add	sp, #12
 8007a40:	bd30      	pop	{r4, r5, pc}
 8007a42:	bf00      	nop

08007a44 <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 8007a44:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 8007a46:	2300      	movs	r3, #0
 8007a48:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 8007a4a:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 8007a4e:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8007a50:	9b01      	ldr	r3, [sp, #4]
 8007a52:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8007a56:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 8007a58:	9b01      	ldr	r3, [sp, #4]
 8007a5a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 8007a5e:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 8007a60:	d101      	bne.n	8007a66 <USB_DriveVbus+0x22>
 8007a62:	2901      	cmp	r1, #1
 8007a64:	d00d      	beq.n	8007a82 <USB_DriveVbus+0x3e>
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8007a66:	04db      	lsls	r3, r3, #19
 8007a68:	d500      	bpl.n	8007a6c <USB_DriveVbus+0x28>
 8007a6a:	b111      	cbz	r1, 8007a72 <USB_DriveVbus+0x2e>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
  }
  return HAL_OK;
}
 8007a6c:	2000      	movs	r0, #0
 8007a6e:	b002      	add	sp, #8
 8007a70:	4770      	bx	lr
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 8007a72:	9b01      	ldr	r3, [sp, #4]
 8007a74:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007a78:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 8007a7c:	2000      	movs	r0, #0
 8007a7e:	b002      	add	sp, #8
 8007a80:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 8007a82:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8007a86:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 8007a8a:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8007a8c:	9b01      	ldr	r3, [sp, #4]
}
 8007a8e:	b002      	add	sp, #8
 8007a90:	4770      	bx	lr
 8007a92:	bf00      	nop

08007a94 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 8007a94:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 8007a96:	2300      	movs	r3, #0
 8007a98:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 8007a9a:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 8007a9e:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8007aa0:	9801      	ldr	r0, [sp, #4]
}
 8007aa2:	f3c0 4041 	ubfx	r0, r0, #17, #2
 8007aa6:	b002      	add	sp, #8
 8007aa8:	4770      	bx	lr
 8007aaa:	bf00      	nop

08007aac <USB_GetCurrentFrame>:
  */
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 8007aac:	f8d0 0408 	ldr.w	r0, [r0, #1032]	; 0x408
}
 8007ab0:	b280      	uxth	r0, r0
 8007ab2:	4770      	bx	lr

08007ab4 <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 8007ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007ab8:	b082      	sub	sp, #8
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 8007aba:	eb00 1e41 	add.w	lr, r0, r1, lsl #5
 8007abe:	f04f 34ff 	mov.w	r4, #4294967295
{
 8007ac2:	f89d c024 	ldrb.w	ip, [sp, #36]	; 0x24
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 8007ac6:	f8ce 4508 	str.w	r4, [lr, #1288]	; 0x508
 8007aca:	f50e 64a0 	add.w	r4, lr, #1280	; 0x500
{
 8007ace:	f89d 6020 	ldrb.w	r6, [sp, #32]
 8007ad2:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 8007ad6:	f1bc 0f03 	cmp.w	ip, #3
 8007ada:	f200 8082 	bhi.w	8007be2 <USB_HC_Init+0x12e>
 8007ade:	e8df f00c 	tbb	[pc, ip]
 8007ae2:	7402      	.short	0x7402
 8007ae4:	5502      	.short	0x5502
  {
    case EP_TYPE_CTRL:
    case EP_TYPE_BULK:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007ae6:	f240 479d 	movw	r7, #1181	; 0x49d
 8007aea:	60e7      	str	r7, [r4, #12]
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 8007aec:	0617      	lsls	r7, r2, #24
 8007aee:	d452      	bmi.n	8007b96 <USB_HC_Init+0xe2>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
      }
      else
      {
        if ((USBx->CID & (0x1U << 8)) != 0U)
 8007af0:	6bc7      	ldr	r7, [r0, #60]	; 0x3c
 8007af2:	05ff      	lsls	r7, r7, #23
 8007af4:	d503      	bpl.n	8007afe <USB_HC_Init+0x4a>
        {
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 8007af6:	68e7      	ldr	r7, [r4, #12]
 8007af8:	f047 0760 	orr.w	r7, r7, #96	; 0x60
 8007afc:	60e7      	str	r7, [r4, #12]
      ret = HAL_ERROR;
      break;
  }

  /* Enable host channel Halt interrupt */
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007afe:	68e7      	ldr	r7, [r4, #12]

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007b00:	f001 010f 	and.w	r1, r1, #15
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007b04:	f047 0702 	orr.w	r7, r7, #2
 8007b08:	60e7      	str	r7, [r4, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007b0a:	2401      	movs	r4, #1
 8007b0c:	fa04 f101 	lsl.w	r1, r4, r1
 8007b10:	f8d0 4418 	ldr.w	r4, [r0, #1048]	; 0x418
 8007b14:	4321      	orrs	r1, r4
 8007b16:	f8c0 1418 	str.w	r1, [r0, #1048]	; 0x418

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8007b1a:	6981      	ldr	r1, [r0, #24]
 8007b1c:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8007b20:	6181      	str	r1, [r0, #24]
 8007b22:	2100      	movs	r1, #0
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
 8007b24:	460c      	mov	r4, r1
  __IO uint32_t hprt0 = 0U;
 8007b26:	2700      	movs	r7, #0
 8007b28:	9701      	str	r7, [sp, #4]
  hprt0 = USBx_HPRT0;
 8007b2a:	f8d0 0440 	ldr.w	r0, [r0, #1088]	; 0x440
 8007b2e:	9001      	str	r0, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8007b30:	9801      	ldr	r0, [sp, #4]
 8007b32:	f3c0 4041 	ubfx	r0, r0, #17, #2
  }

  HostCoreSpeed = USB_GetHostSpeed(USBx);

  /* LS device plugged to HUB */
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 8007b36:	2802      	cmp	r0, #2
 8007b38:	d051      	beq.n	8007bde <USB_HC_Init+0x12a>
 8007b3a:	2e02      	cmp	r6, #2
 8007b3c:	d14f      	bne.n	8007bde <USB_HC_Init+0x12a>
  {
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 8007b3e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007b42:	059b      	lsls	r3, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 8007b44:	f3c5 050a 	ubfx	r5, r5, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 8007b48:	02d2      	lsls	r2, r2, #11
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007b4a:	f003 53fe 	and.w	r3, r3, #532676608	; 0x1fc00000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 8007b4e:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007b52:	432b      	orrs	r3, r5
 8007b54:	4313      	orrs	r3, r2
 8007b56:	ea4f 428c 	mov.w	r2, ip, lsl #18

  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8007b5a:	f00c 0cfd 	and.w	ip, ip, #253	; 0xfd
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007b5e:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8007b62:	f1bc 0f01 	cmp.w	ip, #1
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007b66:	ea43 0302 	orr.w	r3, r3, r2
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 8007b6a:	ea43 0304 	orr.w	r3, r3, r4
 8007b6e:	ea43 0300 	orr.w	r3, r3, r0
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007b72:	f8ce 3500 	str.w	r3, [lr, #1280]	; 0x500
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8007b76:	d105      	bne.n	8007b84 <USB_HC_Init+0xd0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8007b78:	f8de 3500 	ldr.w	r3, [lr, #1280]	; 0x500
 8007b7c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8007b80:	f8ce 3500 	str.w	r3, [lr, #1280]	; 0x500
  }

  return ret;
}
 8007b84:	4608      	mov	r0, r1
 8007b86:	b002      	add	sp, #8
 8007b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007b8c:	f240 679d 	movw	r7, #1693	; 0x69d
 8007b90:	60e7      	str	r7, [r4, #12]
      if ((epnum & 0x80U) == 0x80U)
 8007b92:	0617      	lsls	r7, r2, #24
 8007b94:	d5b3      	bpl.n	8007afe <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8007b96:	68e7      	ldr	r7, [r4, #12]
 8007b98:	f447 7780 	orr.w	r7, r7, #256	; 0x100
 8007b9c:	60e7      	str	r7, [r4, #12]
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007b9e:	68e7      	ldr	r7, [r4, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007ba0:	f001 080f 	and.w	r8, r1, #15
 8007ba4:	2101      	movs	r1, #1
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007ba6:	f047 0702 	orr.w	r7, r7, #2
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007baa:	fa01 f108 	lsl.w	r1, r1, r8
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007bae:	60e7      	str	r7, [r4, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007bb0:	f8d0 4418 	ldr.w	r4, [r0, #1048]	; 0x418
 8007bb4:	4321      	orrs	r1, r4
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 8007bb6:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007bba:	f8c0 1418 	str.w	r1, [r0, #1048]	; 0x418
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8007bbe:	6981      	ldr	r1, [r0, #24]
 8007bc0:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8007bc4:	6181      	str	r1, [r0, #24]
 8007bc6:	2100      	movs	r1, #0
 8007bc8:	e7ad      	b.n	8007b26 <USB_HC_Init+0x72>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007bca:	f240 2725 	movw	r7, #549	; 0x225
 8007bce:	60e7      	str	r7, [r4, #12]
      if ((epnum & 0x80U) == 0x80U)
 8007bd0:	0617      	lsls	r7, r2, #24
 8007bd2:	d594      	bpl.n	8007afe <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 8007bd4:	68e7      	ldr	r7, [r4, #12]
 8007bd6:	f447 77c0 	orr.w	r7, r7, #384	; 0x180
 8007bda:	60e7      	str	r7, [r4, #12]
 8007bdc:	e7df      	b.n	8007b9e <USB_HC_Init+0xea>
    HCcharLowSpeed = 0U;
 8007bde:	2000      	movs	r0, #0
 8007be0:	e7af      	b.n	8007b42 <USB_HC_Init+0x8e>
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007be2:	68e7      	ldr	r7, [r4, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007be4:	f001 010f 	and.w	r1, r1, #15
      ret = HAL_ERROR;
 8007be8:	f012 0f80 	tst.w	r2, #128	; 0x80
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007bec:	f047 0702 	orr.w	r7, r7, #2
 8007bf0:	60e7      	str	r7, [r4, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007bf2:	f04f 0701 	mov.w	r7, #1
 8007bf6:	fa07 f401 	lsl.w	r4, r7, r1
      ret = HAL_ERROR;
 8007bfa:	4639      	mov	r1, r7
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8007bfc:	f8d0 7418 	ldr.w	r7, [r0, #1048]	; 0x418
 8007c00:	ea44 0407 	orr.w	r4, r4, r7
 8007c04:	f8c0 4418 	str.w	r4, [r0, #1048]	; 0x418
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8007c08:	6984      	ldr	r4, [r0, #24]
 8007c0a:	f044 7400 	orr.w	r4, r4, #33554432	; 0x2000000
 8007c0e:	6184      	str	r4, [r0, #24]
      ret = HAL_ERROR;
 8007c10:	bf14      	ite	ne
 8007c12:	f44f 4400 	movne.w	r4, #32768	; 0x8000
 8007c16:	2400      	moveq	r4, #0
 8007c18:	e785      	b.n	8007b26 <USB_HC_Init+0x72>
 8007c1a:	bf00      	nop

08007c1c <USB_HC_StartXfer>:
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
 8007c1c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8007c1e:	05db      	lsls	r3, r3, #23
{
 8007c20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c22:	b083      	sub	sp, #12
  uint32_t ch_num = (uint32_t)hc->ch_num;
 8007c24:	f891 c001 	ldrb.w	ip, [r1, #1]
  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
 8007c28:	d502      	bpl.n	8007c30 <USB_HC_StartXfer+0x14>
 8007c2a:	790b      	ldrb	r3, [r1, #4]
 8007c2c:	2b00      	cmp	r3, #0
 8007c2e:	d054      	beq.n	8007cda <USB_HC_StartXfer+0xbe>
  {
    /* in DMA mode host Core automatically issues ping  in case of NYET/NAK */
    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
    {
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 8007c30:	eb00 134c 	add.w	r3, r0, ip, lsl #5
 8007c34:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    }

  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
 8007c38:	694d      	ldr	r5, [r1, #20]
 8007c3a:	2d00      	cmp	r5, #0
 8007c3c:	d13a      	bne.n	8007cb4 <USB_HC_StartXfer+0x98>

  /*
   * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
   * max_packet size.
   */
  if (hc->ep_is_in != 0U)
 8007c3e:	78ce      	ldrb	r6, [r1, #3]
 8007c40:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 8007c44:	2401      	movs	r4, #1
 8007c46:	2e00      	cmp	r6, #0
 8007c48:	d045      	beq.n	8007cd6 <USB_HC_StartXfer+0xba>
  {
    hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 8007c4a:	890f      	ldrh	r7, [r1, #8]
 8007c4c:	fb04 f707 	mul.w	r7, r4, r7
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 8007c50:	7a8c      	ldrb	r4, [r1, #10]
 8007c52:	610f      	str	r7, [r1, #16]
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007c54:	f3c7 0712 	ubfx	r7, r7, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 8007c58:	0764      	lsls	r4, r4, #29
 8007c5a:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007c5e:	ea44 040e 	orr.w	r4, r4, lr
 8007c62:	433c      	orrs	r4, r7
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007c64:	611c      	str	r4, [r3, #16]

  if (dma != 0U)
 8007c66:	b10a      	cbz	r2, 8007c6c <USB_HC_StartXfer+0x50>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 8007c68:	68cc      	ldr	r4, [r1, #12]
 8007c6a:	615c      	str	r4, [r3, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 8007c6c:	f8d0 4408 	ldr.w	r4, [r0, #1032]	; 0x408
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8007c70:	681f      	ldr	r7, [r3, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8007c72:	43e4      	mvns	r4, r4
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8007c74:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8007c78:	0764      	lsls	r4, r4, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8007c7a:	601f      	str	r7, [r3, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8007c7c:	f004 5400 	and.w	r4, r4, #536870912	; 0x20000000
 8007c80:	681f      	ldr	r7, [r3, #0]
 8007c82:	433c      	orrs	r4, r7
  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 8007c84:	f500 6780 	add.w	r7, r0, #1024	; 0x400
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8007c88:	601c      	str	r4, [r3, #0]

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 8007c8a:	681c      	ldr	r4, [r3, #0]
 8007c8c:	9401      	str	r4, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8007c8e:	9c01      	ldr	r4, [sp, #4]
 8007c90:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
 8007c94:	9401      	str	r4, [sp, #4]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 8007c96:	2e00      	cmp	r6, #0
 8007c98:	d034      	beq.n	8007d04 <USB_HC_StartXfer+0xe8>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 8007c9a:	9a01      	ldr	r2, [sp, #4]
 8007c9c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007ca0:	9201      	str	r2, [sp, #4]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007ca2:	9a01      	ldr	r2, [sp, #4]
 8007ca4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8007ca8:	9201      	str	r2, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 8007caa:	9a01      	ldr	r2, [sp, #4]
 8007cac:	601a      	str	r2, [r3, #0]
    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
  }

  return HAL_OK;
}
 8007cae:	2000      	movs	r0, #0
 8007cb0:	b003      	add	sp, #12
 8007cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 8007cb4:	890c      	ldrh	r4, [r1, #8]
 8007cb6:	1e6f      	subs	r7, r5, #1
  if (hc->ep_is_in != 0U)
 8007cb8:	78ce      	ldrb	r6, [r1, #3]
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 8007cba:	4427      	add	r7, r4
 8007cbc:	fbb7 f7f4 	udiv	r7, r7, r4
    hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 8007cc0:	b2bf      	uxth	r7, r7
 8007cc2:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
 8007cc6:	463c      	mov	r4, r7
 8007cc8:	bf28      	it	cs
 8007cca:	f44f 7480 	movcs.w	r4, #256	; 0x100
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007cce:	ea4f 4ec4 	mov.w	lr, r4, lsl #19
  if (hc->ep_is_in != 0U)
 8007cd2:	2e00      	cmp	r6, #0
 8007cd4:	d1b9      	bne.n	8007c4a <USB_HC_StartXfer+0x2e>
  if (hc->xfer_len > 0U)
 8007cd6:	462f      	mov	r7, r5
 8007cd8:	e7ba      	b.n	8007c50 <USB_HC_StartXfer+0x34>
    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
 8007cda:	2a01      	cmp	r2, #1
 8007cdc:	d027      	beq.n	8007d2e <USB_HC_StartXfer+0x112>
    if ((dma == 0U) && (hc->do_ping == 1U))
 8007cde:	2a00      	cmp	r2, #0
 8007ce0:	d1a6      	bne.n	8007c30 <USB_HC_StartXfer+0x14>
 8007ce2:	794b      	ldrb	r3, [r1, #5]
 8007ce4:	2b01      	cmp	r3, #1
 8007ce6:	d1a3      	bne.n	8007c30 <USB_HC_StartXfer+0x14>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007ce8:	eb00 104c 	add.w	r0, r0, ip, lsl #5
 8007cec:	4b2c      	ldr	r3, [pc, #176]	; (8007da0 <USB_HC_StartXfer+0x184>)
 8007cee:	f8c0 3510 	str.w	r3, [r0, #1296]	; 0x510
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 8007cf2:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8007cf6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007cfa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8007cfe:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
      return HAL_OK;
 8007d02:	e7d4      	b.n	8007cae <USB_HC_StartXfer+0x92>
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 8007d04:	9c01      	ldr	r4, [sp, #4]
 8007d06:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 8007d0a:	9401      	str	r4, [sp, #4]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007d0c:	9c01      	ldr	r4, [sp, #4]
 8007d0e:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8007d12:	9401      	str	r4, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 8007d14:	9c01      	ldr	r4, [sp, #4]
 8007d16:	601c      	str	r4, [r3, #0]
  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
 8007d18:	2d00      	cmp	r5, #0
 8007d1a:	d0c8      	beq.n	8007cae <USB_HC_StartXfer+0x92>
 8007d1c:	2a00      	cmp	r2, #0
 8007d1e:	d1c6      	bne.n	8007cae <USB_HC_StartXfer+0x92>
    switch (hc->ep_type)
 8007d20:	79cb      	ldrb	r3, [r1, #7]
 8007d22:	2b03      	cmp	r3, #3
 8007d24:	d818      	bhi.n	8007d58 <USB_HC_StartXfer+0x13c>
 8007d26:	e8df f003 	tbb	[pc, r3]
 8007d2a:	102a      	.short	0x102a
 8007d2c:	102a      	.short	0x102a
    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
 8007d2e:	79cb      	ldrb	r3, [r1, #7]
 8007d30:	f013 0ffd 	tst.w	r3, #253	; 0xfd
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 8007d34:	eb00 134c 	add.w	r3, r0, ip, lsl #5
 8007d38:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
 8007d3c:	f47f af7c 	bne.w	8007c38 <USB_HC_StartXfer+0x1c>
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 8007d40:	68dc      	ldr	r4, [r3, #12]
 8007d42:	f024 0470 	bic.w	r4, r4, #112	; 0x70
 8007d46:	60dc      	str	r4, [r3, #12]
 8007d48:	e776      	b.n	8007c38 <USB_HC_StartXfer+0x1c>
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8007d4a:	693a      	ldr	r2, [r7, #16]
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007d4c:	1ceb      	adds	r3, r5, #3
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8007d4e:	b292      	uxth	r2, r2
 8007d50:	f3c3 038f 	ubfx	r3, r3, #2, #16
 8007d54:	429a      	cmp	r2, r3
 8007d56:	d31e      	bcc.n	8007d96 <USB_HC_StartXfer+0x17a>
    count32b = ((uint32_t)len + 3U) / 4U;
 8007d58:	b2ab      	uxth	r3, r5
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 8007d5a:	68ca      	ldr	r2, [r1, #12]
    count32b = ((uint32_t)len + 3U) / 4U;
 8007d5c:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8007d5e:	089b      	lsrs	r3, r3, #2
 8007d60:	d0a5      	beq.n	8007cae <USB_HC_StartXfer+0x92>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8007d62:	eb00 300c 	add.w	r0, r0, ip, lsl #12
 8007d66:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8007d6a:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8007d6e:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
 8007d72:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8007d74:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8007d76:	d1fa      	bne.n	8007d6e <USB_HC_StartXfer+0x152>
}
 8007d78:	2000      	movs	r0, #0
 8007d7a:	b003      	add	sp, #12
 8007d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8007d7e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007d80:	1ceb      	adds	r3, r5, #3
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8007d82:	b292      	uxth	r2, r2
 8007d84:	f3c3 038f 	ubfx	r3, r3, #2, #16
 8007d88:	429a      	cmp	r2, r3
 8007d8a:	d2e5      	bcs.n	8007d58 <USB_HC_StartXfer+0x13c>
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8007d8c:	6983      	ldr	r3, [r0, #24]
 8007d8e:	f043 0320 	orr.w	r3, r3, #32
 8007d92:	6183      	str	r3, [r0, #24]
 8007d94:	e7e0      	b.n	8007d58 <USB_HC_StartXfer+0x13c>
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 8007d96:	6983      	ldr	r3, [r0, #24]
 8007d98:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8007d9c:	6183      	str	r3, [r0, #24]
 8007d9e:	e7db      	b.n	8007d58 <USB_HC_StartXfer+0x13c>
 8007da0:	80080000 	.word	0x80080000

08007da4 <USB_HC_ReadInterrupt>:
  return ((USBx_HOST->HAINT) & 0xFFFFU);
 8007da4:	f8d0 0414 	ldr.w	r0, [r0, #1044]	; 0x414
}
 8007da8:	b280      	uxth	r0, r0
 8007daa:	4770      	bx	lr

08007dac <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8007dac:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  __IO uint32_t count = 0U;
 8007db0:	2300      	movs	r3, #0
{
 8007db2:	b410      	push	{r4}
 8007db4:	b083      	sub	sp, #12
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8007db6:	f501 6ca0 	add.w	ip, r1, #1280	; 0x500
  __IO uint32_t count = 0U;
 8007dba:	9301      	str	r3, [sp, #4]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8007dbc:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 8007dc0:	f8d1 4500 	ldr.w	r4, [r1, #1280]	; 0x500
  if (((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) &&
 8007dc4:	6882      	ldr	r2, [r0, #8]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8007dc6:	0c9b      	lsrs	r3, r3, #18
  if (((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) &&
 8007dc8:	0692      	lsls	r2, r2, #26
 8007dca:	d501      	bpl.n	8007dd0 <USB_HC_Halt+0x24>
 8007dcc:	2c00      	cmp	r4, #0
 8007dce:	da25      	bge.n	8007e1c <USB_HC_Halt+0x70>
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8007dd0:	f013 0f01 	tst.w	r3, #1
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8007dd4:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8007dd8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8007ddc:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8007de0:	d021      	beq.n	8007e26 <USB_HC_Halt+0x7a>
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8007de2:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
 8007de6:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007dea:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8007dee:	d13a      	bne.n	8007e66 <USB_HC_Halt+0xba>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007df0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8007df4:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007df8:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8007dfc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007e00:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
 8007e04:	e003      	b.n	8007e0e <USB_HC_Halt+0x62>
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007e06:	f8dc 3000 	ldr.w	r3, [ip]
 8007e0a:	2b00      	cmp	r3, #0
 8007e0c:	da06      	bge.n	8007e1c <USB_HC_Halt+0x70>
        count++;
 8007e0e:	9b01      	ldr	r3, [sp, #4]
 8007e10:	3301      	adds	r3, #1
 8007e12:	9301      	str	r3, [sp, #4]
        if (count > 1000U)
 8007e14:	9b01      	ldr	r3, [sp, #4]
 8007e16:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8007e1a:	d9f4      	bls.n	8007e06 <USB_HC_Halt+0x5a>
}
 8007e1c:	2000      	movs	r0, #0
 8007e1e:	b003      	add	sp, #12
 8007e20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007e24:	4770      	bx	lr
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007e26:	6883      	ldr	r3, [r0, #8]
 8007e28:	069b      	lsls	r3, r3, #26
 8007e2a:	d4f7      	bmi.n	8007e1c <USB_HC_Halt+0x70>
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8007e2c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8007e2e:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007e32:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8007e36:	d116      	bne.n	8007e66 <USB_HC_Halt+0xba>
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007e38:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8007e3c:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007e40:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8007e44:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007e48:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
 8007e4c:	e003      	b.n	8007e56 <USB_HC_Halt+0xaa>
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007e4e:	f8dc 3000 	ldr.w	r3, [ip]
 8007e52:	2b00      	cmp	r3, #0
 8007e54:	dae2      	bge.n	8007e1c <USB_HC_Halt+0x70>
          count++;
 8007e56:	9b01      	ldr	r3, [sp, #4]
 8007e58:	3301      	adds	r3, #1
 8007e5a:	9301      	str	r3, [sp, #4]
          if (count > 1000U)
 8007e5c:	9b01      	ldr	r3, [sp, #4]
 8007e5e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8007e62:	d9f4      	bls.n	8007e4e <USB_HC_Halt+0xa2>
 8007e64:	e7da      	b.n	8007e1c <USB_HC_Halt+0x70>
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007e66:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
}
 8007e6a:	2000      	movs	r0, #0
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007e6c:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
 8007e70:	b003      	add	sp, #12
 8007e72:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007e76:	4770      	bx	lr

08007e78 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 8007e78:	b410      	push	{r4}
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t count = 0U;
 8007e7a:	2400      	movs	r4, #0
{
 8007e7c:	b085      	sub	sp, #20
    if (count > 200000U)
 8007e7e:	4a76      	ldr	r2, [pc, #472]	; (8008058 <USB_StopHost+0x1e0>)
{
 8007e80:	4601      	mov	r1, r0
  __IO uint32_t count = 0U;
 8007e82:	9401      	str	r4, [sp, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8007e84:	6883      	ldr	r3, [r0, #8]
 8007e86:	f023 0301 	bic.w	r3, r3, #1
 8007e8a:	6083      	str	r3, [r0, #8]
  __IO uint32_t count = 0U;
 8007e8c:	9402      	str	r4, [sp, #8]
 8007e8e:	e003      	b.n	8007e98 <USB_StopHost+0x20>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007e90:	690b      	ldr	r3, [r1, #16]
 8007e92:	2b00      	cmp	r3, #0
 8007e94:	f2c0 80bb 	blt.w	800800e <USB_StopHost+0x196>
    count++;
 8007e98:	9b02      	ldr	r3, [sp, #8]
 8007e9a:	3301      	adds	r3, #1
 8007e9c:	9302      	str	r3, [sp, #8]
    if (count > 200000U)
 8007e9e:	9b02      	ldr	r3, [sp, #8]
 8007ea0:	4293      	cmp	r3, r2
 8007ea2:	d9f5      	bls.n	8007e90 <USB_StopHost+0x18>
  (void)USB_DisableGlobalInt(USBx);

  /* Flush USB FIFO */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
  {
    ret = HAL_ERROR;
 8007ea4:	2001      	movs	r0, #1
  __IO uint32_t count = 0U;
 8007ea6:	2300      	movs	r3, #0
    if (count > 200000U)
 8007ea8:	4a6b      	ldr	r2, [pc, #428]	; (8008058 <USB_StopHost+0x1e0>)
  __IO uint32_t count = 0U;
 8007eaa:	9303      	str	r3, [sp, #12]
 8007eac:	e003      	b.n	8007eb6 <USB_StopHost+0x3e>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007eae:	690b      	ldr	r3, [r1, #16]
 8007eb0:	2b00      	cmp	r3, #0
 8007eb2:	f2c0 80bf 	blt.w	8008034 <USB_StopHost+0x1bc>
    count++;
 8007eb6:	9b03      	ldr	r3, [sp, #12]
 8007eb8:	3301      	adds	r3, #1
 8007eba:	9303      	str	r3, [sp, #12]
    if (count > 200000U)
 8007ebc:	9b03      	ldr	r3, [sp, #12]
 8007ebe:	4293      	cmp	r3, r2
 8007ec0:	d9f5      	bls.n	8007eae <USB_StopHost+0x36>
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
  {
    ret = HAL_ERROR;
 8007ec2:	2001      	movs	r0, #1
  }

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 8007ec4:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8007ec8:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007ecc:	f501 6ce0 	add.w	ip, r1, #1792	; 0x700
 8007ed0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007ed4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007ed8:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
 8007edc:	f8d1 3520 	ldr.w	r3, [r1, #1312]	; 0x520
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007ee0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007ee4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007ee8:	f8c1 3520 	str.w	r3, [r1, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
 8007eec:	f8d1 3540 	ldr.w	r3, [r1, #1344]	; 0x540
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007ef0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007ef4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007ef8:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
 8007efc:	f8d1 3560 	ldr.w	r3, [r1, #1376]	; 0x560
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f00:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f04:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f08:	f8c1 3560 	str.w	r3, [r1, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
 8007f0c:	f8d1 3580 	ldr.w	r3, [r1, #1408]	; 0x580
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f10:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f14:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f18:	f8c1 3580 	str.w	r3, [r1, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
 8007f1c:	f8d1 35a0 	ldr.w	r3, [r1, #1440]	; 0x5a0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f20:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f24:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f28:	f8c1 35a0 	str.w	r3, [r1, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
 8007f2c:	f8d1 35c0 	ldr.w	r3, [r1, #1472]	; 0x5c0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f30:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f34:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f38:	f8c1 35c0 	str.w	r3, [r1, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
 8007f3c:	f8d1 35e0 	ldr.w	r3, [r1, #1504]	; 0x5e0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f40:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f44:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f48:	f8c1 35e0 	str.w	r3, [r1, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
 8007f4c:	f8d1 3600 	ldr.w	r3, [r1, #1536]	; 0x600
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f50:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f54:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f58:	f8c1 3600 	str.w	r3, [r1, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
 8007f5c:	f8d1 3620 	ldr.w	r3, [r1, #1568]	; 0x620
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f60:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f64:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f68:	f8c1 3620 	str.w	r3, [r1, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
 8007f6c:	f8d1 3640 	ldr.w	r3, [r1, #1600]	; 0x640
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f70:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f74:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f78:	f8c1 3640 	str.w	r3, [r1, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
 8007f7c:	f8d1 3660 	ldr.w	r3, [r1, #1632]	; 0x660
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f80:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f84:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f88:	f8c1 3660 	str.w	r3, [r1, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
 8007f8c:	f8d1 3680 	ldr.w	r3, [r1, #1664]	; 0x680
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007f90:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007f94:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007f98:	f8c1 3680 	str.w	r3, [r1, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
 8007f9c:	f8d1 36a0 	ldr.w	r3, [r1, #1696]	; 0x6a0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007fa0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007fa4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007fa8:	f8c1 36a0 	str.w	r3, [r1, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
 8007fac:	f8d1 36c0 	ldr.w	r3, [r1, #1728]	; 0x6c0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007fb0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007fb4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007fb8:	f8c1 36c0 	str.w	r3, [r1, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
 8007fbc:	f8d1 36e0 	ldr.w	r3, [r1, #1760]	; 0x6e0
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007fc0:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 8007fc4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8007fc8:	f8c1 36e0 	str.w	r3, [r1, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 8007fcc:	6813      	ldr	r3, [r2, #0]
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007fce:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007fd2:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
 8007fd6:	6013      	str	r3, [r2, #0]
 8007fd8:	e002      	b.n	8007fe0 <USB_StopHost+0x168>

      if (count > 1000U)
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007fda:	6813      	ldr	r3, [r2, #0]
 8007fdc:	2b00      	cmp	r3, #0
 8007fde:	da06      	bge.n	8007fee <USB_StopHost+0x176>
      count++;
 8007fe0:	9b01      	ldr	r3, [sp, #4]
 8007fe2:	3301      	adds	r3, #1
 8007fe4:	9301      	str	r3, [sp, #4]
      if (count > 1000U)
 8007fe6:	9b01      	ldr	r3, [sp, #4]
 8007fe8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8007fec:	d9f5      	bls.n	8007fda <USB_StopHost+0x162>
  for (i = 0U; i <= 15U; i++)
 8007fee:	3220      	adds	r2, #32
 8007ff0:	4562      	cmp	r2, ip
 8007ff2:	d1eb      	bne.n	8007fcc <USB_StopHost+0x154>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 8007ff4:	f04f 33ff 	mov.w	r3, #4294967295
 8007ff8:	f8c1 3414 	str.w	r3, [r1, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
 8007ffc:	614b      	str	r3, [r1, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8007ffe:	688b      	ldr	r3, [r1, #8]
 8008000:	f043 0301 	orr.w	r3, r3, #1
 8008004:	608b      	str	r3, [r1, #8]

  (void)USB_EnableGlobalInt(USBx);

  return ret;
}
 8008006:	b005      	add	sp, #20
 8008008:	f85d 4b04 	ldr.w	r4, [sp], #4
 800800c:	4770      	bx	lr
  count = 0U;
 800800e:	2000      	movs	r0, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8008010:	f44f 6384 	mov.w	r3, #1056	; 0x420
    if (count > 200000U)
 8008014:	4a10      	ldr	r2, [pc, #64]	; (8008058 <USB_StopHost+0x1e0>)
  count = 0U;
 8008016:	9002      	str	r0, [sp, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8008018:	610b      	str	r3, [r1, #16]
 800801a:	e004      	b.n	8008026 <USB_StopHost+0x1ae>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800801c:	6908      	ldr	r0, [r1, #16]
 800801e:	f010 0020 	ands.w	r0, r0, #32
 8008022:	f43f af40 	beq.w	8007ea6 <USB_StopHost+0x2e>
    count++;
 8008026:	9b02      	ldr	r3, [sp, #8]
 8008028:	3301      	adds	r3, #1
 800802a:	9302      	str	r3, [sp, #8]
    if (count > 200000U)
 800802c:	9b02      	ldr	r3, [sp, #8]
 800802e:	4293      	cmp	r3, r2
 8008030:	d9f4      	bls.n	800801c <USB_StopHost+0x1a4>
 8008032:	e737      	b.n	8007ea4 <USB_StopHost+0x2c>
  count = 0U;
 8008034:	2400      	movs	r4, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8008036:	2310      	movs	r3, #16
    if (count > 200000U)
 8008038:	4a07      	ldr	r2, [pc, #28]	; (8008058 <USB_StopHost+0x1e0>)
  count = 0U;
 800803a:	9403      	str	r4, [sp, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800803c:	610b      	str	r3, [r1, #16]
 800803e:	e003      	b.n	8008048 <USB_StopHost+0x1d0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8008040:	690b      	ldr	r3, [r1, #16]
 8008042:	06db      	lsls	r3, r3, #27
 8008044:	f57f af3e 	bpl.w	8007ec4 <USB_StopHost+0x4c>
    count++;
 8008048:	9b03      	ldr	r3, [sp, #12]
 800804a:	3301      	adds	r3, #1
 800804c:	9303      	str	r3, [sp, #12]
    if (count > 200000U)
 800804e:	9b03      	ldr	r3, [sp, #12]
 8008050:	4293      	cmp	r3, r2
 8008052:	d9f5      	bls.n	8008040 <USB_StopHost+0x1c8>
 8008054:	e735      	b.n	8007ec2 <USB_StopHost+0x4a>
 8008056:	bf00      	nop
 8008058:	00030d40 	.word	0x00030d40

0800805c <USBH_MSC_SOFProcess>:
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phost);

  return USBH_OK;
}
 800805c:	2000      	movs	r0, #0
 800805e:	4770      	bx	lr

08008060 <USBH_MSC_Process>:
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008060:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
{
 8008064:	b570      	push	{r4, r5, r6, lr}
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008066:	69dd      	ldr	r5, [r3, #28]
  switch (MSC_Handle->state)
 8008068:	7b2b      	ldrb	r3, [r5, #12]
 800806a:	b12b      	cbz	r3, 8008078 <USBH_MSC_Process+0x18>
 800806c:	2b01      	cmp	r3, #1
 800806e:	d001      	beq.n	8008074 <USBH_MSC_Process+0x14>
  USBH_StatusTypeDef error = USBH_BUSY;
 8008070:	2001      	movs	r0, #1
}
 8008072:	bd70      	pop	{r4, r5, r6, pc}
  switch (MSC_Handle->state)
 8008074:	2000      	movs	r0, #0
}
 8008076:	bd70      	pop	{r4, r5, r6, pc}
      if (MSC_Handle->current_lun < MSC_Handle->max_lun)
 8008078:	f8b5 10f8 	ldrh.w	r1, [r5, #248]	; 0xf8
 800807c:	4604      	mov	r4, r0
 800807e:	782a      	ldrb	r2, [r5, #0]
 8008080:	428a      	cmp	r2, r1
 8008082:	d91f      	bls.n	80080c4 <USBH_MSC_Process+0x64>
        MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 8008084:	2334      	movs	r3, #52	; 0x34
 8008086:	2201      	movs	r2, #1
 8008088:	fb03 5301 	mla	r3, r3, r1, r5
 800808c:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
        switch (MSC_Handle->unit[MSC_Handle->current_lun].state)
 8008090:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008094:	2b08      	cmp	r3, #8
 8008096:	d8eb      	bhi.n	8008070 <USBH_MSC_Process+0x10>
 8008098:	a201      	add	r2, pc, #4	; (adr r2, 80080a0 <USBH_MSC_Process+0x40>)
 800809a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800809e:	bf00      	nop
 80080a0:	080081cd 	.word	0x080081cd
 80080a4:	08008071 	.word	0x08008071
 80080a8:	08008191 	.word	0x08008191
 80080ac:	08008159 	.word	0x08008159
 80080b0:	08008129 	.word	0x08008129
 80080b4:	080080e3 	.word	0x080080e3
 80080b8:	08008071 	.word	0x08008071
 80080bc:	08008071 	.word	0x08008071
 80080c0:	080080d9 	.word	0x080080d9
        MSC_Handle->state = MSC_IDLE;
 80080c4:	2601      	movs	r6, #1
        MSC_Handle->current_lun = 0U;
 80080c6:	f8a5 30f8 	strh.w	r3, [r5, #248]	; 0xf8
        phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 80080ca:	2102      	movs	r1, #2
        MSC_Handle->state = MSC_IDLE;
 80080cc:	732e      	strb	r6, [r5, #12]
        phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 80080ce:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 80080d2:	4798      	blx	r3
  USBH_StatusTypeDef error = USBH_BUSY;
 80080d4:	4630      	mov	r0, r6
}
 80080d6:	bd70      	pop	{r4, r5, r6, pc}
            MSC_Handle->current_lun++;
 80080d8:	3101      	adds	r1, #1
  USBH_StatusTypeDef error = USBH_BUSY;
 80080da:	2001      	movs	r0, #1
            MSC_Handle->current_lun++;
 80080dc:	f8a5 10f8 	strh.w	r1, [r5, #248]	; 0xf8
}
 80080e0:	bd70      	pop	{r4, r5, r6, pc}
            scsi_status = USBH_MSC_SCSI_RequestSense(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].sense);
 80080e2:	2634      	movs	r6, #52	; 0x34
 80080e4:	fb06 5201 	mla	r2, r6, r1, r5
 80080e8:	b2c9      	uxtb	r1, r1
 80080ea:	329c      	adds	r2, #156	; 0x9c
 80080ec:	f000 fdf6 	bl	8008cdc <USBH_MSC_SCSI_RequestSense>
            if (scsi_status == USBH_OK)
 80080f0:	2800      	cmp	r0, #0
 80080f2:	f040 8088 	bne.w	8008206 <USBH_MSC_Process+0x1a6>
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 80080f6:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 80080fa:	fb06 5603 	mla	r6, r6, r3, r5
 80080fe:	f896 109c 	ldrb.w	r1, [r6, #156]	; 0x9c
 8008102:	f001 02fb 	and.w	r2, r1, #251	; 0xfb
 8008106:	2a02      	cmp	r2, #2
 8008108:	f040 80a9 	bne.w	800825e <USBH_MSC_Process+0x1fe>
                if ((phost->Timer - MSC_Handle->timer) < 10000U)
 800810c:	f8d5 00fc 	ldr.w	r0, [r5, #252]	; 0xfc
 8008110:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
 8008114:	1a1b      	subs	r3, r3, r0
 8008116:	f242 700f 	movw	r0, #9999	; 0x270f
 800811a:	4283      	cmp	r3, r0
 800811c:	f200 809f 	bhi.w	800825e <USBH_MSC_Process+0x1fe>
  USBH_StatusTypeDef error = USBH_BUSY;
 8008120:	2001      	movs	r0, #1
                  MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 8008122:	f886 2090 	strb.w	r2, [r6, #144]	; 0x90
}
 8008126:	bd70      	pop	{r4, r5, r6, pc}
            scsi_status = USBH_MSC_SCSI_Inquiry(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].inquiry);
 8008128:	2634      	movs	r6, #52	; 0x34
 800812a:	fb06 5201 	mla	r2, r6, r1, r5
 800812e:	b2c9      	uxtb	r1, r1
 8008130:	329f      	adds	r2, #159	; 0x9f
 8008132:	f000 fd73 	bl	8008c1c <USBH_MSC_SCSI_Inquiry>
            if (scsi_status == USBH_OK)
 8008136:	2800      	cmp	r0, #0
 8008138:	f000 80bc 	beq.w	80082b4 <USBH_MSC_Process+0x254>
            else if (scsi_status == USBH_FAIL)
 800813c:	2802      	cmp	r0, #2
 800813e:	d059      	beq.n	80081f4 <USBH_MSC_Process+0x194>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 8008140:	2804      	cmp	r0, #4
 8008142:	d195      	bne.n	8008070 <USBH_MSC_Process+0x10>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 8008144:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008148:	f240 2201 	movw	r2, #513	; 0x201
  USBH_StatusTypeDef error = USBH_BUSY;
 800814c:	2001      	movs	r0, #1
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800814e:	fb06 5503 	mla	r5, r6, r3, r5
 8008152:	f8a5 2090 	strh.w	r2, [r5, #144]	; 0x90
}
 8008156:	bd70      	pop	{r4, r5, r6, pc}
            scsi_status = USBH_MSC_SCSI_ReadCapacity(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].capacity);
 8008158:	2634      	movs	r6, #52	; 0x34
 800815a:	fb06 5201 	mla	r2, r6, r1, r5
 800815e:	b2c9      	uxtb	r1, r1
 8008160:	3294      	adds	r2, #148	; 0x94
 8008162:	f000 fd21 	bl	8008ba8 <USBH_MSC_SCSI_ReadCapacity>
            if (scsi_status == USBH_OK)
 8008166:	2800      	cmp	r0, #0
 8008168:	d1e8      	bne.n	800813c <USBH_MSC_Process+0xdc>
              if (MSC_Handle->unit[MSC_Handle->current_lun].state_changed == 1U)
 800816a:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 800816e:	fb06 5203 	mla	r2, r6, r3, r5
 8008172:	f892 10c1 	ldrb.w	r1, [r2, #193]	; 0xc1
 8008176:	2901      	cmp	r1, #1
 8008178:	f000 80e4 	beq.w	8008344 <USBH_MSC_Process+0x2e4>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800817c:	2001      	movs	r0, #1
 800817e:	2134      	movs	r1, #52	; 0x34
              MSC_Handle->current_lun++;
 8008180:	181a      	adds	r2, r3, r0
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 8008182:	fb01 5303 	mla	r3, r1, r3, r5
 8008186:	f8a3 0090 	strh.w	r0, [r3, #144]	; 0x90
              MSC_Handle->current_lun++;
 800818a:	f8a5 20f8 	strh.w	r2, [r5, #248]	; 0xf8
}
 800818e:	bd70      	pop	{r4, r5, r6, pc}
            ready_status = USBH_MSC_SCSI_TestUnitReady(phost, (uint8_t)MSC_Handle->current_lun);
 8008190:	b2c9      	uxtb	r1, r1
 8008192:	f000 fce3 	bl	8008b5c <USBH_MSC_SCSI_TestUnitReady>
            if (ready_status == USBH_OK)
 8008196:	2800      	cmp	r0, #0
 8008198:	d146      	bne.n	8008228 <USBH_MSC_Process+0x1c8>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_OK)
 800819a:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 800819e:	2234      	movs	r2, #52	; 0x34
 80081a0:	fb02 5203 	mla	r2, r2, r3, r5
 80081a4:	f892 1092 	ldrb.w	r1, [r2, #146]	; 0x92
 80081a8:	2900      	cmp	r1, #0
 80081aa:	f040 80bf 	bne.w	800832c <USBH_MSC_Process+0x2cc>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 80081ae:	f882 10c1 	strb.w	r1, [r2, #193]	; 0xc1
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_CAPACITY10;
 80081b2:	2134      	movs	r1, #52	; 0x34
 80081b4:	2003      	movs	r0, #3
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_OK;
 80081b6:	2200      	movs	r2, #0
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80081b8:	fb01 f303 	mul.w	r3, r1, r3
 80081bc:	f103 0190 	add.w	r1, r3, #144	; 0x90
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 80081c0:	442b      	add	r3, r5
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80081c2:	5268      	strh	r0, [r5, r1]
  USBH_StatusTypeDef error = USBH_BUSY;
 80081c4:	2001      	movs	r0, #1
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 80081c6:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
}
 80081ca:	bd70      	pop	{r4, r5, r6, pc}
            USBH_UsrLog("LUN #%d: ", MSC_Handle->current_lun);
 80081cc:	4871      	ldr	r0, [pc, #452]	; (8008394 <USBH_MSC_Process+0x334>)
 80081ce:	f018 f883 	bl	80202d8 <iprintf>
 80081d2:	200a      	movs	r0, #10
 80081d4:	f018 f898 	bl	8020308 <putchar>
            MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_INQUIRY;
 80081d8:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 80081dc:	2134      	movs	r1, #52	; 0x34
 80081de:	2204      	movs	r2, #4
  USBH_StatusTypeDef error = USBH_BUSY;
 80081e0:	2001      	movs	r0, #1
            MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_INQUIRY;
 80081e2:	fb01 5303 	mla	r3, r1, r3, r5
 80081e6:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
            MSC_Handle->timer = phost->Timer;
 80081ea:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
 80081ee:	f8c5 30fc 	str.w	r3, [r5, #252]	; 0xfc
}
 80081f2:	bd70      	pop	{r4, r5, r6, pc}
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80081f4:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 80081f8:	2205      	movs	r2, #5
  USBH_StatusTypeDef error = USBH_BUSY;
 80081fa:	2001      	movs	r0, #1
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80081fc:	fb06 5503 	mla	r5, r6, r3, r5
 8008200:	f885 2090 	strb.w	r2, [r5, #144]	; 0x90
}
 8008204:	bd70      	pop	{r4, r5, r6, pc}
            if (scsi_status == USBH_FAIL)
 8008206:	2802      	cmp	r0, #2
 8008208:	d19a      	bne.n	8008140 <USBH_MSC_Process+0xe0>
              USBH_UsrLog("MSC Device NOT ready");
 800820a:	4863      	ldr	r0, [pc, #396]	; (8008398 <USBH_MSC_Process+0x338>)
 800820c:	f018 f864 	bl	80202d8 <iprintf>
 8008210:	200a      	movs	r0, #10
 8008212:	f018 f879 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_UNRECOVERED_ERROR;
 8008216:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 800821a:	2208      	movs	r2, #8
  USBH_StatusTypeDef error = USBH_BUSY;
 800821c:	2001      	movs	r0, #1
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_UNRECOVERED_ERROR;
 800821e:	fb06 5503 	mla	r5, r6, r3, r5
 8008222:	f885 2090 	strb.w	r2, [r5, #144]	; 0x90
}
 8008226:	bd70      	pop	{r4, r5, r6, pc}
            if (ready_status == USBH_FAIL)
 8008228:	2802      	cmp	r0, #2
 800822a:	d16d      	bne.n	8008308 <USBH_MSC_Process+0x2a8>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_FAIL)
 800822c:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008230:	2234      	movs	r2, #52	; 0x34
 8008232:	fb02 5203 	mla	r2, r2, r3, r5
 8008236:	f892 1092 	ldrb.w	r1, [r2, #146]	; 0x92
 800823a:	2902      	cmp	r1, #2
 800823c:	d072      	beq.n	8008324 <USBH_MSC_Process+0x2c4>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800823e:	2301      	movs	r3, #1
                USBH_UsrLog("MSC Device NOT ready");
 8008240:	4855      	ldr	r0, [pc, #340]	; (8008398 <USBH_MSC_Process+0x338>)
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 8008242:	f882 30c1 	strb.w	r3, [r2, #193]	; 0xc1
                USBH_UsrLog("MSC Device NOT ready");
 8008246:	f018 f847 	bl	80202d8 <iprintf>
 800824a:	200a      	movs	r0, #10
 800824c:	f018 f85c 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 8008250:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008254:	2134      	movs	r1, #52	; 0x34
 8008256:	f240 1005 	movw	r0, #261	; 0x105
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 800825a:	2202      	movs	r2, #2
 800825c:	e7ac      	b.n	80081b8 <USBH_MSC_Process+0x158>
              USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[MSC_Handle->current_lun].sense.key);
 800825e:	484f      	ldr	r0, [pc, #316]	; (800839c <USBH_MSC_Process+0x33c>)
              USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[MSC_Handle->current_lun].sense.asc);
 8008260:	2434      	movs	r4, #52	; 0x34
              USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[MSC_Handle->current_lun].sense.key);
 8008262:	f018 f839 	bl	80202d8 <iprintf>
 8008266:	200a      	movs	r0, #10
 8008268:	f018 f84e 	bl	8020308 <putchar>
              USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[MSC_Handle->current_lun].sense.asc);
 800826c:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008270:	484b      	ldr	r0, [pc, #300]	; (80083a0 <USBH_MSC_Process+0x340>)
 8008272:	fb04 5303 	mla	r3, r4, r3, r5
 8008276:	f893 109d 	ldrb.w	r1, [r3, #157]	; 0x9d
 800827a:	f018 f82d 	bl	80202d8 <iprintf>
 800827e:	200a      	movs	r0, #10
 8008280:	f018 f842 	bl	8020308 <putchar>
              USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[MSC_Handle->current_lun].sense.ascq);
 8008284:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008288:	4846      	ldr	r0, [pc, #280]	; (80083a4 <USBH_MSC_Process+0x344>)
 800828a:	fb04 5303 	mla	r3, r4, r3, r5
 800828e:	f893 109e 	ldrb.w	r1, [r3, #158]	; 0x9e
 8008292:	f018 f821 	bl	80202d8 <iprintf>
 8008296:	200a      	movs	r0, #10
 8008298:	f018 f836 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800829c:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 80082a0:	2201      	movs	r2, #1
 80082a2:	fb04 5403 	mla	r4, r4, r3, r5
              MSC_Handle->current_lun++;
 80082a6:	4413      	add	r3, r2
  USBH_StatusTypeDef error = USBH_BUSY;
 80082a8:	4610      	mov	r0, r2
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 80082aa:	f884 2090 	strb.w	r2, [r4, #144]	; 0x90
              MSC_Handle->current_lun++;
 80082ae:	f8a5 30f8 	strh.w	r3, [r5, #248]	; 0xf8
}
 80082b2:	bd70      	pop	{r4, r5, r6, pc}
              USBH_UsrLog("Inquiry Vendor  : %s", MSC_Handle->unit[MSC_Handle->current_lun].inquiry.vendor_id);
 80082b4:	f8b5 10f8 	ldrh.w	r1, [r5, #248]	; 0xf8
 80082b8:	483b      	ldr	r0, [pc, #236]	; (80083a8 <USBH_MSC_Process+0x348>)
 80082ba:	fb06 5101 	mla	r1, r6, r1, r5
 80082be:	31a2      	adds	r1, #162	; 0xa2
 80082c0:	f018 f80a 	bl	80202d8 <iprintf>
 80082c4:	200a      	movs	r0, #10
 80082c6:	f018 f81f 	bl	8020308 <putchar>
              USBH_UsrLog("Inquiry Product : %s", MSC_Handle->unit[MSC_Handle->current_lun].inquiry.product_id);
 80082ca:	f8b5 10f8 	ldrh.w	r1, [r5, #248]	; 0xf8
 80082ce:	4837      	ldr	r0, [pc, #220]	; (80083ac <USBH_MSC_Process+0x34c>)
 80082d0:	fb06 5101 	mla	r1, r6, r1, r5
 80082d4:	31ab      	adds	r1, #171	; 0xab
 80082d6:	f017 ffff 	bl	80202d8 <iprintf>
 80082da:	200a      	movs	r0, #10
 80082dc:	f018 f814 	bl	8020308 <putchar>
              USBH_UsrLog("Inquiry Version : %s", MSC_Handle->unit[MSC_Handle->current_lun].inquiry.revision_id);
 80082e0:	f8b5 10f8 	ldrh.w	r1, [r5, #248]	; 0xf8
 80082e4:	4832      	ldr	r0, [pc, #200]	; (80083b0 <USBH_MSC_Process+0x350>)
 80082e6:	fb06 5101 	mla	r1, r6, r1, r5
 80082ea:	31bc      	adds	r1, #188	; 0xbc
 80082ec:	f017 fff4 	bl	80202d8 <iprintf>
 80082f0:	200a      	movs	r0, #10
 80082f2:	f018 f809 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 80082f6:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 80082fa:	2202      	movs	r2, #2
  USBH_StatusTypeDef error = USBH_BUSY;
 80082fc:	2001      	movs	r0, #1
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 80082fe:	fb06 5503 	mla	r5, r6, r3, r5
 8008302:	f885 2090 	strb.w	r2, [r5, #144]	; 0x90
}
 8008306:	bd70      	pop	{r4, r5, r6, pc}
              if (ready_status == USBH_UNRECOVERED_ERROR)
 8008308:	2804      	cmp	r0, #4
 800830a:	f47f aeb1 	bne.w	8008070 <USBH_MSC_Process+0x10>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800830e:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008312:	2134      	movs	r1, #52	; 0x34
 8008314:	f240 2201 	movw	r2, #513	; 0x201
  USBH_StatusTypeDef error = USBH_BUSY;
 8008318:	2001      	movs	r0, #1
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800831a:	fb01 5503 	mla	r5, r1, r3, r5
 800831e:	f8a5 2090 	strh.w	r2, [r5, #144]	; 0x90
}
 8008322:	bd70      	pop	{r4, r5, r6, pc}
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 8008324:	2100      	movs	r1, #0
 8008326:	f882 10c1 	strb.w	r1, [r2, #193]	; 0xc1
 800832a:	e793      	b.n	8008254 <USBH_MSC_Process+0x1f4>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800832c:	2301      	movs	r3, #1
                USBH_UsrLog("MSC Device ready");
 800832e:	4821      	ldr	r0, [pc, #132]	; (80083b4 <USBH_MSC_Process+0x354>)
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 8008330:	f882 30c1 	strb.w	r3, [r2, #193]	; 0xc1
                USBH_UsrLog("MSC Device ready");
 8008334:	f017 ffd0 	bl	80202d8 <iprintf>
 8008338:	200a      	movs	r0, #10
 800833a:	f017 ffe5 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_CAPACITY10;
 800833e:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008342:	e736      	b.n	80081b2 <USBH_MSC_Process+0x152>
                USBH_UsrLog("MSC Device capacity : %u Bytes", \
 8008344:	f8b2 3098 	ldrh.w	r3, [r2, #152]	; 0x98
 8008348:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
 800834c:	481a      	ldr	r0, [pc, #104]	; (80083b8 <USBH_MSC_Process+0x358>)
 800834e:	fb03 f101 	mul.w	r1, r3, r1
 8008352:	f017 ffc1 	bl	80202d8 <iprintf>
 8008356:	200a      	movs	r0, #10
 8008358:	f017 ffd6 	bl	8020308 <putchar>
                USBH_UsrLog("Block number : %u", (unsigned int)(MSC_Handle->unit[MSC_Handle->current_lun].capacity.block_nbr));
 800835c:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008360:	4816      	ldr	r0, [pc, #88]	; (80083bc <USBH_MSC_Process+0x35c>)
 8008362:	fb06 5303 	mla	r3, r6, r3, r5
 8008366:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 800836a:	f017 ffb5 	bl	80202d8 <iprintf>
 800836e:	200a      	movs	r0, #10
 8008370:	f017 ffca 	bl	8020308 <putchar>
                USBH_UsrLog("Block Size   : %u", (unsigned int)(MSC_Handle->unit[MSC_Handle->current_lun].capacity.block_size));
 8008374:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008378:	4811      	ldr	r0, [pc, #68]	; (80083c0 <USBH_MSC_Process+0x360>)
 800837a:	fb06 5603 	mla	r6, r6, r3, r5
 800837e:	f8b6 1098 	ldrh.w	r1, [r6, #152]	; 0x98
 8008382:	f017 ffa9 	bl	80202d8 <iprintf>
 8008386:	200a      	movs	r0, #10
 8008388:	f017 ffbe 	bl	8020308 <putchar>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800838c:	f8b5 30f8 	ldrh.w	r3, [r5, #248]	; 0xf8
 8008390:	e6f4      	b.n	800817c <USBH_MSC_Process+0x11c>
 8008392:	bf00      	nop
 8008394:	0802184c 	.word	0x0802184c
 8008398:	080218b4 	.word	0x080218b4
 800839c:	08021914 	.word	0x08021914
 80083a0:	08021924 	.word	0x08021924
 80083a4:	08021940 	.word	0x08021940
 80083a8:	08021858 	.word	0x08021858
 80083ac:	08021870 	.word	0x08021870
 80083b0:	08021888 	.word	0x08021888
 80083b4:	080218a0 	.word	0x080218a0
 80083b8:	080218cc 	.word	0x080218cc
 80083bc:	080218ec 	.word	0x080218ec
 80083c0:	08021900 	.word	0x08021900

080083c4 <USBH_MSC_ClassRequest>:
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80083c4:	f8d0 247c 	ldr.w	r2, [r0, #1148]	; 0x47c
{
 80083c8:	4603      	mov	r3, r0
 80083ca:	b510      	push	{r4, lr}
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80083cc:	69d4      	ldr	r4, [r2, #28]
  switch (MSC_Handle->req_state)
 80083ce:	7ba2      	ldrb	r2, [r4, #14]
 80083d0:	2a02      	cmp	r2, #2
 80083d2:	d004      	beq.n	80083de <USBH_MSC_ClassRequest+0x1a>
 80083d4:	2a03      	cmp	r2, #3
 80083d6:	d026      	beq.n	8008426 <USBH_MSC_ClassRequest+0x62>
 80083d8:	b10a      	cbz	r2, 80083de <USBH_MSC_ClassRequest+0x1a>
  USBH_StatusTypeDef status = USBH_BUSY;
 80083da:	2001      	movs	r0, #1
}
 80083dc:	bd10      	pop	{r4, pc}
      status = USBH_MSC_BOT_REQ_GetMaxLUN(phost, &MSC_Handle->max_lun);
 80083de:	4621      	mov	r1, r4
 80083e0:	4618      	mov	r0, r3
 80083e2:	f000 fa8b 	bl	80088fc <USBH_MSC_BOT_REQ_GetMaxLUN>
      if (status == USBH_NOT_SUPPORTED)
 80083e6:	2803      	cmp	r0, #3
 80083e8:	d026      	beq.n	8008438 <USBH_MSC_ClassRequest+0x74>
      if (status == USBH_OK)
 80083ea:	2800      	cmp	r0, #0
 80083ec:	d1f6      	bne.n	80083dc <USBH_MSC_ClassRequest+0x18>
        MSC_Handle->max_lun = (MSC_Handle->max_lun > MAX_SUPPORTED_LUN) ? MAX_SUPPORTED_LUN : (MSC_Handle->max_lun + 1U);
 80083ee:	7823      	ldrb	r3, [r4, #0]
 80083f0:	2b02      	cmp	r3, #2
 80083f2:	d924      	bls.n	800843e <USBH_MSC_ClassRequest+0x7a>
 80083f4:	2102      	movs	r1, #2
 80083f6:	460b      	mov	r3, r1
 80083f8:	7023      	strb	r3, [r4, #0]
        USBH_UsrLog("Number of supported LUN: %d", MSC_Handle->max_lun);
 80083fa:	4813      	ldr	r0, [pc, #76]	; (8008448 <USBH_MSC_ClassRequest+0x84>)
 80083fc:	f017 ff6c 	bl	80202d8 <iprintf>
 8008400:	200a      	movs	r0, #10
 8008402:	f017 ff81 	bl	8020308 <putchar>
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 8008406:	7823      	ldrb	r3, [r4, #0]
 8008408:	b15b      	cbz	r3, 8008422 <USBH_MSC_ClassRequest+0x5e>
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 800840a:	2102      	movs	r1, #2
          MSC_Handle->unit[i].state_changed = 0U;
 800840c:	2200      	movs	r2, #0
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800840e:	2b01      	cmp	r3, #1
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 8008410:	f884 1092 	strb.w	r1, [r4, #146]	; 0x92
          MSC_Handle->unit[i].state_changed = 0U;
 8008414:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 8008418:	d003      	beq.n	8008422 <USBH_MSC_ClassRequest+0x5e>
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 800841a:	f884 10c6 	strb.w	r1, [r4, #198]	; 0xc6
          MSC_Handle->unit[i].state_changed = 0U;
 800841e:	f884 20f5 	strb.w	r2, [r4, #245]	; 0xf5
  USBH_StatusTypeDef status = USBH_BUSY;
 8008422:	2000      	movs	r0, #0
}
 8008424:	bd10      	pop	{r4, pc}
      if (USBH_ClrFeature(phost, 0x00U) == USBH_OK)
 8008426:	2100      	movs	r1, #0
 8008428:	f001 ff20 	bl	800a26c <USBH_ClrFeature>
 800842c:	2800      	cmp	r0, #0
 800842e:	d1d4      	bne.n	80083da <USBH_MSC_ClassRequest+0x16>
        MSC_Handle->req_state = MSC_Handle->prev_req_state;
 8008430:	7be3      	ldrb	r3, [r4, #15]
  USBH_StatusTypeDef status = USBH_BUSY;
 8008432:	2001      	movs	r0, #1
        MSC_Handle->req_state = MSC_Handle->prev_req_state;
 8008434:	73a3      	strb	r3, [r4, #14]
}
 8008436:	bd10      	pop	{r4, pc}
 8008438:	2101      	movs	r1, #1
 800843a:	460b      	mov	r3, r1
 800843c:	e7dc      	b.n	80083f8 <USBH_MSC_ClassRequest+0x34>
        MSC_Handle->max_lun = (MSC_Handle->max_lun > MAX_SUPPORTED_LUN) ? MAX_SUPPORTED_LUN : (MSC_Handle->max_lun + 1U);
 800843e:	3301      	adds	r3, #1
 8008440:	b2db      	uxtb	r3, r3
        USBH_UsrLog("Number of supported LUN: %d", MSC_Handle->max_lun);
 8008442:	4619      	mov	r1, r3
 8008444:	e7d8      	b.n	80083f8 <USBH_MSC_ClassRequest+0x34>
 8008446:	bf00      	nop
 8008448:	08021964 	.word	0x08021964

0800844c <USBH_MSC_InterfaceDeInit>:
{
 800844c:	b538      	push	{r3, r4, r5, lr}
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800844e:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
{
 8008452:	4604      	mov	r4, r0
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008454:	69dd      	ldr	r5, [r3, #28]
  if ((MSC_Handle->OutPipe) != 0U)
 8008456:	7969      	ldrb	r1, [r5, #5]
 8008458:	b951      	cbnz	r1, 8008470 <USBH_MSC_InterfaceDeInit+0x24>
  if ((MSC_Handle->InPipe != 0U))
 800845a:	7929      	ldrb	r1, [r5, #4]
 800845c:	b991      	cbnz	r1, 8008484 <USBH_MSC_InterfaceDeInit+0x38>
    USBH_free(phost->pActiveClass->pData);
 800845e:	4628      	mov	r0, r5
 8008460:	f017 fe0c 	bl	802007c <free>
    phost->pActiveClass->pData = 0U;
 8008464:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 8008468:	2200      	movs	r2, #0
}
 800846a:	2000      	movs	r0, #0
    phost->pActiveClass->pData = 0U;
 800846c:	61da      	str	r2, [r3, #28]
}
 800846e:	bd38      	pop	{r3, r4, r5, pc}
    (void)USBH_ClosePipe(phost, MSC_Handle->OutPipe);
 8008470:	f002 f93a 	bl	800a6e8 <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->OutPipe);
 8008474:	7969      	ldrb	r1, [r5, #5]
 8008476:	4620      	mov	r0, r4
 8008478:	f002 f98a 	bl	800a790 <USBH_FreePipe>
    MSC_Handle->OutPipe = 0U;     /* Reset the Channel as Free */
 800847c:	2300      	movs	r3, #0
  if ((MSC_Handle->InPipe != 0U))
 800847e:	7929      	ldrb	r1, [r5, #4]
    MSC_Handle->OutPipe = 0U;     /* Reset the Channel as Free */
 8008480:	716b      	strb	r3, [r5, #5]
  if ((MSC_Handle->InPipe != 0U))
 8008482:	b141      	cbz	r1, 8008496 <USBH_MSC_InterfaceDeInit+0x4a>
    (void)USBH_ClosePipe(phost, MSC_Handle->InPipe);
 8008484:	4620      	mov	r0, r4
 8008486:	f002 f92f 	bl	800a6e8 <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->InPipe);
 800848a:	7929      	ldrb	r1, [r5, #4]
 800848c:	4620      	mov	r0, r4
 800848e:	f002 f97f 	bl	800a790 <USBH_FreePipe>
    MSC_Handle->InPipe = 0U;     /* Reset the Channel as Free */
 8008492:	2300      	movs	r3, #0
 8008494:	712b      	strb	r3, [r5, #4]
  if ((phost->pActiveClass->pData) != NULL)
 8008496:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 800849a:	69dd      	ldr	r5, [r3, #28]
 800849c:	2d00      	cmp	r5, #0
 800849e:	d1de      	bne.n	800845e <USBH_MSC_InterfaceDeInit+0x12>
}
 80084a0:	2000      	movs	r0, #0
 80084a2:	bd38      	pop	{r3, r4, r5, pc}

080084a4 <USBH_MSC_InterfaceInit>:
  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 80084a4:	f8d0 147c 	ldr.w	r1, [r0, #1148]	; 0x47c
 80084a8:	2350      	movs	r3, #80	; 0x50
 80084aa:	2206      	movs	r2, #6
{
 80084ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80084b0:	b084      	sub	sp, #16
  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 80084b2:	7909      	ldrb	r1, [r1, #4]
{
 80084b4:	4604      	mov	r4, r0
  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 80084b6:	f000 fda5 	bl	8009004 <USBH_FindInterface>
  if ((interface == 0xFFU) || (interface >= USBH_MAX_NUM_INTERFACES)) /* Not Valid Interface */
 80084ba:	2801      	cmp	r0, #1
 80084bc:	d868      	bhi.n	8008590 <USBH_MSC_InterfaceInit+0xec>
  status = USBH_SelectInterface(phost, interface);
 80084be:	4601      	mov	r1, r0
 80084c0:	4605      	mov	r5, r0
 80084c2:	4620      	mov	r0, r4
 80084c4:	f000 fd5a 	bl	8008f7c <USBH_SelectInterface>
  if (status != USBH_OK)
 80084c8:	4607      	mov	r7, r0
 80084ca:	2800      	cmp	r0, #0
 80084cc:	d160      	bne.n	8008590 <USBH_MSC_InterfaceInit+0xec>
  phost->pActiveClass->pData = (MSC_HandleTypeDef *)USBH_malloc(sizeof(MSC_HandleTypeDef));
 80084ce:	f8d4 847c 	ldr.w	r8, [r4, #1148]	; 0x47c
 80084d2:	f44f 7080 	mov.w	r0, #256	; 0x100
 80084d6:	f017 fdc9 	bl	802006c <malloc>
 80084da:	4606      	mov	r6, r0
 80084dc:	f8c8 001c 	str.w	r0, [r8, #28]
  if (MSC_Handle == NULL)
 80084e0:	2800      	cmp	r0, #0
 80084e2:	d055      	beq.n	8008590 <USBH_MSC_InterfaceInit+0xec>
  (void)USBH_memset(MSC_Handle, 0, sizeof(MSC_HandleTypeDef));
 80084e4:	f44f 7280 	mov.w	r2, #256	; 0x100
 80084e8:	4639      	mov	r1, r7
 80084ea:	f017 fdf7 	bl	80200dc <memset>
  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress & 0x80U) != 0U)
 80084ee:	231a      	movs	r3, #26
 80084f0:	fb03 4305 	mla	r3, r3, r5, r4
 80084f4:	f993 244e 	ldrsb.w	r2, [r3, #1102]	; 0x44e
 80084f8:	f893 144e 	ldrb.w	r1, [r3, #1102]	; 0x44e
 80084fc:	2a00      	cmp	r2, #0
 80084fe:	db55      	blt.n	80085ac <USBH_MSC_InterfaceInit+0x108>
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 8008500:	f8b3 3450 	ldrh.w	r3, [r3, #1104]	; 0x450
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 8008504:	71b1      	strb	r1, [r6, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 8008506:	8133      	strh	r3, [r6, #8]
  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress & 0x80U) != 0U)
 8008508:	201a      	movs	r0, #26
 800850a:	fb00 4505 	mla	r5, r0, r5, r4
 800850e:	f995 3456 	ldrsb.w	r3, [r5, #1110]	; 0x456
 8008512:	f895 1456 	ldrb.w	r1, [r5, #1110]	; 0x456
 8008516:	2b00      	cmp	r3, #0
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 8008518:	f8b5 3458 	ldrh.w	r3, [r5, #1112]	; 0x458
  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress & 0x80U) != 0U)
 800851c:	db42      	blt.n	80085a4 <USBH_MSC_InterfaceInit+0x100>
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 800851e:	71b1      	strb	r1, [r6, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 8008520:	8133      	strh	r3, [r6, #8]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 8008522:	4620      	mov	r0, r4
 8008524:	f002 f8e6 	bl	800a6f4 <USBH_AllocPipe>
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 8008528:	79f1      	ldrb	r1, [r6, #7]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 800852a:	7170      	strb	r0, [r6, #5]
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 800852c:	4620      	mov	r0, r4
 800852e:	f002 f8e1 	bl	800a6f4 <USBH_AllocPipe>
 8008532:	4603      	mov	r3, r0
  (void)USBH_MSC_BOT_Init(phost);
 8008534:	4620      	mov	r0, r4
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 8008536:	7133      	strb	r3, [r6, #4]
  (void)USBH_MSC_BOT_Init(phost);
 8008538:	f000 f9ec 	bl	8008914 <USBH_MSC_BOT_Init>
  if ((MSC_Handle->OutEp != 0U) && (MSC_Handle->OutEpSize != 0U))
 800853c:	79b2      	ldrb	r2, [r6, #6]
 800853e:	b362      	cbz	r2, 800859a <USBH_MSC_InterfaceInit+0xf6>
 8008540:	8933      	ldrh	r3, [r6, #8]
 8008542:	b353      	cbz	r3, 800859a <USBH_MSC_InterfaceInit+0xf6>
    (void)USBH_OpenPipe(phost, MSC_Handle->OutPipe, MSC_Handle->OutEp,
 8008544:	2502      	movs	r5, #2
 8008546:	9302      	str	r3, [sp, #8]
 8008548:	7971      	ldrb	r1, [r6, #5]
 800854a:	4620      	mov	r0, r4
 800854c:	9501      	str	r5, [sp, #4]
 800854e:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
 8008552:	9300      	str	r3, [sp, #0]
 8008554:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 8008558:	f002 f8b6 	bl	800a6c8 <USBH_OpenPipe>
  if ((MSC_Handle->InEp != 0U) && (MSC_Handle->InEpSize != 0U))
 800855c:	79f2      	ldrb	r2, [r6, #7]
 800855e:	b1e2      	cbz	r2, 800859a <USBH_MSC_InterfaceInit+0xf6>
 8008560:	8973      	ldrh	r3, [r6, #10]
 8008562:	b1d3      	cbz	r3, 800859a <USBH_MSC_InterfaceInit+0xf6>
    (void)USBH_OpenPipe(phost, MSC_Handle->InPipe, MSC_Handle->InEp,
 8008564:	7931      	ldrb	r1, [r6, #4]
 8008566:	4620      	mov	r0, r4
 8008568:	e9cd 5301 	strd	r5, r3, [sp, #4]
 800856c:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
 8008570:	9300      	str	r3, [sp, #0]
 8008572:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 8008576:	f002 f8a7 	bl	800a6c8 <USBH_OpenPipe>
  (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 800857a:	7931      	ldrb	r1, [r6, #4]
 800857c:	2200      	movs	r2, #0
 800857e:	4620      	mov	r0, r4
 8008580:	f016 fb82 	bl	801ec88 <USBH_LL_SetToggle>
  (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 0U);
 8008584:	2200      	movs	r2, #0
 8008586:	7971      	ldrb	r1, [r6, #5]
 8008588:	4620      	mov	r0, r4
 800858a:	f016 fb7d 	bl	801ec88 <USBH_LL_SetToggle>
  return USBH_OK;
 800858e:	e000      	b.n	8008592 <USBH_MSC_InterfaceInit+0xee>
    return USBH_FAIL;
 8008590:	2702      	movs	r7, #2
}
 8008592:	4638      	mov	r0, r7
 8008594:	b004      	add	sp, #16
 8008596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return USBH_NOT_SUPPORTED;
 800859a:	2703      	movs	r7, #3
}
 800859c:	4638      	mov	r0, r7
 800859e:	b004      	add	sp, #16
 80085a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 80085a4:	71f1      	strb	r1, [r6, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 80085a6:	8173      	strh	r3, [r6, #10]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 80085a8:	79b1      	ldrb	r1, [r6, #6]
 80085aa:	e7ba      	b.n	8008522 <USBH_MSC_InterfaceInit+0x7e>
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 80085ac:	f8b3 3450 	ldrh.w	r3, [r3, #1104]	; 0x450
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 80085b0:	71f1      	strb	r1, [r6, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 80085b2:	8173      	strh	r3, [r6, #10]
 80085b4:	e7a8      	b.n	8008508 <USBH_MSC_InterfaceInit+0x64>
 80085b6:	bf00      	nop

080085b8 <USBH_MSC_UnitIsReady>:
uint8_t USBH_MSC_UnitIsReady(USBH_HandleTypeDef *phost, uint8_t lun)
{
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
  uint8_t res;

  if ((phost->gState == HOST_CLASS) && (MSC_Handle->unit[lun].error == MSC_OK))
 80085b8:	7803      	ldrb	r3, [r0, #0]
 80085ba:	2b0b      	cmp	r3, #11
 80085bc:	d001      	beq.n	80085c2 <USBH_MSC_UnitIsReady+0xa>
  {
    res = 1U;
  }
  else
  {
    res = 0U;
 80085be:	2000      	movs	r0, #0
  }

  return res;
}
 80085c0:	4770      	bx	lr
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80085c2:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
  if ((phost->gState == HOST_CLASS) && (MSC_Handle->unit[lun].error == MSC_OK))
 80085c6:	2234      	movs	r2, #52	; 0x34
 80085c8:	69db      	ldr	r3, [r3, #28]
 80085ca:	fb02 3101 	mla	r1, r2, r1, r3
 80085ce:	f891 0091 	ldrb.w	r0, [r1, #145]	; 0x91
    res = 0U;
 80085d2:	fab0 f080 	clz	r0, r0
 80085d6:	0940      	lsrs	r0, r0, #5
 80085d8:	4770      	bx	lr
 80085da:	bf00      	nop

080085dc <USBH_MSC_GetLUNInfo>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_GetLUNInfo(USBH_HandleTypeDef *phost, uint8_t lun, MSC_LUNTypeDef *info)
{
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
  if (phost->gState == HOST_CLASS)
 80085dc:	7803      	ldrb	r3, [r0, #0]
 80085de:	2b0b      	cmp	r3, #11
 80085e0:	d001      	beq.n	80085e6 <USBH_MSC_GetLUNInfo+0xa>
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
    return USBH_OK;
  }
  else
  {
    return USBH_FAIL;
 80085e2:	2002      	movs	r0, #2
  }
}
 80085e4:	4770      	bx	lr
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80085e6:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 80085ea:	2034      	movs	r0, #52	; 0x34
{
 80085ec:	b510      	push	{r4, lr}
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 80085ee:	2490      	movs	r4, #144	; 0x90
 80085f0:	69db      	ldr	r3, [r3, #28]
 80085f2:	fb10 4101 	smlabb	r1, r0, r1, r4
 80085f6:	4419      	add	r1, r3
 80085f8:	f101 0430 	add.w	r4, r1, #48	; 0x30
 80085fc:	f8d1 e000 	ldr.w	lr, [r1]
 8008600:	3110      	adds	r1, #16
 8008602:	f851 cc0c 	ldr.w	ip, [r1, #-12]
 8008606:	3210      	adds	r2, #16
 8008608:	f851 0c08 	ldr.w	r0, [r1, #-8]
 800860c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8008610:	42a1      	cmp	r1, r4
 8008612:	f842 ec10 	str.w	lr, [r2, #-16]
 8008616:	f842 cc0c 	str.w	ip, [r2, #-12]
 800861a:	f842 0c08 	str.w	r0, [r2, #-8]
 800861e:	f842 3c04 	str.w	r3, [r2, #-4]
 8008622:	d1eb      	bne.n	80085fc <USBH_MSC_GetLUNInfo+0x20>
 8008624:	680b      	ldr	r3, [r1, #0]
    return USBH_OK;
 8008626:	2000      	movs	r0, #0
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 8008628:	6013      	str	r3, [r2, #0]
}
 800862a:	bd10      	pop	{r4, pc}

0800862c <USBH_MSC_Read>:
USBH_StatusTypeDef USBH_MSC_Read(USBH_HandleTypeDef *phost,
                                 uint8_t lun,
                                 uint32_t address,
                                 uint8_t *pbuf,
                                 uint32_t length)
{
 800862c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;

  if ((phost->device.is_connected == 0U) ||
 8008630:	f890 5420 	ldrb.w	r5, [r0, #1056]	; 0x420
{
 8008634:	b085      	sub	sp, #20
  if ((phost->device.is_connected == 0U) ||
 8008636:	b195      	cbz	r5, 800865e <USBH_MSC_Read+0x32>
      (phost->gState != HOST_CLASS) ||
 8008638:	7805      	ldrb	r5, [r0, #0]
 800863a:	4604      	mov	r4, r0
  if ((phost->device.is_connected == 0U) ||
 800863c:	2d0b      	cmp	r5, #11
 800863e:	d10e      	bne.n	800865e <USBH_MSC_Read+0x32>
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008640:	f8d0 547c 	ldr.w	r5, [r0, #1148]	; 0x47c
 8008644:	460e      	mov	r6, r1
 8008646:	f8d5 b01c 	ldr.w	fp, [r5, #28]
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800864a:	2534      	movs	r5, #52	; 0x34
 800864c:	fb05 f801 	mul.w	r8, r5, r1
 8008650:	eb0b 0708 	add.w	r7, fp, r8
      (phost->gState != HOST_CLASS) ||
 8008654:	f897 c090 	ldrb.w	ip, [r7, #144]	; 0x90
 8008658:	f1bc 0f01 	cmp.w	ip, #1
 800865c:	d003      	beq.n	8008666 <USBH_MSC_Read+0x3a>
  {
    return  USBH_FAIL;
 800865e:	2002      	movs	r0, #2
    }
  }
  MSC_Handle->state = MSC_IDLE;

  return USBH_OK;
}
 8008660:	b005      	add	sp, #20
 8008662:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  MSC_Handle->state = MSC_READ;
 8008666:	f04f 0c06 	mov.w	ip, #6
 800866a:	f88b c00c 	strb.w	ip, [fp, #12]
  MSC_Handle->unit[lun].state = MSC_READ;
 800866e:	f887 c090 	strb.w	ip, [r7, #144]	; 0x90
  (void)USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 8008672:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  MSC_Handle->rw_lun = lun;
 8008674:	f8ab 10fa 	strh.w	r1, [fp, #250]	; 0xfa
  (void)USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 8008678:	9700      	str	r7, [sp, #0]
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800867a:	f242 7710 	movw	r7, #10000	; 0x2710
  (void)USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 800867e:	f000 fbb1 	bl	8008de4 <USBH_MSC_SCSI_Read>
  timeout = phost->Timer;
 8008682:	239c      	movs	r3, #156	; 0x9c
 8008684:	f8d4 a4c4 	ldr.w	sl, [r4, #1220]	; 0x4c4
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 8008688:	fb15 3306 	smlabb	r3, r5, r6, r3
 800868c:	9303      	str	r3, [sp, #12]
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800868e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008690:	fb03 f707 	mul.w	r7, r3, r7
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 8008694:	e00b      	b.n	80086ae <USBH_MSC_Read+0x82>
  switch (MSC_Handle->unit[lun].state)
 8008696:	2a05      	cmp	r2, #5
 8008698:	d037      	beq.n	800870a <USBH_MSC_Read+0xde>
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800869a:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
 800869e:	eba3 030a 	sub.w	r3, r3, sl
 80086a2:	42bb      	cmp	r3, r7
 80086a4:	d866      	bhi.n	8008774 <USBH_MSC_Read+0x148>
 80086a6:	f894 3420 	ldrb.w	r3, [r4, #1056]	; 0x420
 80086aa:	2b00      	cmp	r3, #0
 80086ac:	d062      	beq.n	8008774 <USBH_MSC_Read+0x148>
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80086ae:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 80086b2:	69db      	ldr	r3, [r3, #28]
  switch (MSC_Handle->unit[lun].state)
 80086b4:	eb03 0508 	add.w	r5, r3, r8
 80086b8:	f895 2090 	ldrb.w	r2, [r5, #144]	; 0x90
 80086bc:	f105 0990 	add.w	r9, r5, #144	; 0x90
 80086c0:	2a06      	cmp	r2, #6
 80086c2:	d011      	beq.n	80086e8 <USBH_MSC_Read+0xbc>
 80086c4:	2a07      	cmp	r2, #7
 80086c6:	d1e6      	bne.n	8008696 <USBH_MSC_Read+0x6a>
      scsi_status = USBH_MSC_SCSI_Write(phost, lun, 0U, NULL, 0U);
 80086c8:	2300      	movs	r3, #0
 80086ca:	4631      	mov	r1, r6
 80086cc:	4620      	mov	r0, r4
 80086ce:	461a      	mov	r2, r3
 80086d0:	9300      	str	r3, [sp, #0]
 80086d2:	f000 fb43 	bl	8008d5c <USBH_MSC_SCSI_Write>
      if (scsi_status == USBH_OK)
 80086d6:	b980      	cbnz	r0, 80086fa <USBH_MSC_Read+0xce>
        MSC_Handle->unit[lun].state = MSC_IDLE;
 80086d8:	2301      	movs	r3, #1
 80086da:	f889 3000 	strb.w	r3, [r9]
  MSC_Handle->state = MSC_IDLE;
 80086de:	2301      	movs	r3, #1
  return USBH_OK;
 80086e0:	2000      	movs	r0, #0
  MSC_Handle->state = MSC_IDLE;
 80086e2:	f88b 300c 	strb.w	r3, [fp, #12]
  return USBH_OK;
 80086e6:	e7bb      	b.n	8008660 <USBH_MSC_Read+0x34>
      scsi_status = USBH_MSC_SCSI_Read(phost, lun, 0U, NULL, 0U);
 80086e8:	2300      	movs	r3, #0
 80086ea:	4631      	mov	r1, r6
 80086ec:	4620      	mov	r0, r4
 80086ee:	461a      	mov	r2, r3
 80086f0:	9300      	str	r3, [sp, #0]
 80086f2:	f000 fb77 	bl	8008de4 <USBH_MSC_SCSI_Read>
      if (scsi_status == USBH_OK)
 80086f6:	2800      	cmp	r0, #0
 80086f8:	d0ee      	beq.n	80086d8 <USBH_MSC_Read+0xac>
      else if (scsi_status == USBH_FAIL)
 80086fa:	2802      	cmp	r0, #2
 80086fc:	d016      	beq.n	800872c <USBH_MSC_Read+0x100>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 80086fe:	2804      	cmp	r0, #4
 8008700:	d1cb      	bne.n	800869a <USBH_MSC_Read+0x6e>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 8008702:	2308      	movs	r3, #8
 8008704:	f889 3000 	strb.w	r3, [r9]
  return error;
 8008708:	e7e9      	b.n	80086de <USBH_MSC_Read+0xb2>
      scsi_status = USBH_MSC_SCSI_RequestSense(phost, lun, &MSC_Handle->unit[lun].sense);
 800870a:	9a03      	ldr	r2, [sp, #12]
 800870c:	4631      	mov	r1, r6
 800870e:	4620      	mov	r0, r4
 8008710:	9302      	str	r3, [sp, #8]
 8008712:	189a      	adds	r2, r3, r2
 8008714:	f000 fae2 	bl	8008cdc <USBH_MSC_SCSI_RequestSense>
      if (scsi_status == USBH_OK)
 8008718:	b160      	cbz	r0, 8008734 <USBH_MSC_Read+0x108>
      if (scsi_status == USBH_FAIL)
 800871a:	2802      	cmp	r0, #2
 800871c:	d1ef      	bne.n	80086fe <USBH_MSC_Read+0xd2>
        USBH_UsrLog("MSC Device NOT ready");
 800871e:	4819      	ldr	r0, [pc, #100]	; (8008784 <USBH_MSC_Read+0x158>)
 8008720:	f017 fdda 	bl	80202d8 <iprintf>
 8008724:	200a      	movs	r0, #10
 8008726:	f017 fdef 	bl	8020308 <putchar>
  return error;
 800872a:	e7b6      	b.n	800869a <USBH_MSC_Read+0x6e>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800872c:	2305      	movs	r3, #5
 800872e:	f885 3090 	strb.w	r3, [r5, #144]	; 0x90
  return error;
 8008732:	e7b2      	b.n	800869a <USBH_MSC_Read+0x6e>
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
 8008734:	f895 109c 	ldrb.w	r1, [r5, #156]	; 0x9c
        MSC_Handle->unit[lun].state = MSC_IDLE;
 8008738:	f108 0890 	add.w	r8, r8, #144	; 0x90
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
 800873c:	4812      	ldr	r0, [pc, #72]	; (8008788 <USBH_MSC_Read+0x15c>)
 800873e:	f017 fdcb 	bl	80202d8 <iprintf>
 8008742:	200a      	movs	r0, #10
 8008744:	f017 fde0 	bl	8020308 <putchar>
        USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[lun].sense.asc);
 8008748:	f895 109d 	ldrb.w	r1, [r5, #157]	; 0x9d
 800874c:	480f      	ldr	r0, [pc, #60]	; (800878c <USBH_MSC_Read+0x160>)
 800874e:	f017 fdc3 	bl	80202d8 <iprintf>
 8008752:	200a      	movs	r0, #10
 8008754:	f017 fdd8 	bl	8020308 <putchar>
        USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[lun].sense.ascq);
 8008758:	f895 109e 	ldrb.w	r1, [r5, #158]	; 0x9e
 800875c:	480c      	ldr	r0, [pc, #48]	; (8008790 <USBH_MSC_Read+0x164>)
 800875e:	f017 fdbb 	bl	80202d8 <iprintf>
 8008762:	200a      	movs	r0, #10
 8008764:	f017 fdd0 	bl	8020308 <putchar>
        MSC_Handle->unit[lun].state = MSC_IDLE;
 8008768:	f240 2201 	movw	r2, #513	; 0x201
 800876c:	9b02      	ldr	r3, [sp, #8]
 800876e:	f823 2008 	strh.w	r2, [r3, r8]
  return error;
 8008772:	e7b4      	b.n	80086de <USBH_MSC_Read+0xb2>
      MSC_Handle->state = MSC_IDLE;
 8008774:	2301      	movs	r3, #1
      return USBH_FAIL;
 8008776:	2002      	movs	r0, #2
      MSC_Handle->state = MSC_IDLE;
 8008778:	f88b 300c 	strb.w	r3, [fp, #12]
}
 800877c:	b005      	add	sp, #20
 800877e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008782:	bf00      	nop
 8008784:	080218b4 	.word	0x080218b4
 8008788:	08021914 	.word	0x08021914
 800878c:	08021924 	.word	0x08021924
 8008790:	08021940 	.word	0x08021940

08008794 <USBH_MSC_Write>:
USBH_StatusTypeDef USBH_MSC_Write(USBH_HandleTypeDef *phost,
                                  uint8_t lun,
                                  uint32_t address,
                                  uint8_t *pbuf,
                                  uint32_t length)
{
 8008794:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;

  if ((phost->device.is_connected == 0U) ||
 8008798:	f890 5420 	ldrb.w	r5, [r0, #1056]	; 0x420
{
 800879c:	b085      	sub	sp, #20
  if ((phost->device.is_connected == 0U) ||
 800879e:	b195      	cbz	r5, 80087c6 <USBH_MSC_Write+0x32>
      (phost->gState != HOST_CLASS) ||
 80087a0:	7805      	ldrb	r5, [r0, #0]
 80087a2:	4604      	mov	r4, r0
  if ((phost->device.is_connected == 0U) ||
 80087a4:	2d0b      	cmp	r5, #11
 80087a6:	d10e      	bne.n	80087c6 <USBH_MSC_Write+0x32>
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80087a8:	f8d0 547c 	ldr.w	r5, [r0, #1148]	; 0x47c
 80087ac:	460e      	mov	r6, r1
 80087ae:	f8d5 b01c 	ldr.w	fp, [r5, #28]
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 80087b2:	2534      	movs	r5, #52	; 0x34
 80087b4:	fb05 f801 	mul.w	r8, r5, r1
 80087b8:	eb0b 0708 	add.w	r7, fp, r8
      (phost->gState != HOST_CLASS) ||
 80087bc:	f897 c090 	ldrb.w	ip, [r7, #144]	; 0x90
 80087c0:	f1bc 0f01 	cmp.w	ip, #1
 80087c4:	d003      	beq.n	80087ce <USBH_MSC_Write+0x3a>
  {
    return  USBH_FAIL;
 80087c6:	2002      	movs	r0, #2
      return USBH_FAIL;
    }
  }
  MSC_Handle->state = MSC_IDLE;
  return USBH_OK;
}
 80087c8:	b005      	add	sp, #20
 80087ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  MSC_Handle->state = MSC_WRITE;
 80087ce:	f04f 0c07 	mov.w	ip, #7
 80087d2:	f88b c00c 	strb.w	ip, [fp, #12]
  MSC_Handle->unit[lun].state = MSC_WRITE;
 80087d6:	f887 c090 	strb.w	ip, [r7, #144]	; 0x90
  (void)USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 80087da:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  MSC_Handle->rw_lun = lun;
 80087dc:	f8ab 10fa 	strh.w	r1, [fp, #250]	; 0xfa
  (void)USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 80087e0:	9700      	str	r7, [sp, #0]
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 80087e2:	f242 7710 	movw	r7, #10000	; 0x2710
  (void)USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 80087e6:	f000 fab9 	bl	8008d5c <USBH_MSC_SCSI_Write>
  timeout = phost->Timer;
 80087ea:	239c      	movs	r3, #156	; 0x9c
 80087ec:	f8d4 a4c4 	ldr.w	sl, [r4, #1220]	; 0x4c4
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 80087f0:	fb15 3306 	smlabb	r3, r5, r6, r3
 80087f4:	9303      	str	r3, [sp, #12]
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 80087f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80087f8:	fb03 f707 	mul.w	r7, r3, r7
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 80087fc:	e00b      	b.n	8008816 <USBH_MSC_Write+0x82>
  switch (MSC_Handle->unit[lun].state)
 80087fe:	2a05      	cmp	r2, #5
 8008800:	d037      	beq.n	8008872 <USBH_MSC_Write+0xde>
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 8008802:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
 8008806:	eba3 030a 	sub.w	r3, r3, sl
 800880a:	42bb      	cmp	r3, r7
 800880c:	d866      	bhi.n	80088dc <USBH_MSC_Write+0x148>
 800880e:	f894 3420 	ldrb.w	r3, [r4, #1056]	; 0x420
 8008812:	2b00      	cmp	r3, #0
 8008814:	d062      	beq.n	80088dc <USBH_MSC_Write+0x148>
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008816:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 800881a:	69db      	ldr	r3, [r3, #28]
  switch (MSC_Handle->unit[lun].state)
 800881c:	eb03 0508 	add.w	r5, r3, r8
 8008820:	f895 2090 	ldrb.w	r2, [r5, #144]	; 0x90
 8008824:	f105 0990 	add.w	r9, r5, #144	; 0x90
 8008828:	2a06      	cmp	r2, #6
 800882a:	d011      	beq.n	8008850 <USBH_MSC_Write+0xbc>
 800882c:	2a07      	cmp	r2, #7
 800882e:	d1e6      	bne.n	80087fe <USBH_MSC_Write+0x6a>
      scsi_status = USBH_MSC_SCSI_Write(phost, lun, 0U, NULL, 0U);
 8008830:	2300      	movs	r3, #0
 8008832:	4631      	mov	r1, r6
 8008834:	4620      	mov	r0, r4
 8008836:	461a      	mov	r2, r3
 8008838:	9300      	str	r3, [sp, #0]
 800883a:	f000 fa8f 	bl	8008d5c <USBH_MSC_SCSI_Write>
      if (scsi_status == USBH_OK)
 800883e:	b980      	cbnz	r0, 8008862 <USBH_MSC_Write+0xce>
        MSC_Handle->unit[lun].state = MSC_IDLE;
 8008840:	2301      	movs	r3, #1
 8008842:	f889 3000 	strb.w	r3, [r9]
  MSC_Handle->state = MSC_IDLE;
 8008846:	2301      	movs	r3, #1
  return USBH_OK;
 8008848:	2000      	movs	r0, #0
  MSC_Handle->state = MSC_IDLE;
 800884a:	f88b 300c 	strb.w	r3, [fp, #12]
  return USBH_OK;
 800884e:	e7bb      	b.n	80087c8 <USBH_MSC_Write+0x34>
      scsi_status = USBH_MSC_SCSI_Read(phost, lun, 0U, NULL, 0U);
 8008850:	2300      	movs	r3, #0
 8008852:	4631      	mov	r1, r6
 8008854:	4620      	mov	r0, r4
 8008856:	461a      	mov	r2, r3
 8008858:	9300      	str	r3, [sp, #0]
 800885a:	f000 fac3 	bl	8008de4 <USBH_MSC_SCSI_Read>
      if (scsi_status == USBH_OK)
 800885e:	2800      	cmp	r0, #0
 8008860:	d0ee      	beq.n	8008840 <USBH_MSC_Write+0xac>
      else if (scsi_status == USBH_FAIL)
 8008862:	2802      	cmp	r0, #2
 8008864:	d016      	beq.n	8008894 <USBH_MSC_Write+0x100>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 8008866:	2804      	cmp	r0, #4
 8008868:	d1cb      	bne.n	8008802 <USBH_MSC_Write+0x6e>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800886a:	2308      	movs	r3, #8
 800886c:	f889 3000 	strb.w	r3, [r9]
  return error;
 8008870:	e7e9      	b.n	8008846 <USBH_MSC_Write+0xb2>
      scsi_status = USBH_MSC_SCSI_RequestSense(phost, lun, &MSC_Handle->unit[lun].sense);
 8008872:	9a03      	ldr	r2, [sp, #12]
 8008874:	4631      	mov	r1, r6
 8008876:	4620      	mov	r0, r4
 8008878:	9302      	str	r3, [sp, #8]
 800887a:	189a      	adds	r2, r3, r2
 800887c:	f000 fa2e 	bl	8008cdc <USBH_MSC_SCSI_RequestSense>
      if (scsi_status == USBH_OK)
 8008880:	b160      	cbz	r0, 800889c <USBH_MSC_Write+0x108>
      if (scsi_status == USBH_FAIL)
 8008882:	2802      	cmp	r0, #2
 8008884:	d1ef      	bne.n	8008866 <USBH_MSC_Write+0xd2>
        USBH_UsrLog("MSC Device NOT ready");
 8008886:	4819      	ldr	r0, [pc, #100]	; (80088ec <USBH_MSC_Write+0x158>)
 8008888:	f017 fd26 	bl	80202d8 <iprintf>
 800888c:	200a      	movs	r0, #10
 800888e:	f017 fd3b 	bl	8020308 <putchar>
  return error;
 8008892:	e7b6      	b.n	8008802 <USBH_MSC_Write+0x6e>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 8008894:	2305      	movs	r3, #5
 8008896:	f885 3090 	strb.w	r3, [r5, #144]	; 0x90
  return error;
 800889a:	e7b2      	b.n	8008802 <USBH_MSC_Write+0x6e>
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
 800889c:	f895 109c 	ldrb.w	r1, [r5, #156]	; 0x9c
        MSC_Handle->unit[lun].state = MSC_IDLE;
 80088a0:	f108 0890 	add.w	r8, r8, #144	; 0x90
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
 80088a4:	4812      	ldr	r0, [pc, #72]	; (80088f0 <USBH_MSC_Write+0x15c>)
 80088a6:	f017 fd17 	bl	80202d8 <iprintf>
 80088aa:	200a      	movs	r0, #10
 80088ac:	f017 fd2c 	bl	8020308 <putchar>
        USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[lun].sense.asc);
 80088b0:	f895 109d 	ldrb.w	r1, [r5, #157]	; 0x9d
 80088b4:	480f      	ldr	r0, [pc, #60]	; (80088f4 <USBH_MSC_Write+0x160>)
 80088b6:	f017 fd0f 	bl	80202d8 <iprintf>
 80088ba:	200a      	movs	r0, #10
 80088bc:	f017 fd24 	bl	8020308 <putchar>
        USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[lun].sense.ascq);
 80088c0:	f895 109e 	ldrb.w	r1, [r5, #158]	; 0x9e
 80088c4:	480c      	ldr	r0, [pc, #48]	; (80088f8 <USBH_MSC_Write+0x164>)
 80088c6:	f017 fd07 	bl	80202d8 <iprintf>
 80088ca:	200a      	movs	r0, #10
 80088cc:	f017 fd1c 	bl	8020308 <putchar>
        MSC_Handle->unit[lun].state = MSC_IDLE;
 80088d0:	f240 2201 	movw	r2, #513	; 0x201
 80088d4:	9b02      	ldr	r3, [sp, #8]
 80088d6:	f823 2008 	strh.w	r2, [r3, r8]
  return error;
 80088da:	e7b4      	b.n	8008846 <USBH_MSC_Write+0xb2>
      MSC_Handle->state = MSC_IDLE;
 80088dc:	2301      	movs	r3, #1
      return USBH_FAIL;
 80088de:	2002      	movs	r0, #2
      MSC_Handle->state = MSC_IDLE;
 80088e0:	f88b 300c 	strb.w	r3, [fp, #12]
}
 80088e4:	b005      	add	sp, #20
 80088e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80088ea:	bf00      	nop
 80088ec:	080218b4 	.word	0x080218b4
 80088f0:	08021914 	.word	0x08021914
 80088f4:	08021924 	.word	0x08021924
 80088f8:	08021940 	.word	0x08021940

080088fc <USBH_MSC_BOT_REQ_GetMaxLUN>:
  * @param  phost: Host handle
  * @param  Maxlun: pointer to Maxlun variable
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
{
 80088fc:	b410      	push	{r4}
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
  phost->Control.setup.b.wValue.w = 0U;
 80088fe:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS
 8008902:	f64f 64a1 	movw	r4, #65185	; 0xfea1
  phost->Control.setup.b.wValue.w = 0U;
 8008906:	e9c0 4204 	strd	r4, r2, [r0, #16]
  phost->Control.setup.b.wIndex.w = 0U;
  phost->Control.setup.b.wLength.w = 1U;

  return USBH_CtlReq(phost, Maxlun, 1U);
 800890a:	2201      	movs	r2, #1
}
 800890c:	f85d 4b04 	ldr.w	r4, [sp], #4
  return USBH_CtlReq(phost, Maxlun, 1U);
 8008910:	f001 bd94 	b.w	800a43c <USBH_CtlReq>

08008914 <USBH_MSC_BOT_Init>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
{

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008914:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c

  MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
  MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008918:	2201      	movs	r2, #1
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
 800891a:	4907      	ldr	r1, [pc, #28]	; (8008938 <USBH_MSC_BOT_Init+0x24>)
  MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;

  return USBH_OK;
}
 800891c:	2000      	movs	r0, #0
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800891e:	69db      	ldr	r3, [r3, #28]
{
 8008920:	b410      	push	{r4}
  MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
 8008922:	4c06      	ldr	r4, [pc, #24]	; (800893c <USBH_MSC_BOT_Init+0x28>)
  MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008924:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 8008928:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
 800892c:	e9c3 4115 	strd	r4, r1, [r3, #84]	; 0x54
}
 8008930:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008934:	4770      	bx	lr
 8008936:	bf00      	nop
 8008938:	20304050 	.word	0x20304050
 800893c:	43425355 	.word	0x43425355

08008940 <USBH_MSC_BOT_Process>:
{
  USBH_StatusTypeDef   status = USBH_BUSY;
  USBH_StatusTypeDef   error  = USBH_BUSY;
  BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008940:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
{
 8008944:	b570      	push	{r4, r5, r6, lr}
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008946:	69de      	ldr	r6, [r3, #28]
{
 8008948:	b082      	sub	sp, #8
 800894a:	4605      	mov	r5, r0
  uint8_t toggle = 0U;

  switch (MSC_Handle->hbot.state)
 800894c:	f896 4050 	ldrb.w	r4, [r6, #80]	; 0x50
 8008950:	1e63      	subs	r3, r4, #1
 8008952:	2b0a      	cmp	r3, #10
 8008954:	d830      	bhi.n	80089b8 <USBH_MSC_BOT_Process+0x78>
 8008956:	e8df f003 	tbb	[pc, r3]
 800895a:	2414      	.short	0x2414
 800895c:	766a8333 	.word	0x766a8333
 8008960:	6156493e 	.word	0x6156493e
 8008964:	06          	.byte	0x06
 8008965:	00          	.byte	0x00
  phost->Control.setup.b.wValue.w = 0U;
 8008966:	2200      	movs	r2, #0
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS
 8008968:	f64f 7321 	movw	r3, #65313	; 0xff21
  return USBH_CtlReq(phost, NULL, 0U);
 800896c:	4611      	mov	r1, r2
  phost->Control.setup.b.wValue.w = 0U;
 800896e:	e9c0 3204 	strd	r3, r2, [r0, #16]
  return USBH_CtlReq(phost, NULL, 0U);
 8008972:	f001 fd63 	bl	800a43c <USBH_CtlReq>
      break;


    case BOT_UNRECOVERED_ERROR:
      status = USBH_MSC_BOT_REQ_Reset(phost);
      if (status == USBH_OK)
 8008976:	4604      	mov	r4, r0
 8008978:	b980      	cbnz	r0, 800899c <USBH_MSC_BOT_Process+0x5c>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800897a:	2301      	movs	r3, #1
 800897c:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008980:	e00c      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;
 8008982:	2202      	movs	r2, #2
      MSC_Handle->hbot.cbw.field.LUN = lun;
 8008984:	f886 1061 	strb.w	r1, [r6, #97]	; 0x61
      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.cbw.data,
 8008988:	7973      	ldrb	r3, [r6, #5]
 800898a:	f106 0154 	add.w	r1, r6, #84	; 0x54
      MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;
 800898e:	f886 2050 	strb.w	r2, [r6, #80]	; 0x50
      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.cbw.data,
 8008992:	2201      	movs	r2, #1
 8008994:	9200      	str	r2, [sp, #0]
 8008996:	221f      	movs	r2, #31
 8008998:	f001 fe6c 	bl	800a674 <USBH_BulkSendData>

    default:
      break;
  }
  return status;
}
 800899c:	4620      	mov	r0, r4
 800899e:	b002      	add	sp, #8
 80089a0:	bd70      	pop	{r4, r5, r6, pc}
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 80089a2:	7971      	ldrb	r1, [r6, #5]
 80089a4:	f016 f96a 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80089a8:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 80089aa:	4604      	mov	r4, r0
      if (URB_Status == USBH_URB_DONE)
 80089ac:	f000 809a 	beq.w	8008ae4 <USBH_MSC_BOT_Process+0x1a4>
      else if (URB_Status == USBH_URB_NOTREADY)
 80089b0:	2802      	cmp	r0, #2
 80089b2:	d068      	beq.n	8008a86 <USBH_MSC_BOT_Process+0x146>
      else if (URB_Status == USBH_URB_STALL)
 80089b4:	2c05      	cmp	r4, #5
 80089b6:	d061      	beq.n	8008a7c <USBH_MSC_BOT_Process+0x13c>
  switch (MSC_Handle->hbot.state)
 80089b8:	2401      	movs	r4, #1
}
 80089ba:	4620      	mov	r0, r4
 80089bc:	b002      	add	sp, #8
 80089be:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 80089c0:	7933      	ldrb	r3, [r6, #4]
  USBH_StatusTypeDef   status = USBH_BUSY;
 80089c2:	2401      	movs	r4, #1
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 80089c4:	8972      	ldrh	r2, [r6, #10]
 80089c6:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 80089ca:	f001 fe6d 	bl	800a6a8 <USBH_BulkReceiveData>
      MSC_Handle->hbot.state = BOT_DATA_IN_WAIT;
 80089ce:	2304      	movs	r3, #4
 80089d0:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
      break;
 80089d4:	e7e2      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.csw.data,
 80089d6:	7933      	ldrb	r3, [r6, #4]
 80089d8:	220d      	movs	r2, #13
 80089da:	f106 0178 	add.w	r1, r6, #120	; 0x78
  USBH_StatusTypeDef   status = USBH_BUSY;
 80089de:	2401      	movs	r4, #1
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.csw.data,
 80089e0:	f001 fe62 	bl	800a6a8 <USBH_BulkReceiveData>
      MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
 80089e4:	2308      	movs	r3, #8
 80089e6:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
      break;
 80089ea:	e7d7      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 80089ec:	7931      	ldrb	r1, [r6, #4]
 80089ee:	f016 f945 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80089f2:	2801      	cmp	r0, #1
 80089f4:	f000 8093 	beq.w	8008b1e <USBH_MSC_BOT_Process+0x1de>
      else if (URB_Status == USBH_URB_STALL)
 80089f8:	2805      	cmp	r0, #5
 80089fa:	d1dd      	bne.n	80089b8 <USBH_MSC_BOT_Process+0x78>
        MSC_Handle->hbot.state = BOT_ERROR_IN;
 80089fc:	2309      	movs	r3, #9
  USBH_StatusTypeDef   status = USBH_BUSY;
 80089fe:	2401      	movs	r4, #1
        MSC_Handle->hbot.state = BOT_ERROR_IN;
 8008a00:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a04:	e7ca      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>

  switch (dir)
  {
    case BOT_DIR_IN :
      /* send ClrFeture on Bulk IN endpoint */
      status = USBH_ClrFeature(phost, MSC_Handle->InEp);
 8008a06:	79f1      	ldrb	r1, [r6, #7]
 8008a08:	f001 fc30 	bl	800a26c <USBH_ClrFeature>
      if (error == USBH_OK)
 8008a0c:	b388      	cbz	r0, 8008a72 <USBH_MSC_BOT_Process+0x132>
      else if (error == USBH_UNRECOVERED_ERROR)
 8008a0e:	2804      	cmp	r0, #4
 8008a10:	d1d2      	bne.n	80089b8 <USBH_MSC_BOT_Process+0x78>
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 8008a12:	230b      	movs	r3, #11
  USBH_StatusTypeDef   status = USBH_BUSY;
 8008a14:	2401      	movs	r4, #1
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 8008a16:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a1a:	e7bf      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>

      break;

    case BOT_DIR_OUT :
      /*send ClrFeature on Bulk OUT endpoint */
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
 8008a1c:	79b1      	ldrb	r1, [r6, #6]
 8008a1e:	f001 fc25 	bl	800a26c <USBH_ClrFeature>
      if (error == USBH_OK)
 8008a22:	4604      	mov	r4, r0
 8008a24:	2800      	cmp	r0, #0
 8008a26:	d069      	beq.n	8008afc <USBH_MSC_BOT_Process+0x1bc>
        if (error == USBH_UNRECOVERED_ERROR)
 8008a28:	2804      	cmp	r0, #4
 8008a2a:	d1c5      	bne.n	80089b8 <USBH_MSC_BOT_Process+0x78>
 8008a2c:	e7f1      	b.n	8008a12 <USBH_MSC_BOT_Process+0xd2>
      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 8008a2e:	2401      	movs	r4, #1
 8008a30:	7973      	ldrb	r3, [r6, #5]
 8008a32:	8932      	ldrh	r2, [r6, #8]
 8008a34:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 8008a38:	9400      	str	r4, [sp, #0]
 8008a3a:	f001 fe1b 	bl	800a674 <USBH_BulkSendData>
      MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
 8008a3e:	2306      	movs	r3, #6
 8008a40:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
      break;
 8008a44:	e7aa      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 8008a46:	7971      	ldrb	r1, [r6, #5]
 8008a48:	f016 f918 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8008a4c:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 8008a4e:	4604      	mov	r4, r0
      if (URB_Status == USBH_URB_DONE)
 8008a50:	d01e      	beq.n	8008a90 <USBH_MSC_BOT_Process+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 8008a52:	2802      	cmp	r0, #2
 8008a54:	d1ae      	bne.n	80089b4 <USBH_MSC_BOT_Process+0x74>
        MSC_Handle->hbot.state  = BOT_DATA_OUT;
 8008a56:	2305      	movs	r3, #5
  USBH_StatusTypeDef   status = USBH_BUSY;
 8008a58:	2401      	movs	r4, #1
        MSC_Handle->hbot.state  = BOT_DATA_OUT;
 8008a5a:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a5e:	e79d      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 8008a60:	7931      	ldrb	r1, [r6, #4]
 8008a62:	f016 f90b 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8008a66:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 8008a68:	4604      	mov	r4, r0
      if (URB_Status == USBH_URB_DONE)
 8008a6a:	d029      	beq.n	8008ac0 <USBH_MSC_BOT_Process+0x180>
      else if (URB_Status == USBH_URB_STALL)
 8008a6c:	2805      	cmp	r0, #5
 8008a6e:	d1a3      	bne.n	80089b8 <USBH_MSC_BOT_Process+0x78>
 8008a70:	e7c4      	b.n	80089fc <USBH_MSC_BOT_Process+0xbc>
        MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 8008a72:	2307      	movs	r3, #7
  USBH_StatusTypeDef   status = USBH_BUSY;
 8008a74:	2401      	movs	r4, #1
        MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 8008a76:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a7a:	e78f      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 8008a7c:	230a      	movs	r3, #10
  USBH_StatusTypeDef   status = USBH_BUSY;
 8008a7e:	2401      	movs	r4, #1
        MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 8008a80:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a84:	e78a      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008a86:	2301      	movs	r3, #1
  USBH_StatusTypeDef   status = USBH_BUSY;
 8008a88:	461c      	mov	r4, r3
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008a8a:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008a8e:	e785      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
 8008a90:	6df3      	ldr	r3, [r6, #92]	; 0x5c
 8008a92:	8932      	ldrh	r2, [r6, #8]
 8008a94:	4293      	cmp	r3, r2
 8008a96:	d90d      	bls.n	8008ab4 <USBH_MSC_BOT_Process+0x174>
          MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
 8008a98:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize;
 8008a9c:	1a9b      	subs	r3, r3, r2
          MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
 8008a9e:	4411      	add	r1, r2
 8008aa0:	65f3      	str	r3, [r6, #92]	; 0x5c
 8008aa2:	f8c6 108c 	str.w	r1, [r6, #140]	; 0x8c
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 8008aa6:	b13b      	cbz	r3, 8008ab8 <USBH_MSC_BOT_Process+0x178>
          (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 8008aa8:	7973      	ldrb	r3, [r6, #5]
 8008aaa:	4628      	mov	r0, r5
 8008aac:	9400      	str	r4, [sp, #0]
 8008aae:	f001 fde1 	bl	800a674 <USBH_BulkSendData>
 8008ab2:	e773      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
 8008ab4:	2300      	movs	r3, #0
 8008ab6:	65f3      	str	r3, [r6, #92]	; 0x5c
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 8008ab8:	2307      	movs	r3, #7
 8008aba:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008abe:	e76d      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
 8008ac0:	6df3      	ldr	r3, [r6, #92]	; 0x5c
 8008ac2:	8972      	ldrh	r2, [r6, #10]
 8008ac4:	4293      	cmp	r3, r2
 8008ac6:	d9f5      	bls.n	8008ab4 <USBH_MSC_BOT_Process+0x174>
          MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
 8008ac8:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;
 8008acc:	1a9b      	subs	r3, r3, r2
          MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
 8008ace:	4411      	add	r1, r2
 8008ad0:	65f3      	str	r3, [r6, #92]	; 0x5c
 8008ad2:	f8c6 108c 	str.w	r1, [r6, #140]	; 0x8c
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 8008ad6:	2b00      	cmp	r3, #0
 8008ad8:	d0ee      	beq.n	8008ab8 <USBH_MSC_BOT_Process+0x178>
          (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 8008ada:	7933      	ldrb	r3, [r6, #4]
 8008adc:	4628      	mov	r0, r5
 8008ade:	f001 fde3 	bl	800a6a8 <USBH_BulkReceiveData>
 8008ae2:	e75b      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        if (MSC_Handle->hbot.cbw.field.DataTransferLength != 0U)
 8008ae4:	6df3      	ldr	r3, [r6, #92]	; 0x5c
 8008ae6:	2b00      	cmp	r3, #0
 8008ae8:	d0e6      	beq.n	8008ab8 <USBH_MSC_BOT_Process+0x178>
          if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
 8008aea:	f996 3060 	ldrsb.w	r3, [r6, #96]	; 0x60
 8008aee:	2b00      	cmp	r3, #0
            MSC_Handle->hbot.state = BOT_DATA_IN;
 8008af0:	bfb4      	ite	lt
 8008af2:	2303      	movlt	r3, #3
            MSC_Handle->hbot.state = BOT_DATA_OUT;
 8008af4:	2305      	movge	r3, #5
 8008af6:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 8008afa:	e74f      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
        toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe);
 8008afc:	7971      	ldrb	r1, [r6, #5]
 8008afe:	4628      	mov	r0, r5
 8008b00:	f016 f8e0 	bl	801ecc4 <USBH_LL_GetToggle>
        (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1U - toggle);
 8008b04:	f1c0 0001 	rsb	r0, r0, #1
 8008b08:	7971      	ldrb	r1, [r6, #5]
 8008b0a:	b2c2      	uxtb	r2, r0
 8008b0c:	4628      	mov	r0, r5
 8008b0e:	f016 f8bb 	bl	801ec88 <USBH_LL_SetToggle>
        (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 8008b12:	4622      	mov	r2, r4
 8008b14:	7931      	ldrb	r1, [r6, #4]
 8008b16:	4628      	mov	r0, r5
 8008b18:	f016 f8b6 	bl	801ec88 <USBH_LL_SetToggle>
 8008b1c:	e76e      	b.n	80089fc <USBH_MSC_BOT_Process+0xbc>
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008b1e:	f886 0050 	strb.w	r0, [r6, #80]	; 0x50
        MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 8008b22:	f886 0052 	strb.w	r0, [r6, #82]	; 0x52
{
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
  BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;

  /*Checking if the transfer length is different than 13*/
  if (USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
 8008b26:	4628      	mov	r0, r5
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008b28:	f8d5 347c 	ldr.w	r3, [r5, #1148]	; 0x47c
 8008b2c:	69dc      	ldr	r4, [r3, #28]
  if (USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
 8008b2e:	7921      	ldrb	r1, [r4, #4]
 8008b30:	f016 f872 	bl	801ec18 <USBH_LL_GetLastXferSize>
 8008b34:	280d      	cmp	r0, #13
 8008b36:	d107      	bne.n	8008b48 <USBH_MSC_BOT_Process+0x208>
  else
  {
    /* CSW length is Correct */

    /* Check validity of the CSW Signature and CSWStatus */
    if (MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
 8008b38:	4b07      	ldr	r3, [pc, #28]	; (8008b58 <USBH_MSC_BOT_Process+0x218>)
 8008b3a:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 8008b3c:	429a      	cmp	r2, r3
 8008b3e:	d103      	bne.n	8008b48 <USBH_MSC_BOT_Process+0x208>
    {
      /* Check Condition 1. dCSWSignature is equal to 53425355h */

      if (MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
 8008b40:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8008b42:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8008b44:	429a      	cmp	r2, r3
 8008b46:	d001      	beq.n	8008b4c <USBH_MSC_BOT_Process+0x20c>
          status = USBH_FAIL;
 8008b48:	2402      	movs	r4, #2
 8008b4a:	e727      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
      {
        /* Check Condition 3. dCSWTag matches the dCBWTag from the
        corresponding CBW */

        if (MSC_Handle->hbot.csw.field.Status == 0U)
 8008b4c:	f894 4084 	ldrb.w	r4, [r4, #132]	; 0x84
          status = USBH_FAIL;
 8008b50:	2c00      	cmp	r4, #0
 8008b52:	bf18      	it	ne
 8008b54:	2402      	movne	r4, #2
 8008b56:	e721      	b.n	800899c <USBH_MSC_BOT_Process+0x5c>
 8008b58:	53425355 	.word	0x53425355

08008b5c <USBH_MSC_SCSI_TestUnitReady>:
  */
USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady(USBH_HandleTypeDef *phost,
                                               uint8_t lun)
{
  USBH_StatusTypeDef    error = USBH_FAIL;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008b5c:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
 8008b60:	69db      	ldr	r3, [r3, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008b62:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
 8008b66:	2a01      	cmp	r2, #1
 8008b68:	d006      	beq.n	8008b78 <USBH_MSC_SCSI_TestUnitReady+0x1c>
 8008b6a:	2a02      	cmp	r2, #2
 8008b6c:	d101      	bne.n	8008b72 <USBH_MSC_SCSI_TestUnitReady+0x16>
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
      error = USBH_BUSY;
      break;

    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
 8008b6e:	f7ff bee7 	b.w	8008940 <USBH_MSC_BOT_Process>
  switch (MSC_Handle->hbot.cmd_state)
 8008b72:	2202      	movs	r2, #2
    default:
      break;
  }

  return error;
}
 8008b74:	4610      	mov	r0, r2
 8008b76:	4770      	bx	lr
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;
 8008b78:	2100      	movs	r1, #0
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008b7a:	f04f 0c0a 	mov.w	ip, #10
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008b7e:	2002      	movs	r0, #2
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008b80:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;
 8008b84:	65d9      	str	r1, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008b86:	f883 0052 	strb.w	r0, [r3, #82]	; 0x52
}
 8008b8a:	4610      	mov	r0, r2
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 8008b8c:	f883 1060 	strb.w	r1, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008b90:	f883 c062 	strb.w	ip, [r3, #98]	; 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008b94:	f8c3 1063 	str.w	r1, [r3, #99]	; 0x63
 8008b98:	f8c3 1067 	str.w	r1, [r3, #103]	; 0x67
 8008b9c:	f8c3 106b 	str.w	r1, [r3, #107]	; 0x6b
 8008ba0:	f8c3 106f 	str.w	r1, [r3, #111]	; 0x6f
}
 8008ba4:	4770      	bx	lr
 8008ba6:	bf00      	nop

08008ba8 <USBH_MSC_SCSI_ReadCapacity>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_CapacityTypeDef *capacity)
{
 8008ba8:	b538      	push	{r3, r4, r5, lr}
  USBH_StatusTypeDef    error = USBH_BUSY;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008baa:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
 8008bae:	69dc      	ldr	r4, [r3, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008bb0:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8008bb4:	2b01      	cmp	r3, #1
 8008bb6:	d013      	beq.n	8008be0 <USBH_MSC_SCSI_ReadCapacity+0x38>
 8008bb8:	2b02      	cmp	r3, #2
 8008bba:	d10e      	bne.n	8008bda <USBH_MSC_SCSI_ReadCapacity+0x32>
      error = USBH_BUSY;
      break;

    case BOT_CMD_WAIT:

      error = USBH_MSC_BOT_Process(phost, lun);
 8008bbc:	4615      	mov	r5, r2
 8008bbe:	f7ff febf 	bl	8008940 <USBH_MSC_BOT_Process>

      if (error == USBH_OK)
 8008bc2:	4603      	mov	r3, r0
 8008bc4:	b938      	cbnz	r0, 8008bd6 <USBH_MSC_SCSI_ReadCapacity+0x2e>
      {
        /*assign the capacity*/
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 8008bc6:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8008bca:	680a      	ldr	r2, [r1, #0]
 8008bcc:	ba12      	rev	r2, r2
 8008bce:	602a      	str	r2, [r5, #0]
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);

        /*assign the page length*/
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
 8008bd0:	88ca      	ldrh	r2, [r1, #6]
 8008bd2:	ba52      	rev16	r2, r2
 8008bd4:	80aa      	strh	r2, [r5, #4]
    default:
      break;
  }

  return error;
}
 8008bd6:	4618      	mov	r0, r3
 8008bd8:	bd38      	pop	{r3, r4, r5, pc}
  switch (MSC_Handle->hbot.cmd_state)
 8008bda:	2301      	movs	r3, #1
}
 8008bdc:	4618      	mov	r0, r3
 8008bde:	bd38      	pop	{r3, r4, r5, pc}
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008be0:	2200      	movs	r2, #0
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
 8008be2:	2008      	movs	r0, #8
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008be4:	2180      	movs	r1, #128	; 0x80
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008be6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008bea:	f8c4 2063 	str.w	r2, [r4, #99]	; 0x63
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
 8008bee:	65e0      	str	r0, [r4, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008bf0:	f242 500a 	movw	r0, #9482	; 0x250a
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008bf4:	f884 1060 	strb.w	r1, [r4, #96]	; 0x60
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008bf8:	2102      	movs	r1, #2
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008bfa:	f8c4 2067 	str.w	r2, [r4, #103]	; 0x67
 8008bfe:	f8c4 206b 	str.w	r2, [r4, #107]	; 0x6b
 8008c02:	f8c4 206f 	str.w	r2, [r4, #111]	; 0x6f
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008c06:	f104 0210 	add.w	r2, r4, #16
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008c0a:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
}
 8008c0e:	4618      	mov	r0, r3
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008c10:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008c14:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
}
 8008c18:	bd38      	pop	{r3, r4, r5, pc}
 8008c1a:	bf00      	nop

08008c1c <USBH_MSC_SCSI_Inquiry>:
  * @param  capacity: pointer to the inquiry structure
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry(USBH_HandleTypeDef *phost, uint8_t lun,
                                         SCSI_StdInquiryDataTypeDef *inquiry)
{
 8008c1c:	b570      	push	{r4, r5, r6, lr}
  USBH_StatusTypeDef error = USBH_FAIL;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008c1e:	f8d0 447c 	ldr.w	r4, [r0, #1148]	; 0x47c
 8008c22:	69e4      	ldr	r4, [r4, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008c24:	f894 5052 	ldrb.w	r5, [r4, #82]	; 0x52
 8008c28:	2d01      	cmp	r5, #1
 8008c2a:	d00b      	beq.n	8008c44 <USBH_MSC_SCSI_Inquiry+0x28>
 8008c2c:	2d02      	cmp	r5, #2
 8008c2e:	d106      	bne.n	8008c3e <USBH_MSC_SCSI_Inquiry+0x22>
      error = USBH_BUSY;
      break;

    case BOT_CMD_WAIT:

      error = USBH_MSC_BOT_Process(phost, lun);
 8008c30:	4616      	mov	r6, r2
 8008c32:	f7ff fe85 	bl	8008940 <USBH_MSC_BOT_Process>

      if (error == USBH_OK)
 8008c36:	4605      	mov	r5, r0
 8008c38:	b320      	cbz	r0, 8008c84 <USBH_MSC_SCSI_Inquiry+0x68>
    default:
      break;
  }

  return error;
}
 8008c3a:	4628      	mov	r0, r5
 8008c3c:	bd70      	pop	{r4, r5, r6, pc}
  switch (MSC_Handle->hbot.cmd_state)
 8008c3e:	2502      	movs	r5, #2
}
 8008c40:	4628      	mov	r0, r5
 8008c42:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
 8008c44:	2300      	movs	r3, #0
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 8008c46:	0149      	lsls	r1, r1, #5
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
 8008c48:	2224      	movs	r2, #36	; 0x24
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008c4a:	2080      	movs	r0, #128	; 0x80
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
 8008c4c:	f8c4 3063 	str.w	r3, [r4, #99]	; 0x63
 8008c50:	f8c4 3067 	str.w	r3, [r4, #103]	; 0x67
 8008c54:	f8a4 306b 	strh.w	r3, [r4, #107]	; 0x6b
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008c58:	f241 230a 	movw	r3, #4618	; 0x120a
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 8008c5c:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008c60:	2102      	movs	r1, #2
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008c62:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008c66:	f104 0310 	add.w	r3, r4, #16
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008c6a:	f884 0060 	strb.w	r0, [r4, #96]	; 0x60
}
 8008c6e:	4628      	mov	r0, r5
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
 8008c70:	65e2      	str	r2, [r4, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.CB[4]  = 0x24U;
 8008c72:	f884 2067 	strb.w	r2, [r4, #103]	; 0x67
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008c76:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008c7a:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008c7e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
}
 8008c82:	bd70      	pop	{r4, r5, r6, pc}
        (void)USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
 8008c84:	2222      	movs	r2, #34	; 0x22
 8008c86:	4601      	mov	r1, r0
 8008c88:	4630      	mov	r0, r6
 8008c8a:	f017 fa27 	bl	80200dc <memset>
        inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1FU;
 8008c8e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8008c92:	781a      	ldrb	r2, [r3, #0]
 8008c94:	f002 021f 	and.w	r2, r2, #31
 8008c98:	7072      	strb	r2, [r6, #1]
        inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5U;
 8008c9a:	781a      	ldrb	r2, [r3, #0]
 8008c9c:	0952      	lsrs	r2, r2, #5
 8008c9e:	7032      	strb	r2, [r6, #0]
        if (((uint32_t)MSC_Handle->hbot.pbuf[1] & 0x80U) == 0x80U)
 8008ca0:	f993 2001 	ldrsb.w	r2, [r3, #1]
 8008ca4:	2a00      	cmp	r2, #0
 8008ca6:	da01      	bge.n	8008cac <USBH_MSC_SCSI_Inquiry+0x90>
          inquiry->RemovableMedia = 1U;
 8008ca8:	2201      	movs	r2, #1
 8008caa:	70b2      	strb	r2, [r6, #2]
        (void)USBH_memcpy(inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8U);
 8008cac:	689a      	ldr	r2, [r3, #8]
 8008cae:	68db      	ldr	r3, [r3, #12]
 8008cb0:	f8c6 2003 	str.w	r2, [r6, #3]
 8008cb4:	f8c6 3007 	str.w	r3, [r6, #7]
        (void)USBH_memcpy(inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16U);
 8008cb8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8008cbc:	6918      	ldr	r0, [r3, #16]
 8008cbe:	6959      	ldr	r1, [r3, #20]
 8008cc0:	699a      	ldr	r2, [r3, #24]
 8008cc2:	69db      	ldr	r3, [r3, #28]
 8008cc4:	60f0      	str	r0, [r6, #12]
}
 8008cc6:	4628      	mov	r0, r5
        (void)USBH_memcpy(inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16U);
 8008cc8:	6131      	str	r1, [r6, #16]
 8008cca:	6172      	str	r2, [r6, #20]
 8008ccc:	61b3      	str	r3, [r6, #24]
        (void)USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
 8008cce:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8008cd2:	6a1b      	ldr	r3, [r3, #32]
 8008cd4:	f8c6 301d 	str.w	r3, [r6, #29]
}
 8008cd8:	bd70      	pop	{r4, r5, r6, pc}
 8008cda:	bf00      	nop

08008cdc <USBH_MSC_SCSI_RequestSense>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_SenseTypeDef *sense_data)
{
 8008cdc:	b538      	push	{r3, r4, r5, lr}
  USBH_StatusTypeDef    error = USBH_FAIL;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008cde:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
 8008ce2:	69dc      	ldr	r4, [r3, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008ce4:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8008ce8:	2b01      	cmp	r3, #1
 8008cea:	d015      	beq.n	8008d18 <USBH_MSC_SCSI_RequestSense+0x3c>
 8008cec:	2b02      	cmp	r3, #2
 8008cee:	d110      	bne.n	8008d12 <USBH_MSC_SCSI_RequestSense+0x36>
      error = USBH_BUSY;
      break;

    case BOT_CMD_WAIT:

      error = USBH_MSC_BOT_Process(phost, lun);
 8008cf0:	4615      	mov	r5, r2
 8008cf2:	f7ff fe25 	bl	8008940 <USBH_MSC_BOT_Process>

      if (error == USBH_OK)
 8008cf6:	4603      	mov	r3, r0
 8008cf8:	b948      	cbnz	r0, 8008d0e <USBH_MSC_SCSI_RequestSense+0x32>
      {
        sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0FU;
 8008cfa:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8008cfe:	7891      	ldrb	r1, [r2, #2]
 8008d00:	f001 010f 	and.w	r1, r1, #15
 8008d04:	7029      	strb	r1, [r5, #0]
        sense_data->asc  = MSC_Handle->hbot.pbuf[12];
 8008d06:	7b11      	ldrb	r1, [r2, #12]
 8008d08:	7069      	strb	r1, [r5, #1]
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
 8008d0a:	7b52      	ldrb	r2, [r2, #13]
 8008d0c:	70aa      	strb	r2, [r5, #2]
    default:
      break;
  }

  return error;
}
 8008d0e:	4618      	mov	r0, r3
 8008d10:	bd38      	pop	{r3, r4, r5, pc}
  switch (MSC_Handle->hbot.cmd_state)
 8008d12:	2302      	movs	r3, #2
}
 8008d14:	4618      	mov	r0, r3
 8008d16:	bd38      	pop	{r3, r4, r5, pc}
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008d18:	2280      	movs	r2, #128	; 0x80
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 8008d1a:	0149      	lsls	r1, r1, #5
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
 8008d1c:	200e      	movs	r0, #14
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008d1e:	2502      	movs	r5, #2
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008d20:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008d24:	2200      	movs	r2, #0
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
 8008d26:	65e0      	str	r0, [r4, #92]	; 0x5c
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008d28:	f8c4 2063 	str.w	r2, [r4, #99]	; 0x63
 8008d2c:	f8c4 2067 	str.w	r2, [r4, #103]	; 0x67
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 8008d30:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008d34:	f240 310a 	movw	r1, #778	; 0x30a
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008d38:	f8c4 206b 	str.w	r2, [r4, #107]	; 0x6b
 8008d3c:	f8c4 206f 	str.w	r2, [r4, #111]	; 0x6f
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008d40:	f104 0210 	add.w	r2, r4, #16
      MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
 8008d44:	f884 0067 	strb.w	r0, [r4, #103]	; 0x67
}
 8008d48:	4618      	mov	r0, r3
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008d4a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008d4e:	f884 5052 	strb.w	r5, [r4, #82]	; 0x52
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008d52:	f8a4 1062 	strh.w	r1, [r4, #98]	; 0x62
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8008d56:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
}
 8008d5a:	bd38      	pop	{r3, r4, r5, pc}

08008d5c <USBH_MSC_SCSI_Write>:
USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
                                       uint8_t lun,
                                       uint32_t address,
                                       uint8_t *pbuf,
                                       uint32_t length)
{
 8008d5c:	b430      	push	{r4, r5}
  USBH_StatusTypeDef    error = USBH_FAIL;

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008d5e:	f8d0 447c 	ldr.w	r4, [r0, #1148]	; 0x47c
{
 8008d62:	9d02      	ldr	r5, [sp, #8]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008d64:	69e4      	ldr	r4, [r4, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008d66:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
 8008d6a:	f1bc 0f01 	cmp.w	ip, #1
 8008d6e:	d00a      	beq.n	8008d86 <USBH_MSC_SCSI_Write+0x2a>
 8008d70:	f1bc 0f02 	cmp.w	ip, #2
 8008d74:	d102      	bne.n	8008d7c <USBH_MSC_SCSI_Write+0x20>
    default:
      break;
  }

  return error;
}
 8008d76:	bc30      	pop	{r4, r5}
      error = USBH_MSC_BOT_Process(phost, lun);
 8008d78:	f7ff bde2 	b.w	8008940 <USBH_MSC_BOT_Process>
  switch (MSC_Handle->hbot.cmd_state)
 8008d7c:	f04f 0c02 	mov.w	ip, #2
}
 8008d80:	bc30      	pop	{r4, r5}
 8008d82:	4660      	mov	r0, ip
 8008d84:	4770      	bx	lr
      MSC_Handle->hbot.pbuf = pbuf;
 8008d86:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008d8a:	2102      	movs	r1, #2
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008d8c:	f8b4 3098 	ldrh.w	r3, [r4, #152]	; 0x98
}
 8008d90:	4660      	mov	r0, ip
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008d92:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 8008d96:	f3c2 6107 	ubfx	r1, r2, #24, #8
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008d9a:	fb05 f303 	mul.w	r3, r5, r3
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 8008d9e:	ba6d      	rev16	r5, r5
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008da0:	f884 c050 	strb.w	ip, [r4, #80]	; 0x50
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008da4:	65e3      	str	r3, [r4, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 8008da6:	2300      	movs	r3, #0
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008da8:	f8c4 3063 	str.w	r3, [r4, #99]	; 0x63
 8008dac:	f8c4 3067 	str.w	r3, [r4, #103]	; 0x67
 8008db0:	f8c4 306b 	str.w	r3, [r4, #107]	; 0x6b
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 8008db4:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008db8:	f8c4 306f 	str.w	r3, [r4, #111]	; 0x6f
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008dbc:	f642 230a 	movw	r3, #10762	; 0x2a0a
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 8008dc0:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008dc4:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 8008dc8:	f3c2 4307 	ubfx	r3, r2, #16, #8
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 8008dcc:	f3c2 2207 	ubfx	r2, r2, #8, #8
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 8008dd0:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 8008dd4:	f884 1065 	strb.w	r1, [r4, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 8008dd8:	f884 3066 	strb.w	r3, [r4, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 8008ddc:	f884 2067 	strb.w	r2, [r4, #103]	; 0x67
}
 8008de0:	bc30      	pop	{r4, r5}
 8008de2:	4770      	bx	lr

08008de4 <USBH_MSC_SCSI_Read>:
USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
                                      uint8_t lun,
                                      uint32_t address,
                                      uint8_t *pbuf,
                                      uint32_t length)
{
 8008de4:	b430      	push	{r4, r5}
  USBH_StatusTypeDef    error = USBH_FAIL;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008de6:	f8d0 447c 	ldr.w	r4, [r0, #1148]	; 0x47c
{
 8008dea:	9d02      	ldr	r5, [sp, #8]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8008dec:	69e4      	ldr	r4, [r4, #28]

  switch (MSC_Handle->hbot.cmd_state)
 8008dee:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
 8008df2:	f1bc 0f01 	cmp.w	ip, #1
 8008df6:	d00a      	beq.n	8008e0e <USBH_MSC_SCSI_Read+0x2a>
 8008df8:	f1bc 0f02 	cmp.w	ip, #2
 8008dfc:	d102      	bne.n	8008e04 <USBH_MSC_SCSI_Read+0x20>
    default:
      break;
  }

  return error;
}
 8008dfe:	bc30      	pop	{r4, r5}
      error = USBH_MSC_BOT_Process(phost, lun);
 8008e00:	f7ff bd9e 	b.w	8008940 <USBH_MSC_BOT_Process>
  switch (MSC_Handle->hbot.cmd_state)
 8008e04:	f04f 0c02 	mov.w	ip, #2
}
 8008e08:	bc30      	pop	{r4, r5}
 8008e0a:	4660      	mov	r0, ip
 8008e0c:	4770      	bx	lr
      MSC_Handle->hbot.pbuf = pbuf;
 8008e0e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008e12:	2102      	movs	r1, #2
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008e14:	f8b4 3098 	ldrh.w	r3, [r4, #152]	; 0x98
}
 8008e18:	4660      	mov	r0, ip
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8008e1a:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 8008e1e:	f3c2 6107 	ubfx	r1, r2, #24, #8
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008e22:	fb05 f303 	mul.w	r3, r5, r3
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 8008e26:	ba6d      	rev16	r5, r5
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8008e28:	f884 c050 	strb.w	ip, [r4, #80]	; 0x50
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8008e2c:	65e3      	str	r3, [r4, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8008e2e:	2380      	movs	r3, #128	; 0x80
 8008e30:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8008e34:	2300      	movs	r3, #0
 8008e36:	f8c4 3063 	str.w	r3, [r4, #99]	; 0x63
 8008e3a:	f8c4 3067 	str.w	r3, [r4, #103]	; 0x67
 8008e3e:	f8c4 306b 	str.w	r3, [r4, #107]	; 0x6b
 8008e42:	f8c4 306f 	str.w	r3, [r4, #111]	; 0x6f
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008e46:	f642 030a 	movw	r3, #10250	; 0x280a
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 8008e4a:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8008e4e:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 8008e52:	f3c2 4307 	ubfx	r3, r2, #16, #8
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 8008e56:	f3c2 2207 	ubfx	r2, r2, #8, #8
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 8008e5a:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 8008e5e:	f884 1065 	strb.w	r1, [r4, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 8008e62:	f884 3066 	strb.w	r3, [r4, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 8008e66:	f884 2067 	strb.w	r2, [r4, #103]	; 0x67
}
 8008e6a:	bc30      	pop	{r4, r5}
 8008e6c:	4770      	bx	lr
 8008e6e:	bf00      	nop

08008e70 <USBH_Init>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Init(USBH_HandleTypeDef *phost,
                             void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                                              uint8_t id), uint8_t id)
{
 8008e70:	b570      	push	{r4, r5, r6, lr}
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 8008e72:	2800      	cmp	r0, #0
 8008e74:	d04a      	beq.n	8008f0c <USBH_Init+0x9c>

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
 8008e76:	2500      	movs	r5, #0
 8008e78:	4613      	mov	r3, r2
 8008e7a:	4604      	mov	r4, r0
  uint32_t i = 0U;

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
  {
    phost->Pipes[i] = 0U;
 8008e7c:	222c      	movs	r2, #44	; 0x2c
  phost->id = id;
 8008e7e:	f880 34cc 	strb.w	r3, [r0, #1228]	; 0x4cc
  phost->pActiveClass = NULL;
 8008e82:	460e      	mov	r6, r1
 8008e84:	f8c0 547c 	str.w	r5, [r0, #1148]	; 0x47c
    phost->Pipes[i] = 0U;
 8008e88:	4629      	mov	r1, r5
  phost->ClassNumber = 0U;
 8008e8a:	f8c0 5480 	str.w	r5, [r0, #1152]	; 0x480
    phost->Pipes[i] = 0U;
 8008e8e:	f200 4084 	addw	r0, r0, #1156	; 0x484
 8008e92:	f017 f923 	bl	80200dc <memset>
  {
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
 8008e96:	f44f 7380 	mov.w	r3, #256	; 0x100
  phost->RequestState = CMD_SEND;
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8008e9a:	2240      	movs	r2, #64	; 0x40
  phost->Control.state = CTRL_SETUP;
 8008e9c:	2101      	movs	r1, #1
  phost->EnumState = ENUM_IDLE;
 8008e9e:	f8a4 3001 	strh.w	r3, [r4, #1]
  phost->device.speed = (uint8_t)USBH_SPEED_FULL;
  phost->device.RstCnt = 0U;
  phost->device.EnumCnt = 0U;

  /* Reset the device struct */
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8008ea2:	f104 001c 	add.w	r0, r4, #28
  phost->device.address = USBH_ADDRESS_DEFAULT;
 8008ea6:	f8c4 341c 	str.w	r3, [r4, #1052]	; 0x41c
  phost->gState = HOST_IDLE;
 8008eaa:	7025      	strb	r5, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8008eac:	71a2      	strb	r2, [r4, #6]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8008eae:	f44f 7200 	mov.w	r2, #512	; 0x200
  phost->Control.state = CTRL_SETUP;
 8008eb2:	8321      	strh	r1, [r4, #24]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8008eb4:	4629      	mov	r1, r5
  phost->Timer = 0U;
 8008eb6:	f8c4 54c4 	str.w	r5, [r4, #1220]	; 0x4c4
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8008eba:	f017 f90f 	bl	80200dc <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 8008ebe:	f44f 7200 	mov.w	r2, #512	; 0x200
 8008ec2:	4629      	mov	r1, r5
 8008ec4:	f504 7007 	add.w	r0, r4, #540	; 0x21c
 8008ec8:	f017 f908 	bl	80200dc <memset>
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 8008ecc:	223e      	movs	r2, #62	; 0x3e
 8008ece:	4629      	mov	r1, r5
 8008ed0:	f504 6087 	add.w	r0, r4, #1080	; 0x438
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 8008ed4:	f8c4 5426 	str.w	r5, [r4, #1062]	; 0x426
 8008ed8:	f8c4 542a 	str.w	r5, [r4, #1066]	; 0x42a
 8008edc:	f8c4 542e 	str.w	r5, [r4, #1070]	; 0x42e
 8008ee0:	f8c4 5432 	str.w	r5, [r4, #1074]	; 0x432
 8008ee4:	f8a4 5436 	strh.w	r5, [r4, #1078]	; 0x436
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 8008ee8:	f017 f8f8 	bl	80200dc <memset>
  phost->device.is_connected = 0U;
 8008eec:	f884 5420 	strb.w	r5, [r4, #1056]	; 0x420
  phost->device.PortEnabled = 0U;
 8008ef0:	f884 5423 	strb.w	r5, [r4, #1059]	; 0x423
  phost->device.is_disconnected = 0U;
 8008ef4:	f884 5421 	strb.w	r5, [r4, #1057]	; 0x421
  phost->device.is_ReEnumerated = 0U;
 8008ef8:	f884 5422 	strb.w	r5, [r4, #1058]	; 0x422
  if (pUsrFunc != NULL)
 8008efc:	b10e      	cbz	r6, 8008f02 <USBH_Init+0x92>
    phost->pUser = pUsrFunc;
 8008efe:	f8c4 64d4 	str.w	r6, [r4, #1236]	; 0x4d4
  (void)USBH_LL_Init(phost);
 8008f02:	4620      	mov	r0, r4
 8008f04:	f015 fe18 	bl	801eb38 <USBH_LL_Init>
  return USBH_OK;
 8008f08:	2000      	movs	r0, #0
}
 8008f0a:	bd70      	pop	{r4, r5, r6, pc}
    USBH_ErrLog("Invalid Host handle");
 8008f0c:	4805      	ldr	r0, [pc, #20]	; (8008f24 <USBH_Init+0xb4>)
 8008f0e:	f017 f9e3 	bl	80202d8 <iprintf>
 8008f12:	4805      	ldr	r0, [pc, #20]	; (8008f28 <USBH_Init+0xb8>)
 8008f14:	f017 f9e0 	bl	80202d8 <iprintf>
 8008f18:	200a      	movs	r0, #10
 8008f1a:	f017 f9f5 	bl	8020308 <putchar>
    return USBH_FAIL;
 8008f1e:	2002      	movs	r0, #2
}
 8008f20:	bd70      	pop	{r4, r5, r6, pc}
 8008f22:	bf00      	nop
 8008f24:	08021984 	.word	0x08021984
 8008f28:	0802198c 	.word	0x0802198c

08008f2c <USBH_RegisterClass>:
  * @param  phost : Host Handle
  * @param  pclass: Class handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
 8008f2c:	b508      	push	{r3, lr}
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
 8008f2e:	b1a1      	cbz	r1, 8008f5a <USBH_RegisterClass+0x2e>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 8008f30:	4603      	mov	r3, r0
 8008f32:	f8d0 0480 	ldr.w	r0, [r0, #1152]	; 0x480
 8008f36:	b928      	cbnz	r0, 8008f44 <USBH_RegisterClass+0x18>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 8008f38:	2201      	movs	r2, #1
 8008f3a:	f8c3 1478 	str.w	r1, [r3, #1144]	; 0x478
 8008f3e:	f8c3 2480 	str.w	r2, [r3, #1152]	; 0x480
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
 8008f42:	bd08      	pop	{r3, pc}
      USBH_ErrLog("Max Class Number reached");
 8008f44:	480a      	ldr	r0, [pc, #40]	; (8008f70 <USBH_RegisterClass+0x44>)
 8008f46:	f017 f9c7 	bl	80202d8 <iprintf>
 8008f4a:	480a      	ldr	r0, [pc, #40]	; (8008f74 <USBH_RegisterClass+0x48>)
 8008f4c:	f017 f9c4 	bl	80202d8 <iprintf>
 8008f50:	200a      	movs	r0, #10
 8008f52:	f017 f9d9 	bl	8020308 <putchar>
      status = USBH_FAIL;
 8008f56:	2002      	movs	r0, #2
}
 8008f58:	bd08      	pop	{r3, pc}
    USBH_ErrLog("Invalid Class handle");
 8008f5a:	4805      	ldr	r0, [pc, #20]	; (8008f70 <USBH_RegisterClass+0x44>)
 8008f5c:	f017 f9bc 	bl	80202d8 <iprintf>
 8008f60:	4805      	ldr	r0, [pc, #20]	; (8008f78 <USBH_RegisterClass+0x4c>)
 8008f62:	f017 f9b9 	bl	80202d8 <iprintf>
 8008f66:	200a      	movs	r0, #10
 8008f68:	f017 f9ce 	bl	8020308 <putchar>
    status = USBH_FAIL;
 8008f6c:	2002      	movs	r0, #2
}
 8008f6e:	bd08      	pop	{r3, pc}
 8008f70:	08021984 	.word	0x08021984
 8008f74:	080219a0 	.word	0x080219a0
 8008f78:	080219bc 	.word	0x080219bc

08008f7c <USBH_SelectInterface>:
  * @param  phost: Host Handle
  * @param  interface: Interface number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
 8008f7c:	b538      	push	{r3, r4, r5, lr}
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 8008f7e:	f890 343c 	ldrb.w	r3, [r0, #1084]	; 0x43c
 8008f82:	428b      	cmp	r3, r1
 8008f84:	d926      	bls.n	8008fd4 <USBH_SelectInterface+0x58>
  {
    phost->device.current_interface = interface;
 8008f86:	4604      	mov	r4, r0
    USBH_UsrLog("Switching to Interface (#%d)", interface);
 8008f88:	4818      	ldr	r0, [pc, #96]	; (8008fec <USBH_SelectInterface+0x70>)
 8008f8a:	460d      	mov	r5, r1
    phost->device.current_interface = interface;
 8008f8c:	f884 1424 	strb.w	r1, [r4, #1060]	; 0x424
    USBH_UsrLog("Switching to Interface (#%d)", interface);
 8008f90:	f017 f9a2 	bl	80202d8 <iprintf>
 8008f94:	200a      	movs	r0, #10
 8008f96:	f017 f9b7 	bl	8020308 <putchar>
    USBH_UsrLog("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass);
 8008f9a:	211a      	movs	r1, #26
 8008f9c:	4814      	ldr	r0, [pc, #80]	; (8008ff0 <USBH_SelectInterface+0x74>)
 8008f9e:	fb01 4405 	mla	r4, r1, r5, r4
 8008fa2:	f894 1447 	ldrb.w	r1, [r4, #1095]	; 0x447
 8008fa6:	f017 f997 	bl	80202d8 <iprintf>
 8008faa:	200a      	movs	r0, #10
 8008fac:	f017 f9ac 	bl	8020308 <putchar>
    USBH_UsrLog("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass);
 8008fb0:	f894 1448 	ldrb.w	r1, [r4, #1096]	; 0x448
 8008fb4:	480f      	ldr	r0, [pc, #60]	; (8008ff4 <USBH_SelectInterface+0x78>)
 8008fb6:	f017 f98f 	bl	80202d8 <iprintf>
 8008fba:	200a      	movs	r0, #10
 8008fbc:	f017 f9a4 	bl	8020308 <putchar>
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
 8008fc0:	f894 1449 	ldrb.w	r1, [r4, #1097]	; 0x449
 8008fc4:	480c      	ldr	r0, [pc, #48]	; (8008ff8 <USBH_SelectInterface+0x7c>)
 8008fc6:	f017 f987 	bl	80202d8 <iprintf>
 8008fca:	200a      	movs	r0, #10
 8008fcc:	f017 f99c 	bl	8020308 <putchar>
  USBH_StatusTypeDef status = USBH_OK;
 8008fd0:	2000      	movs	r0, #0
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
  }

  return status;
}
 8008fd2:	bd38      	pop	{r3, r4, r5, pc}
    USBH_ErrLog("Cannot Select This Interface.");
 8008fd4:	4809      	ldr	r0, [pc, #36]	; (8008ffc <USBH_SelectInterface+0x80>)
 8008fd6:	f017 f97f 	bl	80202d8 <iprintf>
 8008fda:	4809      	ldr	r0, [pc, #36]	; (8009000 <USBH_SelectInterface+0x84>)
 8008fdc:	f017 f97c 	bl	80202d8 <iprintf>
 8008fe0:	200a      	movs	r0, #10
 8008fe2:	f017 f991 	bl	8020308 <putchar>
    status = USBH_FAIL;
 8008fe6:	2002      	movs	r0, #2
}
 8008fe8:	bd38      	pop	{r3, r4, r5, pc}
 8008fea:	bf00      	nop
 8008fec:	080219d4 	.word	0x080219d4
 8008ff0:	080219f4 	.word	0x080219f4
 8008ff4:	08021a04 	.word	0x08021a04
 8008ff8:	08021a14 	.word	0x08021a14
 8008ffc:	08021984 	.word	0x08021984
 8009000:	08021a24 	.word	0x08021a24

08009004 <USBH_FindInterface>:
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8009004:	f890 c447 	ldrb.w	ip, [r0, #1095]	; 0x447
{
 8009008:	b410      	push	{r4}
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800900a:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
 800900e:	458c      	cmp	ip, r1
 8009010:	fab4 f484 	clz	r4, r4
 8009014:	ea4f 1454 	mov.w	r4, r4, lsr #5
 8009018:	d009      	beq.n	800902e <USBH_FindInterface+0x2a>
 800901a:	b944      	cbnz	r4, 800902e <USBH_FindInterface+0x2a>
 800901c:	f890 c461 	ldrb.w	ip, [r0, #1121]	; 0x461
 8009020:	458c      	cmp	ip, r1
 8009022:	d012      	beq.n	800904a <USBH_FindInterface+0x46>
 8009024:	b98c      	cbnz	r4, 800904a <USBH_FindInterface+0x46>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
 8009026:	20ff      	movs	r0, #255	; 0xff
}
 8009028:	f85d 4b04 	ldr.w	r4, [sp], #4
 800902c:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800902e:	f890 c448 	ldrb.w	ip, [r0, #1096]	; 0x448
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8009032:	4594      	cmp	ip, r2
 8009034:	d001      	beq.n	800903a <USBH_FindInterface+0x36>
 8009036:	2aff      	cmp	r2, #255	; 0xff
 8009038:	d1f0      	bne.n	800901c <USBH_FindInterface+0x18>
 800903a:	f890 c449 	ldrb.w	ip, [r0, #1097]	; 0x449
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800903e:	459c      	cmp	ip, r3
 8009040:	d001      	beq.n	8009046 <USBH_FindInterface+0x42>
 8009042:	2bff      	cmp	r3, #255	; 0xff
 8009044:	d1ea      	bne.n	800901c <USBH_FindInterface+0x18>
  uint8_t if_ix = 0U;
 8009046:	2000      	movs	r0, #0
 8009048:	e7ee      	b.n	8009028 <USBH_FindInterface+0x24>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800904a:	f890 1462 	ldrb.w	r1, [r0, #1122]	; 0x462
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800904e:	4291      	cmp	r1, r2
 8009050:	d001      	beq.n	8009056 <USBH_FindInterface+0x52>
 8009052:	2aff      	cmp	r2, #255	; 0xff
 8009054:	d1e7      	bne.n	8009026 <USBH_FindInterface+0x22>
 8009056:	f890 2463 	ldrb.w	r2, [r0, #1123]	; 0x463
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800905a:	429a      	cmp	r2, r3
 800905c:	d001      	beq.n	8009062 <USBH_FindInterface+0x5e>
 800905e:	2bff      	cmp	r3, #255	; 0xff
 8009060:	d1e1      	bne.n	8009026 <USBH_FindInterface+0x22>
    if_ix++;
 8009062:	2001      	movs	r0, #1
 8009064:	e7e0      	b.n	8009028 <USBH_FindInterface+0x24>
 8009066:	bf00      	nop

08009068 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Start(USBH_HandleTypeDef *phost)
{
 8009068:	b510      	push	{r4, lr}
 800906a:	4604      	mov	r4, r0
	  /* Activate VBUS on the port */
	  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800906c:	2101      	movs	r1, #1
 800906e:	f015 fe09 	bl	801ec84 <USBH_LL_DriverVBUS>

	  /* Start the low level driver  */
  (void)USBH_LL_Start(phost);
 8009072:	4620      	mov	r0, r4
 8009074:	f015 fdae 	bl	801ebd4 <USBH_LL_Start>


  return USBH_OK;
}
 8009078:	2000      	movs	r0, #0
 800907a:	bd10      	pop	{r4, pc}

0800907c <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Process(USBH_HandleTypeDef *phost)
{
 800907c:	b570      	push	{r4, r5, r6, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 800907e:	2302      	movs	r3, #2
{
 8009080:	b086      	sub	sp, #24
 8009082:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 8009084:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 8009088:	f890 3421 	ldrb.w	r3, [r0, #1057]	; 0x421
 800908c:	2b01      	cmp	r3, #1
 800908e:	d101      	bne.n	8009094 <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 8009090:	2303      	movs	r3, #3
 8009092:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
 8009094:	7823      	ldrb	r3, [r4, #0]
 8009096:	2b0b      	cmp	r3, #11
 8009098:	d843      	bhi.n	8009122 <USBH_Process+0xa6>
 800909a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800909e:	004d      	.short	0x004d
 80090a0:	000c0065 	.word	0x000c0065
 80090a4:	0042007c 	.word	0x0042007c
 80090a8:	00dc00ce 	.word	0x00dc00ce
 80090ac:	010600fb 	.word	0x010600fb
 80090b0:	011f0117 	.word	0x011f0117
 80090b4:	0045      	.short	0x0045
#endif
      break;

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 80090b6:	f8d4 34d4 	ldr.w	r3, [r4, #1236]	; 0x4d4
 80090ba:	b113      	cbz	r3, 80090c2 <USBH_Process+0x46>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 80090bc:	2104      	movs	r1, #4
 80090be:	4620      	mov	r0, r4
 80090c0:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 80090c2:	2064      	movs	r0, #100	; 0x64

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 80090c4:	2500      	movs	r5, #0
      USBH_Delay(100U);
 80090c6:	f015 fe19 	bl	801ecfc <USBH_Delay>
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 80090ca:	4620      	mov	r0, r4
 80090cc:	f015 fd92 	bl	801ebf4 <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
 80090d0:	2305      	movs	r3, #5
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 80090d2:	4629      	mov	r1, r5
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 80090d4:	f884 041d 	strb.w	r0, [r4, #1053]	; 0x41d
      phost->gState = HOST_ENUMERATION;
 80090d8:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 80090da:	4620      	mov	r0, r4
 80090dc:	f001 fb0a 	bl	800a6f4 <USBH_AllocPipe>
 80090e0:	4603      	mov	r3, r0
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 80090e2:	2180      	movs	r1, #128	; 0x80
 80090e4:	4620      	mov	r0, r4
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 80090e6:	7163      	strb	r3, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 80090e8:	f001 fb04 	bl	800a6f4 <USBH_AllocPipe>
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 80090ec:	79a2      	ldrb	r2, [r4, #6]
 80090ee:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 80090f2:	4601      	mov	r1, r0
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 80090f4:	e9cd 5201 	strd	r5, r2, [sp, #4]
 80090f8:	9300      	str	r3, [sp, #0]
 80090fa:	2280      	movs	r2, #128	; 0x80
 80090fc:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8009100:	7120      	strb	r0, [r4, #4]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8009102:	4620      	mov	r0, r4
 8009104:	f001 fae0 	bl	800a6c8 <USBH_OpenPipe>
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 8009108:	79a2      	ldrb	r2, [r4, #6]
 800910a:	f894 141d 	ldrb.w	r1, [r4, #1053]	; 0x41d
 800910e:	4620      	mov	r0, r4
 8009110:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 8009114:	9100      	str	r1, [sp, #0]
 8009116:	e9cd 5201 	strd	r5, r2, [sp, #4]
 800911a:	462a      	mov	r2, r5
 800911c:	7961      	ldrb	r1, [r4, #5]
 800911e:	f001 fad3 	bl	800a6c8 <USBH_OpenPipe>
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
 8009122:	2000      	movs	r0, #0
 8009124:	b006      	add	sp, #24
 8009126:	bd70      	pop	{r4, r5, r6, pc}
      if (phost->pActiveClass != NULL)
 8009128:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 800912c:	2b00      	cmp	r3, #0
 800912e:	d0f8      	beq.n	8009122 <USBH_Process+0xa6>
        phost->pActiveClass->BgndProcess(phost);
 8009130:	695b      	ldr	r3, [r3, #20]
 8009132:	4620      	mov	r0, r4
 8009134:	4798      	blx	r3
 8009136:	e7f4      	b.n	8009122 <USBH_Process+0xa6>
      if ((phost->device.is_connected) != 0U)
 8009138:	f894 3420 	ldrb.w	r3, [r4, #1056]	; 0x420
 800913c:	2b00      	cmp	r3, #0
 800913e:	d0f0      	beq.n	8009122 <USBH_Process+0xa6>
        USBH_UsrLog("USB Device Connected");
 8009140:	48c7      	ldr	r0, [pc, #796]	; (8009460 <USBH_Process+0x3e4>)
 8009142:	f017 f8c9 	bl	80202d8 <iprintf>
 8009146:	200a      	movs	r0, #10
 8009148:	f017 f8de 	bl	8020308 <putchar>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800914c:	2301      	movs	r3, #1
        USBH_Delay(200U);
 800914e:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 8009150:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
 8009152:	f015 fdd3 	bl	801ecfc <USBH_Delay>
        (void)USBH_LL_ResetPort(phost);
 8009156:	4620      	mov	r0, r4
 8009158:	f015 fd56 	bl	801ec08 <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
 800915c:	2300      	movs	r3, #0
 800915e:	f884 341c 	strb.w	r3, [r4, #1052]	; 0x41c
        phost->Timeout = 0U;
 8009162:	f8c4 34c8 	str.w	r3, [r4, #1224]	; 0x4c8
 8009166:	e7dc      	b.n	8009122 <USBH_Process+0xa6>
      if (phost->device.PortEnabled == 1U)
 8009168:	f894 3423 	ldrb.w	r3, [r4, #1059]	; 0x423
 800916c:	2b01      	cmp	r3, #1
 800916e:	f000 821a 	beq.w	80095a6 <USBH_Process+0x52a>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 8009172:	f8d4 34c8 	ldr.w	r3, [r4, #1224]	; 0x4c8
 8009176:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800917a:	f240 80da 	bls.w	8009332 <USBH_Process+0x2b6>
          phost->device.RstCnt++;
 800917e:	f894 341f 	ldrb.w	r3, [r4, #1055]	; 0x41f
 8009182:	3301      	adds	r3, #1
 8009184:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
 8009186:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
 8009188:	f884 341f 	strb.w	r3, [r4, #1055]	; 0x41f
          if (phost->device.RstCnt > 3U)
 800918c:	f200 8217 	bhi.w	80095be <USBH_Process+0x542>
            phost->gState = HOST_IDLE;
 8009190:	2300      	movs	r3, #0
 8009192:	7023      	strb	r3, [r4, #0]
 8009194:	e7c5      	b.n	8009122 <USBH_Process+0xa6>
      phost->device.is_disconnected = 0U;
 8009196:	2500      	movs	r5, #0
    phost->Pipes[i] = 0U;
 8009198:	222c      	movs	r2, #44	; 0x2c
 800919a:	f204 4084 	addw	r0, r4, #1156	; 0x484
 800919e:	4629      	mov	r1, r5
      phost->device.is_disconnected = 0U;
 80091a0:	f884 5421 	strb.w	r5, [r4, #1057]	; 0x421
    phost->Pipes[i] = 0U;
 80091a4:	f016 ff9a 	bl	80200dc <memset>
  phost->EnumState = ENUM_IDLE;
 80091a8:	f44f 7380 	mov.w	r3, #256	; 0x100
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 80091ac:	2140      	movs	r1, #64	; 0x40
  phost->Control.state = CTRL_SETUP;
 80091ae:	2201      	movs	r2, #1
  phost->EnumState = ENUM_IDLE;
 80091b0:	f8a4 3001 	strh.w	r3, [r4, #1]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 80091b4:	f104 001c 	add.w	r0, r4, #28
  phost->device.address = USBH_ADDRESS_DEFAULT;
 80091b8:	f8c4 341c 	str.w	r3, [r4, #1052]	; 0x41c
  phost->gState = HOST_IDLE;
 80091bc:	7025      	strb	r5, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 80091be:	71a1      	strb	r1, [r4, #6]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 80091c0:	4629      	mov	r1, r5
  phost->Control.state = CTRL_SETUP;
 80091c2:	8322      	strh	r2, [r4, #24]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 80091c4:	f44f 7200 	mov.w	r2, #512	; 0x200
  phost->Timer = 0U;
 80091c8:	f8c4 54c4 	str.w	r5, [r4, #1220]	; 0x4c4
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 80091cc:	f016 ff86 	bl	80200dc <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 80091d0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80091d4:	4629      	mov	r1, r5
 80091d6:	f504 7007 	add.w	r0, r4, #540	; 0x21c
 80091da:	f016 ff7f 	bl	80200dc <memset>
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 80091de:	223e      	movs	r2, #62	; 0x3e
 80091e0:	4629      	mov	r1, r5
 80091e2:	f504 6087 	add.w	r0, r4, #1080	; 0x438
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 80091e6:	f8c4 5426 	str.w	r5, [r4, #1062]	; 0x426
 80091ea:	f8c4 542a 	str.w	r5, [r4, #1066]	; 0x42a
 80091ee:	f8c4 542e 	str.w	r5, [r4, #1070]	; 0x42e
 80091f2:	f8c4 5432 	str.w	r5, [r4, #1074]	; 0x432
 80091f6:	f8a4 5436 	strh.w	r5, [r4, #1078]	; 0x436
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 80091fa:	f016 ff6f 	bl	80200dc <memset>
      if (phost->pActiveClass != NULL)
 80091fe:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 8009202:	b123      	cbz	r3, 800920e <USBH_Process+0x192>
        phost->pActiveClass->DeInit(phost);
 8009204:	68db      	ldr	r3, [r3, #12]
 8009206:	4620      	mov	r0, r4
 8009208:	4798      	blx	r3
        phost->pActiveClass = NULL;
 800920a:	f8c4 547c 	str.w	r5, [r4, #1148]	; 0x47c
      if (phost->pUser != NULL)
 800920e:	f8d4 34d4 	ldr.w	r3, [r4, #1236]	; 0x4d4
 8009212:	b113      	cbz	r3, 800921a <USBH_Process+0x19e>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 8009214:	2105      	movs	r1, #5
 8009216:	4620      	mov	r0, r4
 8009218:	4798      	blx	r3
      USBH_UsrLog("USB Device disconnected");
 800921a:	4892      	ldr	r0, [pc, #584]	; (8009464 <USBH_Process+0x3e8>)
 800921c:	f017 f85c 	bl	80202d8 <iprintf>
 8009220:	200a      	movs	r0, #10
 8009222:	f017 f871 	bl	8020308 <putchar>
      if (phost->device.is_ReEnumerated == 1U)
 8009226:	f894 3422 	ldrb.w	r3, [r4, #1058]	; 0x422
 800922a:	2b01      	cmp	r3, #1
 800922c:	b2d9      	uxtb	r1, r3
 800922e:	f000 8189 	beq.w	8009544 <USBH_Process+0x4c8>
        (void)USBH_LL_Start(phost);
 8009232:	4620      	mov	r0, r4
 8009234:	f015 fcce 	bl	801ebd4 <USBH_LL_Start>
 8009238:	e773      	b.n	8009122 <USBH_Process+0xa6>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
 800923a:	7865      	ldrb	r5, [r4, #1]
 800923c:	2d07      	cmp	r5, #7
 800923e:	f200 809b 	bhi.w	8009378 <USBH_Process+0x2fc>
 8009242:	e8df f015 	tbh	[pc, r5, lsl #1]
 8009246:	00e5      	.short	0x00e5
 8009248:	013a015a 	.word	0x013a015a
 800924c:	0123012f 	.word	0x0123012f
 8009250:	00b300cc 	.word	0x00b300cc
 8009254:	0086      	.short	0x0086
      if (phost->pActiveClass != NULL)
 8009256:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 800925a:	2b00      	cmp	r3, #0
 800925c:	f000 81b8 	beq.w	80095d0 <USBH_Process+0x554>
        status = phost->pActiveClass->Requests(phost);
 8009260:	691b      	ldr	r3, [r3, #16]
 8009262:	4620      	mov	r0, r4
 8009264:	4798      	blx	r3
 8009266:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 800926a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800926e:	2b00      	cmp	r3, #0
 8009270:	d05c      	beq.n	800932c <USBH_Process+0x2b0>
        else if (status == USBH_FAIL)
 8009272:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009276:	2b02      	cmp	r3, #2
 8009278:	f47f af53 	bne.w	8009122 <USBH_Process+0xa6>
          phost->gState = HOST_ABORT_STATE;
 800927c:	230d      	movs	r3, #13
          USBH_ErrLog("Device not responding Please Unplug.");
 800927e:	487a      	ldr	r0, [pc, #488]	; (8009468 <USBH_Process+0x3ec>)
          phost->gState = HOST_ABORT_STATE;
 8009280:	7023      	strb	r3, [r4, #0]
          USBH_ErrLog("Device not responding Please Unplug.");
 8009282:	f017 f829 	bl	80202d8 <iprintf>
 8009286:	4879      	ldr	r0, [pc, #484]	; (800946c <USBH_Process+0x3f0>)
 8009288:	f017 f826 	bl	80202d8 <iprintf>
 800928c:	200a      	movs	r0, #10
 800928e:	f017 f83b 	bl	8020308 <putchar>
 8009292:	e746      	b.n	8009122 <USBH_Process+0xa6>
      if (phost->pUser != NULL)
 8009294:	f8d4 34d4 	ldr.w	r3, [r4, #1236]	; 0x4d4
 8009298:	2b00      	cmp	r3, #0
 800929a:	f43f af42 	beq.w	8009122 <USBH_Process+0xa6>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 800929e:	2101      	movs	r1, #1
 80092a0:	4620      	mov	r0, r4
 80092a2:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 80092a4:	2308      	movs	r3, #8
 80092a6:	7023      	strb	r3, [r4, #0]
 80092a8:	e73b      	b.n	8009122 <USBH_Process+0xa6>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 80092aa:	f894 143d 	ldrb.w	r1, [r4, #1085]	; 0x43d
 80092ae:	4620      	mov	r0, r4
 80092b0:	f000 fe0c 	bl	8009ecc <USBH_SetCfg>
 80092b4:	2800      	cmp	r0, #0
 80092b6:	f47f af34 	bne.w	8009122 <USBH_Process+0xa6>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 80092ba:	2309      	movs	r3, #9
        USBH_UsrLog("Default configuration set.");
 80092bc:	486c      	ldr	r0, [pc, #432]	; (8009470 <USBH_Process+0x3f4>)
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 80092be:	7023      	strb	r3, [r4, #0]
        USBH_UsrLog("Default configuration set.");
 80092c0:	f017 f80a 	bl	80202d8 <iprintf>
 80092c4:	200a      	movs	r0, #10
 80092c6:	f017 f81f 	bl	8020308 <putchar>
 80092ca:	e72a      	b.n	8009122 <USBH_Process+0xa6>
      if (((phost->device.CfgDesc.bmAttributes) & (1U << 5)) != 0U)
 80092cc:	f894 343f 	ldrb.w	r3, [r4, #1087]	; 0x43f
 80092d0:	069b      	lsls	r3, r3, #26
 80092d2:	f100 8141 	bmi.w	8009558 <USBH_Process+0x4dc>
          phost->gState = HOST_CHECK_CLASS;
 80092d6:	230a      	movs	r3, #10
 80092d8:	7023      	strb	r3, [r4, #0]
 80092da:	e722      	b.n	8009122 <USBH_Process+0xa6>
      if (phost->ClassNumber == 0U)
 80092dc:	f8d4 3480 	ldr.w	r3, [r4, #1152]	; 0x480
 80092e0:	2b00      	cmp	r3, #0
 80092e2:	f000 814f 	beq.w	8009584 <USBH_Process+0x508>
        phost->pActiveClass = NULL;
 80092e6:	2100      	movs	r1, #0
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 80092e8:	f8d4 3478 	ldr.w	r3, [r4, #1144]	; 0x478
 80092ec:	f894 2447 	ldrb.w	r2, [r4, #1095]	; 0x447
        phost->pActiveClass = NULL;
 80092f0:	f8c4 147c 	str.w	r1, [r4, #1148]	; 0x47c
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 80092f4:	7919      	ldrb	r1, [r3, #4]
 80092f6:	4291      	cmp	r1, r2
 80092f8:	d122      	bne.n	8009340 <USBH_Process+0x2c4>
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 80092fa:	689a      	ldr	r2, [r3, #8]
 80092fc:	4620      	mov	r0, r4
            phost->pActiveClass = phost->pClass[idx];
 80092fe:	f8c4 347c 	str.w	r3, [r4, #1148]	; 0x47c
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 8009302:	4790      	blx	r2
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8009304:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 8009308:	2800      	cmp	r0, #0
 800930a:	f040 8142 	bne.w	8009592 <USBH_Process+0x516>
            phost->gState = HOST_CLASS_REQUEST;
 800930e:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8009310:	4858      	ldr	r0, [pc, #352]	; (8009474 <USBH_Process+0x3f8>)
            phost->gState = HOST_CLASS_REQUEST;
 8009312:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8009314:	6819      	ldr	r1, [r3, #0]
 8009316:	f016 ffdf 	bl	80202d8 <iprintf>
 800931a:	200a      	movs	r0, #10
 800931c:	f016 fff4 	bl	8020308 <putchar>
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 8009320:	f8d4 34d4 	ldr.w	r3, [r4, #1236]	; 0x4d4
 8009324:	2103      	movs	r1, #3
 8009326:	4620      	mov	r0, r4
 8009328:	4798      	blx	r3
 800932a:	e6fa      	b.n	8009122 <USBH_Process+0xa6>
          phost->gState = HOST_CLASS;
 800932c:	230b      	movs	r3, #11
 800932e:	7023      	strb	r3, [r4, #0]
 8009330:	e6f7      	b.n	8009122 <USBH_Process+0xa6>
          phost->Timeout += 10U;
 8009332:	330a      	adds	r3, #10
          USBH_Delay(10U);
 8009334:	200a      	movs	r0, #10
          phost->Timeout += 10U;
 8009336:	f8c4 34c8 	str.w	r3, [r4, #1224]	; 0x4c8
          USBH_Delay(10U);
 800933a:	f015 fcdf 	bl	801ecfc <USBH_Delay>
 800933e:	e6f0      	b.n	8009122 <USBH_Process+0xa6>
          phost->gState = HOST_ABORT_STATE;
 8009340:	230d      	movs	r3, #13
          USBH_UsrLog("No registered class for this device.");
 8009342:	484d      	ldr	r0, [pc, #308]	; (8009478 <USBH_Process+0x3fc>)
          phost->gState = HOST_ABORT_STATE;
 8009344:	7023      	strb	r3, [r4, #0]
          USBH_UsrLog("No registered class for this device.");
 8009346:	f016 ffc7 	bl	80202d8 <iprintf>
 800934a:	200a      	movs	r0, #10
 800934c:	f016 ffdc 	bl	8020308 <putchar>
  return USBH_OK;
 8009350:	e6e7      	b.n	8009122 <USBH_Process+0xa6>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 8009352:	f894 1436 	ldrb.w	r1, [r4, #1078]	; 0x436
 8009356:	2900      	cmp	r1, #0
 8009358:	f000 8173 	beq.w	8009642 <USBH_Process+0x5c6>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
                                        phost->device.Data, 0xFFU);
 800935c:	f504 7607 	add.w	r6, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 8009360:	23ff      	movs	r3, #255	; 0xff
 8009362:	4620      	mov	r0, r4
 8009364:	4632      	mov	r2, r6
 8009366:	f000 fc8b 	bl	8009c80 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800936a:	4605      	mov	r5, r0
 800936c:	2800      	cmp	r0, #0
 800936e:	f000 81b8 	beq.w	80096e2 <USBH_Process+0x666>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
        }
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8009372:	2803      	cmp	r0, #3
 8009374:	f000 8165 	beq.w	8009642 <USBH_Process+0x5c6>
  switch (phost->EnumState)
 8009378:	2501      	movs	r5, #1
      status = USBH_HandleEnum(phost);
 800937a:	f88d 5017 	strb.w	r5, [sp, #23]
      if (status == USBH_OK)
 800937e:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009382:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8009386:	2b00      	cmp	r3, #0
 8009388:	f47f aecb 	bne.w	8009122 <USBH_Process+0xa6>
        USBH_UsrLog("Enumeration done.");
 800938c:	483b      	ldr	r0, [pc, #236]	; (800947c <USBH_Process+0x400>)
 800938e:	f016 ffa3 	bl	80202d8 <iprintf>
 8009392:	200a      	movs	r0, #10
 8009394:	f016 ffb8 	bl	8020308 <putchar>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 8009398:	f894 3437 	ldrb.w	r3, [r4, #1079]	; 0x437
        phost->device.current_interface = 0U;
 800939c:	f884 5424 	strb.w	r5, [r4, #1060]	; 0x424
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 80093a0:	2b01      	cmp	r3, #1
 80093a2:	f000 8145 	beq.w	8009630 <USBH_Process+0x5b4>
          phost->gState = HOST_INPUT;
 80093a6:	2307      	movs	r3, #7
 80093a8:	7023      	strb	r3, [r4, #0]
 80093aa:	e6ba      	b.n	8009122 <USBH_Process+0xa6>
      if (phost->device.DevDesc.iProduct != 0U)
 80093ac:	f894 1435 	ldrb.w	r1, [r4, #1077]	; 0x435
 80093b0:	b159      	cbz	r1, 80093ca <USBH_Process+0x34e>
                                        phost->device.Data, 0xFFU);
 80093b2:	f504 7507 	add.w	r5, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 80093b6:	23ff      	movs	r3, #255	; 0xff
 80093b8:	4620      	mov	r0, r4
 80093ba:	462a      	mov	r2, r5
 80093bc:	f000 fc60 	bl	8009c80 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 80093c0:	2800      	cmp	r0, #0
 80093c2:	f000 8196 	beq.w	80096f2 <USBH_Process+0x676>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 80093c6:	2803      	cmp	r0, #3
 80093c8:	d1d6      	bne.n	8009378 <USBH_Process+0x2fc>
          USBH_UsrLog("Product : N/A");
 80093ca:	482d      	ldr	r0, [pc, #180]	; (8009480 <USBH_Process+0x404>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 80093cc:	2501      	movs	r5, #1
          USBH_UsrLog("Product : N/A");
 80093ce:	f016 ff83 	bl	80202d8 <iprintf>
 80093d2:	200a      	movs	r0, #10
 80093d4:	f016 ff98 	bl	8020308 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80093d8:	2307      	movs	r3, #7
 80093da:	7063      	strb	r3, [r4, #1]
 80093dc:	e7cd      	b.n	800937a <USBH_Process+0x2fe>
      if (phost->device.DevDesc.iManufacturer != 0U)
 80093de:	f894 1434 	ldrb.w	r1, [r4, #1076]	; 0x434
 80093e2:	b159      	cbz	r1, 80093fc <USBH_Process+0x380>
                                        phost->device.Data, 0xFFU);
 80093e4:	f504 7507 	add.w	r5, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 80093e8:	23ff      	movs	r3, #255	; 0xff
 80093ea:	4620      	mov	r0, r4
 80093ec:	462a      	mov	r2, r5
 80093ee:	f000 fc47 	bl	8009c80 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 80093f2:	2800      	cmp	r0, #0
 80093f4:	f000 8188 	beq.w	8009708 <USBH_Process+0x68c>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 80093f8:	2803      	cmp	r0, #3
 80093fa:	d1bd      	bne.n	8009378 <USBH_Process+0x2fc>
          USBH_UsrLog("Manufacturer : N/A");
 80093fc:	4821      	ldr	r0, [pc, #132]	; (8009484 <USBH_Process+0x408>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 80093fe:	2501      	movs	r5, #1
          USBH_UsrLog("Manufacturer : N/A");
 8009400:	f016 ff6a 	bl	80202d8 <iprintf>
 8009404:	200a      	movs	r0, #10
 8009406:	f016 ff7f 	bl	8020308 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800940a:	2306      	movs	r3, #6
 800940c:	7063      	strb	r3, [r4, #1]
 800940e:	e7b4      	b.n	800937a <USBH_Process+0x2fe>
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 8009410:	2108      	movs	r1, #8
 8009412:	4620      	mov	r0, r4
 8009414:	f000 face 	bl	80099b4 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 8009418:	4606      	mov	r6, r0
 800941a:	2800      	cmp	r0, #0
 800941c:	f000 8143 	beq.w	80096a6 <USBH_Process+0x62a>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8009420:	2803      	cmp	r0, #3
 8009422:	d1a9      	bne.n	8009378 <USBH_Process+0x2fc>
        USBH_ErrLog("Control error: Get Device Descriptor request failed");
 8009424:	4810      	ldr	r0, [pc, #64]	; (8009468 <USBH_Process+0x3ec>)
 8009426:	f016 ff57 	bl	80202d8 <iprintf>
 800942a:	4817      	ldr	r0, [pc, #92]	; (8009488 <USBH_Process+0x40c>)
 800942c:	f016 ff54 	bl	80202d8 <iprintf>
 8009430:	200a      	movs	r0, #10
 8009432:	f016 ff69 	bl	8020308 <putchar>
        phost->device.EnumCnt++;
 8009436:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 800943a:	3301      	adds	r3, #1
 800943c:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800943e:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 8009440:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 8009444:	f200 816b 	bhi.w	800971e <USBH_Process+0x6a2>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8009448:	7961      	ldrb	r1, [r4, #5]
 800944a:	4620      	mov	r0, r4
 800944c:	f001 f9a0 	bl	800a790 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8009450:	7921      	ldrb	r1, [r4, #4]
 8009452:	4620      	mov	r0, r4
  USBH_StatusTypeDef Status = USBH_BUSY;
 8009454:	2501      	movs	r5, #1
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8009456:	f001 f99b 	bl	800a790 <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 800945a:	2300      	movs	r3, #0
 800945c:	7023      	strb	r3, [r4, #0]
 800945e:	e78c      	b.n	800937a <USBH_Process+0x2fe>
 8009460:	08021a44 	.word	0x08021a44
 8009464:	08021d94 	.word	0x08021d94
 8009468:	08021984 	.word	0x08021984
 800946c:	08021d54 	.word	0x08021d54
 8009470:	08021c98 	.word	0x08021c98
 8009474:	08021d20 	.word	0x08021d20
 8009478:	08021dac 	.word	0x08021dac
 800947c:	08021c5c 	.word	0x08021c5c
 8009480:	08021c24 	.word	0x08021c24
 8009484:	08021c10 	.word	0x08021c10
 8009488:	08021aa4 	.word	0x08021aa4
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800948c:	f8b4 143a 	ldrh.w	r1, [r4, #1082]	; 0x43a
 8009490:	4620      	mov	r0, r4
 8009492:	f000 fae9 	bl	8009a68 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 8009496:	2800      	cmp	r0, #0
 8009498:	f040 80a6 	bne.w	80095e8 <USBH_Process+0x56c>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800949c:	2305      	movs	r3, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
 800949e:	2501      	movs	r5, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 80094a0:	7063      	strb	r3, [r4, #1]
 80094a2:	e76a      	b.n	800937a <USBH_Process+0x2fe>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 80094a4:	2109      	movs	r1, #9
 80094a6:	4620      	mov	r0, r4
 80094a8:	f000 fade 	bl	8009a68 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 80094ac:	2800      	cmp	r0, #0
 80094ae:	f040 809b 	bne.w	80095e8 <USBH_Process+0x56c>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 80094b2:	2304      	movs	r3, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
 80094b4:	2501      	movs	r5, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 80094b6:	7063      	strb	r3, [r4, #1]
 80094b8:	e75f      	b.n	800937a <USBH_Process+0x2fe>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 80094ba:	2101      	movs	r1, #1
 80094bc:	4620      	mov	r0, r4
 80094be:	f000 fc1d 	bl	8009cfc <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
 80094c2:	4606      	mov	r6, r0
 80094c4:	2800      	cmp	r0, #0
 80094c6:	f000 80c4 	beq.w	8009652 <USBH_Process+0x5d6>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80094ca:	2803      	cmp	r0, #3
 80094cc:	f47f af54 	bne.w	8009378 <USBH_Process+0x2fc>
        USBH_ErrLog("Control error: Device Set Address request failed");
 80094d0:	489a      	ldr	r0, [pc, #616]	; (800973c <USBH_Process+0x6c0>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 80094d2:	2501      	movs	r5, #1
        USBH_ErrLog("Control error: Device Set Address request failed");
 80094d4:	f016 ff00 	bl	80202d8 <iprintf>
 80094d8:	4899      	ldr	r0, [pc, #612]	; (8009740 <USBH_Process+0x6c4>)
 80094da:	f016 fefd 	bl	80202d8 <iprintf>
 80094de:	200a      	movs	r0, #10
 80094e0:	f016 ff12 	bl	8020308 <putchar>
        USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 80094e4:	4897      	ldr	r0, [pc, #604]	; (8009744 <USBH_Process+0x6c8>)
 80094e6:	f016 fef7 	bl	80202d8 <iprintf>
 80094ea:	200a      	movs	r0, #10
 80094ec:	f016 ff0c 	bl	8020308 <putchar>
        phost->gState = HOST_ABORT_STATE;
 80094f0:	220d      	movs	r2, #13
        phost->EnumState = ENUM_IDLE;
 80094f2:	2300      	movs	r3, #0
        phost->gState = HOST_ABORT_STATE;
 80094f4:	7022      	strb	r2, [r4, #0]
        phost->EnumState = ENUM_IDLE;
 80094f6:	7063      	strb	r3, [r4, #1]
 80094f8:	e73f      	b.n	800937a <USBH_Process+0x2fe>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 80094fa:	2112      	movs	r1, #18
 80094fc:	4620      	mov	r0, r4
 80094fe:	f000 fa59 	bl	80099b4 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 8009502:	2800      	cmp	r0, #0
 8009504:	f000 80da 	beq.w	80096bc <USBH_Process+0x640>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8009508:	2803      	cmp	r0, #3
 800950a:	f47f af35 	bne.w	8009378 <USBH_Process+0x2fc>
        USBH_ErrLog("Control error: Get Full Device Descriptor request failed");
 800950e:	488b      	ldr	r0, [pc, #556]	; (800973c <USBH_Process+0x6c0>)
 8009510:	f016 fee2 	bl	80202d8 <iprintf>
 8009514:	488c      	ldr	r0, [pc, #560]	; (8009748 <USBH_Process+0x6cc>)
 8009516:	f016 fedf 	bl	80202d8 <iprintf>
 800951a:	200a      	movs	r0, #10
 800951c:	f016 fef4 	bl	8020308 <putchar>
        phost->device.EnumCnt++;
 8009520:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 8009524:	3301      	adds	r3, #1
 8009526:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 8009528:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800952a:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 800952e:	f240 80f9 	bls.w	8009724 <USBH_Process+0x6a8>
          USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 8009532:	4884      	ldr	r0, [pc, #528]	; (8009744 <USBH_Process+0x6c8>)
 8009534:	f016 fed0 	bl	80202d8 <iprintf>
 8009538:	200a      	movs	r0, #10
 800953a:	f016 fee5 	bl	8020308 <putchar>
          phost->gState = HOST_ABORT_STATE;
 800953e:	230d      	movs	r3, #13
 8009540:	7023      	strb	r3, [r4, #0]
 8009542:	e71a      	b.n	800937a <USBH_Process+0x2fe>
        phost->device.is_ReEnumerated = 0U;
 8009544:	2300      	movs	r3, #0
	  (void)USBH_LL_DriverVBUS(phost, TRUE);
 8009546:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
 8009548:	f884 3422 	strb.w	r3, [r4, #1058]	; 0x422
	  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800954c:	f015 fb9a 	bl	801ec84 <USBH_LL_DriverVBUS>
  (void)USBH_LL_Start(phost);
 8009550:	4620      	mov	r0, r4
 8009552:	f015 fb3f 	bl	801ebd4 <USBH_LL_Start>
  return USBH_OK;
 8009556:	e5e4      	b.n	8009122 <USBH_Process+0xa6>
        status = USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP);
 8009558:	2101      	movs	r1, #1
 800955a:	4620      	mov	r0, r4
 800955c:	f000 fd9e 	bl	800a09c <USBH_SetFeature>
 8009560:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 8009564:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009568:	2b00      	cmp	r3, #0
 800956a:	d05f      	beq.n	800962c <USBH_Process+0x5b0>
        else if (status == USBH_NOT_SUPPORTED)
 800956c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009570:	2b03      	cmp	r3, #3
 8009572:	f47f add6 	bne.w	8009122 <USBH_Process+0xa6>
          USBH_UsrLog("Remote wakeup not supported by the device");
 8009576:	4875      	ldr	r0, [pc, #468]	; (800974c <USBH_Process+0x6d0>)
 8009578:	f016 feae 	bl	80202d8 <iprintf>
 800957c:	200a      	movs	r0, #10
 800957e:	f016 fec3 	bl	8020308 <putchar>
 8009582:	e6a8      	b.n	80092d6 <USBH_Process+0x25a>
        USBH_UsrLog("No Class has been registered.");
 8009584:	4872      	ldr	r0, [pc, #456]	; (8009750 <USBH_Process+0x6d4>)
 8009586:	f016 fea7 	bl	80202d8 <iprintf>
 800958a:	200a      	movs	r0, #10
 800958c:	f016 febc 	bl	8020308 <putchar>
 8009590:	e5c7      	b.n	8009122 <USBH_Process+0xa6>
            phost->gState = HOST_ABORT_STATE;
 8009592:	220d      	movs	r2, #13
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 8009594:	486f      	ldr	r0, [pc, #444]	; (8009754 <USBH_Process+0x6d8>)
            phost->gState = HOST_ABORT_STATE;
 8009596:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 8009598:	6819      	ldr	r1, [r3, #0]
 800959a:	f016 fe9d 	bl	80202d8 <iprintf>
 800959e:	200a      	movs	r0, #10
 80095a0:	f016 feb2 	bl	8020308 <putchar>
 80095a4:	e5bd      	b.n	8009122 <USBH_Process+0xa6>
        USBH_UsrLog("USB Device Reset Completed");
 80095a6:	486c      	ldr	r0, [pc, #432]	; (8009758 <USBH_Process+0x6dc>)
 80095a8:	f016 fe96 	bl	80202d8 <iprintf>
 80095ac:	200a      	movs	r0, #10
 80095ae:	f016 feab 	bl	8020308 <putchar>
        phost->device.RstCnt = 0U;
 80095b2:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
 80095b4:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
 80095b6:	f884 241f 	strb.w	r2, [r4, #1055]	; 0x41f
        phost->gState = HOST_DEV_ATTACHED;
 80095ba:	7023      	strb	r3, [r4, #0]
 80095bc:	e5b1      	b.n	8009122 <USBH_Process+0xa6>
            USBH_UsrLog("USB Reset Failed, Please unplug the Device.");
 80095be:	4867      	ldr	r0, [pc, #412]	; (800975c <USBH_Process+0x6e0>)
 80095c0:	f016 fe8a 	bl	80202d8 <iprintf>
 80095c4:	200a      	movs	r0, #10
 80095c6:	f016 fe9f 	bl	8020308 <putchar>
            phost->gState = HOST_ABORT_STATE;
 80095ca:	230d      	movs	r3, #13
 80095cc:	7023      	strb	r3, [r4, #0]
 80095ce:	e5a8      	b.n	8009122 <USBH_Process+0xa6>
        phost->gState = HOST_ABORT_STATE;
 80095d0:	230d      	movs	r3, #13
        USBH_ErrLog("Invalid Class Driver.");
 80095d2:	485a      	ldr	r0, [pc, #360]	; (800973c <USBH_Process+0x6c0>)
        phost->gState = HOST_ABORT_STATE;
 80095d4:	7023      	strb	r3, [r4, #0]
        USBH_ErrLog("Invalid Class Driver.");
 80095d6:	f016 fe7f 	bl	80202d8 <iprintf>
 80095da:	4861      	ldr	r0, [pc, #388]	; (8009760 <USBH_Process+0x6e4>)
 80095dc:	f016 fe7c 	bl	80202d8 <iprintf>
 80095e0:	200a      	movs	r0, #10
 80095e2:	f016 fe91 	bl	8020308 <putchar>
 80095e6:	e59c      	b.n	8009122 <USBH_Process+0xa6>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80095e8:	2803      	cmp	r0, #3
 80095ea:	f47f aec5 	bne.w	8009378 <USBH_Process+0x2fc>
        USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
 80095ee:	4853      	ldr	r0, [pc, #332]	; (800973c <USBH_Process+0x6c0>)
 80095f0:	f016 fe72 	bl	80202d8 <iprintf>
 80095f4:	485b      	ldr	r0, [pc, #364]	; (8009764 <USBH_Process+0x6e8>)
 80095f6:	f016 fe6f 	bl	80202d8 <iprintf>
 80095fa:	200a      	movs	r0, #10
 80095fc:	f016 fe84 	bl	8020308 <putchar>
        phost->device.EnumCnt++;
 8009600:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 8009604:	3301      	adds	r3, #1
 8009606:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 8009608:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800960a:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 800960e:	f200 8086 	bhi.w	800971e <USBH_Process+0x6a2>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8009612:	7961      	ldrb	r1, [r4, #5]
 8009614:	4620      	mov	r0, r4
 8009616:	f001 f8bb 	bl	800a790 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800961a:	7921      	ldrb	r1, [r4, #4]
 800961c:	4620      	mov	r0, r4
  USBH_StatusTypeDef Status = USBH_BUSY;
 800961e:	2501      	movs	r5, #1
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8009620:	f001 f8b6 	bl	800a790 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8009624:	2300      	movs	r3, #0
 8009626:	7063      	strb	r3, [r4, #1]
          phost->gState = HOST_IDLE;
 8009628:	7023      	strb	r3, [r4, #0]
 800962a:	e6a6      	b.n	800937a <USBH_Process+0x2fe>
          USBH_UsrLog("Device remote wakeup enabled");
 800962c:	484e      	ldr	r0, [pc, #312]	; (8009768 <USBH_Process+0x6ec>)
 800962e:	e7a3      	b.n	8009578 <USBH_Process+0x4fc>
          USBH_UsrLog("This device has only 1 configuration.");
 8009630:	484e      	ldr	r0, [pc, #312]	; (800976c <USBH_Process+0x6f0>)
 8009632:	f016 fe51 	bl	80202d8 <iprintf>
 8009636:	200a      	movs	r0, #10
 8009638:	f016 fe66 	bl	8020308 <putchar>
          phost->gState = HOST_SET_CONFIGURATION;
 800963c:	2308      	movs	r3, #8
 800963e:	7023      	strb	r3, [r4, #0]
 8009640:	e56f      	b.n	8009122 <USBH_Process+0xa6>
        {
          USBH_UsrLog("Serial Number : N/A");
 8009642:	484b      	ldr	r0, [pc, #300]	; (8009770 <USBH_Process+0x6f4>)
          Status = USBH_OK;
 8009644:	2500      	movs	r5, #0
          USBH_UsrLog("Serial Number : N/A");
 8009646:	f016 fe47 	bl	80202d8 <iprintf>
 800964a:	200a      	movs	r0, #10
 800964c:	f016 fe5c 	bl	8020308 <putchar>
          Status = USBH_OK;
 8009650:	e693      	b.n	800937a <USBH_Process+0x2fe>
        phost->device.address = USBH_DEVICE_ADDRESS;
 8009652:	2501      	movs	r5, #1
        USBH_Delay(2U);
 8009654:	2002      	movs	r0, #2
 8009656:	f015 fb51 	bl	801ecfc <USBH_Delay>
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 800965a:	4846      	ldr	r0, [pc, #280]	; (8009774 <USBH_Process+0x6f8>)
 800965c:	4629      	mov	r1, r5
        phost->device.address = USBH_DEVICE_ADDRESS;
 800965e:	f884 541c 	strb.w	r5, [r4, #1052]	; 0x41c
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 8009662:	f016 fe39 	bl	80202d8 <iprintf>
 8009666:	200a      	movs	r0, #10
 8009668:	f016 fe4e 	bl	8020308 <putchar>
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800966c:	79a1      	ldrb	r1, [r4, #6]
 800966e:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
        phost->EnumState = ENUM_GET_CFG_DESC;
 8009672:	2203      	movs	r2, #3
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8009674:	9102      	str	r1, [sp, #8]
        phost->EnumState = ENUM_GET_CFG_DESC;
 8009676:	7062      	strb	r2, [r4, #1]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8009678:	e9cd 3600 	strd	r3, r6, [sp]
 800967c:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 8009680:	2280      	movs	r2, #128	; 0x80
 8009682:	7921      	ldrb	r1, [r4, #4]
 8009684:	4620      	mov	r0, r4
 8009686:	f001 f81f 	bl	800a6c8 <USBH_OpenPipe>
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800968a:	79a1      	ldrb	r1, [r4, #6]
 800968c:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
 8009690:	4632      	mov	r2, r6
 8009692:	9601      	str	r6, [sp, #4]
 8009694:	4620      	mov	r0, r4
 8009696:	9102      	str	r1, [sp, #8]
 8009698:	9300      	str	r3, [sp, #0]
 800969a:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 800969e:	7961      	ldrb	r1, [r4, #5]
 80096a0:	f001 f812 	bl	800a6c8 <USBH_OpenPipe>
 80096a4:	e669      	b.n	800937a <USBH_Process+0x2fe>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 80096a6:	f894 342d 	ldrb.w	r3, [r4, #1069]	; 0x42d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 80096aa:	2501      	movs	r5, #1
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 80096ac:	f894 241d 	ldrb.w	r2, [r4, #1053]	; 0x41d
 80096b0:	9001      	str	r0, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 80096b2:	71a3      	strb	r3, [r4, #6]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 80096b4:	7065      	strb	r5, [r4, #1]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 80096b6:	9302      	str	r3, [sp, #8]
 80096b8:	9200      	str	r2, [sp, #0]
 80096ba:	e7df      	b.n	800967c <USBH_Process+0x600>
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
 80096bc:	f8b4 1430 	ldrh.w	r1, [r4, #1072]	; 0x430
 80096c0:	482d      	ldr	r0, [pc, #180]	; (8009778 <USBH_Process+0x6fc>)
 80096c2:	f016 fe09 	bl	80202d8 <iprintf>
 80096c6:	200a      	movs	r0, #10
 80096c8:	f016 fe1e 	bl	8020308 <putchar>
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);
 80096cc:	f8b4 142e 	ldrh.w	r1, [r4, #1070]	; 0x42e
 80096d0:	482a      	ldr	r0, [pc, #168]	; (800977c <USBH_Process+0x700>)
 80096d2:	f016 fe01 	bl	80202d8 <iprintf>
 80096d6:	200a      	movs	r0, #10
 80096d8:	f016 fe16 	bl	8020308 <putchar>
        phost->EnumState = ENUM_SET_ADDR;
 80096dc:	2302      	movs	r3, #2
 80096de:	7063      	strb	r3, [r4, #1]
 80096e0:	e64b      	b.n	800937a <USBH_Process+0x2fe>
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
 80096e2:	4631      	mov	r1, r6
 80096e4:	4826      	ldr	r0, [pc, #152]	; (8009780 <USBH_Process+0x704>)
 80096e6:	f016 fdf7 	bl	80202d8 <iprintf>
 80096ea:	200a      	movs	r0, #10
 80096ec:	f016 fe0c 	bl	8020308 <putchar>
          Status = USBH_OK;
 80096f0:	e643      	b.n	800937a <USBH_Process+0x2fe>
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
 80096f2:	4629      	mov	r1, r5
 80096f4:	4823      	ldr	r0, [pc, #140]	; (8009784 <USBH_Process+0x708>)
 80096f6:	f016 fdef 	bl	80202d8 <iprintf>
 80096fa:	200a      	movs	r0, #10
 80096fc:	f016 fe04 	bl	8020308 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 8009700:	2307      	movs	r3, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
 8009702:	2501      	movs	r5, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 8009704:	7063      	strb	r3, [r4, #1]
 8009706:	e638      	b.n	800937a <USBH_Process+0x2fe>
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
 8009708:	4629      	mov	r1, r5
 800970a:	481f      	ldr	r0, [pc, #124]	; (8009788 <USBH_Process+0x70c>)
 800970c:	f016 fde4 	bl	80202d8 <iprintf>
 8009710:	200a      	movs	r0, #10
 8009712:	f016 fdf9 	bl	8020308 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 8009716:	2306      	movs	r3, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
 8009718:	2501      	movs	r5, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800971a:	7063      	strb	r3, [r4, #1]
 800971c:	e62d      	b.n	800937a <USBH_Process+0x2fe>
          USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 800971e:	4809      	ldr	r0, [pc, #36]	; (8009744 <USBH_Process+0x6c8>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 8009720:	2501      	movs	r5, #1
 8009722:	e707      	b.n	8009534 <USBH_Process+0x4b8>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8009724:	7961      	ldrb	r1, [r4, #5]
 8009726:	4620      	mov	r0, r4
 8009728:	f001 f832 	bl	800a790 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800972c:	7921      	ldrb	r1, [r4, #4]
 800972e:	4620      	mov	r0, r4
 8009730:	f001 f82e 	bl	800a790 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8009734:	2300      	movs	r3, #0
 8009736:	7063      	strb	r3, [r4, #1]
          phost->gState = HOST_IDLE;
 8009738:	7023      	strb	r3, [r4, #0]
 800973a:	e61e      	b.n	800937a <USBH_Process+0x2fe>
 800973c:	08021984 	.word	0x08021984
 8009740:	08021b84 	.word	0x08021b84
 8009744:	08021ad8 	.word	0x08021ad8
 8009748:	08021b30 	.word	0x08021b30
 800974c:	08021cd4 	.word	0x08021cd4
 8009750:	08021d00 	.word	0x08021d00
 8009754:	08021d34 	.word	0x08021d34
 8009758:	08021a5c 	.word	0x08021a5c
 800975c:	08021a78 	.word	0x08021a78
 8009760:	08021d7c 	.word	0x08021d7c
 8009764:	08021bb8 	.word	0x08021bb8
 8009768:	08021cb4 	.word	0x08021cb4
 800976c:	08021c70 	.word	0x08021c70
 8009770:	08021c48 	.word	0x08021c48
 8009774:	08021b6c 	.word	0x08021b6c
 8009778:	08021b18 	.word	0x08021b18
 800977c:	08021b24 	.word	0x08021b24
 8009780:	08021c34 	.word	0x08021c34
 8009784:	08021878 	.word	0x08021878
 8009788:	08021bfc 	.word	0x08021bfc

0800978c <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
 800978c:	f8c0 14c4 	str.w	r1, [r0, #1220]	; 0x4c4
}
 8009790:	4770      	bx	lr
 8009792:	bf00      	nop

08009794 <USBH_LL_IncTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
  phost->Timer++;
 8009794:	f8d0 24c4 	ldr.w	r2, [r0, #1220]	; 0x4c4
 8009798:	3201      	adds	r2, #1
 800979a:	f8c0 24c4 	str.w	r2, [r0, #1220]	; 0x4c4
  * @param  phost: Host Handle
  * @retval None
  */
static void USBH_HandleSof(USBH_HandleTypeDef *phost)
{
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800979e:	7802      	ldrb	r2, [r0, #0]
 80097a0:	2a0b      	cmp	r2, #11
 80097a2:	d000      	beq.n	80097a6 <USBH_LL_IncTimer+0x12>
}
 80097a4:	4770      	bx	lr
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 80097a6:	f8d0 347c 	ldr.w	r3, [r0, #1148]	; 0x47c
 80097aa:	2b00      	cmp	r3, #0
 80097ac:	d0fa      	beq.n	80097a4 <USBH_LL_IncTimer+0x10>
  {
    phost->pActiveClass->SOFProcess(phost);
 80097ae:	699b      	ldr	r3, [r3, #24]
 80097b0:	4718      	bx	r3
 80097b2:	bf00      	nop

080097b4 <USBH_LL_PortEnabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 1U;
 80097b4:	2301      	movs	r3, #1
 80097b6:	f880 3423 	strb.w	r3, [r0, #1059]	; 0x423
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return;
}
 80097ba:	4770      	bx	lr

080097bc <USBH_LL_PortDisabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 0U;
 80097bc:	2300      	movs	r3, #0
 80097be:	f880 3423 	strb.w	r3, [r0, #1059]	; 0x423

  return;
}
 80097c2:	4770      	bx	lr

080097c4 <USBH_LL_Connect>:
  *         Handle USB Host connection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 80097c4:	4603      	mov	r3, r0
  phost->device.is_connected = 1U;
  phost->device.is_disconnected = 0U;
 80097c6:	2200      	movs	r2, #0
  phost->device.is_connected = 1U;
 80097c8:	2101      	movs	r1, #1
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
}
 80097ca:	4610      	mov	r0, r2
  phost->device.is_connected = 1U;
 80097cc:	f883 1420 	strb.w	r1, [r3, #1056]	; 0x420
  phost->device.is_disconnected = 0U;
 80097d0:	f883 2421 	strb.w	r2, [r3, #1057]	; 0x421
  phost->device.is_ReEnumerated = 0U;
 80097d4:	f883 2422 	strb.w	r2, [r3, #1058]	; 0x422
}
 80097d8:	4770      	bx	lr
 80097da:	bf00      	nop

080097dc <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 80097dc:	b538      	push	{r3, r4, r5, lr}
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 80097de:	2301      	movs	r3, #1
  phost->device.is_connected = 0U;
 80097e0:	2500      	movs	r5, #0
{
 80097e2:	4604      	mov	r4, r0
  phost->device.is_disconnected = 1U;
 80097e4:	f880 3421 	strb.w	r3, [r0, #1057]	; 0x421
  phost->device.PortEnabled = 0U;
 80097e8:	f880 5423 	strb.w	r5, [r0, #1059]	; 0x423
  phost->device.is_connected = 0U;
 80097ec:	f880 5420 	strb.w	r5, [r0, #1056]	; 0x420

  /* Stop Host */
  (void)USBH_LL_Stop(phost);
 80097f0:	f015 f9f8 	bl	801ebe4 <USBH_LL_Stop>

  /* FRee Control Pipes */
  (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 80097f4:	7921      	ldrb	r1, [r4, #4]
 80097f6:	4620      	mov	r0, r4
 80097f8:	f000 ffca 	bl	800a790 <USBH_FreePipe>
  (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 80097fc:	7961      	ldrb	r1, [r4, #5]
 80097fe:	4620      	mov	r0, r4
 8009800:	f000 ffc6 	bl	800a790 <USBH_FreePipe>
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
}
 8009804:	4628      	mov	r0, r5
 8009806:	bd38      	pop	{r3, r4, r5, pc}

08009808 <USBH_CtlReq.part.0>:
  * @param  req: Setup Request Structure
  * @param  buff: data buffer address to store the response
  * @param  length: length of the response
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
 8009808:	b530      	push	{r4, r5, lr}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
 800980a:	7e05      	ldrb	r5, [r0, #24]
USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
 800980c:	b083      	sub	sp, #12
 800980e:	4604      	mov	r4, r0
  switch (phost->Control.state)
 8009810:	1e6b      	subs	r3, r5, #1
 8009812:	2b0a      	cmp	r3, #10
 8009814:	d828      	bhi.n	8009868 <USBH_CtlReq.part.0+0x60>
 8009816:	e8df f003 	tbb	[pc, r3]
 800981a:	1c14      	.short	0x1c14
 800981c:	7669892b 	.word	0x7669892b
 8009820:	5c4f4438 	.word	0x5c4f4438
 8009824:	06          	.byte	0x06
 8009825:	00          	.byte	0x00
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8009826:	7e43      	ldrb	r3, [r0, #25]
 8009828:	3301      	adds	r3, #1
 800982a:	b2db      	uxtb	r3, r3
 800982c:	2b02      	cmp	r3, #2
 800982e:	7643      	strb	r3, [r0, #25]
 8009830:	f200 8096 	bhi.w	8009960 <USBH_CtlReq.part.0+0x158>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 8009834:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 8009836:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 8009838:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800983a:	7083      	strb	r3, [r0, #2]
}
 800983c:	4628      	mov	r0, r5
 800983e:	b003      	add	sp, #12
 8009840:	bd30      	pop	{r4, r5, pc}
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8009842:	7942      	ldrb	r2, [r0, #5]
 8009844:	f100 0110 	add.w	r1, r0, #16
 8009848:	f000 feda 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800984c:	2302      	movs	r3, #2
 800984e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009850:	e7f4      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009852:	7941      	ldrb	r1, [r0, #5]
 8009854:	f015 fa12 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009858:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800985a:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 800985c:	f000 8099 	beq.w	8009992 <USBH_CtlReq.part.0+0x18a>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8009860:	2804      	cmp	r0, #4
 8009862:	d03f      	beq.n	80098e4 <USBH_CtlReq.part.0+0xdc>
 8009864:	2802      	cmp	r0, #2
 8009866:	d03d      	beq.n	80098e4 <USBH_CtlReq.part.0+0xdc>
  switch (phost->Control.state)
 8009868:	2501      	movs	r5, #1
}
 800986a:	4628      	mov	r0, r5
 800986c:	b003      	add	sp, #12
 800986e:	bd30      	pop	{r4, r5, pc}
      phost->Control.timer = (uint16_t)phost->Timer;
 8009870:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 8009874:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 8009876:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8009878:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800987a:	4620      	mov	r0, r4
 800987c:	89a2      	ldrh	r2, [r4, #12]
 800987e:	68a1      	ldr	r1, [r4, #8]
 8009880:	f000 fee8 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8009884:	2304      	movs	r3, #4
 8009886:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009888:	e7d8      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800988a:	2200      	movs	r2, #0
 800988c:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 800988e:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8009890:	4611      	mov	r1, r2
 8009892:	f000 fedf 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009896:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800989a:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 800989c:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800989e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80098a0:	e7cc      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80098a2:	7901      	ldrb	r1, [r0, #4]
 80098a4:	f015 f9ea 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80098a8:	2801      	cmp	r0, #1
 80098aa:	d04d      	beq.n	8009948 <USBH_CtlReq.part.0+0x140>
      else if (URB_Status == USBH_URB_ERROR)
 80098ac:	2804      	cmp	r0, #4
 80098ae:	d019      	beq.n	80098e4 <USBH_CtlReq.part.0+0xdc>
        if (URB_Status == USBH_URB_STALL)
 80098b0:	2805      	cmp	r0, #5
 80098b2:	d1d9      	bne.n	8009868 <USBH_CtlReq.part.0+0x60>
        status = USBH_NOT_SUPPORTED;
 80098b4:	2503      	movs	r5, #3
 80098b6:	e048      	b.n	800994a <USBH_CtlReq.part.0+0x142>
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 80098b8:	2200      	movs	r2, #0
 80098ba:	2501      	movs	r5, #1
 80098bc:	7943      	ldrb	r3, [r0, #5]
 80098be:	4611      	mov	r1, r2
 80098c0:	9500      	str	r5, [sp, #0]
 80098c2:	f000 fead 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80098c6:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80098ca:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 80098cc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80098ce:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80098d0:	e7b4      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80098d2:	7941      	ldrb	r1, [r0, #5]
 80098d4:	f015 f9d2 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80098d8:	2801      	cmp	r0, #1
 80098da:	d035      	beq.n	8009948 <USBH_CtlReq.part.0+0x140>
      else if (URB_Status == USBH_URB_NOTREADY)
 80098dc:	2802      	cmp	r0, #2
 80098de:	d02f      	beq.n	8009940 <USBH_CtlReq.part.0+0x138>
        if (URB_Status == USBH_URB_ERROR)
 80098e0:	2804      	cmp	r0, #4
 80098e2:	d1c1      	bne.n	8009868 <USBH_CtlReq.part.0+0x60>
          phost->Control.state = CTRL_ERROR;
 80098e4:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 80098e6:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 80098e8:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80098ea:	e7a7      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 80098ec:	2501      	movs	r5, #1
 80098ee:	7943      	ldrb	r3, [r0, #5]
 80098f0:	8982      	ldrh	r2, [r0, #12]
 80098f2:	6881      	ldr	r1, [r0, #8]
 80098f4:	9500      	str	r5, [sp, #0]
 80098f6:	f000 fe93 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80098fa:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80098fe:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 8009900:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8009902:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009904:	e79a      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009906:	7941      	ldrb	r1, [r0, #5]
 8009908:	f015 f9b8 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800990c:	2801      	cmp	r0, #1
 800990e:	d023      	beq.n	8009958 <USBH_CtlReq.part.0+0x150>
      else if (URB_Status == USBH_URB_STALL)
 8009910:	2805      	cmp	r0, #5
 8009912:	d0cf      	beq.n	80098b4 <USBH_CtlReq.part.0+0xac>
      else if (URB_Status == USBH_URB_NOTREADY)
 8009914:	2802      	cmp	r0, #2
 8009916:	d042      	beq.n	800999e <USBH_CtlReq.part.0+0x196>
        if (URB_Status == USBH_URB_ERROR)
 8009918:	2804      	cmp	r0, #4
 800991a:	d1a5      	bne.n	8009868 <USBH_CtlReq.part.0+0x60>
          phost->Control.state = CTRL_ERROR;
 800991c:	230b      	movs	r3, #11
 800991e:	7623      	strb	r3, [r4, #24]
      status = USBH_HandleControl(phost);
 8009920:	2502      	movs	r5, #2
        phost->RequestState = CMD_SEND;
 8009922:	2301      	movs	r3, #1
}
 8009924:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 8009926:	70a3      	strb	r3, [r4, #2]
}
 8009928:	b003      	add	sp, #12
 800992a:	bd30      	pop	{r4, r5, pc}
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800992c:	7901      	ldrb	r1, [r0, #4]
 800992e:	f015 f9a5 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009932:	2801      	cmp	r0, #1
 8009934:	d004      	beq.n	8009940 <USBH_CtlReq.part.0+0x138>
      if (URB_Status == USBH_URB_STALL)
 8009936:	2805      	cmp	r0, #5
 8009938:	d1d2      	bne.n	80098e0 <USBH_CtlReq.part.0+0xd8>
 800993a:	e7bb      	b.n	80098b4 <USBH_CtlReq.part.0+0xac>
          if (direction == USB_D2H)
 800993c:	061b      	lsls	r3, r3, #24
 800993e:	d50b      	bpl.n	8009958 <USBH_CtlReq.part.0+0x150>
            phost->Control.state = CTRL_STATUS_OUT;
 8009940:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 8009942:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 8009944:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009946:	e779      	b.n	800983c <USBH_CtlReq.part.0+0x34>
        status = USBH_OK;
 8009948:	2500      	movs	r5, #0
        phost->RequestState = CMD_SEND;
 800994a:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800994c:	2300      	movs	r3, #0
}
 800994e:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 8009950:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8009952:	7623      	strb	r3, [r4, #24]
}
 8009954:	b003      	add	sp, #12
 8009956:	bd30      	pop	{r4, r5, pc}
            phost->Control.state = CTRL_STATUS_IN;
 8009958:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800995a:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800995c:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800995e:	e76d      	b.n	800983c <USBH_CtlReq.part.0+0x34>
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
 8009960:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8009962:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 8009966:	2106      	movs	r1, #6
 8009968:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800996a:	4810      	ldr	r0, [pc, #64]	; (80099ac <USBH_CtlReq.part.0+0x1a4>)
        phost->Control.errorcount = 0U;
 800996c:	7665      	strb	r5, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800996e:	f016 fcb3 	bl	80202d8 <iprintf>
 8009972:	480f      	ldr	r0, [pc, #60]	; (80099b0 <USBH_CtlReq.part.0+0x1a8>)
 8009974:	f016 fcb0 	bl	80202d8 <iprintf>
 8009978:	200a      	movs	r0, #10
 800997a:	f016 fcc5 	bl	8020308 <putchar>

        /* Free control pipes */
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800997e:	7961      	ldrb	r1, [r4, #5]
 8009980:	4620      	mov	r0, r4
 8009982:	f000 ff05 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8009986:	7921      	ldrb	r1, [r4, #4]
 8009988:	4620      	mov	r0, r4
 800998a:	f000 ff01 	bl	800a790 <USBH_FreePipe>

        phost->gState = HOST_IDLE;
 800998e:	7025      	strb	r5, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009990:	e7c6      	b.n	8009920 <USBH_CtlReq.part.0+0x118>
        if (phost->Control.setup.b.wLength.w != 0U)
 8009992:	8ae2      	ldrh	r2, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 8009994:	7c23      	ldrb	r3, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 8009996:	2a00      	cmp	r2, #0
 8009998:	d0d0      	beq.n	800993c <USBH_CtlReq.part.0+0x134>
          if (direction == USB_D2H)
 800999a:	061a      	lsls	r2, r3, #24
 800999c:	d403      	bmi.n	80099a6 <USBH_CtlReq.part.0+0x19e>
            phost->Control.state = CTRL_DATA_OUT;
 800999e:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 80099a0:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 80099a2:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80099a4:	e74a      	b.n	800983c <USBH_CtlReq.part.0+0x34>
            phost->Control.state = CTRL_DATA_IN;
 80099a6:	2303      	movs	r3, #3
 80099a8:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80099aa:	e747      	b.n	800983c <USBH_CtlReq.part.0+0x34>
 80099ac:	08021984 	.word	0x08021984
 80099b0:	08021dd4 	.word	0x08021dd4

080099b4 <USBH_Get_DevDesc>:
{
 80099b4:	b538      	push	{r3, r4, r5, lr}
  if (phost->RequestState == CMD_SEND)
 80099b6:	7883      	ldrb	r3, [r0, #2]
{
 80099b8:	4604      	mov	r4, r0
  status = USBH_GetDescriptor(phost,
 80099ba:	460d      	mov	r5, r1
  if (phost->RequestState == CMD_SEND)
 80099bc:	2b01      	cmp	r3, #1
 80099be:	d039      	beq.n	8009a34 <USBH_Get_DevDesc+0x80>
  switch (phost->RequestState)
 80099c0:	2b02      	cmp	r3, #2
 80099c2:	d134      	bne.n	8009a2e <USBH_Get_DevDesc+0x7a>
 80099c4:	f7ff ff20 	bl	8009808 <USBH_CtlReq.part.0>
  if (status == USBH_OK)
 80099c8:	4603      	mov	r3, r0
 80099ca:	bb88      	cbnz	r0, 8009a30 <USBH_Get_DevDesc+0x7c>
  dev_desc->bcdUSB             = LE16(buf +  2);
 80099cc:	f8b4 221e 	ldrh.w	r2, [r4, #542]	; 0x21e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 80099d0:	f8b4 121c 	ldrh.w	r1, [r4, #540]	; 0x21c
  dev_desc->bcdUSB             = LE16(buf +  2);
 80099d4:	f8a4 2428 	strh.w	r2, [r4, #1064]	; 0x428
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6);
 80099d8:	f894 2222 	ldrb.w	r2, [r4, #546]	; 0x222
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 80099dc:	f8a4 1426 	strh.w	r1, [r4, #1062]	; 0x426
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6);
 80099e0:	f884 242c 	strb.w	r2, [r4, #1068]	; 0x42c
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7);
 80099e4:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 80099e8:	f8b4 1220 	ldrh.w	r1, [r4, #544]	; 0x220
  switch (dev_desc->bMaxPacketSize)
 80099ec:	2a20      	cmp	r2, #32
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 80099ee:	f8a4 142a 	strh.w	r1, [r4, #1066]	; 0x42a
  switch (dev_desc->bMaxPacketSize)
 80099f2:	d82d      	bhi.n	8009a50 <USBH_Get_DevDesc+0x9c>
 80099f4:	2a07      	cmp	r2, #7
 80099f6:	d907      	bls.n	8009a08 <USBH_Get_DevDesc+0x54>
 80099f8:	f1a2 0008 	sub.w	r0, r2, #8
 80099fc:	b2c1      	uxtb	r1, r0
 80099fe:	2001      	movs	r0, #1
 8009a00:	4088      	lsls	r0, r1
 8009a02:	4917      	ldr	r1, [pc, #92]	; (8009a60 <USBH_Get_DevDesc+0xac>)
 8009a04:	4001      	ands	r1, r0
 8009a06:	b901      	cbnz	r1, 8009a0a <USBH_Get_DevDesc+0x56>
      dev_desc->bMaxPacketSize = 64U;
 8009a08:	2240      	movs	r2, #64	; 0x40
  if (length > 8U)
 8009a0a:	2d08      	cmp	r5, #8
      dev_desc->bMaxPacketSize = 64U;
 8009a0c:	f884 242d 	strb.w	r2, [r4, #1069]	; 0x42d
  if (length > 8U)
 8009a10:	d90e      	bls.n	8009a30 <USBH_Get_DevDesc+0x7c>
    dev_desc->idVendor           = LE16(buf +  8);
 8009a12:	f8d4 0224 	ldr.w	r0, [r4, #548]	; 0x224
    dev_desc->bcdDevice          = LE16(buf + 12);
 8009a16:	f8b4 1228 	ldrh.w	r1, [r4, #552]	; 0x228
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 8009a1a:	f8d4 222a 	ldr.w	r2, [r4, #554]	; 0x22a
    dev_desc->idVendor           = LE16(buf +  8);
 8009a1e:	f8c4 042e 	str.w	r0, [r4, #1070]	; 0x42e
}
 8009a22:	4618      	mov	r0, r3
    dev_desc->bcdDevice          = LE16(buf + 12);
 8009a24:	f8a4 1432 	strh.w	r1, [r4, #1074]	; 0x432
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 8009a28:	f8c4 2434 	str.w	r2, [r4, #1076]	; 0x434
}
 8009a2c:	bd38      	pop	{r3, r4, r5, pc}
  switch (phost->RequestState)
 8009a2e:	2301      	movs	r3, #1
}
 8009a30:	4618      	mov	r0, r3
 8009a32:	bd38      	pop	{r3, r4, r5, pc}
      phost->Control.setup.b.wIndex.w = 0U;
 8009a34:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009a36:	480b      	ldr	r0, [pc, #44]	; (8009a64 <USBH_Get_DevDesc+0xb0>)
    phost->Control.setup.b.wLength.w = length;
 8009a38:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
 8009a3a:	81a1      	strh	r1, [r4, #12]
      phost->RequestState = CMD_WAIT;
 8009a3c:	2102      	movs	r1, #2
      phost->Control.setup.b.wIndex.w = 0U;
 8009a3e:	82a2      	strh	r2, [r4, #20]
                              USB_DESC_DEVICE, phost->device.Data,
 8009a40:	f504 7207 	add.w	r2, r4, #540	; 0x21c
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009a44:	6120      	str	r0, [r4, #16]
}
 8009a46:	4618      	mov	r0, r3
      phost->Control.state = CTRL_SETUP;
 8009a48:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8009a4a:	70a1      	strb	r1, [r4, #2]
      phost->Control.buff = buff;
 8009a4c:	60a2      	str	r2, [r4, #8]
}
 8009a4e:	bd38      	pop	{r3, r4, r5, pc}
  switch (dev_desc->bMaxPacketSize)
 8009a50:	2a40      	cmp	r2, #64	; 0x40
 8009a52:	d1d9      	bne.n	8009a08 <USBH_Get_DevDesc+0x54>
  if (length > 8U)
 8009a54:	2d08      	cmp	r5, #8
      dev_desc->bMaxPacketSize = 64U;
 8009a56:	f884 242d 	strb.w	r2, [r4, #1069]	; 0x42d
  if (length > 8U)
 8009a5a:	d9e9      	bls.n	8009a30 <USBH_Get_DevDesc+0x7c>
 8009a5c:	e7d9      	b.n	8009a12 <USBH_Get_DevDesc+0x5e>
 8009a5e:	bf00      	nop
 8009a60:	01000101 	.word	0x01000101
 8009a64:	01000680 	.word	0x01000680

08009a68 <USBH_Get_CfgDesc>:
{
 8009a68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (phost->RequestState == CMD_SEND)
 8009a6c:	7883      	ldrb	r3, [r0, #2]
{
 8009a6e:	b083      	sub	sp, #12
 8009a70:	4605      	mov	r5, r0
 8009a72:	460e      	mov	r6, r1
  if (phost->RequestState == CMD_SEND)
 8009a74:	2b01      	cmp	r3, #1
  uint8_t *pData = phost->device.CfgDesc_Raw;
 8009a76:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
 8009a7a:	d04d      	beq.n	8009b18 <USBH_Get_CfgDesc+0xb0>
  switch (phost->RequestState)
 8009a7c:	2b02      	cmp	r3, #2
 8009a7e:	d146      	bne.n	8009b0e <USBH_Get_CfgDesc+0xa6>
 8009a80:	f7ff fec2 	bl	8009808 <USBH_CtlReq.part.0>
  if (status == USBH_OK)
 8009a84:	4603      	mov	r3, r0
 8009a86:	2800      	cmp	r0, #0
 8009a88:	d142      	bne.n	8009b10 <USBH_Get_CfgDesc+0xa8>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8009a8a:	8ba8      	ldrh	r0, [r5, #28]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 8009a8c:	8bea      	ldrh	r2, [r5, #30]
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8009a8e:	f8a5 0438 	strh.w	r0, [r5, #1080]	; 0x438
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5);
 8009a92:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 8009a96:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8009a9a:	7f29      	ldrb	r1, [r5, #28]
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5);
 8009a9c:	f885 043d 	strb.w	r0, [r5, #1085]	; 0x43d
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 8009aa0:	bf28      	it	cs
 8009aa2:	f44f 7200 	movcs.w	r2, #512	; 0x200
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6);
 8009aa6:	f895 0022 	ldrb.w	r0, [r5, #34]	; 0x22
  if (cfg_desc->bLength  != USB_CONFIGURATION_DESC_SIZE)
 8009aaa:	2909      	cmp	r1, #9
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 8009aac:	f895 b020 	ldrb.w	fp, [r5, #32]
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6);
 8009ab0:	f885 043e 	strb.w	r0, [r5, #1086]	; 0x43e
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7);
 8009ab4:	f895 0023 	ldrb.w	r0, [r5, #35]	; 0x23
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 8009ab8:	f8a5 243a 	strh.w	r2, [r5, #1082]	; 0x43a
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7);
 8009abc:	f885 043f 	strb.w	r0, [r5, #1087]	; 0x43f
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 8009ac0:	f895 0024 	ldrb.w	r0, [r5, #36]	; 0x24
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 8009ac4:	f885 b43c 	strb.w	fp, [r5, #1084]	; 0x43c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 8009ac8:	f885 0440 	strb.w	r0, [r5, #1088]	; 0x440
  if (cfg_desc->bLength  != USB_CONFIGURATION_DESC_SIZE)
 8009acc:	d002      	beq.n	8009ad4 <USBH_Get_CfgDesc+0x6c>
    cfg_desc->bLength = USB_CONFIGURATION_DESC_SIZE;
 8009ace:	2109      	movs	r1, #9
 8009ad0:	f885 1438 	strb.w	r1, [r5, #1080]	; 0x438
  if (length > USB_CONFIGURATION_DESC_SIZE)
 8009ad4:	2e09      	cmp	r6, #9
 8009ad6:	d91b      	bls.n	8009b10 <USBH_Get_CfgDesc+0xa8>
  USBH_StatusTypeDef           status = USBH_OK;
 8009ad8:	2000      	movs	r0, #0
 8009ada:	46ae      	mov	lr, r5
    ptr = USB_LEN_CFG_DESC;
 8009adc:	2309      	movs	r3, #9
  if (length > USB_CONFIGURATION_DESC_SIZE)
 8009ade:	4682      	mov	sl, r0
 8009ae0:	f1ba 0f02 	cmp.w	sl, #2
 8009ae4:	fa5f f68a 	uxtb.w	r6, sl
 8009ae8:	d107      	bne.n	8009afa <USBH_Get_CfgDesc+0x92>
 8009aea:	e00e      	b.n	8009b0a <USBH_Get_CfgDesc+0xa2>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009aec:	7821      	ldrb	r1, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 8009aee:	440c      	add	r4, r1
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009af0:	440b      	add	r3, r1
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 8009af2:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009af4:	b29b      	uxth	r3, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 8009af6:	2904      	cmp	r1, #4
 8009af8:	d01e      	beq.n	8009b38 <USBH_Get_CfgDesc+0xd0>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 8009afa:	429a      	cmp	r2, r3
 8009afc:	d8f6      	bhi.n	8009aec <USBH_Get_CfgDesc+0x84>
    if (if_ix < MIN(cfg_desc->bNumInterfaces, (uint8_t)USBH_MAX_NUM_INTERFACES))
 8009afe:	465b      	mov	r3, fp
 8009b00:	2b02      	cmp	r3, #2
 8009b02:	bf28      	it	cs
 8009b04:	2302      	movcs	r3, #2
 8009b06:	42b3      	cmp	r3, r6
 8009b08:	d814      	bhi.n	8009b34 <USBH_Get_CfgDesc+0xcc>
          return USBH_NOT_SUPPORTED;
 8009b0a:	4603      	mov	r3, r0
  return status;
 8009b0c:	e000      	b.n	8009b10 <USBH_Get_CfgDesc+0xa8>
  switch (phost->RequestState)
 8009b0e:	2301      	movs	r3, #1
}
 8009b10:	4618      	mov	r0, r3
 8009b12:	b003      	add	sp, #12
 8009b14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009b18:	4858      	ldr	r0, [pc, #352]	; (8009c7c <USBH_Get_CfgDesc+0x214>)
      phost->RequestState = CMD_WAIT;
 8009b1a:	2202      	movs	r2, #2
    phost->Control.setup.b.wLength.w = length;
 8009b1c:	82e9      	strh	r1, [r5, #22]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009b1e:	6128      	str	r0, [r5, #16]
      phost->Control.setup.b.wIndex.w = 0U;
 8009b20:	2000      	movs	r0, #0
      phost->Control.buff = buff;
 8009b22:	60ac      	str	r4, [r5, #8]
      phost->Control.setup.b.wIndex.w = 0U;
 8009b24:	82a8      	strh	r0, [r5, #20]
}
 8009b26:	4618      	mov	r0, r3
      phost->Control.length = length;
 8009b28:	81a9      	strh	r1, [r5, #12]
      phost->Control.state = CTRL_SETUP;
 8009b2a:	762b      	strb	r3, [r5, #24]
      phost->RequestState = CMD_WAIT;
 8009b2c:	70aa      	strb	r2, [r5, #2]
}
 8009b2e:	b003      	add	sp, #12
 8009b30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          return USBH_NOT_SUPPORTED;
 8009b34:	2303      	movs	r3, #3
 8009b36:	e7eb      	b.n	8009b10 <USBH_Get_CfgDesc+0xa8>
        if (pdesc->bLength != USB_INTERFACE_DESC_SIZE)
 8009b38:	7821      	ldrb	r1, [r4, #0]
 8009b3a:	2909      	cmp	r1, #9
 8009b3c:	d002      	beq.n	8009b44 <USBH_Get_CfgDesc+0xdc>
          pdesc->bLength = USB_INTERFACE_DESC_SIZE;
 8009b3e:	f04f 0109 	mov.w	r1, #9
 8009b42:	7021      	strb	r1, [r4, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 8009b44:	f04f 0109 	mov.w	r1, #9
 8009b48:	f88e 1442 	strb.w	r1, [lr, #1090]	; 0x442
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
 8009b4c:	7861      	ldrb	r1, [r4, #1]
 8009b4e:	f88e 1443 	strb.w	r1, [lr, #1091]	; 0x443
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
 8009b52:	78a1      	ldrb	r1, [r4, #2]
 8009b54:	f88e 1444 	strb.w	r1, [lr, #1092]	; 0x444
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
 8009b58:	78e1      	ldrb	r1, [r4, #3]
 8009b5a:	f88e 1445 	strb.w	r1, [lr, #1093]	; 0x445
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
 8009b5e:	f894 c004 	ldrb.w	ip, [r4, #4]
 8009b62:	f88e c446 	strb.w	ip, [lr, #1094]	; 0x446
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
 8009b66:	7966      	ldrb	r6, [r4, #5]
 8009b68:	f88e 6447 	strb.w	r6, [lr, #1095]	; 0x447
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
 8009b6c:	79a1      	ldrb	r1, [r4, #6]
 8009b6e:	f88e 1448 	strb.w	r1, [lr, #1096]	; 0x448
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
 8009b72:	79e7      	ldrb	r7, [r4, #7]
 8009b74:	9701      	str	r7, [sp, #4]
 8009b76:	f88e 7449 	strb.w	r7, [lr, #1097]	; 0x449
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
 8009b7a:	7a27      	ldrb	r7, [r4, #8]
 8009b7c:	f88e 744a 	strb.w	r7, [lr, #1098]	; 0x44a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8009b80:	f1bc 0f00 	cmp.w	ip, #0
 8009b84:	d069      	beq.n	8009c5a <USBH_Get_CfgDesc+0x1f2>
 8009b86:	429a      	cmp	r2, r3
 8009b88:	d9d4      	bls.n	8009b34 <USBH_Get_CfgDesc+0xcc>
            if ((pif->bInterfaceClass == 0x01U) && (pif->bInterfaceSubClass == 0x02U))
 8009b8a:	2e01      	cmp	r6, #1
 8009b8c:	bf08      	it	eq
 8009b8e:	2902      	cmpeq	r1, #2
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 8009b90:	f04f 091a 	mov.w	r9, #26
        ep_ix = 0U;
 8009b94:	f04f 0600 	mov.w	r6, #0
            if ((pif->bInterfaceClass == 0x01U) && (pif->bInterfaceSubClass == 0x02U))
 8009b98:	bf0c      	ite	eq
 8009b9a:	2101      	moveq	r1, #1
 8009b9c:	2100      	movne	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 8009b9e:	fb09 f90a 	mul.w	r9, r9, sl
            if ((pif->bInterfaceClass == 0x01U) && (pif->bInterfaceSubClass == 0x02U))
 8009ba2:	9100      	str	r1, [sp, #0]
 8009ba4:	2109      	movs	r1, #9
 8009ba6:	e004      	b.n	8009bb2 <USBH_Get_CfgDesc+0x14a>
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8009ba8:	45b4      	cmp	ip, r6
 8009baa:	d956      	bls.n	8009c5a <USBH_Get_CfgDesc+0x1f2>
 8009bac:	429a      	cmp	r2, r3
 8009bae:	d9c1      	bls.n	8009b34 <USBH_Get_CfgDesc+0xcc>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009bb0:	7821      	ldrb	r1, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 8009bb2:	440c      	add	r4, r1
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009bb4:	440b      	add	r3, r1
          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8009bb6:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8009bb8:	b29b      	uxth	r3, r3
          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8009bba:	2905      	cmp	r1, #5
 8009bbc:	d1f4      	bne.n	8009ba8 <USBH_Get_CfgDesc+0x140>
            if ((pif->bInterfaceClass == 0x01U) && (pif->bInterfaceSubClass == 0x02U))
 8009bbe:	9900      	ldr	r1, [sp, #0]
 8009bc0:	2900      	cmp	r1, #0
 8009bc2:	d14f      	bne.n	8009c64 <USBH_Get_CfgDesc+0x1fc>
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 8009bc4:	f04f 0107 	mov.w	r1, #7
 8009bc8:	2007      	movs	r0, #7
 8009bca:	7021      	strb	r1, [r4, #0]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 8009bcc:	3601      	adds	r6, #1
 8009bce:	eb09 01c6 	add.w	r1, r9, r6, lsl #3
 8009bd2:	4429      	add	r1, r5
 8009bd4:	f881 0444 	strb.w	r0, [r1, #1092]	; 0x444
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
 8009bd8:	7860      	ldrb	r0, [r4, #1]
 8009bda:	f881 0445 	strb.w	r0, [r1, #1093]	; 0x445
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
 8009bde:	78a0      	ldrb	r0, [r4, #2]
 8009be0:	f881 0446 	strb.w	r0, [r1, #1094]	; 0x446
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
 8009be4:	78e7      	ldrb	r7, [r4, #3]
 8009be6:	f881 7447 	strb.w	r7, [r1, #1095]	; 0x447
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
 8009bea:	88a0      	ldrh	r0, [r4, #4]
 8009bec:	f8a1 0448 	strh.w	r0, [r1, #1096]	; 0x448
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
 8009bf0:	f894 8006 	ldrb.w	r8, [r4, #6]
 8009bf4:	f881 844a 	strb.w	r8, [r1, #1098]	; 0x44a
  if (ep_descriptor->wMaxPacketSize == 0x00U)
 8009bf8:	b368      	cbz	r0, 8009c56 <USBH_Get_CfgDesc+0x1ee>
      ep_descriptor->wMaxPacketSize &= ~0x7FFU;
 8009bfa:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
 8009bfe:	f020 0007 	bic.w	r0, r0, #7
 8009c02:	f8a1 0448 	strh.w	r0, [r1, #1096]	; 0x448
      ep_descriptor->wMaxPacketSize |= MIN((uint16_t)(LE16(buf + 4) & 0x7FFU), (uint16_t)USBH_MAX_DATA_BUFFER);
 8009c06:	b200      	sxth	r0, r0
 8009c08:	88a1      	ldrh	r1, [r4, #4]
 8009c0a:	f411 6fc0 	tst.w	r1, #1536	; 0x600
 8009c0e:	bf0c      	ite	eq
 8009c10:	f3c1 010a 	ubfxeq	r1, r1, #0, #11
 8009c14:	f44f 7100 	movne.w	r1, #512	; 0x200
 8009c18:	4308      	orrs	r0, r1
 8009c1a:	eb09 01c6 	add.w	r1, r9, r6, lsl #3
 8009c1e:	4429      	add	r1, r5
 8009c20:	f8a1 0448 	strh.w	r0, [r1, #1096]	; 0x448
  USBH_StatusTypeDef status = USBH_OK;
 8009c24:	2000      	movs	r0, #0
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 8009c26:	f895 141d 	ldrb.w	r1, [r5, #1053]	; 0x41d
 8009c2a:	b949      	cbnz	r1, 8009c40 <USBH_Get_CfgDesc+0x1d8>
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 8009c2c:	07f9      	lsls	r1, r7, #31
 8009c2e:	d505      	bpl.n	8009c3c <USBH_Get_CfgDesc+0x1d4>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 8009c30:	f108 38ff 	add.w	r8, r8, #4294967295
        status = USBH_NOT_SUPPORTED;
 8009c34:	f1b8 0f0f 	cmp.w	r8, #15
 8009c38:	bf88      	it	hi
 8009c3a:	2003      	movhi	r0, #3
            ep_ix++;
 8009c3c:	b2f6      	uxtb	r6, r6
 8009c3e:	e7b3      	b.n	8009ba8 <USBH_Get_CfgDesc+0x140>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC)
 8009c40:	f007 0703 	and.w	r7, r7, #3
 8009c44:	2f01      	cmp	r7, #1
 8009c46:	d0f3      	beq.n	8009c30 <USBH_Get_CfgDesc+0x1c8>
      if (ep_descriptor->bInterval == 0U)
 8009c48:	2f03      	cmp	r7, #3
 8009c4a:	d1f7      	bne.n	8009c3c <USBH_Get_CfgDesc+0x1d4>
        status = USBH_NOT_SUPPORTED;
 8009c4c:	f1b8 0f00 	cmp.w	r8, #0
 8009c50:	bf08      	it	eq
 8009c52:	2003      	moveq	r0, #3
 8009c54:	e7f2      	b.n	8009c3c <USBH_Get_CfgDesc+0x1d4>
    status = USBH_NOT_SUPPORTED;
 8009c56:	2003      	movs	r0, #3
 8009c58:	e7e5      	b.n	8009c26 <USBH_Get_CfgDesc+0x1be>
        if_ix++;
 8009c5a:	f10a 0a01 	add.w	sl, sl, #1
 8009c5e:	f10e 0e1a 	add.w	lr, lr, #26
 8009c62:	e73d      	b.n	8009ae0 <USBH_Get_CfgDesc+0x78>
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 8009c64:	9901      	ldr	r1, [sp, #4]
 8009c66:	7820      	ldrb	r0, [r4, #0]
 8009c68:	2900      	cmp	r1, #0
 8009c6a:	d1af      	bne.n	8009bcc <USBH_Get_CfgDesc+0x164>
 8009c6c:	2809      	cmp	r0, #9
 8009c6e:	d0ad      	beq.n	8009bcc <USBH_Get_CfgDesc+0x164>
                pdesc->bLength = 0x09U;
 8009c70:	f04f 0109 	mov.w	r1, #9
 8009c74:	2009      	movs	r0, #9
 8009c76:	7021      	strb	r1, [r4, #0]
 8009c78:	e7a8      	b.n	8009bcc <USBH_Get_CfgDesc+0x164>
 8009c7a:	bf00      	nop
 8009c7c:	02000680 	.word	0x02000680

08009c80 <USBH_Get_StringDesc>:
{
 8009c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009c82:	4616      	mov	r6, r2
  if (phost->RequestState == CMD_SEND)
 8009c84:	7882      	ldrb	r2, [r0, #2]
{
 8009c86:	4604      	mov	r4, r0
 8009c88:	461d      	mov	r5, r3
  if (phost->RequestState == CMD_SEND)
 8009c8a:	2a01      	cmp	r2, #1
                              phost->device.Data, length);
 8009c8c:	f500 7707 	add.w	r7, r0, #540	; 0x21c
  if (phost->RequestState == CMD_SEND)
 8009c90:	d00e      	beq.n	8009cb0 <USBH_Get_StringDesc+0x30>
  switch (phost->RequestState)
 8009c92:	2a02      	cmp	r2, #2
 8009c94:	d109      	bne.n	8009caa <USBH_Get_StringDesc+0x2a>
 8009c96:	f7ff fdb7 	bl	8009808 <USBH_CtlReq.part.0>
  if (status == USBH_OK)
 8009c9a:	4602      	mov	r2, r0
 8009c9c:	b918      	cbnz	r0, 8009ca6 <USBH_Get_StringDesc+0x26>
  if (psrc[1] == USB_DESC_TYPE_STRING)
 8009c9e:	f894 321d 	ldrb.w	r3, [r4, #541]	; 0x21d
 8009ca2:	2b03      	cmp	r3, #3
 8009ca4:	d015      	beq.n	8009cd2 <USBH_Get_StringDesc+0x52>
}
 8009ca6:	4610      	mov	r0, r2
 8009ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (phost->RequestState)
 8009caa:	2201      	movs	r2, #1
}
 8009cac:	4610      	mov	r0, r2
 8009cae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  status = USBH_GetDescriptor(phost,
 8009cb0:	f441 7140 	orr.w	r1, r1, #768	; 0x300
      phost->RequestState = CMD_WAIT;
 8009cb4:	2302      	movs	r3, #2
      phost->Control.buff = buff;
 8009cb6:	6087      	str	r7, [r0, #8]
    phost->Control.setup.b.wValue.w = value_idx;
 8009cb8:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8009cba:	f240 4109 	movw	r1, #1033	; 0x409
      phost->RequestState = CMD_WAIT;
 8009cbe:	7083      	strb	r3, [r0, #2]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009cc0:	f44f 63d0 	mov.w	r3, #1664	; 0x680
    phost->Control.setup.b.wLength.w = length;
 8009cc4:	82c5      	strh	r5, [r0, #22]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8009cc6:	8281      	strh	r1, [r0, #20]
      phost->Control.length = length;
 8009cc8:	8185      	strh	r5, [r0, #12]
      phost->Control.state = CTRL_SETUP;
 8009cca:	7602      	strb	r2, [r0, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8009ccc:	8203      	strh	r3, [r0, #16]
}
 8009cce:	4610      	mov	r0, r2
 8009cd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 8009cd2:	f894 321c 	ldrb.w	r3, [r4, #540]	; 0x21c
 8009cd6:	3b02      	subs	r3, #2
 8009cd8:	42ab      	cmp	r3, r5
 8009cda:	bf28      	it	cs
 8009cdc:	462b      	movcs	r3, r5
 8009cde:	b298      	uxth	r0, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 8009ce0:	b143      	cbz	r3, 8009cf4 <USBH_Get_StringDesc+0x74>
 8009ce2:	4613      	mov	r3, r2
      *pdest =  psrc[idx];
 8009ce4:	18f9      	adds	r1, r7, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 8009ce6:	3302      	adds	r3, #2
 8009ce8:	b29b      	uxth	r3, r3
      *pdest =  psrc[idx];
 8009cea:	7889      	ldrb	r1, [r1, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
 8009cec:	4298      	cmp	r0, r3
      *pdest =  psrc[idx];
 8009cee:	f806 1b01 	strb.w	r1, [r6], #1
    for (idx = 0U; idx < strlength; idx += 2U)
 8009cf2:	d8f7      	bhi.n	8009ce4 <USBH_Get_StringDesc+0x64>
    *pdest = 0U; /* mark end of string */
 8009cf4:	2300      	movs	r3, #0
}
 8009cf6:	4610      	mov	r0, r2
    *pdest = 0U; /* mark end of string */
 8009cf8:	7033      	strb	r3, [r6, #0]
}
 8009cfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08009cfc <USBH_SetAddress>:
{
 8009cfc:	b570      	push	{r4, r5, r6, lr}
  if (phost->RequestState == CMD_SEND)
 8009cfe:	7885      	ldrb	r5, [r0, #2]
{
 8009d00:	b082      	sub	sp, #8
 8009d02:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 8009d04:	2d01      	cmp	r5, #1
 8009d06:	d01d      	beq.n	8009d44 <USBH_SetAddress+0x48>
  switch (phost->RequestState)
 8009d08:	2d02      	cmp	r5, #2
 8009d0a:	d117      	bne.n	8009d3c <USBH_SetAddress+0x40>
  switch (phost->Control.state)
 8009d0c:	f890 c018 	ldrb.w	ip, [r0, #24]
 8009d10:	f10c 33ff 	add.w	r3, ip, #4294967295
 8009d14:	2b0a      	cmp	r3, #10
 8009d16:	d811      	bhi.n	8009d3c <USBH_SetAddress+0x40>
 8009d18:	e8df f003 	tbb	[pc, r3]
 8009d1c:	0646372e 	.word	0x0646372e
 8009d20:	7c706053 	.word	0x7c706053
 8009d24:	9a8d      	.short	0x9a8d
 8009d26:	22          	.byte	0x22
 8009d27:	00          	.byte	0x00
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8009d28:	7901      	ldrb	r1, [r0, #4]
 8009d2a:	f014 ffa7 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009d2e:	2801      	cmp	r0, #1
 8009d30:	f000 8096 	beq.w	8009e60 <USBH_SetAddress+0x164>
      if (URB_Status == USBH_URB_STALL)
 8009d34:	2805      	cmp	r0, #5
 8009d36:	d076      	beq.n	8009e26 <USBH_SetAddress+0x12a>
        if (URB_Status == USBH_URB_ERROR)
 8009d38:	2804      	cmp	r0, #4
 8009d3a:	d031      	beq.n	8009da0 <USBH_SetAddress+0xa4>
  switch (phost->Control.state)
 8009d3c:	2501      	movs	r5, #1
}
 8009d3e:	4628      	mov	r0, r5
 8009d40:	b002      	add	sp, #8
 8009d42:	bd70      	pop	{r4, r5, r6, pc}
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8009d44:	f44f 60a0 	mov.w	r0, #1280	; 0x500
      phost->Control.buff = buff;
 8009d48:	2300      	movs	r3, #0
      phost->RequestState = CMD_WAIT;
 8009d4a:	2202      	movs	r2, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 8009d4c:	8261      	strh	r1, [r4, #18]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8009d4e:	8220      	strh	r0, [r4, #16]
}
 8009d50:	4628      	mov	r0, r5
      phost->Control.buff = buff;
 8009d52:	60a3      	str	r3, [r4, #8]
      phost->Control.length = length;
 8009d54:	81a3      	strh	r3, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 8009d56:	6163      	str	r3, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 8009d58:	7625      	strb	r5, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8009d5a:	70a2      	strb	r2, [r4, #2]
}
 8009d5c:	b002      	add	sp, #8
 8009d5e:	bd70      	pop	{r4, r5, r6, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8009d60:	7e43      	ldrb	r3, [r0, #25]
 8009d62:	3301      	adds	r3, #1
 8009d64:	b2db      	uxtb	r3, r3
 8009d66:	2b02      	cmp	r3, #2
 8009d68:	7643      	strb	r3, [r0, #25]
 8009d6a:	f200 8085 	bhi.w	8009e78 <USBH_SetAddress+0x17c>
        phost->Control.state = CTRL_SETUP;
 8009d6e:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 8009d70:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 8009d72:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 8009d74:	7083      	strb	r3, [r0, #2]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009d76:	e7e2      	b.n	8009d3e <USBH_SetAddress+0x42>
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8009d78:	7942      	ldrb	r2, [r0, #5]
 8009d7a:	f100 0110 	add.w	r1, r0, #16
  USBH_StatusTypeDef status = USBH_BUSY;
 8009d7e:	4665      	mov	r5, ip
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8009d80:	f000 fc3e 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8009d84:	2302      	movs	r3, #2
 8009d86:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009d88:	e7d9      	b.n	8009d3e <USBH_SetAddress+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009d8a:	7941      	ldrb	r1, [r0, #5]
 8009d8c:	f014 ff76 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009d90:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009d92:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 8009d94:	f000 8089 	beq.w	8009eaa <USBH_SetAddress+0x1ae>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8009d98:	2804      	cmp	r0, #4
 8009d9a:	d001      	beq.n	8009da0 <USBH_SetAddress+0xa4>
 8009d9c:	2802      	cmp	r0, #2
 8009d9e:	d1cd      	bne.n	8009d3c <USBH_SetAddress+0x40>
          phost->Control.state = CTRL_ERROR;
 8009da0:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 8009da2:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 8009da4:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009da6:	e7ca      	b.n	8009d3e <USBH_SetAddress+0x42>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009da8:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 8009dac:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 8009dae:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8009db0:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 8009db2:	4620      	mov	r0, r4
 8009db4:	89a2      	ldrh	r2, [r4, #12]
 8009db6:	68a1      	ldr	r1, [r4, #8]
 8009db8:	f000 fc4c 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8009dbc:	2304      	movs	r3, #4
 8009dbe:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009dc0:	e7bd      	b.n	8009d3e <USBH_SetAddress+0x42>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8009dc2:	2501      	movs	r5, #1
 8009dc4:	7943      	ldrb	r3, [r0, #5]
 8009dc6:	8982      	ldrh	r2, [r0, #12]
 8009dc8:	6881      	ldr	r1, [r0, #8]
 8009dca:	9500      	str	r5, [sp, #0]
 8009dcc:	f000 fc28 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009dd0:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8009dd4:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 8009dd6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8009dd8:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009dda:	e7b0      	b.n	8009d3e <USBH_SetAddress+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009ddc:	7941      	ldrb	r1, [r0, #5]
 8009dde:	f014 ff4d 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009de2:	2801      	cmp	r0, #1
 8009de4:	d044      	beq.n	8009e70 <USBH_SetAddress+0x174>
      else if (URB_Status == USBH_URB_STALL)
 8009de6:	2805      	cmp	r0, #5
 8009de8:	d01d      	beq.n	8009e26 <USBH_SetAddress+0x12a>
      else if (URB_Status == USBH_URB_NOTREADY)
 8009dea:	2802      	cmp	r0, #2
 8009dec:	d063      	beq.n	8009eb6 <USBH_SetAddress+0x1ba>
        if (URB_Status == USBH_URB_ERROR)
 8009dee:	2804      	cmp	r0, #4
 8009df0:	d1a4      	bne.n	8009d3c <USBH_SetAddress+0x40>
          phost->Control.state = CTRL_ERROR;
 8009df2:	230b      	movs	r3, #11
 8009df4:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8009df6:	2301      	movs	r3, #1
 8009df8:	70a3      	strb	r3, [r4, #2]
 8009dfa:	e7a0      	b.n	8009d3e <USBH_SetAddress+0x42>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8009dfc:	2200      	movs	r2, #0
 8009dfe:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 8009e00:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8009e02:	4611      	mov	r1, r2
 8009e04:	f000 fc26 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009e08:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8009e0c:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 8009e0e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8009e10:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009e12:	e794      	b.n	8009d3e <USBH_SetAddress+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8009e14:	7901      	ldrb	r1, [r0, #4]
 8009e16:	f014 ff31 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009e1a:	2801      	cmp	r0, #1
 8009e1c:	d024      	beq.n	8009e68 <USBH_SetAddress+0x16c>
      else if (URB_Status == USBH_URB_ERROR)
 8009e1e:	2804      	cmp	r0, #4
 8009e20:	d0be      	beq.n	8009da0 <USBH_SetAddress+0xa4>
        if (URB_Status == USBH_URB_STALL)
 8009e22:	2805      	cmp	r0, #5
 8009e24:	d18a      	bne.n	8009d3c <USBH_SetAddress+0x40>
        status = USBH_NOT_SUPPORTED;
 8009e26:	2503      	movs	r5, #3
        phost->RequestState = CMD_SEND;
 8009e28:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8009e2a:	2300      	movs	r3, #0
}
 8009e2c:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 8009e2e:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8009e30:	7623      	strb	r3, [r4, #24]
}
 8009e32:	b002      	add	sp, #8
 8009e34:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 8009e36:	2200      	movs	r2, #0
 8009e38:	2501      	movs	r5, #1
 8009e3a:	7943      	ldrb	r3, [r0, #5]
 8009e3c:	4611      	mov	r1, r2
 8009e3e:	9500      	str	r5, [sp, #0]
 8009e40:	f000 fbee 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009e44:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8009e48:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 8009e4a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8009e4c:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009e4e:	e776      	b.n	8009d3e <USBH_SetAddress+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009e50:	7941      	ldrb	r1, [r0, #5]
 8009e52:	f014 ff13 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009e56:	2801      	cmp	r0, #1
 8009e58:	d006      	beq.n	8009e68 <USBH_SetAddress+0x16c>
      else if (URB_Status == USBH_URB_NOTREADY)
 8009e5a:	2802      	cmp	r0, #2
 8009e5c:	f47f af6c 	bne.w	8009d38 <USBH_SetAddress+0x3c>
            phost->Control.state = CTRL_STATUS_OUT;
 8009e60:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 8009e62:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 8009e64:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009e66:	e76a      	b.n	8009d3e <USBH_SetAddress+0x42>
        status = USBH_OK;
 8009e68:	2500      	movs	r5, #0
 8009e6a:	e7dd      	b.n	8009e28 <USBH_SetAddress+0x12c>
          if (direction == USB_D2H)
 8009e6c:	0613      	lsls	r3, r2, #24
 8009e6e:	d4f7      	bmi.n	8009e60 <USBH_SetAddress+0x164>
            phost->Control.state = CTRL_STATUS_IN;
 8009e70:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 8009e72:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 8009e74:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009e76:	e762      	b.n	8009d3e <USBH_SetAddress+0x42>
        phost->Control.errorcount = 0U;
 8009e78:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8009e7a:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 8009e7e:	2106      	movs	r1, #6
 8009e80:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 8009e82:	4810      	ldr	r0, [pc, #64]	; (8009ec4 <USBH_SetAddress+0x1c8>)
        phost->Control.errorcount = 0U;
 8009e84:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 8009e86:	f016 fa27 	bl	80202d8 <iprintf>
 8009e8a:	480f      	ldr	r0, [pc, #60]	; (8009ec8 <USBH_SetAddress+0x1cc>)
 8009e8c:	f016 fa24 	bl	80202d8 <iprintf>
 8009e90:	200a      	movs	r0, #10
 8009e92:	f016 fa39 	bl	8020308 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8009e96:	7961      	ldrb	r1, [r4, #5]
 8009e98:	4620      	mov	r0, r4
 8009e9a:	f000 fc79 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8009e9e:	7921      	ldrb	r1, [r4, #4]
 8009ea0:	4620      	mov	r0, r4
 8009ea2:	f000 fc75 	bl	800a790 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8009ea6:	7026      	strb	r6, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009ea8:	e7a5      	b.n	8009df6 <USBH_SetAddress+0xfa>
        if (phost->Control.setup.b.wLength.w != 0U)
 8009eaa:	8ae3      	ldrh	r3, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 8009eac:	7c22      	ldrb	r2, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 8009eae:	2b00      	cmp	r3, #0
 8009eb0:	d0dc      	beq.n	8009e6c <USBH_SetAddress+0x170>
          if (direction == USB_D2H)
 8009eb2:	0612      	lsls	r2, r2, #24
 8009eb4:	d403      	bmi.n	8009ebe <USBH_SetAddress+0x1c2>
            phost->Control.state = CTRL_DATA_OUT;
 8009eb6:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 8009eb8:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 8009eba:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009ebc:	e73f      	b.n	8009d3e <USBH_SetAddress+0x42>
            phost->Control.state = CTRL_DATA_IN;
 8009ebe:	2303      	movs	r3, #3
 8009ec0:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009ec2:	e73c      	b.n	8009d3e <USBH_SetAddress+0x42>
 8009ec4:	08021984 	.word	0x08021984
 8009ec8:	08021dd4 	.word	0x08021dd4

08009ecc <USBH_SetCfg>:
{
 8009ecc:	b570      	push	{r4, r5, r6, lr}
  if (phost->RequestState == CMD_SEND)
 8009ece:	7885      	ldrb	r5, [r0, #2]
{
 8009ed0:	b082      	sub	sp, #8
 8009ed2:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 8009ed4:	2d01      	cmp	r5, #1
 8009ed6:	d01d      	beq.n	8009f14 <USBH_SetCfg+0x48>
  switch (phost->RequestState)
 8009ed8:	2d02      	cmp	r5, #2
 8009eda:	d117      	bne.n	8009f0c <USBH_SetCfg+0x40>
  switch (phost->Control.state)
 8009edc:	f890 c018 	ldrb.w	ip, [r0, #24]
 8009ee0:	f10c 33ff 	add.w	r3, ip, #4294967295
 8009ee4:	2b0a      	cmp	r3, #10
 8009ee6:	d811      	bhi.n	8009f0c <USBH_SetCfg+0x40>
 8009ee8:	e8df f003 	tbb	[pc, r3]
 8009eec:	0646372e 	.word	0x0646372e
 8009ef0:	7c706053 	.word	0x7c706053
 8009ef4:	9a8d      	.short	0x9a8d
 8009ef6:	22          	.byte	0x22
 8009ef7:	00          	.byte	0x00
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8009ef8:	7901      	ldrb	r1, [r0, #4]
 8009efa:	f014 febf 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009efe:	2801      	cmp	r0, #1
 8009f00:	f000 8096 	beq.w	800a030 <USBH_SetCfg+0x164>
      if (URB_Status == USBH_URB_STALL)
 8009f04:	2805      	cmp	r0, #5
 8009f06:	d076      	beq.n	8009ff6 <USBH_SetCfg+0x12a>
        if (URB_Status == USBH_URB_ERROR)
 8009f08:	2804      	cmp	r0, #4
 8009f0a:	d031      	beq.n	8009f70 <USBH_SetCfg+0xa4>
  switch (phost->Control.state)
 8009f0c:	2501      	movs	r5, #1
}
 8009f0e:	4628      	mov	r0, r5
 8009f10:	b002      	add	sp, #8
 8009f12:	bd70      	pop	{r4, r5, r6, pc}
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8009f14:	f44f 6010 	mov.w	r0, #2304	; 0x900
      phost->Control.buff = buff;
 8009f18:	2300      	movs	r3, #0
      phost->RequestState = CMD_WAIT;
 8009f1a:	2202      	movs	r2, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
 8009f1c:	8261      	strh	r1, [r4, #18]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8009f1e:	8220      	strh	r0, [r4, #16]
}
 8009f20:	4628      	mov	r0, r5
      phost->Control.buff = buff;
 8009f22:	60a3      	str	r3, [r4, #8]
      phost->Control.length = length;
 8009f24:	81a3      	strh	r3, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 8009f26:	6163      	str	r3, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 8009f28:	7625      	strb	r5, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8009f2a:	70a2      	strb	r2, [r4, #2]
}
 8009f2c:	b002      	add	sp, #8
 8009f2e:	bd70      	pop	{r4, r5, r6, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8009f30:	7e43      	ldrb	r3, [r0, #25]
 8009f32:	3301      	adds	r3, #1
 8009f34:	b2db      	uxtb	r3, r3
 8009f36:	2b02      	cmp	r3, #2
 8009f38:	7643      	strb	r3, [r0, #25]
 8009f3a:	f200 8085 	bhi.w	800a048 <USBH_SetCfg+0x17c>
        phost->Control.state = CTRL_SETUP;
 8009f3e:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 8009f40:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 8009f42:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 8009f44:	7083      	strb	r3, [r0, #2]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009f46:	e7e2      	b.n	8009f0e <USBH_SetCfg+0x42>
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8009f48:	7942      	ldrb	r2, [r0, #5]
 8009f4a:	f100 0110 	add.w	r1, r0, #16
  USBH_StatusTypeDef status = USBH_BUSY;
 8009f4e:	4665      	mov	r5, ip
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8009f50:	f000 fb56 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8009f54:	2302      	movs	r3, #2
 8009f56:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009f58:	e7d9      	b.n	8009f0e <USBH_SetCfg+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009f5a:	7941      	ldrb	r1, [r0, #5]
 8009f5c:	f014 fe8e 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009f60:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009f62:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 8009f64:	f000 8089 	beq.w	800a07a <USBH_SetCfg+0x1ae>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8009f68:	2804      	cmp	r0, #4
 8009f6a:	d001      	beq.n	8009f70 <USBH_SetCfg+0xa4>
 8009f6c:	2802      	cmp	r0, #2
 8009f6e:	d1cd      	bne.n	8009f0c <USBH_SetCfg+0x40>
          phost->Control.state = CTRL_ERROR;
 8009f70:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 8009f72:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 8009f74:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009f76:	e7ca      	b.n	8009f0e <USBH_SetCfg+0x42>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009f78:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 8009f7c:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 8009f7e:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8009f80:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 8009f82:	4620      	mov	r0, r4
 8009f84:	89a2      	ldrh	r2, [r4, #12]
 8009f86:	68a1      	ldr	r1, [r4, #8]
 8009f88:	f000 fb64 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8009f8c:	2304      	movs	r3, #4
 8009f8e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009f90:	e7bd      	b.n	8009f0e <USBH_SetCfg+0x42>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8009f92:	2501      	movs	r5, #1
 8009f94:	7943      	ldrb	r3, [r0, #5]
 8009f96:	8982      	ldrh	r2, [r0, #12]
 8009f98:	6881      	ldr	r1, [r0, #8]
 8009f9a:	9500      	str	r5, [sp, #0]
 8009f9c:	f000 fb40 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009fa0:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8009fa4:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 8009fa6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8009fa8:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009faa:	e7b0      	b.n	8009f0e <USBH_SetCfg+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8009fac:	7941      	ldrb	r1, [r0, #5]
 8009fae:	f014 fe65 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009fb2:	2801      	cmp	r0, #1
 8009fb4:	d044      	beq.n	800a040 <USBH_SetCfg+0x174>
      else if (URB_Status == USBH_URB_STALL)
 8009fb6:	2805      	cmp	r0, #5
 8009fb8:	d01d      	beq.n	8009ff6 <USBH_SetCfg+0x12a>
      else if (URB_Status == USBH_URB_NOTREADY)
 8009fba:	2802      	cmp	r0, #2
 8009fbc:	d063      	beq.n	800a086 <USBH_SetCfg+0x1ba>
        if (URB_Status == USBH_URB_ERROR)
 8009fbe:	2804      	cmp	r0, #4
 8009fc0:	d1a4      	bne.n	8009f0c <USBH_SetCfg+0x40>
          phost->Control.state = CTRL_ERROR;
 8009fc2:	230b      	movs	r3, #11
 8009fc4:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8009fc6:	2301      	movs	r3, #1
 8009fc8:	70a3      	strb	r3, [r4, #2]
 8009fca:	e7a0      	b.n	8009f0e <USBH_SetCfg+0x42>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8009fcc:	2200      	movs	r2, #0
 8009fce:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 8009fd0:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8009fd2:	4611      	mov	r1, r2
 8009fd4:	f000 fb3e 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8009fd8:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8009fdc:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 8009fde:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8009fe0:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8009fe2:	e794      	b.n	8009f0e <USBH_SetCfg+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8009fe4:	7901      	ldrb	r1, [r0, #4]
 8009fe6:	f014 fe49 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8009fea:	2801      	cmp	r0, #1
 8009fec:	d024      	beq.n	800a038 <USBH_SetCfg+0x16c>
      else if (URB_Status == USBH_URB_ERROR)
 8009fee:	2804      	cmp	r0, #4
 8009ff0:	d0be      	beq.n	8009f70 <USBH_SetCfg+0xa4>
        if (URB_Status == USBH_URB_STALL)
 8009ff2:	2805      	cmp	r0, #5
 8009ff4:	d18a      	bne.n	8009f0c <USBH_SetCfg+0x40>
        status = USBH_NOT_SUPPORTED;
 8009ff6:	2503      	movs	r5, #3
        phost->RequestState = CMD_SEND;
 8009ff8:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8009ffa:	2300      	movs	r3, #0
}
 8009ffc:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 8009ffe:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800a000:	7623      	strb	r3, [r4, #24]
}
 800a002:	b002      	add	sp, #8
 800a004:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800a006:	2200      	movs	r2, #0
 800a008:	2501      	movs	r5, #1
 800a00a:	7943      	ldrb	r3, [r0, #5]
 800a00c:	4611      	mov	r1, r2
 800a00e:	9500      	str	r5, [sp, #0]
 800a010:	f000 fb06 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a014:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a018:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 800a01a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a01c:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a01e:	e776      	b.n	8009f0e <USBH_SetCfg+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a020:	7941      	ldrb	r1, [r0, #5]
 800a022:	f014 fe2b 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a026:	2801      	cmp	r0, #1
 800a028:	d006      	beq.n	800a038 <USBH_SetCfg+0x16c>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a02a:	2802      	cmp	r0, #2
 800a02c:	f47f af6c 	bne.w	8009f08 <USBH_SetCfg+0x3c>
            phost->Control.state = CTRL_STATUS_OUT;
 800a030:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 800a032:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 800a034:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a036:	e76a      	b.n	8009f0e <USBH_SetCfg+0x42>
        status = USBH_OK;
 800a038:	2500      	movs	r5, #0
 800a03a:	e7dd      	b.n	8009ff8 <USBH_SetCfg+0x12c>
          if (direction == USB_D2H)
 800a03c:	0613      	lsls	r3, r2, #24
 800a03e:	d4f7      	bmi.n	800a030 <USBH_SetCfg+0x164>
            phost->Control.state = CTRL_STATUS_IN;
 800a040:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800a042:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800a044:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a046:	e762      	b.n	8009f0e <USBH_SetCfg+0x42>
        phost->Control.errorcount = 0U;
 800a048:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800a04a:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 800a04e:	2106      	movs	r1, #6
 800a050:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800a052:	4810      	ldr	r0, [pc, #64]	; (800a094 <USBH_SetCfg+0x1c8>)
        phost->Control.errorcount = 0U;
 800a054:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800a056:	f016 f93f 	bl	80202d8 <iprintf>
 800a05a:	480f      	ldr	r0, [pc, #60]	; (800a098 <USBH_SetCfg+0x1cc>)
 800a05c:	f016 f93c 	bl	80202d8 <iprintf>
 800a060:	200a      	movs	r0, #10
 800a062:	f016 f951 	bl	8020308 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800a066:	7961      	ldrb	r1, [r4, #5]
 800a068:	4620      	mov	r0, r4
 800a06a:	f000 fb91 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800a06e:	7921      	ldrb	r1, [r4, #4]
 800a070:	4620      	mov	r0, r4
 800a072:	f000 fb8d 	bl	800a790 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800a076:	7026      	strb	r6, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a078:	e7a5      	b.n	8009fc6 <USBH_SetCfg+0xfa>
        if (phost->Control.setup.b.wLength.w != 0U)
 800a07a:	8ae3      	ldrh	r3, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800a07c:	7c22      	ldrb	r2, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 800a07e:	2b00      	cmp	r3, #0
 800a080:	d0dc      	beq.n	800a03c <USBH_SetCfg+0x170>
          if (direction == USB_D2H)
 800a082:	0612      	lsls	r2, r2, #24
 800a084:	d403      	bmi.n	800a08e <USBH_SetCfg+0x1c2>
            phost->Control.state = CTRL_DATA_OUT;
 800a086:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 800a088:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 800a08a:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a08c:	e73f      	b.n	8009f0e <USBH_SetCfg+0x42>
            phost->Control.state = CTRL_DATA_IN;
 800a08e:	2303      	movs	r3, #3
 800a090:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a092:	e73c      	b.n	8009f0e <USBH_SetCfg+0x42>
 800a094:	08021984 	.word	0x08021984
 800a098:	08021dd4 	.word	0x08021dd4

0800a09c <USBH_SetFeature>:
{
 800a09c:	b570      	push	{r4, r5, r6, lr}
  if (phost->RequestState == CMD_SEND)
 800a09e:	7885      	ldrb	r5, [r0, #2]
{
 800a0a0:	b082      	sub	sp, #8
 800a0a2:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 800a0a4:	2d01      	cmp	r5, #1
 800a0a6:	d01d      	beq.n	800a0e4 <USBH_SetFeature+0x48>
  switch (phost->RequestState)
 800a0a8:	2d02      	cmp	r5, #2
 800a0aa:	d117      	bne.n	800a0dc <USBH_SetFeature+0x40>
  switch (phost->Control.state)
 800a0ac:	f890 c018 	ldrb.w	ip, [r0, #24]
 800a0b0:	f10c 33ff 	add.w	r3, ip, #4294967295
 800a0b4:	2b0a      	cmp	r3, #10
 800a0b6:	d811      	bhi.n	800a0dc <USBH_SetFeature+0x40>
 800a0b8:	e8df f003 	tbb	[pc, r3]
 800a0bc:	0646372e 	.word	0x0646372e
 800a0c0:	7c706053 	.word	0x7c706053
 800a0c4:	9a8d      	.short	0x9a8d
 800a0c6:	22          	.byte	0x22
 800a0c7:	00          	.byte	0x00
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a0c8:	7901      	ldrb	r1, [r0, #4]
 800a0ca:	f014 fdd7 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a0ce:	2801      	cmp	r0, #1
 800a0d0:	f000 8096 	beq.w	800a200 <USBH_SetFeature+0x164>
      if (URB_Status == USBH_URB_STALL)
 800a0d4:	2805      	cmp	r0, #5
 800a0d6:	d076      	beq.n	800a1c6 <USBH_SetFeature+0x12a>
        if (URB_Status == USBH_URB_ERROR)
 800a0d8:	2804      	cmp	r0, #4
 800a0da:	d031      	beq.n	800a140 <USBH_SetFeature+0xa4>
  switch (phost->Control.state)
 800a0dc:	2501      	movs	r5, #1
}
 800a0de:	4628      	mov	r0, r5
 800a0e0:	b002      	add	sp, #8
 800a0e2:	bd70      	pop	{r4, r5, r6, pc}
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800a0e4:	f44f 7040 	mov.w	r0, #768	; 0x300
      phost->Control.buff = buff;
 800a0e8:	2300      	movs	r3, #0
      phost->RequestState = CMD_WAIT;
 800a0ea:	2202      	movs	r2, #2
    phost->Control.setup.b.wValue.w = wValue;
 800a0ec:	8261      	strh	r1, [r4, #18]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800a0ee:	8220      	strh	r0, [r4, #16]
}
 800a0f0:	4628      	mov	r0, r5
      phost->Control.buff = buff;
 800a0f2:	60a3      	str	r3, [r4, #8]
      phost->Control.length = length;
 800a0f4:	81a3      	strh	r3, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 800a0f6:	6163      	str	r3, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 800a0f8:	7625      	strb	r5, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800a0fa:	70a2      	strb	r2, [r4, #2]
}
 800a0fc:	b002      	add	sp, #8
 800a0fe:	bd70      	pop	{r4, r5, r6, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800a100:	7e43      	ldrb	r3, [r0, #25]
 800a102:	3301      	adds	r3, #1
 800a104:	b2db      	uxtb	r3, r3
 800a106:	2b02      	cmp	r3, #2
 800a108:	7643      	strb	r3, [r0, #25]
 800a10a:	f200 8085 	bhi.w	800a218 <USBH_SetFeature+0x17c>
        phost->Control.state = CTRL_SETUP;
 800a10e:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 800a110:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 800a112:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800a114:	7083      	strb	r3, [r0, #2]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a116:	e7e2      	b.n	800a0de <USBH_SetFeature+0x42>
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a118:	7942      	ldrb	r2, [r0, #5]
 800a11a:	f100 0110 	add.w	r1, r0, #16
  USBH_StatusTypeDef status = USBH_BUSY;
 800a11e:	4665      	mov	r5, ip
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a120:	f000 fa6e 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800a124:	2302      	movs	r3, #2
 800a126:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a128:	e7d9      	b.n	800a0de <USBH_SetFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a12a:	7941      	ldrb	r1, [r0, #5]
 800a12c:	f014 fda6 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a130:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a132:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 800a134:	f000 8089 	beq.w	800a24a <USBH_SetFeature+0x1ae>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800a138:	2804      	cmp	r0, #4
 800a13a:	d001      	beq.n	800a140 <USBH_SetFeature+0xa4>
 800a13c:	2802      	cmp	r0, #2
 800a13e:	d1cd      	bne.n	800a0dc <USBH_SetFeature+0x40>
          phost->Control.state = CTRL_ERROR;
 800a140:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 800a142:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 800a144:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a146:	e7ca      	b.n	800a0de <USBH_SetFeature+0x42>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a148:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 800a14c:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a14e:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800a150:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a152:	4620      	mov	r0, r4
 800a154:	89a2      	ldrh	r2, [r4, #12]
 800a156:	68a1      	ldr	r1, [r4, #8]
 800a158:	f000 fa7c 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800a15c:	2304      	movs	r3, #4
 800a15e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a160:	e7bd      	b.n	800a0de <USBH_SetFeature+0x42>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800a162:	2501      	movs	r5, #1
 800a164:	7943      	ldrb	r3, [r0, #5]
 800a166:	8982      	ldrh	r2, [r0, #12]
 800a168:	6881      	ldr	r1, [r0, #8]
 800a16a:	9500      	str	r5, [sp, #0]
 800a16c:	f000 fa58 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a170:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a174:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 800a176:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a178:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a17a:	e7b0      	b.n	800a0de <USBH_SetFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a17c:	7941      	ldrb	r1, [r0, #5]
 800a17e:	f014 fd7d 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a182:	2801      	cmp	r0, #1
 800a184:	d044      	beq.n	800a210 <USBH_SetFeature+0x174>
      else if (URB_Status == USBH_URB_STALL)
 800a186:	2805      	cmp	r0, #5
 800a188:	d01d      	beq.n	800a1c6 <USBH_SetFeature+0x12a>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a18a:	2802      	cmp	r0, #2
 800a18c:	d063      	beq.n	800a256 <USBH_SetFeature+0x1ba>
        if (URB_Status == USBH_URB_ERROR)
 800a18e:	2804      	cmp	r0, #4
 800a190:	d1a4      	bne.n	800a0dc <USBH_SetFeature+0x40>
          phost->Control.state = CTRL_ERROR;
 800a192:	230b      	movs	r3, #11
 800a194:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 800a196:	2301      	movs	r3, #1
 800a198:	70a3      	strb	r3, [r4, #2]
 800a19a:	e7a0      	b.n	800a0de <USBH_SetFeature+0x42>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a19c:	2200      	movs	r2, #0
 800a19e:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 800a1a0:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a1a2:	4611      	mov	r1, r2
 800a1a4:	f000 fa56 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a1a8:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a1ac:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 800a1ae:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a1b0:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a1b2:	e794      	b.n	800a0de <USBH_SetFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a1b4:	7901      	ldrb	r1, [r0, #4]
 800a1b6:	f014 fd61 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a1ba:	2801      	cmp	r0, #1
 800a1bc:	d024      	beq.n	800a208 <USBH_SetFeature+0x16c>
      else if (URB_Status == USBH_URB_ERROR)
 800a1be:	2804      	cmp	r0, #4
 800a1c0:	d0be      	beq.n	800a140 <USBH_SetFeature+0xa4>
        if (URB_Status == USBH_URB_STALL)
 800a1c2:	2805      	cmp	r0, #5
 800a1c4:	d18a      	bne.n	800a0dc <USBH_SetFeature+0x40>
        status = USBH_NOT_SUPPORTED;
 800a1c6:	2503      	movs	r5, #3
        phost->RequestState = CMD_SEND;
 800a1c8:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800a1ca:	2300      	movs	r3, #0
}
 800a1cc:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 800a1ce:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800a1d0:	7623      	strb	r3, [r4, #24]
}
 800a1d2:	b002      	add	sp, #8
 800a1d4:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800a1d6:	2200      	movs	r2, #0
 800a1d8:	2501      	movs	r5, #1
 800a1da:	7943      	ldrb	r3, [r0, #5]
 800a1dc:	4611      	mov	r1, r2
 800a1de:	9500      	str	r5, [sp, #0]
 800a1e0:	f000 fa1e 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a1e4:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a1e8:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 800a1ea:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a1ec:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a1ee:	e776      	b.n	800a0de <USBH_SetFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a1f0:	7941      	ldrb	r1, [r0, #5]
 800a1f2:	f014 fd43 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a1f6:	2801      	cmp	r0, #1
 800a1f8:	d006      	beq.n	800a208 <USBH_SetFeature+0x16c>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a1fa:	2802      	cmp	r0, #2
 800a1fc:	f47f af6c 	bne.w	800a0d8 <USBH_SetFeature+0x3c>
            phost->Control.state = CTRL_STATUS_OUT;
 800a200:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 800a202:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 800a204:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a206:	e76a      	b.n	800a0de <USBH_SetFeature+0x42>
        status = USBH_OK;
 800a208:	2500      	movs	r5, #0
 800a20a:	e7dd      	b.n	800a1c8 <USBH_SetFeature+0x12c>
          if (direction == USB_D2H)
 800a20c:	0613      	lsls	r3, r2, #24
 800a20e:	d4f7      	bmi.n	800a200 <USBH_SetFeature+0x164>
            phost->Control.state = CTRL_STATUS_IN;
 800a210:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800a212:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800a214:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a216:	e762      	b.n	800a0de <USBH_SetFeature+0x42>
        phost->Control.errorcount = 0U;
 800a218:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800a21a:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 800a21e:	2106      	movs	r1, #6
 800a220:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800a222:	4810      	ldr	r0, [pc, #64]	; (800a264 <USBH_SetFeature+0x1c8>)
        phost->Control.errorcount = 0U;
 800a224:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800a226:	f016 f857 	bl	80202d8 <iprintf>
 800a22a:	480f      	ldr	r0, [pc, #60]	; (800a268 <USBH_SetFeature+0x1cc>)
 800a22c:	f016 f854 	bl	80202d8 <iprintf>
 800a230:	200a      	movs	r0, #10
 800a232:	f016 f869 	bl	8020308 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800a236:	7961      	ldrb	r1, [r4, #5]
 800a238:	4620      	mov	r0, r4
 800a23a:	f000 faa9 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800a23e:	7921      	ldrb	r1, [r4, #4]
 800a240:	4620      	mov	r0, r4
 800a242:	f000 faa5 	bl	800a790 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800a246:	7026      	strb	r6, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a248:	e7a5      	b.n	800a196 <USBH_SetFeature+0xfa>
        if (phost->Control.setup.b.wLength.w != 0U)
 800a24a:	8ae3      	ldrh	r3, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800a24c:	7c22      	ldrb	r2, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 800a24e:	2b00      	cmp	r3, #0
 800a250:	d0dc      	beq.n	800a20c <USBH_SetFeature+0x170>
          if (direction == USB_D2H)
 800a252:	0612      	lsls	r2, r2, #24
 800a254:	d403      	bmi.n	800a25e <USBH_SetFeature+0x1c2>
            phost->Control.state = CTRL_DATA_OUT;
 800a256:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 800a258:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 800a25a:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a25c:	e73f      	b.n	800a0de <USBH_SetFeature+0x42>
            phost->Control.state = CTRL_DATA_IN;
 800a25e:	2303      	movs	r3, #3
 800a260:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a262:	e73c      	b.n	800a0de <USBH_SetFeature+0x42>
 800a264:	08021984 	.word	0x08021984
 800a268:	08021dd4 	.word	0x08021dd4

0800a26c <USBH_ClrFeature>:
{
 800a26c:	b570      	push	{r4, r5, r6, lr}
  if (phost->RequestState == CMD_SEND)
 800a26e:	7885      	ldrb	r5, [r0, #2]
{
 800a270:	b082      	sub	sp, #8
 800a272:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 800a274:	2d01      	cmp	r5, #1
 800a276:	d01d      	beq.n	800a2b4 <USBH_ClrFeature+0x48>
  switch (phost->RequestState)
 800a278:	2d02      	cmp	r5, #2
 800a27a:	d117      	bne.n	800a2ac <USBH_ClrFeature+0x40>
  switch (phost->Control.state)
 800a27c:	f890 c018 	ldrb.w	ip, [r0, #24]
 800a280:	f10c 33ff 	add.w	r3, ip, #4294967295
 800a284:	2b0a      	cmp	r3, #10
 800a286:	d811      	bhi.n	800a2ac <USBH_ClrFeature+0x40>
 800a288:	e8df f003 	tbb	[pc, r3]
 800a28c:	0646372e 	.word	0x0646372e
 800a290:	7c706053 	.word	0x7c706053
 800a294:	9a8d      	.short	0x9a8d
 800a296:	22          	.byte	0x22
 800a297:	00          	.byte	0x00
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a298:	7901      	ldrb	r1, [r0, #4]
 800a29a:	f014 fcef 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a29e:	2801      	cmp	r0, #1
 800a2a0:	f000 8096 	beq.w	800a3d0 <USBH_ClrFeature+0x164>
      if (URB_Status == USBH_URB_STALL)
 800a2a4:	2805      	cmp	r0, #5
 800a2a6:	d076      	beq.n	800a396 <USBH_ClrFeature+0x12a>
        if (URB_Status == USBH_URB_ERROR)
 800a2a8:	2804      	cmp	r0, #4
 800a2aa:	d031      	beq.n	800a310 <USBH_ClrFeature+0xa4>
  switch (phost->Control.state)
 800a2ac:	2501      	movs	r5, #1
}
 800a2ae:	4628      	mov	r0, r5
 800a2b0:	b002      	add	sp, #8
 800a2b2:	bd70      	pop	{r4, r5, r6, pc}
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 800a2b4:	f44f 7081 	mov.w	r0, #258	; 0x102
    phost->Control.setup.b.wLength.w = 0U;
 800a2b8:	2300      	movs	r3, #0
      phost->RequestState = CMD_WAIT;
 800a2ba:	2202      	movs	r2, #2
    phost->Control.setup.b.wIndex.w = ep_num;
 800a2bc:	82a1      	strh	r1, [r4, #20]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 800a2be:	6120      	str	r0, [r4, #16]
}
 800a2c0:	4628      	mov	r0, r5
    phost->Control.setup.b.wLength.w = 0U;
 800a2c2:	82e3      	strh	r3, [r4, #22]
      phost->Control.buff = buff;
 800a2c4:	60a3      	str	r3, [r4, #8]
      phost->Control.length = length;
 800a2c6:	81a3      	strh	r3, [r4, #12]
      phost->Control.state = CTRL_SETUP;
 800a2c8:	7625      	strb	r5, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800a2ca:	70a2      	strb	r2, [r4, #2]
}
 800a2cc:	b002      	add	sp, #8
 800a2ce:	bd70      	pop	{r4, r5, r6, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800a2d0:	7e43      	ldrb	r3, [r0, #25]
 800a2d2:	3301      	adds	r3, #1
 800a2d4:	b2db      	uxtb	r3, r3
 800a2d6:	2b02      	cmp	r3, #2
 800a2d8:	7643      	strb	r3, [r0, #25]
 800a2da:	f200 8085 	bhi.w	800a3e8 <USBH_ClrFeature+0x17c>
        phost->Control.state = CTRL_SETUP;
 800a2de:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 800a2e0:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 800a2e2:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800a2e4:	7083      	strb	r3, [r0, #2]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a2e6:	e7e2      	b.n	800a2ae <USBH_ClrFeature+0x42>
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a2e8:	7942      	ldrb	r2, [r0, #5]
 800a2ea:	f100 0110 	add.w	r1, r0, #16
  USBH_StatusTypeDef status = USBH_BUSY;
 800a2ee:	4665      	mov	r5, ip
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a2f0:	f000 f986 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800a2f4:	2302      	movs	r3, #2
 800a2f6:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a2f8:	e7d9      	b.n	800a2ae <USBH_ClrFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a2fa:	7941      	ldrb	r1, [r0, #5]
 800a2fc:	f014 fcbe 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a300:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a302:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 800a304:	f000 8089 	beq.w	800a41a <USBH_ClrFeature+0x1ae>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800a308:	2804      	cmp	r0, #4
 800a30a:	d001      	beq.n	800a310 <USBH_ClrFeature+0xa4>
 800a30c:	2802      	cmp	r0, #2
 800a30e:	d1cd      	bne.n	800a2ac <USBH_ClrFeature+0x40>
          phost->Control.state = CTRL_ERROR;
 800a310:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 800a312:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 800a314:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a316:	e7ca      	b.n	800a2ae <USBH_ClrFeature+0x42>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a318:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 800a31c:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a31e:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800a320:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a322:	4620      	mov	r0, r4
 800a324:	89a2      	ldrh	r2, [r4, #12]
 800a326:	68a1      	ldr	r1, [r4, #8]
 800a328:	f000 f994 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800a32c:	2304      	movs	r3, #4
 800a32e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a330:	e7bd      	b.n	800a2ae <USBH_ClrFeature+0x42>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800a332:	2501      	movs	r5, #1
 800a334:	7943      	ldrb	r3, [r0, #5]
 800a336:	8982      	ldrh	r2, [r0, #12]
 800a338:	6881      	ldr	r1, [r0, #8]
 800a33a:	9500      	str	r5, [sp, #0]
 800a33c:	f000 f970 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a340:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a344:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 800a346:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a348:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a34a:	e7b0      	b.n	800a2ae <USBH_ClrFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a34c:	7941      	ldrb	r1, [r0, #5]
 800a34e:	f014 fc95 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a352:	2801      	cmp	r0, #1
 800a354:	d044      	beq.n	800a3e0 <USBH_ClrFeature+0x174>
      else if (URB_Status == USBH_URB_STALL)
 800a356:	2805      	cmp	r0, #5
 800a358:	d01d      	beq.n	800a396 <USBH_ClrFeature+0x12a>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a35a:	2802      	cmp	r0, #2
 800a35c:	d063      	beq.n	800a426 <USBH_ClrFeature+0x1ba>
        if (URB_Status == USBH_URB_ERROR)
 800a35e:	2804      	cmp	r0, #4
 800a360:	d1a4      	bne.n	800a2ac <USBH_ClrFeature+0x40>
          phost->Control.state = CTRL_ERROR;
 800a362:	230b      	movs	r3, #11
 800a364:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 800a366:	2301      	movs	r3, #1
 800a368:	70a3      	strb	r3, [r4, #2]
 800a36a:	e7a0      	b.n	800a2ae <USBH_ClrFeature+0x42>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a36c:	2200      	movs	r2, #0
 800a36e:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 800a370:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a372:	4611      	mov	r1, r2
 800a374:	f000 f96e 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a378:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a37c:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 800a37e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a380:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a382:	e794      	b.n	800a2ae <USBH_ClrFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a384:	7901      	ldrb	r1, [r0, #4]
 800a386:	f014 fc79 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a38a:	2801      	cmp	r0, #1
 800a38c:	d024      	beq.n	800a3d8 <USBH_ClrFeature+0x16c>
      else if (URB_Status == USBH_URB_ERROR)
 800a38e:	2804      	cmp	r0, #4
 800a390:	d0be      	beq.n	800a310 <USBH_ClrFeature+0xa4>
        if (URB_Status == USBH_URB_STALL)
 800a392:	2805      	cmp	r0, #5
 800a394:	d18a      	bne.n	800a2ac <USBH_ClrFeature+0x40>
        status = USBH_NOT_SUPPORTED;
 800a396:	2503      	movs	r5, #3
        phost->RequestState = CMD_SEND;
 800a398:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800a39a:	2300      	movs	r3, #0
}
 800a39c:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 800a39e:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800a3a0:	7623      	strb	r3, [r4, #24]
}
 800a3a2:	b002      	add	sp, #8
 800a3a4:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800a3a6:	2200      	movs	r2, #0
 800a3a8:	2501      	movs	r5, #1
 800a3aa:	7943      	ldrb	r3, [r0, #5]
 800a3ac:	4611      	mov	r1, r2
 800a3ae:	9500      	str	r5, [sp, #0]
 800a3b0:	f000 f936 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a3b4:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a3b8:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 800a3ba:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a3bc:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a3be:	e776      	b.n	800a2ae <USBH_ClrFeature+0x42>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a3c0:	7941      	ldrb	r1, [r0, #5]
 800a3c2:	f014 fc5b 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a3c6:	2801      	cmp	r0, #1
 800a3c8:	d006      	beq.n	800a3d8 <USBH_ClrFeature+0x16c>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a3ca:	2802      	cmp	r0, #2
 800a3cc:	f47f af6c 	bne.w	800a2a8 <USBH_ClrFeature+0x3c>
            phost->Control.state = CTRL_STATUS_OUT;
 800a3d0:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 800a3d2:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 800a3d4:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a3d6:	e76a      	b.n	800a2ae <USBH_ClrFeature+0x42>
        status = USBH_OK;
 800a3d8:	2500      	movs	r5, #0
 800a3da:	e7dd      	b.n	800a398 <USBH_ClrFeature+0x12c>
          if (direction == USB_D2H)
 800a3dc:	0613      	lsls	r3, r2, #24
 800a3de:	d4f7      	bmi.n	800a3d0 <USBH_ClrFeature+0x164>
            phost->Control.state = CTRL_STATUS_IN;
 800a3e0:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800a3e2:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800a3e4:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a3e6:	e762      	b.n	800a2ae <USBH_ClrFeature+0x42>
        phost->Control.errorcount = 0U;
 800a3e8:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800a3ea:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 800a3ee:	2106      	movs	r1, #6
 800a3f0:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800a3f2:	4810      	ldr	r0, [pc, #64]	; (800a434 <USBH_ClrFeature+0x1c8>)
        phost->Control.errorcount = 0U;
 800a3f4:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800a3f6:	f015 ff6f 	bl	80202d8 <iprintf>
 800a3fa:	480f      	ldr	r0, [pc, #60]	; (800a438 <USBH_ClrFeature+0x1cc>)
 800a3fc:	f015 ff6c 	bl	80202d8 <iprintf>
 800a400:	200a      	movs	r0, #10
 800a402:	f015 ff81 	bl	8020308 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800a406:	7961      	ldrb	r1, [r4, #5]
 800a408:	4620      	mov	r0, r4
 800a40a:	f000 f9c1 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800a40e:	7921      	ldrb	r1, [r4, #4]
 800a410:	4620      	mov	r0, r4
 800a412:	f000 f9bd 	bl	800a790 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800a416:	7026      	strb	r6, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a418:	e7a5      	b.n	800a366 <USBH_ClrFeature+0xfa>
        if (phost->Control.setup.b.wLength.w != 0U)
 800a41a:	8ae3      	ldrh	r3, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800a41c:	7c22      	ldrb	r2, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 800a41e:	2b00      	cmp	r3, #0
 800a420:	d0dc      	beq.n	800a3dc <USBH_ClrFeature+0x170>
          if (direction == USB_D2H)
 800a422:	0612      	lsls	r2, r2, #24
 800a424:	d403      	bmi.n	800a42e <USBH_ClrFeature+0x1c2>
            phost->Control.state = CTRL_DATA_OUT;
 800a426:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 800a428:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 800a42a:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a42c:	e73f      	b.n	800a2ae <USBH_ClrFeature+0x42>
            phost->Control.state = CTRL_DATA_IN;
 800a42e:	2303      	movs	r3, #3
 800a430:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a432:	e73c      	b.n	800a2ae <USBH_ClrFeature+0x42>
 800a434:	08021984 	.word	0x08021984
 800a438:	08021dd4 	.word	0x08021dd4

0800a43c <USBH_CtlReq>:
{
 800a43c:	b570      	push	{r4, r5, r6, lr}
  switch (phost->RequestState)
 800a43e:	7885      	ldrb	r5, [r0, #2]
{
 800a440:	b082      	sub	sp, #8
 800a442:	4604      	mov	r4, r0
  switch (phost->RequestState)
 800a444:	2d01      	cmp	r5, #1
 800a446:	d01e      	beq.n	800a486 <USBH_CtlReq+0x4a>
 800a448:	2d02      	cmp	r5, #2
 800a44a:	d118      	bne.n	800a47e <USBH_CtlReq+0x42>
  switch (phost->Control.state)
 800a44c:	f890 c018 	ldrb.w	ip, [r0, #24]
 800a450:	f10c 33ff 	add.w	r3, ip, #4294967295
 800a454:	2b0a      	cmp	r3, #10
 800a456:	d812      	bhi.n	800a47e <USBH_CtlReq+0x42>
 800a458:	e8df f003 	tbb	[pc, r3]
 800a45c:	7d850692 	.word	0x7d850692
 800a460:	43546070 	.word	0x43546070
 800a464:	2936      	.short	0x2936
 800a466:	1d          	.byte	0x1d
 800a467:	00          	.byte	0x00
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a468:	7941      	ldrb	r1, [r0, #5]
 800a46a:	f014 fc07 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a46e:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a470:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 800a472:	f000 80b3 	beq.w	800a5dc <USBH_CtlReq+0x1a0>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800a476:	2804      	cmp	r0, #4
 800a478:	d022      	beq.n	800a4c0 <USBH_CtlReq+0x84>
 800a47a:	2802      	cmp	r0, #2
 800a47c:	d020      	beq.n	800a4c0 <USBH_CtlReq+0x84>
  switch (phost->Control.state)
 800a47e:	2501      	movs	r5, #1
}
 800a480:	4628      	mov	r0, r5
 800a482:	b002      	add	sp, #8
 800a484:	bd70      	pop	{r4, r5, r6, pc}
      phost->RequestState = CMD_WAIT;
 800a486:	2302      	movs	r3, #2
      phost->Control.buff = buff;
 800a488:	6081      	str	r1, [r0, #8]
      phost->Control.length = length;
 800a48a:	8182      	strh	r2, [r0, #12]
      phost->Control.state = CTRL_SETUP;
 800a48c:	7605      	strb	r5, [r0, #24]
      phost->RequestState = CMD_WAIT;
 800a48e:	7083      	strb	r3, [r0, #2]
}
 800a490:	4628      	mov	r0, r5
 800a492:	b002      	add	sp, #8
 800a494:	bd70      	pop	{r4, r5, r6, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800a496:	7e43      	ldrb	r3, [r0, #25]
 800a498:	3301      	adds	r3, #1
 800a49a:	b2db      	uxtb	r3, r3
 800a49c:	2b02      	cmp	r3, #2
 800a49e:	7643      	strb	r3, [r0, #25]
 800a4a0:	f200 8083 	bhi.w	800a5aa <USBH_CtlReq+0x16e>
        phost->Control.state = CTRL_SETUP;
 800a4a4:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 800a4a6:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 800a4a8:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800a4aa:	7083      	strb	r3, [r0, #2]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a4ac:	e7e8      	b.n	800a480 <USBH_CtlReq+0x44>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a4ae:	7941      	ldrb	r1, [r0, #5]
 800a4b0:	f014 fbe4 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a4b4:	2801      	cmp	r0, #1
 800a4b6:	d06c      	beq.n	800a592 <USBH_CtlReq+0x156>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a4b8:	2802      	cmp	r0, #2
 800a4ba:	d06e      	beq.n	800a59a <USBH_CtlReq+0x15e>
        if (URB_Status == USBH_URB_ERROR)
 800a4bc:	2804      	cmp	r0, #4
 800a4be:	d1de      	bne.n	800a47e <USBH_CtlReq+0x42>
          phost->Control.state = CTRL_ERROR;
 800a4c0:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 800a4c2:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 800a4c4:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a4c6:	e7db      	b.n	800a480 <USBH_CtlReq+0x44>
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800a4c8:	2200      	movs	r2, #0
 800a4ca:	2501      	movs	r5, #1
 800a4cc:	7943      	ldrb	r3, [r0, #5]
 800a4ce:	4611      	mov	r1, r2
 800a4d0:	9500      	str	r5, [sp, #0]
 800a4d2:	f000 f8a5 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a4d6:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a4da:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 800a4dc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800a4de:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a4e0:	e7ce      	b.n	800a480 <USBH_CtlReq+0x44>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a4e2:	7901      	ldrb	r1, [r0, #4]
 800a4e4:	f014 fbca 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a4e8:	2801      	cmp	r0, #1
 800a4ea:	d052      	beq.n	800a592 <USBH_CtlReq+0x156>
      else if (URB_Status == USBH_URB_ERROR)
 800a4ec:	2804      	cmp	r0, #4
 800a4ee:	d0e7      	beq.n	800a4c0 <USBH_CtlReq+0x84>
        if (URB_Status == USBH_URB_STALL)
 800a4f0:	2805      	cmp	r0, #5
 800a4f2:	d1c4      	bne.n	800a47e <USBH_CtlReq+0x42>
        status = USBH_NOT_SUPPORTED;
 800a4f4:	2503      	movs	r5, #3
        phost->RequestState = CMD_SEND;
 800a4f6:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800a4f8:	2300      	movs	r3, #0
}
 800a4fa:	4628      	mov	r0, r5
        phost->RequestState = CMD_SEND;
 800a4fc:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800a4fe:	7623      	strb	r3, [r4, #24]
}
 800a500:	b002      	add	sp, #8
 800a502:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a504:	2200      	movs	r2, #0
 800a506:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 800a508:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800a50a:	4611      	mov	r1, r2
 800a50c:	f000 f8a2 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a510:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a514:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 800a516:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800a518:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a51a:	e7b1      	b.n	800a480 <USBH_CtlReq+0x44>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800a51c:	7941      	ldrb	r1, [r0, #5]
 800a51e:	f014 fbad 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a522:	2801      	cmp	r0, #1
 800a524:	d03d      	beq.n	800a5a2 <USBH_CtlReq+0x166>
      else if (URB_Status == USBH_URB_STALL)
 800a526:	2805      	cmp	r0, #5
 800a528:	d0e4      	beq.n	800a4f4 <USBH_CtlReq+0xb8>
      else if (URB_Status == USBH_URB_NOTREADY)
 800a52a:	2802      	cmp	r0, #2
 800a52c:	d05c      	beq.n	800a5e8 <USBH_CtlReq+0x1ac>
        if (URB_Status == USBH_URB_ERROR)
 800a52e:	2804      	cmp	r0, #4
 800a530:	d1a5      	bne.n	800a47e <USBH_CtlReq+0x42>
          phost->Control.state = CTRL_ERROR;
 800a532:	230b      	movs	r3, #11
 800a534:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 800a536:	2301      	movs	r3, #1
 800a538:	70a3      	strb	r3, [r4, #2]
 800a53a:	e7a1      	b.n	800a480 <USBH_CtlReq+0x44>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800a53c:	2501      	movs	r5, #1
 800a53e:	7943      	ldrb	r3, [r0, #5]
 800a540:	8982      	ldrh	r2, [r0, #12]
 800a542:	6881      	ldr	r1, [r0, #8]
 800a544:	9500      	str	r5, [sp, #0]
 800a546:	f000 f86b 	bl	800a620 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a54a:	f8d4 24c4 	ldr.w	r2, [r4, #1220]	; 0x4c4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a54e:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 800a550:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800a552:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a554:	e794      	b.n	800a480 <USBH_CtlReq+0x44>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800a556:	7901      	ldrb	r1, [r0, #4]
 800a558:	f014 fb90 	bl	801ec7c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800a55c:	2801      	cmp	r0, #1
 800a55e:	d01c      	beq.n	800a59a <USBH_CtlReq+0x15e>
      if (URB_Status == USBH_URB_STALL)
 800a560:	2805      	cmp	r0, #5
 800a562:	d1ab      	bne.n	800a4bc <USBH_CtlReq+0x80>
 800a564:	e7c6      	b.n	800a4f4 <USBH_CtlReq+0xb8>
      phost->Control.timer = (uint16_t)phost->Timer;
 800a566:	f8d0 04c4 	ldr.w	r0, [r0, #1220]	; 0x4c4
  USBH_StatusTypeDef status = USBH_BUSY;
 800a56a:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a56c:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800a56e:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800a570:	4620      	mov	r0, r4
 800a572:	89a2      	ldrh	r2, [r4, #12]
 800a574:	68a1      	ldr	r1, [r4, #8]
 800a576:	f000 f86d 	bl	800a654 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800a57a:	2304      	movs	r3, #4
 800a57c:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a57e:	e77f      	b.n	800a480 <USBH_CtlReq+0x44>
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a580:	7942      	ldrb	r2, [r0, #5]
 800a582:	f100 0110 	add.w	r1, r0, #16
  USBH_StatusTypeDef status = USBH_BUSY;
 800a586:	4665      	mov	r5, ip
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800a588:	f000 f83a 	bl	800a600 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800a58c:	2302      	movs	r3, #2
 800a58e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a590:	e776      	b.n	800a480 <USBH_CtlReq+0x44>
        status = USBH_OK;
 800a592:	2500      	movs	r5, #0
 800a594:	e7af      	b.n	800a4f6 <USBH_CtlReq+0xba>
          if (direction == USB_D2H)
 800a596:	0613      	lsls	r3, r2, #24
 800a598:	d503      	bpl.n	800a5a2 <USBH_CtlReq+0x166>
            phost->Control.state = CTRL_STATUS_OUT;
 800a59a:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 800a59c:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 800a59e:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a5a0:	e76e      	b.n	800a480 <USBH_CtlReq+0x44>
            phost->Control.state = CTRL_STATUS_IN;
 800a5a2:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800a5a4:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800a5a6:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a5a8:	e76a      	b.n	800a480 <USBH_CtlReq+0x44>
        phost->Control.errorcount = 0U;
 800a5aa:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800a5ac:	f8d0 34d4 	ldr.w	r3, [r0, #1236]	; 0x4d4
 800a5b0:	2106      	movs	r1, #6
 800a5b2:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800a5b4:	4810      	ldr	r0, [pc, #64]	; (800a5f8 <USBH_CtlReq+0x1bc>)
        phost->Control.errorcount = 0U;
 800a5b6:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800a5b8:	f015 fe8e 	bl	80202d8 <iprintf>
 800a5bc:	480f      	ldr	r0, [pc, #60]	; (800a5fc <USBH_CtlReq+0x1c0>)
 800a5be:	f015 fe8b 	bl	80202d8 <iprintf>
 800a5c2:	200a      	movs	r0, #10
 800a5c4:	f015 fea0 	bl	8020308 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800a5c8:	7961      	ldrb	r1, [r4, #5]
 800a5ca:	4620      	mov	r0, r4
 800a5cc:	f000 f8e0 	bl	800a790 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800a5d0:	7921      	ldrb	r1, [r4, #4]
 800a5d2:	4620      	mov	r0, r4
 800a5d4:	f000 f8dc 	bl	800a790 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800a5d8:	7026      	strb	r6, [r4, #0]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a5da:	e7ac      	b.n	800a536 <USBH_CtlReq+0xfa>
        if (phost->Control.setup.b.wLength.w != 0U)
 800a5dc:	8ae3      	ldrh	r3, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800a5de:	7c22      	ldrb	r2, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 800a5e0:	2b00      	cmp	r3, #0
 800a5e2:	d0d8      	beq.n	800a596 <USBH_CtlReq+0x15a>
          if (direction == USB_D2H)
 800a5e4:	0612      	lsls	r2, r2, #24
 800a5e6:	d403      	bmi.n	800a5f0 <USBH_CtlReq+0x1b4>
            phost->Control.state = CTRL_DATA_OUT;
 800a5e8:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 800a5ea:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 800a5ec:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a5ee:	e747      	b.n	800a480 <USBH_CtlReq+0x44>
            phost->Control.state = CTRL_DATA_IN;
 800a5f0:	2303      	movs	r3, #3
 800a5f2:	7623      	strb	r3, [r4, #24]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800a5f4:	e744      	b.n	800a480 <USBH_CtlReq+0x44>
 800a5f6:	bf00      	nop
 800a5f8:	08021984 	.word	0x08021984
 800a5fc:	08021dd4 	.word	0x08021dd4

0800a600 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 800a600:	b530      	push	{r4, r5, lr}

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a602:	2400      	movs	r4, #0
{
 800a604:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a606:	2508      	movs	r5, #8
 800a608:	9101      	str	r1, [sp, #4]
 800a60a:	4623      	mov	r3, r4
 800a60c:	4611      	mov	r1, r2
 800a60e:	9403      	str	r4, [sp, #12]
 800a610:	4622      	mov	r2, r4
 800a612:	9502      	str	r5, [sp, #8]
 800a614:	9400      	str	r4, [sp, #0]
 800a616:	f014 fb1d 	bl	801ec54 <USBH_LL_SubmitURB>
                          USBH_PID_SETUP,       /* Type setup       */
                          buff,                 /* data buffer      */
                          USBH_SETUP_PKT_SIZE,  /* data length      */
                          0U);
  return USBH_OK;
}
 800a61a:	4620      	mov	r0, r4
 800a61c:	b005      	add	sp, #20
 800a61e:	bd30      	pop	{r4, r5, pc}

0800a620 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 800a620:	b510      	push	{r4, lr}
 800a622:	460c      	mov	r4, r1
 800a624:	b084      	sub	sp, #16
 800a626:	4619      	mov	r1, r3
  if (phost->device.speed != USBH_SPEED_HIGH)
 800a628:	f890 341d 	ldrb.w	r3, [r0, #1053]	; 0x41d
  {
    do_ping = 0U;
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a62c:	e9cd 4201 	strd	r4, r2, [sp, #4]
    do_ping = 0U;
 800a630:	2b00      	cmp	r3, #0
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a632:	f04f 0401 	mov.w	r4, #1
 800a636:	f04f 0300 	mov.w	r3, #0
 800a63a:	9400      	str	r4, [sp, #0]
{
 800a63c:	f89d 4018 	ldrb.w	r4, [sp, #24]
    do_ping = 0U;
 800a640:	bf18      	it	ne
 800a642:	461c      	movne	r4, r3
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a644:	461a      	mov	r2, r3
 800a646:	9403      	str	r4, [sp, #12]
 800a648:	f014 fb04 	bl	801ec54 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
 800a64c:	2000      	movs	r0, #0
 800a64e:	b004      	add	sp, #16
 800a650:	bd10      	pop	{r4, pc}
 800a652:	bf00      	nop

0800a654 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 800a654:	b530      	push	{r4, r5, lr}
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a656:	2400      	movs	r4, #0
{
 800a658:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a65a:	2501      	movs	r5, #1
 800a65c:	9101      	str	r1, [sp, #4]
 800a65e:	4619      	mov	r1, r3
 800a660:	9202      	str	r2, [sp, #8]
 800a662:	4623      	mov	r3, r4
 800a664:	462a      	mov	r2, r5
 800a666:	9403      	str	r4, [sp, #12]
 800a668:	9500      	str	r5, [sp, #0]
 800a66a:	f014 faf3 	bl	801ec54 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;

}
 800a66e:	4620      	mov	r0, r4
 800a670:	b005      	add	sp, #20
 800a672:	bd30      	pop	{r4, r5, pc}

0800a674 <USBH_BulkSendData>:
USBH_StatusTypeDef USBH_BulkSendData(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint16_t length,
                                     uint8_t pipe_num,
                                     uint8_t do_ping)
{
 800a674:	b510      	push	{r4, lr}
 800a676:	460c      	mov	r4, r1
 800a678:	b084      	sub	sp, #16
 800a67a:	4619      	mov	r1, r3
  if (phost->device.speed != USBH_SPEED_HIGH)
 800a67c:	f890 341d 	ldrb.w	r3, [r0, #1053]	; 0x41d
  {
    do_ping = 0U;
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a680:	e9cd 4201 	strd	r4, r2, [sp, #4]
    do_ping = 0U;
 800a684:	2b00      	cmp	r3, #0
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a686:	f04f 0200 	mov.w	r2, #0
 800a68a:	f04f 0401 	mov.w	r4, #1
 800a68e:	f04f 0302 	mov.w	r3, #2
 800a692:	9400      	str	r4, [sp, #0]
{
 800a694:	f89d 4018 	ldrb.w	r4, [sp, #24]
    do_ping = 0U;
 800a698:	bf18      	it	ne
 800a69a:	4614      	movne	r4, r2
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a69c:	9403      	str	r4, [sp, #12]
 800a69e:	f014 fad9 	bl	801ec54 <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/
  return USBH_OK;
}
 800a6a2:	2000      	movs	r0, #0
 800a6a4:	b004      	add	sp, #16
 800a6a6:	bd10      	pop	{r4, pc}

0800a6a8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 800a6a8:	b530      	push	{r4, r5, lr}
 800a6aa:	b085      	sub	sp, #20
 800a6ac:	460d      	mov	r5, r1
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800a6ae:	2400      	movs	r4, #0
 800a6b0:	4619      	mov	r1, r3
 800a6b2:	9202      	str	r2, [sp, #8]
 800a6b4:	2201      	movs	r2, #1
 800a6b6:	2302      	movs	r3, #2
 800a6b8:	9403      	str	r4, [sp, #12]
 800a6ba:	e9cd 2500 	strd	r2, r5, [sp]
 800a6be:	f014 fac9 	bl	801ec54 <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
}
 800a6c2:	4620      	mov	r0, r4
 800a6c4:	b005      	add	sp, #20
 800a6c6:	bd30      	pop	{r4, r5, pc}

0800a6c8 <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 800a6c8:	b510      	push	{r4, lr}
 800a6ca:	b084      	sub	sp, #16
 800a6cc:	f89d 4018 	ldrb.w	r4, [sp, #24]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800a6d0:	9400      	str	r4, [sp, #0]
{
 800a6d2:	f89d 401c 	ldrb.w	r4, [sp, #28]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800a6d6:	9401      	str	r4, [sp, #4]
{
 800a6d8:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800a6dc:	9402      	str	r4, [sp, #8]
 800a6de:	f014 fa9f 	bl	801ec20 <USBH_LL_OpenPipe>

  return USBH_OK;
}
 800a6e2:	2000      	movs	r0, #0
 800a6e4:	b004      	add	sp, #16
 800a6e6:	bd10      	pop	{r4, pc}

0800a6e8 <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 800a6e8:	b508      	push	{r3, lr}
  (void)USBH_LL_ClosePipe(phost, pipe_num);
 800a6ea:	f014 faab 	bl	801ec44 <USBH_LL_ClosePipe>

  return USBH_OK;
}
 800a6ee:	2000      	movs	r0, #0
 800a6f0:	bd08      	pop	{r3, pc}
 800a6f2:	bf00      	nop

0800a6f4 <USBH_AllocPipe>:
{
  uint8_t idx = 0U;

  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 800a6f4:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 800a6f8:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
 800a6fc:	d02a      	beq.n	800a754 <USBH_AllocPipe+0x60>
 800a6fe:	f8d0 3488 	ldr.w	r3, [r0, #1160]	; 0x488
 800a702:	041a      	lsls	r2, r3, #16
 800a704:	d52f      	bpl.n	800a766 <USBH_AllocPipe+0x72>
 800a706:	f8d0 348c 	ldr.w	r3, [r0, #1164]	; 0x48c
 800a70a:	041b      	lsls	r3, r3, #16
 800a70c:	d52d      	bpl.n	800a76a <USBH_AllocPipe+0x76>
 800a70e:	f8d0 3490 	ldr.w	r3, [r0, #1168]	; 0x490
 800a712:	041a      	lsls	r2, r3, #16
 800a714:	d52b      	bpl.n	800a76e <USBH_AllocPipe+0x7a>
 800a716:	f8d0 3494 	ldr.w	r3, [r0, #1172]	; 0x494
 800a71a:	041b      	lsls	r3, r3, #16
 800a71c:	d529      	bpl.n	800a772 <USBH_AllocPipe+0x7e>
 800a71e:	f8d0 3498 	ldr.w	r3, [r0, #1176]	; 0x498
 800a722:	041a      	lsls	r2, r3, #16
 800a724:	d527      	bpl.n	800a776 <USBH_AllocPipe+0x82>
 800a726:	f8d0 349c 	ldr.w	r3, [r0, #1180]	; 0x49c
 800a72a:	041b      	lsls	r3, r3, #16
 800a72c:	d525      	bpl.n	800a77a <USBH_AllocPipe+0x86>
 800a72e:	f8d0 34a0 	ldr.w	r3, [r0, #1184]	; 0x4a0
 800a732:	041a      	lsls	r2, r3, #16
 800a734:	d523      	bpl.n	800a77e <USBH_AllocPipe+0x8a>
 800a736:	f8d0 34a4 	ldr.w	r3, [r0, #1188]	; 0x4a4
 800a73a:	041b      	lsls	r3, r3, #16
 800a73c:	d521      	bpl.n	800a782 <USBH_AllocPipe+0x8e>
 800a73e:	f8d0 34a8 	ldr.w	r3, [r0, #1192]	; 0x4a8
 800a742:	041a      	lsls	r2, r3, #16
 800a744:	d51f      	bpl.n	800a786 <USBH_AllocPipe+0x92>
 800a746:	f8d0 34ac 	ldr.w	r3, [r0, #1196]	; 0x4ac
 800a74a:	041b      	lsls	r3, r3, #16
 800a74c:	d51d      	bpl.n	800a78a <USBH_AllocPipe+0x96>
 800a74e:	22ff      	movs	r2, #255	; 0xff
}
 800a750:	4610      	mov	r0, r2
 800a752:	4770      	bx	lr
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800a754:	461a      	mov	r2, r3
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800a756:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 800a75a:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
}
 800a75e:	4610      	mov	r0, r2
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800a760:	f8c3 1484 	str.w	r1, [r3, #1156]	; 0x484
}
 800a764:	4770      	bx	lr
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800a766:	2201      	movs	r2, #1
 800a768:	e7f5      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a76a:	2202      	movs	r2, #2
 800a76c:	e7f3      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a76e:	2203      	movs	r2, #3
 800a770:	e7f1      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a772:	2204      	movs	r2, #4
 800a774:	e7ef      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a776:	2205      	movs	r2, #5
 800a778:	e7ed      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a77a:	2206      	movs	r2, #6
 800a77c:	e7eb      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a77e:	2207      	movs	r2, #7
 800a780:	e7e9      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a782:	2208      	movs	r2, #8
 800a784:	e7e7      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a786:	2209      	movs	r2, #9
 800a788:	e7e5      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a78a:	220a      	movs	r2, #10
 800a78c:	e7e3      	b.n	800a756 <USBH_AllocPipe+0x62>
 800a78e:	bf00      	nop

0800a790 <USBH_FreePipe>:
  if (idx < USBH_MAX_PIPES_NBR)
 800a790:	290a      	cmp	r1, #10
 800a792:	d807      	bhi.n	800a7a4 <USBH_FreePipe+0x14>
    phost->Pipes[idx] &= 0x7FFFU;
 800a794:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 800a798:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 800a79c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800a7a0:	f8c0 3484 	str.w	r3, [r0, #1156]	; 0x484
}
 800a7a4:	2000      	movs	r0, #0
 800a7a6:	4770      	bx	lr

0800a7a8 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800a7a8:	4b03      	ldr	r3, [pc, #12]	; (800a7b8 <disk_status+0x10>)
 800a7aa:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800a7ae:	4403      	add	r3, r0
 800a7b0:	6852      	ldr	r2, [r2, #4]
 800a7b2:	7b18      	ldrb	r0, [r3, #12]
 800a7b4:	6853      	ldr	r3, [r2, #4]
 800a7b6:	4718      	bx	r3
 800a7b8:	2000079c 	.word	0x2000079c

0800a7bc <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 800a7bc:	4b07      	ldr	r3, [pc, #28]	; (800a7dc <disk_initialize+0x20>)
 800a7be:	5c1a      	ldrb	r2, [r3, r0]
 800a7c0:	b952      	cbnz	r2, 800a7d8 <disk_initialize+0x1c>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800a7c2:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800a7c6:	1819      	adds	r1, r3, r0
    disk.is_initialized[pdrv] = 1;
 800a7c8:	f04f 0c01 	mov.w	ip, #1
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800a7cc:	6852      	ldr	r2, [r2, #4]
    disk.is_initialized[pdrv] = 1;
 800a7ce:	f803 c000 	strb.w	ip, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800a7d2:	7b08      	ldrb	r0, [r1, #12]
 800a7d4:	6813      	ldr	r3, [r2, #0]
 800a7d6:	4718      	bx	r3
  }
  return stat;
}
 800a7d8:	2000      	movs	r0, #0
 800a7da:	4770      	bx	lr
 800a7dc:	2000079c 	.word	0x2000079c

0800a7e0 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800a7e0:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800a7e2:	4c05      	ldr	r4, [pc, #20]	; (800a7f8 <disk_read+0x18>)
 800a7e4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 800a7e8:	4404      	add	r4, r0
 800a7ea:	686d      	ldr	r5, [r5, #4]
 800a7ec:	7b20      	ldrb	r0, [r4, #12]
 800a7ee:	68ac      	ldr	r4, [r5, #8]
 800a7f0:	46a4      	mov	ip, r4
  return res;
}
 800a7f2:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800a7f4:	4760      	bx	ip
 800a7f6:	bf00      	nop
 800a7f8:	2000079c 	.word	0x2000079c

0800a7fc <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno	 	/* Pointer to the file information to be filled */
)
{
 800a7fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FATFS *fs = dp->obj.fs;
#endif


	fno->fname[0] = 0;		/* Invaidate file info */
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 800a800:	6b82      	ldr	r2, [r0, #56]	; 0x38
	fno->fname[0] = 0;		/* Invaidate file info */
 800a802:	2500      	movs	r5, #0
	FATFS *fs = dp->obj.fs;
 800a804:	6803      	ldr	r3, [r0, #0]
	fno->fname[0] = 0;		/* Invaidate file info */
 800a806:	644d      	str	r5, [r1, #68]	; 0x44
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 800a808:	2a00      	cmp	r2, #0
 800a80a:	f000 8084 	beq.w	800a916 <get_fileinfo+0x11a>

#if _USE_LFN != 0	/* LFN configuration */
#if _FS_EXFAT
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800a80e:	781a      	ldrb	r2, [r3, #0]
 800a810:	468a      	mov	sl, r1
 800a812:	2a04      	cmp	r2, #4
 800a814:	f000 8081 	beq.w	800a91a <get_fileinfo+0x11e>
		get_xdir_info(fs->dirbuf, fno);
		return;
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 800a818:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 800a81a:	4606      	mov	r6, r0
 800a81c:	3201      	adds	r2, #1
 800a81e:	d01b      	beq.n	800a858 <get_fileinfo+0x5c>
			i = j = 0;
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800a820:	68d9      	ldr	r1, [r3, #12]
 800a822:	680a      	ldr	r2, [r1, #0]
 800a824:	2a00      	cmp	r2, #0
 800a826:	f000 80a1 	beq.w	800a96c <get_fileinfo+0x170>
 800a82a:	f10a 0040 	add.w	r0, sl, #64	; 0x40
 800a82e:	2301      	movs	r3, #1
 800a830:	e003      	b.n	800a83a <get_fileinfo+0x3e>
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
					fno->fname[i++] = (char)(w >> 8);
				}
#endif
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
 800a832:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a836:	f000 8099 	beq.w	800a96c <get_fileinfo+0x170>
				fno->fname[i++] = (TCHAR)w;
 800a83a:	f840 2f04 	str.w	r2, [r0, #4]!
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800a83e:	461c      	mov	r4, r3
 800a840:	f851 2f04 	ldr.w	r2, [r1, #4]!
 800a844:	3301      	adds	r3, #1
 800a846:	2a00      	cmp	r2, #0
 800a848:	d1f3      	bne.n	800a832 <get_fileinfo+0x36>
			}
			fno->fname[i] = 0;	/* Terminate the LFN */
 800a84a:	3410      	adds	r4, #16
 800a84c:	2300      	movs	r3, #0
 800a84e:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
 800a852:	6063      	str	r3, [r4, #4]
		}
	}

	i = j = 0;
	lfv = fno->fname[i];	/* LFN is exist if non-zero */
 800a854:	f8da 5044 	ldr.w	r5, [sl, #68]	; 0x44
	i = j = 0;
 800a858:	f04f 0900 	mov.w	r9, #0
	while (i < 11) {		/* Copy name body and extension */
		c = (TCHAR)dp->dir[i++];
 800a85c:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
			c = c << 8 | dp->dir[i++];
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
		fno->altname[j] = c;
 800a85e:	273f      	movs	r7, #63	; 0x3f
			fno->altname[j++] = '.';
 800a860:	f04f 082e 	mov.w	r8, #46	; 0x2e
	i = j = 0;
 800a864:	464c      	mov	r4, r9
 800a866:	e017      	b.n	800a898 <get_fileinfo+0x9c>
		fno->altname[j] = c;
 800a868:	f84a 0023 	str.w	r0, [sl, r3, lsl #2]
		if (!lfv) {
 800a86c:	bb55      	cbnz	r5, 800a8c4 <get_fileinfo+0xc8>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800a86e:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 800a872:	2b19      	cmp	r3, #25
 800a874:	f200 8083 	bhi.w	800a97e <get_fileinfo+0x182>
 800a878:	2c08      	cmp	r4, #8
 800a87a:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 800a87c:	bf8c      	ite	hi
 800a87e:	2310      	movhi	r3, #16
 800a880:	2308      	movls	r3, #8
 800a882:	7b11      	ldrb	r1, [r2, #12]
 800a884:	4219      	tst	r1, r3
				c += 0x20;			/* To lower */
 800a886:	bf18      	it	ne
 800a888:	3020      	addne	r0, #32
			}
			fno->fname[j] = c;
 800a88a:	eb0a 0389 	add.w	r3, sl, r9, lsl #2
 800a88e:	6458      	str	r0, [r3, #68]	; 0x44
		}
		j++;
 800a890:	f109 0901 	add.w	r9, r9, #1
	while (i < 11) {		/* Copy name body and extension */
 800a894:	2c0b      	cmp	r4, #11
 800a896:	d023      	beq.n	800a8e0 <get_fileinfo+0xe4>
		c = (TCHAR)dp->dir[i++];
 800a898:	5d10      	ldrb	r0, [r2, r4]
 800a89a:	3401      	adds	r4, #1
		if (c == ' ') continue;				/* Skip padding spaces */
 800a89c:	2820      	cmp	r0, #32
 800a89e:	d0f9      	beq.n	800a894 <get_fileinfo+0x98>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800a8a0:	2805      	cmp	r0, #5
 800a8a2:	bf08      	it	eq
 800a8a4:	20e5      	moveq	r0, #229	; 0xe5
		if (i == 9) {						/* Insert a . if extension is exist */
 800a8a6:	2c09      	cmp	r4, #9
 800a8a8:	d00e      	beq.n	800a8c8 <get_fileinfo+0xcc>
		c = ff_convert(c, 1);	/* OEM -> Unicode */
 800a8aa:	2101      	movs	r1, #1
 800a8ac:	f002 f872 	bl	800c994 <ff_convert>
		fno->altname[j] = c;
 800a8b0:	f109 0304 	add.w	r3, r9, #4
		if (!c) c = '?';
 800a8b4:	2800      	cmp	r0, #0
 800a8b6:	d1d7      	bne.n	800a868 <get_fileinfo+0x6c>
		fno->altname[j] = c;
 800a8b8:	f84a 7023 	str.w	r7, [sl, r3, lsl #2]
		if (!lfv) {
 800a8bc:	b915      	cbnz	r5, 800a8c4 <get_fileinfo+0xc8>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800a8be:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
		if (!c) c = '?';
 800a8c0:	203f      	movs	r0, #63	; 0x3f
 800a8c2:	e7e2      	b.n	800a88a <get_fileinfo+0x8e>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800a8c4:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 800a8c6:	e7e3      	b.n	800a890 <get_fileinfo+0x94>
			if (!lfv) fno->fname[j] = '.';
 800a8c8:	b91d      	cbnz	r5, 800a8d2 <get_fileinfo+0xd6>
 800a8ca:	eb0a 0389 	add.w	r3, sl, r9, lsl #2
 800a8ce:	f8c3 8044 	str.w	r8, [r3, #68]	; 0x44
			fno->altname[j++] = '.';
 800a8d2:	f109 0304 	add.w	r3, r9, #4
 800a8d6:	f109 0901 	add.w	r9, r9, #1
 800a8da:	f84a 8023 	str.w	r8, [sl, r3, lsl #2]
 800a8de:	e7e4      	b.n	800a8aa <get_fileinfo+0xae>
	}
	if (!lfv) {
 800a8e0:	b93d      	cbnz	r5, 800a8f2 <get_fileinfo+0xf6>
		fno->fname[j] = 0;
 800a8e2:	eb0a 0389 	add.w	r3, sl, r9, lsl #2
 800a8e6:	645d      	str	r5, [r3, #68]	; 0x44
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
 800a8e8:	7b13      	ldrb	r3, [r2, #12]
 800a8ea:	2b00      	cmp	r3, #0
 800a8ec:	bf08      	it	eq
 800a8ee:	f04f 0900 	moveq.w	r9, #0
	}
	fno->altname[j] = 0;	/* Terminate the SFN */
 800a8f2:	2300      	movs	r3, #0
 800a8f4:	f109 0904 	add.w	r9, r9, #4
 800a8f8:	f84a 3029 	str.w	r3, [sl, r9, lsl #2]
		fno->fname[j++] = c;
	}
	fno->fname[j] = 0;
#endif

	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 800a8fc:	7ad1      	ldrb	r1, [r2, #11]
 800a8fe:	f88a 100c 	strb.w	r1, [sl, #12]
	rv = rv << 8 | ptr[0];
 800a902:	69d1      	ldr	r1, [r2, #28]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 800a904:	e9ca 1300 	strd	r1, r3, [sl]
	rv = rv << 8 | ptr[0];
 800a908:	f8d2 3016 	ldr.w	r3, [r2, #22]
	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 800a90c:	0c1a      	lsrs	r2, r3, #16
 800a90e:	f8aa 300a 	strh.w	r3, [sl, #10]
 800a912:	f8aa 2008 	strh.w	r2, [sl, #8]
}
 800a916:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		get_xdir_info(fs->dirbuf, fno);
 800a91a:	691a      	ldr	r2, [r3, #16]
	for (si = SZDIRE * 2; di < dirb[XDIR_NumName]; si += 2, di++) {
 800a91c:	f892 3023 	ldrb.w	r3, [r2, #35]	; 0x23
 800a920:	b34b      	cbz	r3, 800a976 <get_fileinfo+0x17a>
 800a922:	3140      	adds	r1, #64	; 0x40
 800a924:	2340      	movs	r3, #64	; 0x40
		if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
 800a926:	06d8      	lsls	r0, r3, #27
	for (si = SZDIRE * 2; di < dirb[XDIR_NumName]; si += 2, di++) {
 800a928:	f105 0501 	add.w	r5, r5, #1
		if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
 800a92c:	bf08      	it	eq
 800a92e:	3302      	addeq	r3, #2
		w = ld_word(dirb + si);					/* Get a character */
 800a930:	5ad0      	ldrh	r0, [r2, r3]
	for (si = SZDIRE * 2; di < dirb[XDIR_NumName]; si += 2, di++) {
 800a932:	3302      	adds	r3, #2
		w = ld_word(dirb + si);					/* Get a character */
 800a934:	f841 0f04 	str.w	r0, [r1, #4]!
	for (si = SZDIRE * 2; di < dirb[XDIR_NumName]; si += 2, di++) {
 800a938:	f892 0023 	ldrb.w	r0, [r2, #35]	; 0x23
 800a93c:	4285      	cmp	r5, r0
 800a93e:	d3f2      	bcc.n	800a926 <get_fileinfo+0x12a>
	fno->fname[di] = 0;						/* Terminate file name */
 800a940:	3510      	adds	r5, #16
 800a942:	2100      	movs	r1, #0
 800a944:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
 800a948:	6059      	str	r1, [r3, #4]
	fno->altname[0] = 0;							/* No SFN */
 800a94a:	f8ca 1010 	str.w	r1, [sl, #16]
	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
 800a94e:	7913      	ldrb	r3, [r2, #4]
 800a950:	f88a 300c 	strb.w	r3, [sl, #12]
	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
 800a954:	06db      	lsls	r3, r3, #27
 800a956:	d50b      	bpl.n	800a970 <get_fileinfo+0x174>
 800a958:	460b      	mov	r3, r1
 800a95a:	e9ca 1300 	strd	r1, r3, [sl]
	rv = ptr[1];
 800a95e:	8993      	ldrh	r3, [r2, #12]
	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
 800a960:	f8aa 300a 	strh.w	r3, [sl, #10]
	rv = ptr[1];
 800a964:	89d3      	ldrh	r3, [r2, #14]
	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
 800a966:	f8aa 3008 	strh.w	r3, [sl, #8]
}
 800a96a:	e7d4      	b.n	800a916 <get_fileinfo+0x11a>
			i = j = 0;
 800a96c:	2400      	movs	r4, #0
 800a96e:	e76c      	b.n	800a84a <get_fileinfo+0x4e>
	rv = rv << 8 | ptr[0];
 800a970:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800a972:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
	return rv;
 800a974:	e7f1      	b.n	800a95a <get_fileinfo+0x15e>
	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
 800a976:	233f      	movs	r3, #63	; 0x3f
 800a978:	2501      	movs	r5, #1
 800a97a:	644b      	str	r3, [r1, #68]	; 0x44
 800a97c:	e7e0      	b.n	800a940 <get_fileinfo+0x144>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800a97e:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 800a980:	e783      	b.n	800a88a <get_fileinfo+0x8e>
 800a982:	bf00      	nop

0800a984 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 800a984:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800a986:	f04f 36ff 	mov.w	r6, #4294967295
 800a98a:	2300      	movs	r3, #0
{
 800a98c:	4604      	mov	r4, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 800a98e:	42b1      	cmp	r1, r6
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800a990:	70c3      	strb	r3, [r0, #3]
 800a992:	62c6      	str	r6, [r0, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 800a994:	d14a      	bne.n	800aa2c <check_fs+0xa8>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800a996:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800a99a:	f8b4 222e 	ldrh.w	r2, [r4, #558]	; 0x22e
 800a99e:	429a      	cmp	r2, r3
 800a9a0:	d154      	bne.n	800aa4c <check_fs+0xc8>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 800a9a2:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800a9a6:	2be9      	cmp	r3, #233	; 0xe9
 800a9a8:	d032      	beq.n	800aa10 <check_fs+0x8c>
 800a9aa:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800a9ac:	492b      	ldr	r1, [pc, #172]	; (800aa5c <check_fs+0xd8>)
 800a9ae:	f002 12ff 	and.w	r2, r2, #16711935	; 0xff00ff
 800a9b2:	428a      	cmp	r2, r1
 800a9b4:	d02c      	beq.n	800aa10 <check_fs+0x8c>
	} while (--cnt && r == 0);
 800a9b6:	2beb      	cmp	r3, #235	; 0xeb
 800a9b8:	d14d      	bne.n	800aa56 <check_fs+0xd2>
 800a9ba:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 800a9be:	2b76      	cmp	r3, #118	; 0x76
 800a9c0:	d149      	bne.n	800aa56 <check_fs+0xd2>
 800a9c2:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
 800a9c6:	2b90      	cmp	r3, #144	; 0x90
 800a9c8:	d145      	bne.n	800aa56 <check_fs+0xd2>
 800a9ca:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 800a9ce:	2b45      	cmp	r3, #69	; 0x45
 800a9d0:	d141      	bne.n	800aa56 <check_fs+0xd2>
 800a9d2:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800a9d6:	2b58      	cmp	r3, #88	; 0x58
 800a9d8:	d13d      	bne.n	800aa56 <check_fs+0xd2>
 800a9da:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a9de:	2b46      	cmp	r3, #70	; 0x46
 800a9e0:	d139      	bne.n	800aa56 <check_fs+0xd2>
 800a9e2:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 800a9e6:	2b41      	cmp	r3, #65	; 0x41
 800a9e8:	d135      	bne.n	800aa56 <check_fs+0xd2>
 800a9ea:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
 800a9ee:	2b54      	cmp	r3, #84	; 0x54
 800a9f0:	d131      	bne.n	800aa56 <check_fs+0xd2>
 800a9f2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 800a9f6:	2b20      	cmp	r3, #32
 800a9f8:	d12d      	bne.n	800aa56 <check_fs+0xd2>
 800a9fa:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 800a9fe:	2b20      	cmp	r3, #32
 800aa00:	d129      	bne.n	800aa56 <check_fs+0xd2>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
 800aa02:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
 800aa06:	2b20      	cmp	r3, #32
 800aa08:	bf14      	ite	ne
 800aa0a:	2002      	movne	r0, #2
 800aa0c:	2001      	moveq	r0, #1
#endif
	return 2;
}
 800aa0e:	bd70      	pop	{r4, r5, r6, pc}
	rv = rv << 8 | ptr[0];
 800aa10:	f8d4 2066 	ldr.w	r2, [r4, #102]	; 0x66
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800aa14:	4912      	ldr	r1, [pc, #72]	; (800aa60 <check_fs+0xdc>)
 800aa16:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800aa1a:	428a      	cmp	r2, r1
 800aa1c:	d004      	beq.n	800aa28 <check_fs+0xa4>
	rv = rv << 8 | ptr[0];
 800aa1e:	f8d4 1082 	ldr.w	r1, [r4, #130]	; 0x82
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800aa22:	4a10      	ldr	r2, [pc, #64]	; (800aa64 <check_fs+0xe0>)
 800aa24:	4291      	cmp	r1, r2
 800aa26:	d1c6      	bne.n	800a9b6 <check_fs+0x32>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800aa28:	2000      	movs	r0, #0
}
 800aa2a:	bd70      	pop	{r4, r5, r6, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800aa2c:	460d      	mov	r5, r1
 800aa2e:	460a      	mov	r2, r1
 800aa30:	2301      	movs	r3, #1
 800aa32:	f100 0130 	add.w	r1, r0, #48	; 0x30
 800aa36:	7840      	ldrb	r0, [r0, #1]
 800aa38:	f7ff fed2 	bl	800a7e0 <disk_read>
 800aa3c:	b940      	cbnz	r0, 800aa50 <check_fs+0xcc>
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800aa3e:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800aa42:	f8b4 222e 	ldrh.w	r2, [r4, #558]	; 0x22e
			fs->winsect = sector;
 800aa46:	62e5      	str	r5, [r4, #44]	; 0x2c
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800aa48:	429a      	cmp	r2, r3
 800aa4a:	d0aa      	beq.n	800a9a2 <check_fs+0x1e>
 800aa4c:	2003      	movs	r0, #3
}
 800aa4e:	bd70      	pop	{r4, r5, r6, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800aa50:	2004      	movs	r0, #4
			fs->winsect = sector;
 800aa52:	62e6      	str	r6, [r4, #44]	; 0x2c
}
 800aa54:	bd70      	pop	{r4, r5, r6, pc}
	return 2;
 800aa56:	2002      	movs	r0, #2
}
 800aa58:	bd70      	pop	{r4, r5, r6, pc}
 800aa5a:	bf00      	nop
 800aa5c:	009000eb 	.word	0x009000eb
 800aa60:	00544146 	.word	0x00544146
 800aa64:	33544146 	.word	0x33544146

0800aa68 <find_volume.constprop.0>:
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 800aa68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 800aa6c:	2300      	movs	r3, #0
	if (*path) {	/* If the pointer is not a null */
 800aa6e:	6805      	ldr	r5, [r0, #0]
	*rfs = 0;
 800aa70:	600b      	str	r3, [r1, #0]
	if (*path) {	/* If the pointer is not a null */
 800aa72:	b19d      	cbz	r5, 800aa9c <find_volume.constprop.0+0x34>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800aa74:	682c      	ldr	r4, [r5, #0]
 800aa76:	2c1f      	cmp	r4, #31
 800aa78:	d914      	bls.n	800aaa4 <find_volume.constprop.0+0x3c>
 800aa7a:	2c3a      	cmp	r4, #58	; 0x3a
 800aa7c:	d012      	beq.n	800aaa4 <find_volume.constprop.0+0x3c>
 800aa7e:	462a      	mov	r2, r5
 800aa80:	f852 3f04 	ldr.w	r3, [r2, #4]!
 800aa84:	2b1f      	cmp	r3, #31
 800aa86:	d90f      	bls.n	800aaa8 <find_volume.constprop.0+0x40>
 800aa88:	2b3a      	cmp	r3, #58	; 0x3a
 800aa8a:	d1f9      	bne.n	800aa80 <find_volume.constprop.0+0x18>
			i = *tp++ - '0';
 800aa8c:	1d2b      	adds	r3, r5, #4
 800aa8e:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800aa92:	429a      	cmp	r2, r3
 800aa94:	d102      	bne.n	800aa9c <find_volume.constprop.0+0x34>
 800aa96:	2d01      	cmp	r5, #1
 800aa98:	f240 8147 	bls.w	800ad2a <find_volume.constprop.0+0x2c2>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 800aa9c:	260b      	movs	r6, #11
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 800aa9e:	4630      	mov	r0, r6
 800aaa0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800aaa4:	4623      	mov	r3, r4
 800aaa6:	462a      	mov	r2, r5
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 800aaa8:	2b3a      	cmp	r3, #58	; 0x3a
 800aaaa:	d0ef      	beq.n	800aa8c <find_volume.constprop.0+0x24>
		vol = 0;		/* Drive 0 */
 800aaac:	2500      	movs	r5, #0
	fs = FatFs[vol];					/* Get pointer to the file system object */
 800aaae:	4baa      	ldr	r3, [pc, #680]	; (800ad58 <find_volume.constprop.0+0x2f0>)
 800aab0:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800aab4:	2c00      	cmp	r4, #0
 800aab6:	f000 80c2 	beq.w	800ac3e <find_volume.constprop.0+0x1d6>
	*rfs = fs;							/* Return pointer to the file system object */
 800aaba:	600c      	str	r4, [r1, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 800aabc:	7823      	ldrb	r3, [r4, #0]
 800aabe:	b12b      	cbz	r3, 800aacc <find_volume.constprop.0+0x64>
		stat = disk_status(fs->drv);
 800aac0:	7860      	ldrb	r0, [r4, #1]
 800aac2:	f7ff fe71 	bl	800a7a8 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800aac6:	f010 0601 	ands.w	r6, r0, #1
 800aaca:	d07e      	beq.n	800abca <find_volume.constprop.0+0x162>
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800aacc:	b2e8      	uxtb	r0, r5
	fs->fs_type = 0;					/* Clear the file system object */
 800aace:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800aad0:	7060      	strb	r0, [r4, #1]
	fs->fs_type = 0;					/* Clear the file system object */
 800aad2:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800aad4:	f7ff fe72 	bl	800a7bc <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800aad8:	f010 0601 	ands.w	r6, r0, #1
 800aadc:	d174      	bne.n	800abc8 <find_volume.constprop.0+0x160>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 800aade:	4631      	mov	r1, r6
 800aae0:	4620      	mov	r0, r4
 800aae2:	f7ff ff4f 	bl	800a984 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 800aae6:	2802      	cmp	r0, #2
 800aae8:	d072      	beq.n	800abd0 <find_volume.constprop.0+0x168>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800aaea:	2804      	cmp	r0, #4
 800aaec:	f000 80a5 	beq.w	800ac3a <find_volume.constprop.0+0x1d2>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800aaf0:	2801      	cmp	r0, #1
 800aaf2:	f200 8089 	bhi.w	800ac08 <find_volume.constprop.0+0x1a0>
	bsect = 0;
 800aaf6:	4635      	mov	r5, r6
	if (fmt == 1) {
 800aaf8:	2801      	cmp	r0, #1
 800aafa:	f000 8089 	beq.w	800ac10 <find_volume.constprop.0+0x1a8>
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800aafe:	f8b4 303b 	ldrh.w	r3, [r4, #59]	; 0x3b
 800ab02:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ab06:	d17f      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800ab08:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800ab0c:	2a00      	cmp	r2, #0
 800ab0e:	f000 809c 	beq.w	800ac4a <find_volume.constprop.0+0x1e2>
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800ab12:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
		fs->fsize = fasize;
 800ab16:	61a2      	str	r2, [r4, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800ab18:	1e59      	subs	r1, r3, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800ab1a:	70a3      	strb	r3, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800ab1c:	2901      	cmp	r1, #1
 800ab1e:	d873      	bhi.n	800ac08 <find_volume.constprop.0+0x1a0>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800ab20:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
 800ab24:	b288      	uxth	r0, r1
 800ab26:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800ab28:	2800      	cmp	r0, #0
 800ab2a:	d06d      	beq.n	800ac08 <find_volume.constprop.0+0x1a0>
 800ab2c:	1e48      	subs	r0, r1, #1
 800ab2e:	4208      	tst	r0, r1
 800ab30:	d16a      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
	rv = ptr[1];
 800ab32:	f8b4 c041 	ldrh.w	ip, [r4, #65]	; 0x41
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800ab36:	f01c 0f0f 	tst.w	ip, #15
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800ab3a:	f8a4 c008 	strh.w	ip, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800ab3e:	d163      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 800ab40:	f8b4 0043 	ldrh.w	r0, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800ab44:	b900      	cbnz	r0, 800ab48 <find_volume.constprop.0+0xe0>
	rv = rv << 8 | ptr[0];
 800ab46:	6d20      	ldr	r0, [r4, #80]	; 0x50
	rv = ptr[1];
 800ab48:	8fe7      	ldrh	r7, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800ab4a:	2f00      	cmp	r7, #0
 800ab4c:	d05c      	beq.n	800ac08 <find_volume.constprop.0+0x1a0>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800ab4e:	fb02 f303 	mul.w	r3, r2, r3
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800ab52:	eb07 1e1c 	add.w	lr, r7, ip, lsr #4
 800ab56:	449e      	add	lr, r3
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800ab58:	4586      	cmp	lr, r0
 800ab5a:	d855      	bhi.n	800ac08 <find_volume.constprop.0+0x1a0>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800ab5c:	eba0 080e 	sub.w	r8, r0, lr
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800ab60:	4588      	cmp	r8, r1
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800ab62:	fbb8 f0f1 	udiv	r0, r8, r1
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800ab66:	d34f      	bcc.n	800ac08 <find_volume.constprop.0+0x1a0>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800ab68:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 800ab6c:	4288      	cmp	r0, r1
 800ab6e:	f200 80df 	bhi.w	800ad30 <find_volume.constprop.0+0x2c8>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800ab72:	f640 71f5 	movw	r1, #4085	; 0xff5
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800ab76:	442f      	add	r7, r5
		fs->volbase = bsect;							/* Volume start sector */
 800ab78:	61e5      	str	r5, [r4, #28]
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800ab7a:	4288      	cmp	r0, r1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800ab7c:	f100 0002 	add.w	r0, r0, #2
		fs->database = bsect + sysect;					/* Data start sector */
 800ab80:	eb0e 0105 	add.w	r1, lr, r5
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800ab84:	6227      	str	r7, [r4, #32]
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800ab86:	6160      	str	r0, [r4, #20]
		fs->database = bsect + sysect;					/* Data start sector */
 800ab88:	62a1      	str	r1, [r4, #40]	; 0x28
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800ab8a:	f200 8138 	bhi.w	800adfe <find_volume.constprop.0+0x396>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800ab8e:	f1bc 0f00 	cmp.w	ip, #0
 800ab92:	d039      	beq.n	800ac08 <find_volume.constprop.0+0x1a0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800ab94:	443b      	add	r3, r7
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800ab96:	2101      	movs	r1, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800ab98:	6263      	str	r3, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800ab9a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 800ab9e:	f000 0001 	and.w	r0, r0, #1
 800aba2:	eb00 0353 	add.w	r3, r0, r3, lsr #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800aba6:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800abaa:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
 800abae:	d32b      	bcc.n	800ac08 <find_volume.constprop.0+0x1a0>
	fs->id = ++Fsid;		/* File system mount ID */
 800abb0:	4a6a      	ldr	r2, [pc, #424]	; (800ad5c <find_volume.constprop.0+0x2f4>)
	fs->fs_type = fmt;		/* FAT sub-type */
 800abb2:	7021      	strb	r1, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 800abb4:	8813      	ldrh	r3, [r2, #0]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800abb6:	496a      	ldr	r1, [pc, #424]	; (800ad60 <find_volume.constprop.0+0x2f8>)
	fs->id = ++Fsid;		/* File system mount ID */
 800abb8:	3301      	adds	r3, #1
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800abba:	60e1      	str	r1, [r4, #12]
	fs->id = ++Fsid;		/* File system mount ID */
 800abbc:	b29b      	uxth	r3, r3
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 800abbe:	4969      	ldr	r1, [pc, #420]	; (800ad64 <find_volume.constprop.0+0x2fc>)
	fs->id = ++Fsid;		/* File system mount ID */
 800abc0:	8013      	strh	r3, [r2, #0]
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 800abc2:	6121      	str	r1, [r4, #16]
	fs->id = ++Fsid;		/* File system mount ID */
 800abc4:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
 800abc6:	e000      	b.n	800abca <find_volume.constprop.0+0x162>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800abc8:	2603      	movs	r6, #3
}
 800abca:	4630      	mov	r0, r6
 800abcc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800abd0:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
 800abd4:	b3ab      	cbz	r3, 800ac42 <find_volume.constprop.0+0x1da>
	rv = rv << 8 | ptr[0];
 800abd6:	f8d4 91f6 	ldr.w	r9, [r4, #502]	; 0x1f6
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800abda:	f894 3202 	ldrb.w	r3, [r4, #514]	; 0x202
 800abde:	b393      	cbz	r3, 800ac46 <find_volume.constprop.0+0x1de>
	rv = rv << 8 | ptr[0];
 800abe0:	f8d4 8206 	ldr.w	r8, [r4, #518]	; 0x206
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800abe4:	f894 7212 	ldrb.w	r7, [r4, #530]	; 0x212
 800abe8:	b10f      	cbz	r7, 800abee <find_volume.constprop.0+0x186>
	rv = rv << 8 | ptr[0];
 800abea:	f8d4 7216 	ldr.w	r7, [r4, #534]	; 0x216
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800abee:	f894 5222 	ldrb.w	r5, [r4, #546]	; 0x222
 800abf2:	b10d      	cbz	r5, 800abf8 <find_volume.constprop.0+0x190>
	rv = rv << 8 | ptr[0];
 800abf4:	f8d4 5226 	ldr.w	r5, [r4, #550]	; 0x226
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800abf8:	f1b9 0f00 	cmp.w	r9, #0
 800abfc:	d127      	bne.n	800ac4e <find_volume.constprop.0+0x1e6>
 800abfe:	f1b8 0f00 	cmp.w	r8, #0
 800ac02:	d12c      	bne.n	800ac5e <find_volume.constprop.0+0x1f6>
 800ac04:	bb9f      	cbnz	r7, 800ac6e <find_volume.constprop.0+0x206>
 800ac06:	b97d      	cbnz	r5, 800ac28 <find_volume.constprop.0+0x1c0>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800ac08:	260d      	movs	r6, #13
}
 800ac0a:	4630      	mov	r0, r6
 800ac0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ac10:	f104 033a 	add.w	r3, r4, #58	; 0x3a
 800ac14:	f104 016f 	add.w	r1, r4, #111	; 0x6f
 800ac18:	e001      	b.n	800ac1e <find_volume.constprop.0+0x1b6>
		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 800ac1a:	4299      	cmp	r1, r3
 800ac1c:	d02f      	beq.n	800ac7e <find_volume.constprop.0+0x216>
 800ac1e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 800ac22:	2a00      	cmp	r2, #0
 800ac24:	d0f9      	beq.n	800ac1a <find_volume.constprop.0+0x1b2>
 800ac26:	e7ef      	b.n	800ac08 <find_volume.constprop.0+0x1a0>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800ac28:	4629      	mov	r1, r5
 800ac2a:	4620      	mov	r0, r4
 800ac2c:	f7ff feaa 	bl	800a984 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800ac30:	2801      	cmp	r0, #1
 800ac32:	f67f af61 	bls.w	800aaf8 <find_volume.constprop.0+0x90>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800ac36:	2804      	cmp	r0, #4
 800ac38:	d1e6      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
 800ac3a:	2601      	movs	r6, #1
 800ac3c:	e7c5      	b.n	800abca <find_volume.constprop.0+0x162>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800ac3e:	260c      	movs	r6, #12
 800ac40:	e7c3      	b.n	800abca <find_volume.constprop.0+0x162>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800ac42:	46b1      	mov	r9, r6
 800ac44:	e7c9      	b.n	800abda <find_volume.constprop.0+0x172>
 800ac46:	4698      	mov	r8, r3
 800ac48:	e7cc      	b.n	800abe4 <find_volume.constprop.0+0x17c>
	rv = rv << 8 | ptr[0];
 800ac4a:	6d62      	ldr	r2, [r4, #84]	; 0x54
	return rv;
 800ac4c:	e761      	b.n	800ab12 <find_volume.constprop.0+0xaa>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800ac4e:	4649      	mov	r1, r9
 800ac50:	4620      	mov	r0, r4
 800ac52:	f7ff fe97 	bl	800a984 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800ac56:	2801      	cmp	r0, #1
 800ac58:	d8d1      	bhi.n	800abfe <find_volume.constprop.0+0x196>
 800ac5a:	464d      	mov	r5, r9
 800ac5c:	e74c      	b.n	800aaf8 <find_volume.constprop.0+0x90>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800ac5e:	4641      	mov	r1, r8
 800ac60:	4620      	mov	r0, r4
 800ac62:	f7ff fe8f 	bl	800a984 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800ac66:	2801      	cmp	r0, #1
 800ac68:	d8cc      	bhi.n	800ac04 <find_volume.constprop.0+0x19c>
 800ac6a:	4645      	mov	r5, r8
 800ac6c:	e744      	b.n	800aaf8 <find_volume.constprop.0+0x90>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800ac6e:	4639      	mov	r1, r7
 800ac70:	4620      	mov	r0, r4
 800ac72:	f7ff fe87 	bl	800a984 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800ac76:	2801      	cmp	r0, #1
 800ac78:	d8c5      	bhi.n	800ac06 <find_volume.constprop.0+0x19e>
 800ac7a:	463d      	mov	r5, r7
 800ac7c:	e73c      	b.n	800aaf8 <find_volume.constprop.0+0x90>
		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
 800ac7e:	f8b4 3098 	ldrh.w	r3, [r4, #152]	; 0x98
 800ac82:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800ac86:	d1bf      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
 800ac88:	f894 309c 	ldrb.w	r3, [r4, #156]	; 0x9c
 800ac8c:	2b09      	cmp	r3, #9
 800ac8e:	d1bb      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800ac90:	6fa3      	ldr	r3, [r4, #120]	; 0x78
		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
 800ac92:	f04f 30ff 	mov.w	r0, #4294967295
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
 800ac96:	1959      	adds	r1, r3, r5
	rv = rv << 8 | ptr[0];
 800ac98:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
 800ac9a:	f143 0300 	adc.w	r3, r3, #0
		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
 800ac9e:	4288      	cmp	r0, r1
 800aca0:	eb72 0003 	sbcs.w	r0, r2, r3
 800aca4:	d3b0      	bcc.n	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800aca6:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 800acaa:	61a0      	str	r0, [r4, #24]
		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 800acac:	f894 009e 	ldrb.w	r0, [r4, #158]	; 0x9e
		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 800acb0:	2801      	cmp	r0, #1
		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 800acb2:	70a0      	strb	r0, [r4, #2]
		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 800acb4:	d1a8      	bne.n	800ac08 <find_volume.constprop.0+0x1a0>
		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
 800acb6:	f894 709d 	ldrb.w	r7, [r4, #157]	; 0x9d
 800acba:	40b8      	lsls	r0, r7
 800acbc:	b287      	uxth	r7, r0
 800acbe:	8167      	strh	r7, [r4, #10]
		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
 800acc0:	2f00      	cmp	r7, #0
 800acc2:	d0a1      	beq.n	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800acc4:	f8d4 c08c 	ldr.w	ip, [r4, #140]	; 0x8c
		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
 800acc8:	4f27      	ldr	r7, [pc, #156]	; (800ad68 <find_volume.constprop.0+0x300>)
 800acca:	45bc      	cmp	ip, r7
 800accc:	d89c      	bhi.n	800ac08 <find_volume.constprop.0+0x1a0>
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 800acce:	b287      	uxth	r7, r0
	rv = rv << 8 | ptr[0];
 800acd0:	f8d4 e080 	ldr.w	lr, [r4, #128]	; 0x80
 800acd4:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
		fs->volbase = bsect;
 800acd8:	61e5      	str	r5, [r4, #28]
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 800acda:	4428      	add	r0, r5
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 800acdc:	4475      	add	r5, lr
		fs->n_fatent = nclst + 2;
 800acde:	f10c 0e02 	add.w	lr, ip, #2
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 800ace2:	6225      	str	r5, [r4, #32]
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 800ace4:	fb07 f50c 	mul.w	r5, r7, ip
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 800ace8:	62a0      	str	r0, [r4, #40]	; 0x28
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 800acea:	182d      	adds	r5, r5, r0
		fs->n_fatent = nclst + 2;
 800acec:	f8c4 e014 	str.w	lr, [r4, #20]
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 800acf0:	4152      	adcs	r2, r2
 800acf2:	42a9      	cmp	r1, r5
 800acf4:	4193      	sbcs	r3, r2
 800acf6:	d387      	bcc.n	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800acf8:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	if (sector != fs->winsect) {	/* Window offset changed? */
 800acfc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 800acfe:	6265      	str	r5, [r4, #36]	; 0x24
	clst -= 2;
 800ad00:	3d02      	subs	r5, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800ad02:	45ac      	cmp	ip, r5
	return clst * fs->csize + fs->database;
 800ad04:	bf8c      	ite	hi
 800ad06:	fb05 0507 	mlahi	r5, r5, r7, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800ad0a:	2500      	movls	r5, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ad0c:	42ab      	cmp	r3, r5
 800ad0e:	d02e      	beq.n	800ad6e <find_volume.constprop.0+0x306>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800ad10:	2301      	movs	r3, #1
 800ad12:	462a      	mov	r2, r5
 800ad14:	f104 0130 	add.w	r1, r4, #48	; 0x30
 800ad18:	7860      	ldrb	r0, [r4, #1]
 800ad1a:	f7ff fd61 	bl	800a7e0 <disk_read>
 800ad1e:	b328      	cbz	r0, 800ad6c <find_volume.constprop.0+0x304>
			fs->winsect = sector;
 800ad20:	f04f 33ff 	mov.w	r3, #4294967295
		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
 800ad24:	2601      	movs	r6, #1
			fs->winsect = sector;
 800ad26:	62e3      	str	r3, [r4, #44]	; 0x2c
	return res;
 800ad28:	e74f      	b.n	800abca <find_volume.constprop.0+0x162>
					*path = ++tt;
 800ad2a:	3204      	adds	r2, #4
 800ad2c:	6002      	str	r2, [r0, #0]
	if (vol < 0) return FR_INVALID_DRIVE;
 800ad2e:	e6be      	b.n	800aaae <find_volume.constprop.0+0x46>
		fs->database = bsect + sysect;					/* Data start sector */
 800ad30:	eb0e 0105 	add.w	r1, lr, r5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800ad34:	1c83      	adds	r3, r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800ad36:	442f      	add	r7, r5
		fs->volbase = bsect;							/* Volume start sector */
 800ad38:	61e5      	str	r5, [r4, #28]
		fs->database = bsect + sysect;					/* Data start sector */
 800ad3a:	62a1      	str	r1, [r4, #40]	; 0x28
	rv = rv << 8 | ptr[0];
 800ad3c:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800ad40:	6227      	str	r7, [r4, #32]
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800ad42:	ea51 010c 	orrs.w	r1, r1, ip
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800ad46:	6163      	str	r3, [r4, #20]
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800ad48:	f47f af5e 	bne.w	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800ad4c:	6de1      	ldr	r1, [r4, #92]	; 0x5c
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800ad4e:	009b      	lsls	r3, r3, #2
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800ad50:	6261      	str	r1, [r4, #36]	; 0x24
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800ad52:	2103      	movs	r1, #3
 800ad54:	e727      	b.n	800aba6 <find_volume.constprop.0+0x13e>
 800ad56:	bf00      	nop
 800ad58:	20000390 	.word	0x20000390
 800ad5c:	20000398 	.word	0x20000398
 800ad60:	2000039c 	.word	0x2000039c
 800ad64:	20000130 	.word	0x20000130
 800ad68:	7ffffffd 	.word	0x7ffffffd
			fs->winsect = sector;
 800ad6c:	62e5      	str	r5, [r4, #44]	; 0x2c
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ad6e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800ad72:	2b81      	cmp	r3, #129	; 0x81
 800ad74:	d05a      	beq.n	800ae2c <find_volume.constprop.0+0x3c4>
 800ad76:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 800ad7a:	2b81      	cmp	r3, #129	; 0x81
 800ad7c:	d052      	beq.n	800ae24 <find_volume.constprop.0+0x3bc>
 800ad7e:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
 800ad82:	2b81      	cmp	r3, #129	; 0x81
 800ad84:	d049      	beq.n	800ae1a <find_volume.constprop.0+0x3b2>
 800ad86:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
 800ad8a:	2b81      	cmp	r3, #129	; 0x81
 800ad8c:	d040      	beq.n	800ae10 <find_volume.constprop.0+0x3a8>
 800ad8e:	f894 30b0 	ldrb.w	r3, [r4, #176]	; 0xb0
 800ad92:	2b81      	cmp	r3, #129	; 0x81
 800ad94:	d05d      	beq.n	800ae52 <find_volume.constprop.0+0x3ea>
 800ad96:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
 800ad9a:	2b81      	cmp	r3, #129	; 0x81
 800ad9c:	d054      	beq.n	800ae48 <find_volume.constprop.0+0x3e0>
 800ad9e:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
 800ada2:	2b81      	cmp	r3, #129	; 0x81
 800ada4:	d04b      	beq.n	800ae3e <find_volume.constprop.0+0x3d6>
 800ada6:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 800adaa:	2b81      	cmp	r3, #129	; 0x81
 800adac:	d042      	beq.n	800ae34 <find_volume.constprop.0+0x3cc>
 800adae:	f894 3130 	ldrb.w	r3, [r4, #304]	; 0x130
 800adb2:	2b81      	cmp	r3, #129	; 0x81
 800adb4:	d070      	beq.n	800ae98 <find_volume.constprop.0+0x430>
 800adb6:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
 800adba:	2b81      	cmp	r3, #129	; 0x81
 800adbc:	d067      	beq.n	800ae8e <find_volume.constprop.0+0x426>
 800adbe:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
 800adc2:	2b81      	cmp	r3, #129	; 0x81
 800adc4:	d05e      	beq.n	800ae84 <find_volume.constprop.0+0x41c>
 800adc6:	f894 3190 	ldrb.w	r3, [r4, #400]	; 0x190
 800adca:	2b81      	cmp	r3, #129	; 0x81
 800adcc:	d055      	beq.n	800ae7a <find_volume.constprop.0+0x412>
 800adce:	f894 31b0 	ldrb.w	r3, [r4, #432]	; 0x1b0
 800add2:	2b81      	cmp	r3, #129	; 0x81
 800add4:	d04c      	beq.n	800ae70 <find_volume.constprop.0+0x408>
 800add6:	f894 31d0 	ldrb.w	r3, [r4, #464]	; 0x1d0
 800adda:	2b81      	cmp	r3, #129	; 0x81
 800addc:	d043      	beq.n	800ae66 <find_volume.constprop.0+0x3fe>
 800adde:	f894 31f0 	ldrb.w	r3, [r4, #496]	; 0x1f0
 800ade2:	2b81      	cmp	r3, #129	; 0x81
 800ade4:	d03a      	beq.n	800ae5c <find_volume.constprop.0+0x3f4>
 800ade6:	f894 3210 	ldrb.w	r3, [r4, #528]	; 0x210
 800adea:	2b81      	cmp	r3, #129	; 0x81
 800adec:	f47f af0c 	bne.w	800ac08 <find_volume.constprop.0+0x1a0>
	rv = rv << 8 | ptr[0];
 800adf0:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800adf4:	2b02      	cmp	r3, #2
 800adf6:	f47f af07 	bne.w	800ac08 <find_volume.constprop.0+0x1a0>
		fmt = FS_EXFAT;			/* FAT sub-type */
 800adfa:	2104      	movs	r1, #4
 800adfc:	e6d8      	b.n	800abb0 <find_volume.constprop.0+0x148>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800adfe:	f1bc 0f00 	cmp.w	ip, #0
 800ae02:	f43f af01 	beq.w	800ac08 <find_volume.constprop.0+0x1a0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800ae06:	441f      	add	r7, r3
 800ae08:	2102      	movs	r1, #2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800ae0a:	0043      	lsls	r3, r0, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800ae0c:	6267      	str	r7, [r4, #36]	; 0x24
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800ae0e:	e6ca      	b.n	800aba6 <find_volume.constprop.0+0x13e>
	rv = rv << 8 | ptr[0];
 800ae10:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae14:	2b02      	cmp	r3, #2
 800ae16:	d1ba      	bne.n	800ad8e <find_volume.constprop.0+0x326>
 800ae18:	e7ef      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae1a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae1e:	2b02      	cmp	r3, #2
 800ae20:	d1b1      	bne.n	800ad86 <find_volume.constprop.0+0x31e>
 800ae22:	e7ea      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae24:	6e63      	ldr	r3, [r4, #100]	; 0x64
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae26:	2b02      	cmp	r3, #2
 800ae28:	d1a9      	bne.n	800ad7e <find_volume.constprop.0+0x316>
 800ae2a:	e7e6      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae2c:	6c63      	ldr	r3, [r4, #68]	; 0x44
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae2e:	2b02      	cmp	r3, #2
 800ae30:	d1a1      	bne.n	800ad76 <find_volume.constprop.0+0x30e>
 800ae32:	e7e2      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae34:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae38:	2b02      	cmp	r3, #2
 800ae3a:	d1b8      	bne.n	800adae <find_volume.constprop.0+0x346>
 800ae3c:	e7dd      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae3e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae42:	2b02      	cmp	r3, #2
 800ae44:	d1af      	bne.n	800ada6 <find_volume.constprop.0+0x33e>
 800ae46:	e7d8      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae48:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae4c:	2b02      	cmp	r3, #2
 800ae4e:	d1a6      	bne.n	800ad9e <find_volume.constprop.0+0x336>
 800ae50:	e7d3      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae52:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae56:	2b02      	cmp	r3, #2
 800ae58:	d19d      	bne.n	800ad96 <find_volume.constprop.0+0x32e>
 800ae5a:	e7ce      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae5c:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae60:	2b02      	cmp	r3, #2
 800ae62:	d1c0      	bne.n	800ade6 <find_volume.constprop.0+0x37e>
 800ae64:	e7c9      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae66:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae6a:	2b02      	cmp	r3, #2
 800ae6c:	d1b7      	bne.n	800adde <find_volume.constprop.0+0x376>
 800ae6e:	e7c4      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae70:	f8d4 31c4 	ldr.w	r3, [r4, #452]	; 0x1c4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae74:	2b02      	cmp	r3, #2
 800ae76:	d1ae      	bne.n	800add6 <find_volume.constprop.0+0x36e>
 800ae78:	e7bf      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae7a:	f8d4 31a4 	ldr.w	r3, [r4, #420]	; 0x1a4
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae7e:	2b02      	cmp	r3, #2
 800ae80:	d1a5      	bne.n	800adce <find_volume.constprop.0+0x366>
 800ae82:	e7ba      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae84:	f8d4 3184 	ldr.w	r3, [r4, #388]	; 0x184
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae88:	2b02      	cmp	r3, #2
 800ae8a:	d19c      	bne.n	800adc6 <find_volume.constprop.0+0x35e>
 800ae8c:	e7b5      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae8e:	f8d4 3164 	ldr.w	r3, [r4, #356]	; 0x164
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae92:	2b02      	cmp	r3, #2
 800ae94:	d193      	bne.n	800adbe <find_volume.constprop.0+0x356>
 800ae96:	e7b0      	b.n	800adfa <find_volume.constprop.0+0x392>
	rv = rv << 8 | ptr[0];
 800ae98:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 800ae9c:	2b02      	cmp	r3, #2
 800ae9e:	d18a      	bne.n	800adb6 <find_volume.constprop.0+0x34e>
 800aea0:	e7ab      	b.n	800adfa <find_volume.constprop.0+0x392>
 800aea2:	bf00      	nop

0800aea4 <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800aea4:	2901      	cmp	r1, #1
 800aea6:	d911      	bls.n	800aecc <get_fat+0x28>
{
 800aea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	FATFS *fs = obj->fs;
 800aeac:	6805      	ldr	r5, [r0, #0]
 800aeae:	460c      	mov	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800aeb0:	696b      	ldr	r3, [r5, #20]
 800aeb2:	428b      	cmp	r3, r1
 800aeb4:	d802      	bhi.n	800aebc <get_fat+0x18>
		val = 1;	/* Internal error */
 800aeb6:	2001      	movs	r0, #1
}
 800aeb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		switch (fs->fs_type) {
 800aebc:	782b      	ldrb	r3, [r5, #0]
 800aebe:	3b01      	subs	r3, #1
 800aec0:	2b03      	cmp	r3, #3
 800aec2:	d8f8      	bhi.n	800aeb6 <get_fat+0x12>
 800aec4:	e8df f003 	tbb	[pc, r3]
 800aec8:	042f3e4b 	.word	0x042f3e4b
		val = 1;	/* Internal error */
 800aecc:	2001      	movs	r0, #1
}
 800aece:	4770      	bx	lr
			if (obj->objsize) {
 800aed0:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 800aed4:	ea53 0102 	orrs.w	r1, r3, r2
 800aed8:	d0ed      	beq.n	800aeb6 <get_fat+0x12>
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800aeda:	79c6      	ldrb	r6, [r0, #7]
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800aedc:	6881      	ldr	r1, [r0, #8]
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800aede:	2e02      	cmp	r6, #2
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800aee0:	eba4 0101 	sub.w	r1, r4, r1
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800aee4:	f000 8087 	beq.w	800aff6 <get_fat+0x152>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800aee8:	2e03      	cmp	r6, #3
 800aeea:	f000 8093 	beq.w	800b014 <get_fat+0x170>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 800aeee:	69c3      	ldr	r3, [r0, #28]
 800aef0:	2b00      	cmp	r3, #0
 800aef2:	f040 8093 	bne.w	800b01c <get_fat+0x178>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800aef6:	6a2e      	ldr	r6, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800aef8:	f105 0730 	add.w	r7, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800aefc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800aefe:	eb06 16d4 	add.w	r6, r6, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af02:	429e      	cmp	r6, r3
 800af04:	d008      	beq.n	800af18 <get_fat+0x74>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800af06:	2301      	movs	r3, #1
 800af08:	4632      	mov	r2, r6
 800af0a:	7868      	ldrb	r0, [r5, #1]
 800af0c:	4639      	mov	r1, r7
 800af0e:	f7ff fc67 	bl	800a7e0 <disk_read>
 800af12:	2800      	cmp	r0, #0
 800af14:	d16a      	bne.n	800afec <get_fat+0x148>
			fs->winsect = sector;
 800af16:	62ee      	str	r6, [r5, #44]	; 0x2c
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800af18:	00a3      	lsls	r3, r4, #2
 800af1a:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800af1e:	58f8      	ldr	r0, [r7, r3]
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800af20:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800af24:	e7c8      	b.n	800aeb8 <get_fat+0x14>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800af26:	6a2e      	ldr	r6, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800af28:	f105 0730 	add.w	r7, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af2c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800af2e:	eb06 16d1 	add.w	r6, r6, r1, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af32:	429e      	cmp	r6, r3
 800af34:	d145      	bne.n	800afc2 <get_fat+0x11e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800af36:	00a4      	lsls	r4, r4, #2
 800af38:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800af3c:	5938      	ldr	r0, [r7, r4]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800af3e:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
 800af42:	e7b9      	b.n	800aeb8 <get_fat+0x14>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800af44:	6a2e      	ldr	r6, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800af46:	f105 0730 	add.w	r7, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af4a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800af4c:	eb06 2611 	add.w	r6, r6, r1, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af50:	429e      	cmp	r6, r3
 800af52:	d12d      	bne.n	800afb0 <get_fat+0x10c>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800af54:	0064      	lsls	r4, r4, #1
 800af56:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 800af5a:	5b38      	ldrh	r0, [r7, r4]
			break;
 800af5c:	e7ac      	b.n	800aeb8 <get_fat+0x14>
			bc = (UINT)clst; bc += bc / 2;
 800af5e:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800af62:	6a2b      	ldr	r3, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af64:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800af66:	eb03 2756 	add.w	r7, r3, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af6a:	428f      	cmp	r7, r1
 800af6c:	d132      	bne.n	800afd4 <get_fat+0x130>
			wc = fs->win[bc++ % SS(fs)];
 800af6e:	1c77      	adds	r7, r6, #1
 800af70:	f3c6 0608 	ubfx	r6, r6, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800af74:	eb03 2857 	add.w	r8, r3, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 800af78:	442e      	add	r6, r5
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af7a:	4588      	cmp	r8, r1
			wc = fs->win[bc++ % SS(fs)];
 800af7c:	f896 6030 	ldrb.w	r6, [r6, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800af80:	d009      	beq.n	800af96 <get_fat+0xf2>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800af82:	2301      	movs	r3, #1
 800af84:	4642      	mov	r2, r8
 800af86:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800af8a:	7868      	ldrb	r0, [r5, #1]
 800af8c:	f7ff fc28 	bl	800a7e0 <disk_read>
 800af90:	bb60      	cbnz	r0, 800afec <get_fat+0x148>
			fs->winsect = sector;
 800af92:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 800af96:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800af9a:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800af9c:	443d      	add	r5, r7
 800af9e:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
 800afa2:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800afa6:	bf4c      	ite	mi
 800afa8:	0900      	lsrmi	r0, r0, #4
 800afaa:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 800afae:	e783      	b.n	800aeb8 <get_fat+0x14>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800afb0:	2301      	movs	r3, #1
 800afb2:	4632      	mov	r2, r6
 800afb4:	7868      	ldrb	r0, [r5, #1]
 800afb6:	4639      	mov	r1, r7
 800afb8:	f7ff fc12 	bl	800a7e0 <disk_read>
 800afbc:	b9b0      	cbnz	r0, 800afec <get_fat+0x148>
			fs->winsect = sector;
 800afbe:	62ee      	str	r6, [r5, #44]	; 0x2c
	return res;
 800afc0:	e7c8      	b.n	800af54 <get_fat+0xb0>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800afc2:	2301      	movs	r3, #1
 800afc4:	4632      	mov	r2, r6
 800afc6:	7868      	ldrb	r0, [r5, #1]
 800afc8:	4639      	mov	r1, r7
 800afca:	f7ff fc09 	bl	800a7e0 <disk_read>
 800afce:	b968      	cbnz	r0, 800afec <get_fat+0x148>
			fs->winsect = sector;
 800afd0:	62ee      	str	r6, [r5, #44]	; 0x2c
	return res;
 800afd2:	e7b0      	b.n	800af36 <get_fat+0x92>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800afd4:	2301      	movs	r3, #1
 800afd6:	463a      	mov	r2, r7
 800afd8:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800afdc:	7868      	ldrb	r0, [r5, #1]
 800afde:	f7ff fbff 	bl	800a7e0 <disk_read>
 800afe2:	b918      	cbnz	r0, 800afec <get_fat+0x148>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800afe4:	6a2b      	ldr	r3, [r5, #32]
 800afe6:	4639      	mov	r1, r7
			fs->winsect = sector;
 800afe8:	62ef      	str	r7, [r5, #44]	; 0x2c
	return res;
 800afea:	e7c0      	b.n	800af6e <get_fat+0xca>
			fs->winsect = sector;
 800afec:	f04f 33ff 	mov.w	r3, #4294967295
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800aff0:	4618      	mov	r0, r3
			fs->winsect = sector;
 800aff2:	62eb      	str	r3, [r5, #44]	; 0x2c
	return res;
 800aff4:	e760      	b.n	800aeb8 <get_fat+0x14>
				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 800aff6:	3b01      	subs	r3, #1
 800aff8:	8968      	ldrh	r0, [r5, #10]
 800affa:	f142 32ff 	adc.w	r2, r2, #4294967295
 800affe:	0a5b      	lsrs	r3, r3, #9
 800b000:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 800b004:	fbb3 f3f0 	udiv	r3, r3, r0
					if (cofs <= clen) {
 800b008:	4299      	cmp	r1, r3
 800b00a:	f63f af54 	bhi.w	800aeb6 <get_fat+0x12>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800b00e:	d005      	beq.n	800b01c <get_fat+0x178>
 800b010:	1c60      	adds	r0, r4, #1
 800b012:	e751      	b.n	800aeb8 <get_fat+0x14>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800b014:	6983      	ldr	r3, [r0, #24]
 800b016:	428b      	cmp	r3, r1
 800b018:	d8fa      	bhi.n	800b010 <get_fat+0x16c>
 800b01a:	e768      	b.n	800aeee <get_fat+0x4a>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800b01c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	return val;
 800b020:	e74a      	b.n	800aeb8 <get_fat+0x14>
 800b022:	bf00      	nop

0800b024 <dir_next.constprop.0>:
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b024:	6b83      	ldr	r3, [r0, #56]	; 0x38
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
 800b026:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800b02a:	6b05      	ldr	r5, [r0, #48]	; 0x30
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b02c:	2b00      	cmp	r3, #0
 800b02e:	d034      	beq.n	800b09a <dir_next.constprop.0+0x76>
	FATFS *fs = dp->obj.fs;
 800b030:	6806      	ldr	r6, [r0, #0]
 800b032:	3520      	adds	r5, #32
 800b034:	4604      	mov	r4, r0
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b036:	7832      	ldrb	r2, [r6, #0]
 800b038:	2a04      	cmp	r2, #4
 800b03a:	bf0c      	ite	eq
 800b03c:	f04f 5280 	moveq.w	r2, #268435456	; 0x10000000
 800b040:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
 800b044:	4295      	cmp	r5, r2
 800b046:	d228      	bcs.n	800b09a <dir_next.constprop.0+0x76>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800b048:	f3c5 0708 	ubfx	r7, r5, #0, #9
 800b04c:	b137      	cbz	r7, 800b05c <dir_next.constprop.0+0x38>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b04e:	3630      	adds	r6, #48	; 0x30
	return FR_OK;
 800b050:	2000      	movs	r0, #0
	dp->dptr = ofs;						/* Current entry */
 800b052:	6325      	str	r5, [r4, #48]	; 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b054:	443e      	add	r6, r7
 800b056:	63e6      	str	r6, [r4, #60]	; 0x3c
}
 800b058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		dp->sect++;				/* Next sector */
 800b05c:	3301      	adds	r3, #1
		if (!dp->clust) {		/* Static table */
 800b05e:	6b41      	ldr	r1, [r0, #52]	; 0x34
		dp->sect++;				/* Next sector */
 800b060:	6383      	str	r3, [r0, #56]	; 0x38
		if (!dp->clust) {		/* Static table */
 800b062:	b1e9      	cbz	r1, 800b0a0 <dir_next.constprop.0+0x7c>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800b064:	8973      	ldrh	r3, [r6, #10]
 800b066:	3b01      	subs	r3, #1
 800b068:	ea13 2855 	ands.w	r8, r3, r5, lsr #9
 800b06c:	d1ef      	bne.n	800b04e <dir_next.constprop.0+0x2a>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800b06e:	f7ff ff19 	bl	800aea4 <get_fat>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800b072:	2801      	cmp	r0, #1
 800b074:	d91c      	bls.n	800b0b0 <dir_next.constprop.0+0x8c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800b076:	1c43      	adds	r3, r0, #1
 800b078:	d01c      	beq.n	800b0b4 <dir_next.constprop.0+0x90>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800b07a:	6973      	ldr	r3, [r6, #20]
 800b07c:	4298      	cmp	r0, r3
 800b07e:	d213      	bcs.n	800b0a8 <dir_next.constprop.0+0x84>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b080:	3b02      	subs	r3, #2
				dp->clust = clst;		/* Initialize data for new cluster */
 800b082:	6360      	str	r0, [r4, #52]	; 0x34
	clst -= 2;
 800b084:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b086:	4298      	cmp	r0, r3
 800b088:	d204      	bcs.n	800b094 <dir_next.constprop.0+0x70>
	return clst * fs->csize + fs->database;
 800b08a:	f8b6 800a 	ldrh.w	r8, [r6, #10]
 800b08e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800b090:	fb00 3808 	mla	r8, r0, r8, r3
				dp->sect = clust2sect(fs, clst);
 800b094:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
 800b098:	e7d9      	b.n	800b04e <dir_next.constprop.0+0x2a>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b09a:	2004      	movs	r0, #4
}
 800b09c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800b0a0:	8933      	ldrh	r3, [r6, #8]
 800b0a2:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 800b0a6:	d8d2      	bhi.n	800b04e <dir_next.constprop.0+0x2a>
				dp->sect = 0; return FR_NO_FILE;
 800b0a8:	2300      	movs	r3, #0
 800b0aa:	2004      	movs	r0, #4
 800b0ac:	63a3      	str	r3, [r4, #56]	; 0x38
 800b0ae:	e7d3      	b.n	800b058 <dir_next.constprop.0+0x34>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800b0b0:	2002      	movs	r0, #2
 800b0b2:	e7d1      	b.n	800b058 <dir_next.constprop.0+0x34>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800b0b4:	2001      	movs	r0, #1
 800b0b6:	e7cf      	b.n	800b058 <dir_next.constprop.0+0x34>

0800b0b8 <dir_read.constprop.0>:
FRESULT dir_read (
 800b0b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	while (dp->sect) {
 800b0bc:	6b86      	ldr	r6, [r0, #56]	; 0x38
FRESULT dir_read (
 800b0be:	b083      	sub	sp, #12
 800b0c0:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 800b0c2:	f8d0 8000 	ldr.w	r8, [r0]
	while (dp->sect) {
 800b0c6:	2e00      	cmp	r6, #0
 800b0c8:	d04c      	beq.n	800b164 <dir_read.constprop.0+0xac>
	BYTE ord = 0xFF, sum = 0xFF;
 800b0ca:	f04f 0bff 	mov.w	fp, #255	; 0xff
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b0ce:	f108 0a30 	add.w	sl, r8, #48	; 0x30
	BYTE ord = 0xFF, sum = 0xFF;
 800b0d2:	46d9      	mov	r9, fp
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b0d4:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800b0d8:	42b3      	cmp	r3, r6
 800b0da:	d00a      	beq.n	800b0f2 <dir_read.constprop.0+0x3a>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b0dc:	2301      	movs	r3, #1
 800b0de:	4632      	mov	r2, r6
 800b0e0:	4651      	mov	r1, sl
 800b0e2:	f898 0001 	ldrb.w	r0, [r8, #1]
 800b0e6:	f7ff fb7b 	bl	800a7e0 <disk_read>
 800b0ea:	2800      	cmp	r0, #0
 800b0ec:	d14b      	bne.n	800b186 <dir_read.constprop.0+0xce>
			fs->winsect = sector;
 800b0ee:	f8c8 602c 	str.w	r6, [r8, #44]	; 0x2c
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800b0f2:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800b0f4:	780b      	ldrb	r3, [r1, #0]
		if (c == 0) {
 800b0f6:	2b00      	cmp	r3, #0
 800b0f8:	d034      	beq.n	800b164 <dir_read.constprop.0+0xac>
		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800b0fa:	f898 2000 	ldrb.w	r2, [r8]
 800b0fe:	2a04      	cmp	r2, #4
 800b100:	d037      	beq.n	800b172 <dir_read.constprop.0+0xba>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800b102:	7aca      	ldrb	r2, [r1, #11]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800b104:	2be5      	cmp	r3, #229	; 0xe5
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800b106:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800b10a:	71a2      	strb	r2, [r4, #6]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800b10c:	d005      	beq.n	800b11a <dir_read.constprop.0+0x62>
 800b10e:	2b2e      	cmp	r3, #46	; 0x2e
 800b110:	d003      	beq.n	800b11a <dir_read.constprop.0+0x62>
 800b112:	f022 0020 	bic.w	r0, r2, #32
 800b116:	2808      	cmp	r0, #8
 800b118:	d15a      	bne.n	800b1d0 <dir_read.constprop.0+0x118>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800b11a:	6b25      	ldr	r5, [r4, #48]	; 0x30
				ord = 0xFF;
 800b11c:	f04f 09ff 	mov.w	r9, #255	; 0xff
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b120:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800b122:	3520      	adds	r5, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b124:	b1f6      	cbz	r6, 800b164 <dir_read.constprop.0+0xac>
	FATFS *fs = dp->obj.fs;
 800b126:	6827      	ldr	r7, [r4, #0]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800b128:	783b      	ldrb	r3, [r7, #0]
 800b12a:	2b04      	cmp	r3, #4
 800b12c:	bf0c      	ite	eq
 800b12e:	f04f 5380 	moveq.w	r3, #268435456	; 0x10000000
 800b132:	f44f 1300 	movne.w	r3, #2097152	; 0x200000
 800b136:	429d      	cmp	r5, r3
 800b138:	d214      	bcs.n	800b164 <dir_read.constprop.0+0xac>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800b13a:	f3c5 0308 	ubfx	r3, r5, #0, #9
 800b13e:	b9eb      	cbnz	r3, 800b17c <dir_read.constprop.0+0xc4>
		dp->sect++;				/* Next sector */
 800b140:	3601      	adds	r6, #1
		if (!dp->clust) {		/* Static table */
 800b142:	6b61      	ldr	r1, [r4, #52]	; 0x34
		dp->sect++;				/* Next sector */
 800b144:	63a6      	str	r6, [r4, #56]	; 0x38
		if (!dp->clust) {		/* Static table */
 800b146:	bb21      	cbnz	r1, 800b192 <dir_read.constprop.0+0xda>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800b148:	893b      	ldrh	r3, [r7, #8]
 800b14a:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 800b14e:	d909      	bls.n	800b164 <dir_read.constprop.0+0xac>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b150:	3730      	adds	r7, #48	; 0x30
	dp->dptr = ofs;						/* Current entry */
 800b152:	6325      	str	r5, [r4, #48]	; 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b154:	63e7      	str	r7, [r4, #60]	; 0x3c
	while (dp->sect) {
 800b156:	2e00      	cmp	r6, #0
 800b158:	d1bc      	bne.n	800b0d4 <dir_read.constprop.0+0x1c>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800b15a:	2500      	movs	r5, #0
}
 800b15c:	4628      	mov	r0, r5
 800b15e:	b003      	add	sp, #12
 800b160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	FRESULT res = FR_NO_FILE;
 800b164:	2504      	movs	r5, #4
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800b166:	2300      	movs	r3, #0
 800b168:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b16a:	4628      	mov	r0, r5
 800b16c:	b003      	add	sp, #12
 800b16e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (c == 0x85) {		/* Start of the file entry block? */
 800b172:	2b85      	cmp	r3, #133	; 0x85
 800b174:	f000 80f6 	beq.w	800b364 <dir_read.constprop.0+0x2ac>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800b178:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800b17a:	e7d1      	b.n	800b120 <dir_read.constprop.0+0x68>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b17c:	3730      	adds	r7, #48	; 0x30
	dp->dptr = ofs;						/* Current entry */
 800b17e:	6325      	str	r5, [r4, #48]	; 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b180:	443b      	add	r3, r7
 800b182:	63e3      	str	r3, [r4, #60]	; 0x3c
	while (dp->sect) {
 800b184:	e7a6      	b.n	800b0d4 <dir_read.constprop.0+0x1c>
			fs->winsect = sector;
 800b186:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800b18a:	2501      	movs	r5, #1
			fs->winsect = sector;
 800b18c:	f8c8 302c 	str.w	r3, [r8, #44]	; 0x2c
		if (res != FR_OK) break;
 800b190:	e7e9      	b.n	800b166 <dir_read.constprop.0+0xae>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800b192:	897b      	ldrh	r3, [r7, #10]
 800b194:	3b01      	subs	r3, #1
 800b196:	ea13 2355 	ands.w	r3, r3, r5, lsr #9
 800b19a:	d1d9      	bne.n	800b150 <dir_read.constprop.0+0x98>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800b19c:	4620      	mov	r0, r4
 800b19e:	9301      	str	r3, [sp, #4]
 800b1a0:	f7ff fe80 	bl	800aea4 <get_fat>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800b1a4:	2801      	cmp	r0, #1
 800b1a6:	f240 80d5 	bls.w	800b354 <dir_read.constprop.0+0x29c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800b1aa:	1c43      	adds	r3, r0, #1
 800b1ac:	f000 80d0 	beq.w	800b350 <dir_read.constprop.0+0x298>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800b1b0:	697a      	ldr	r2, [r7, #20]
 800b1b2:	4290      	cmp	r0, r2
 800b1b4:	d2d6      	bcs.n	800b164 <dir_read.constprop.0+0xac>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b1b6:	3a02      	subs	r2, #2
				dp->clust = clst;		/* Initialize data for new cluster */
 800b1b8:	6360      	str	r0, [r4, #52]	; 0x34
	clst -= 2;
 800b1ba:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b1bc:	9b01      	ldr	r3, [sp, #4]
 800b1be:	4290      	cmp	r0, r2
 800b1c0:	f080 80ca 	bcs.w	800b358 <dir_read.constprop.0+0x2a0>
	return clst * fs->csize + fs->database;
 800b1c4:	897e      	ldrh	r6, [r7, #10]
 800b1c6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b1c8:	fb00 2606 	mla	r6, r0, r6, r2
				dp->sect = clust2sect(fs, clst);
 800b1cc:	63a6      	str	r6, [r4, #56]	; 0x38
 800b1ce:	e7bf      	b.n	800b150 <dir_read.constprop.0+0x98>
				if (a == AM_LFN) {			/* An LFN entry is found */
 800b1d0:	2a0f      	cmp	r2, #15
 800b1d2:	f040 81f9 	bne.w	800b5c8 <dir_read.constprop.0+0x510>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800b1d6:	0658      	lsls	r0, r3, #25
 800b1d8:	f140 80b5 	bpl.w	800b346 <dir_read.constprop.0+0x28e>
						dp->blk_ofs = dp->dptr;
 800b1dc:	6b25      	ldr	r5, [r4, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;
 800b1de:	f003 09bf 	and.w	r9, r3, #191	; 0xbf
						sum = dp->dir[LDIR_Chksum];
 800b1e2:	f891 b00d 	ldrb.w	fp, [r1, #13]
						dp->blk_ofs = dp->dptr;
 800b1e6:	64e5      	str	r5, [r4, #76]	; 0x4c
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800b1e8:	7b4b      	ldrb	r3, [r1, #13]
 800b1ea:	455b      	cmp	r3, fp
 800b1ec:	d196      	bne.n	800b11c <dir_read.constprop.0+0x64>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 800b1ee:	8b4b      	ldrh	r3, [r1, #26]
 800b1f0:	2b00      	cmp	r3, #0
 800b1f2:	d193      	bne.n	800b11c <dir_read.constprop.0+0x64>
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800b1f4:	780b      	ldrb	r3, [r1, #0]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b1f6:	f8b1 0001 	ldrh.w	r0, [r1, #1]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800b1fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b1fe:	3b01      	subs	r3, #1
 800b200:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800b204:	eb03 0382 	add.w	r3, r3, r2, lsl #2
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b208:	2bfe      	cmp	r3, #254	; 0xfe
 800b20a:	d887      	bhi.n	800b11c <dir_read.constprop.0+0x64>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800b20c:	f8d8 600c 	ldr.w	r6, [r8, #12]
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b210:	1c5a      	adds	r2, r3, #1
 800b212:	f846 0023 	str.w	r0, [r6, r3, lsl #2]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b216:	f8b1 c003 	ldrh.w	ip, [r1, #3]
		if (wc) {
 800b21a:	2800      	cmp	r0, #0
 800b21c:	f000 813a 	beq.w	800b494 <dir_read.constprop.0+0x3dc>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b220:	2aff      	cmp	r2, #255	; 0xff
 800b222:	f000 8227 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b226:	f846 c022 	str.w	ip, [r6, r2, lsl #2]
 800b22a:	0090      	lsls	r0, r2, #2
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b22c:	f8b1 7005 	ldrh.w	r7, [r1, #5]
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b230:	1c9a      	adds	r2, r3, #2
		if (wc) {
 800b232:	f1bc 0f00 	cmp.w	ip, #0
 800b236:	f000 8134 	beq.w	800b4a2 <dir_read.constprop.0+0x3ea>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b23a:	2aff      	cmp	r2, #255	; 0xff
 800b23c:	f000 821a 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b240:	4430      	add	r0, r6
 800b242:	1cda      	adds	r2, r3, #3
 800b244:	6047      	str	r7, [r0, #4]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b246:	f8b1 c007 	ldrh.w	ip, [r1, #7]
		if (wc) {
 800b24a:	2f00      	cmp	r7, #0
 800b24c:	f000 8130 	beq.w	800b4b0 <dir_read.constprop.0+0x3f8>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b250:	2aff      	cmp	r2, #255	; 0xff
 800b252:	f000 820f 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b256:	f8c0 c008 	str.w	ip, [r0, #8]
 800b25a:	1d1a      	adds	r2, r3, #4
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b25c:	f8b1 7009 	ldrh.w	r7, [r1, #9]
		if (wc) {
 800b260:	f1bc 0f00 	cmp.w	ip, #0
 800b264:	f000 812b 	beq.w	800b4be <dir_read.constprop.0+0x406>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b268:	2aff      	cmp	r2, #255	; 0xff
 800b26a:	f000 8203 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b26e:	60c7      	str	r7, [r0, #12]
 800b270:	1d5a      	adds	r2, r3, #5
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b272:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
		if (wc) {
 800b276:	2f00      	cmp	r7, #0
 800b278:	f000 8128 	beq.w	800b4cc <dir_read.constprop.0+0x414>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b27c:	2aff      	cmp	r2, #255	; 0xff
 800b27e:	f000 81f9 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b282:	f8c0 c010 	str.w	ip, [r0, #16]
 800b286:	1d9a      	adds	r2, r3, #6
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b288:	f8b1 e010 	ldrh.w	lr, [r1, #16]
		if (wc) {
 800b28c:	f1bc 0f00 	cmp.w	ip, #0
 800b290:	f000 8123 	beq.w	800b4da <dir_read.constprop.0+0x422>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b294:	2aff      	cmp	r2, #255	; 0xff
 800b296:	f000 81ed 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b29a:	f8c0 e014 	str.w	lr, [r0, #20]
 800b29e:	1dda      	adds	r2, r3, #7
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b2a0:	8a4f      	ldrh	r7, [r1, #18]
		if (wc) {
 800b2a2:	f1be 0f00 	cmp.w	lr, #0
 800b2a6:	f000 811e 	beq.w	800b4e6 <dir_read.constprop.0+0x42e>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b2aa:	2aff      	cmp	r2, #255	; 0xff
 800b2ac:	f000 81e2 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b2b0:	6187      	str	r7, [r0, #24]
 800b2b2:	f103 0208 	add.w	r2, r3, #8
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b2b6:	f8b1 c014 	ldrh.w	ip, [r1, #20]
		if (wc) {
 800b2ba:	2f00      	cmp	r7, #0
 800b2bc:	f000 811a 	beq.w	800b4f4 <dir_read.constprop.0+0x43c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b2c0:	2aff      	cmp	r2, #255	; 0xff
 800b2c2:	f000 81d7 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b2c6:	f8c0 c01c 	str.w	ip, [r0, #28]
 800b2ca:	f103 0209 	add.w	r2, r3, #9
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b2ce:	8acf      	ldrh	r7, [r1, #22]
		if (wc) {
 800b2d0:	f1bc 0f00 	cmp.w	ip, #0
 800b2d4:	f000 8114 	beq.w	800b500 <dir_read.constprop.0+0x448>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b2d8:	2aff      	cmp	r2, #255	; 0xff
 800b2da:	f43f af1f 	beq.w	800b11c <dir_read.constprop.0+0x64>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b2de:	6207      	str	r7, [r0, #32]
 800b2e0:	f103 020a 	add.w	r2, r3, #10
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b2e4:	f8b1 c018 	ldrh.w	ip, [r1, #24]
		if (wc) {
 800b2e8:	2f00      	cmp	r7, #0
 800b2ea:	f000 8110 	beq.w	800b50e <dir_read.constprop.0+0x456>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b2ee:	2aff      	cmp	r2, #255	; 0xff
 800b2f0:	f000 81c0 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b2f4:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
 800b2f8:	f103 020b 	add.w	r2, r3, #11
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b2fc:	8b8f      	ldrh	r7, [r1, #28]
		if (wc) {
 800b2fe:	f1bc 0f00 	cmp.w	ip, #0
 800b302:	f000 810a 	beq.w	800b51a <dir_read.constprop.0+0x462>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b306:	2aff      	cmp	r2, #255	; 0xff
 800b308:	f000 81b4 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b30c:	6287      	str	r7, [r0, #40]	; 0x28
 800b30e:	f103 020c 	add.w	r2, r3, #12
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b312:	f8b1 c01e 	ldrh.w	ip, [r1, #30]
		if (wc) {
 800b316:	2f00      	cmp	r7, #0
 800b318:	f000 8106 	beq.w	800b528 <dir_read.constprop.0+0x470>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800b31c:	2aff      	cmp	r2, #255	; 0xff
 800b31e:	f000 81a9 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800b322:	f103 020d 	add.w	r2, r3, #13
 800b326:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 800b32a:	780b      	ldrb	r3, [r1, #0]
 800b32c:	0659      	lsls	r1, r3, #25
 800b32e:	d505      	bpl.n	800b33c <dir_read.constprop.0+0x284>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 800b330:	2aff      	cmp	r2, #255	; 0xff
 800b332:	f000 819f 	beq.w	800b674 <dir_read.constprop.0+0x5bc>
		lfnbuf[i] = 0;
 800b336:	2300      	movs	r3, #0
 800b338:	f846 3022 	str.w	r3, [r6, r2, lsl #2]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800b33c:	f109 39ff 	add.w	r9, r9, #4294967295
 800b340:	fa5f f989 	uxtb.w	r9, r9
 800b344:	e6ec      	b.n	800b120 <dir_read.constprop.0+0x68>
 800b346:	454b      	cmp	r3, r9
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 800b348:	6b25      	ldr	r5, [r4, #48]	; 0x30
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800b34a:	f47f aee7 	bne.w	800b11c <dir_read.constprop.0+0x64>
 800b34e:	e74b      	b.n	800b1e8 <dir_read.constprop.0+0x130>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800b350:	2501      	movs	r5, #1
 800b352:	e708      	b.n	800b166 <dir_read.constprop.0+0xae>
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 800b354:	2502      	movs	r5, #2
 800b356:	e706      	b.n	800b166 <dir_read.constprop.0+0xae>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b358:	3730      	adds	r7, #48	; 0x30
	dp->dptr = ofs;						/* Current entry */
 800b35a:	6325      	str	r5, [r4, #48]	; 0x30
				dp->sect = clust2sect(fs, clst);
 800b35c:	63a3      	str	r3, [r4, #56]	; 0x38
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800b35e:	2500      	movs	r5, #0
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800b360:	63e7      	str	r7, [r4, #60]	; 0x3c
	while (dp->sect) {
 800b362:	e6fb      	b.n	800b15c <dir_read.constprop.0+0xa4>
	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 800b364:	6827      	ldr	r7, [r4, #0]
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 800b366:	6b23      	ldr	r3, [r4, #48]	; 0x30
	res = move_window(dp->obj.fs, dp->sect);
 800b368:	6ba5      	ldr	r5, [r4, #56]	; 0x38
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 800b36a:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b36c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 800b36e:	693e      	ldr	r6, [r7, #16]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b370:	429d      	cmp	r5, r3
 800b372:	f040 8082 	bne.w	800b47a <dir_read.constprop.0+0x3c2>
	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
 800b376:	780b      	ldrb	r3, [r1, #0]
 800b378:	2b85      	cmp	r3, #133	; 0x85
 800b37a:	d1eb      	bne.n	800b354 <dir_read.constprop.0+0x29c>
 800b37c:	1c4b      	adds	r3, r1, #1
 800b37e:	1af2      	subs	r2, r6, r3
 800b380:	2a02      	cmp	r2, #2
 800b382:	f240 80d7 	bls.w	800b534 <dir_read.constprop.0+0x47c>
			*d++ = *s++;
 800b386:	680b      	ldr	r3, [r1, #0]
 800b388:	6033      	str	r3, [r6, #0]
 800b38a:	684b      	ldr	r3, [r1, #4]
 800b38c:	6073      	str	r3, [r6, #4]
 800b38e:	688b      	ldr	r3, [r1, #8]
 800b390:	60b3      	str	r3, [r6, #8]
 800b392:	68cb      	ldr	r3, [r1, #12]
 800b394:	60f3      	str	r3, [r6, #12]
 800b396:	690b      	ldr	r3, [r1, #16]
 800b398:	6133      	str	r3, [r6, #16]
 800b39a:	694b      	ldr	r3, [r1, #20]
 800b39c:	6173      	str	r3, [r6, #20]
 800b39e:	698b      	ldr	r3, [r1, #24]
 800b3a0:	61b3      	str	r3, [r6, #24]
 800b3a2:	69cb      	ldr	r3, [r1, #28]
 800b3a4:	61f3      	str	r3, [r6, #28]
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 800b3a6:	f896 9001 	ldrb.w	r9, [r6, #1]
 800b3aa:	f109 0901 	add.w	r9, r9, #1
 800b3ae:	ea4f 1949 	mov.w	r9, r9, lsl #5
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 800b3b2:	f1a9 0360 	sub.w	r3, r9, #96	; 0x60
 800b3b6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b3ba:	d8cb      	bhi.n	800b354 <dir_read.constprop.0+0x29c>
	res = dir_next(dp, 0);
 800b3bc:	4620      	mov	r0, r4
 800b3be:	f7ff fe31 	bl	800b024 <dir_next.constprop.0>
	if (res != FR_OK) return res;
 800b3c2:	4605      	mov	r5, r0
 800b3c4:	2800      	cmp	r0, #0
 800b3c6:	f47f aece 	bne.w	800b166 <dir_read.constprop.0+0xae>
	res = move_window(dp->obj.fs, dp->sect);
 800b3ca:	6827      	ldr	r7, [r4, #0]
 800b3cc:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b3ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3d0:	429d      	cmp	r5, r3
 800b3d2:	d00a      	beq.n	800b3ea <dir_read.constprop.0+0x332>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b3d4:	2301      	movs	r3, #1
 800b3d6:	462a      	mov	r2, r5
 800b3d8:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b3dc:	7878      	ldrb	r0, [r7, #1]
 800b3de:	f7ff f9ff 	bl	800a7e0 <disk_read>
 800b3e2:	2800      	cmp	r0, #0
 800b3e4:	f040 8141 	bne.w	800b66a <dir_read.constprop.0+0x5b2>
			fs->winsect = sector;
 800b3e8:	62fd      	str	r5, [r7, #44]	; 0x2c
	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
 800b3ea:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b3ec:	781a      	ldrb	r2, [r3, #0]
 800b3ee:	2ac0      	cmp	r2, #192	; 0xc0
 800b3f0:	d1b0      	bne.n	800b354 <dir_read.constprop.0+0x29c>
	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
 800b3f2:	f106 0120 	add.w	r1, r6, #32
 800b3f6:	1c5a      	adds	r2, r3, #1
 800b3f8:	1a89      	subs	r1, r1, r2
 800b3fa:	2902      	cmp	r1, #2
 800b3fc:	f240 8164 	bls.w	800b6c8 <dir_read.constprop.0+0x610>
			*d++ = *s++;
 800b400:	681a      	ldr	r2, [r3, #0]
 800b402:	6232      	str	r2, [r6, #32]
 800b404:	685a      	ldr	r2, [r3, #4]
 800b406:	6272      	str	r2, [r6, #36]	; 0x24
 800b408:	689a      	ldr	r2, [r3, #8]
 800b40a:	62b2      	str	r2, [r6, #40]	; 0x28
 800b40c:	68da      	ldr	r2, [r3, #12]
 800b40e:	62f2      	str	r2, [r6, #44]	; 0x2c
 800b410:	691a      	ldr	r2, [r3, #16]
 800b412:	6332      	str	r2, [r6, #48]	; 0x30
 800b414:	695a      	ldr	r2, [r3, #20]
 800b416:	6372      	str	r2, [r6, #52]	; 0x34
 800b418:	699a      	ldr	r2, [r3, #24]
 800b41a:	63b2      	str	r2, [r6, #56]	; 0x38
 800b41c:	69db      	ldr	r3, [r3, #28]
 800b41e:	63f3      	str	r3, [r6, #60]	; 0x3c
	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 800b420:	f896 3023 	ldrb.w	r3, [r6, #35]	; 0x23
 800b424:	4aae      	ldr	r2, [pc, #696]	; (800b6e0 <dir_read.constprop.0+0x628>)
 800b426:	332c      	adds	r3, #44	; 0x2c
 800b428:	fba2 2303 	umull	r2, r3, r2, r3
 800b42c:	08db      	lsrs	r3, r3, #3
 800b42e:	ebb9 1f43 	cmp.w	r9, r3, lsl #5
 800b432:	d38f      	bcc.n	800b354 <dir_read.constprop.0+0x29c>
 800b434:	f106 073f 	add.w	r7, r6, #63	; 0x3f
	i = SZDIRE * 2;	/* C1 offset */
 800b438:	f04f 0a40 	mov.w	sl, #64	; 0x40
		res = dir_next(dp, 0);
 800b43c:	4620      	mov	r0, r4
 800b43e:	f7ff fdf1 	bl	800b024 <dir_next.constprop.0>
		if (res != FR_OK) return res;
 800b442:	4605      	mov	r5, r0
 800b444:	2800      	cmp	r0, #0
 800b446:	f47f ae8e 	bne.w	800b166 <dir_read.constprop.0+0xae>
		res = move_window(dp->obj.fs, dp->sect);
 800b44a:	f8d4 b000 	ldr.w	fp, [r4]
 800b44e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b450:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
 800b454:	429a      	cmp	r2, r3
 800b456:	d07a      	beq.n	800b54e <dir_read.constprop.0+0x496>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b458:	2301      	movs	r3, #1
 800b45a:	f10b 0130 	add.w	r1, fp, #48	; 0x30
 800b45e:	f89b 0001 	ldrb.w	r0, [fp, #1]
 800b462:	9201      	str	r2, [sp, #4]
 800b464:	f7ff f9bc 	bl	800a7e0 <disk_read>
 800b468:	9a01      	ldr	r2, [sp, #4]
 800b46a:	2800      	cmp	r0, #0
 800b46c:	d06d      	beq.n	800b54a <dir_read.constprop.0+0x492>
			fs->winsect = sector;
 800b46e:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800b472:	2501      	movs	r5, #1
			fs->winsect = sector;
 800b474:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
		if (res != FR_OK) return res;
 800b478:	e675      	b.n	800b166 <dir_read.constprop.0+0xae>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b47a:	2301      	movs	r3, #1
 800b47c:	462a      	mov	r2, r5
 800b47e:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b482:	7878      	ldrb	r0, [r7, #1]
 800b484:	f7ff f9ac 	bl	800a7e0 <disk_read>
 800b488:	2800      	cmp	r0, #0
 800b48a:	f040 80ee 	bne.w	800b66a <dir_read.constprop.0+0x5b2>
	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
 800b48e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
			fs->winsect = sector;
 800b490:	62fd      	str	r5, [r7, #44]	; 0x2c
	if (res != FR_OK) return res;
 800b492:	e770      	b.n	800b376 <dir_read.constprop.0+0x2be>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b494:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b498:	459c      	cmp	ip, r3
 800b49a:	f47f ae3f 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b49e:	f8b1 7005 	ldrh.w	r7, [r1, #5]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4a2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4a6:	429f      	cmp	r7, r3
 800b4a8:	f47f ae38 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4ac:	f8b1 c007 	ldrh.w	ip, [r1, #7]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4b4:	459c      	cmp	ip, r3
 800b4b6:	f47f ae31 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4ba:	f8b1 7009 	ldrh.w	r7, [r1, #9]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4be:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4c2:	429f      	cmp	r7, r3
 800b4c4:	f47f ae2a 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4c8:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4d0:	459c      	cmp	ip, r3
 800b4d2:	f47f ae23 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4d6:	f8b1 e010 	ldrh.w	lr, [r1, #16]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4da:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4de:	459e      	cmp	lr, r3
 800b4e0:	f47f ae1c 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4e4:	8a4f      	ldrh	r7, [r1, #18]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4e6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4ea:	429f      	cmp	r7, r3
 800b4ec:	f47f ae16 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4f0:	f8b1 c014 	ldrh.w	ip, [r1, #20]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b4f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b4f8:	459c      	cmp	ip, r3
 800b4fa:	f47f ae0f 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b4fe:	8acf      	ldrh	r7, [r1, #22]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b500:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b504:	429f      	cmp	r7, r3
 800b506:	f47f ae09 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b50a:	f8b1 c018 	ldrh.w	ip, [r1, #24]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b50e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b512:	459c      	cmp	ip, r3
 800b514:	f47f ae02 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b518:	8b8f      	ldrh	r7, [r1, #28]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b51a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b51e:	429f      	cmp	r7, r3
 800b520:	f47f adfc 	bne.w	800b11c <dir_read.constprop.0+0x64>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800b524:	f8b1 c01e 	ldrh.w	ip, [r1, #30]
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800b528:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b52c:	459c      	cmp	ip, r3
 800b52e:	f43f aefc 	beq.w	800b32a <dir_read.constprop.0+0x272>
 800b532:	e5f3      	b.n	800b11c <dir_read.constprop.0+0x64>
 800b534:	3120      	adds	r1, #32
 800b536:	1e72      	subs	r2, r6, #1
			*d++ = *s++;
 800b538:	f813 0c01 	ldrb.w	r0, [r3, #-1]
		} while (--cnt);
 800b53c:	428b      	cmp	r3, r1
 800b53e:	f103 0301 	add.w	r3, r3, #1
			*d++ = *s++;
 800b542:	f802 0f01 	strb.w	r0, [r2, #1]!
		} while (--cnt);
 800b546:	d1f7      	bne.n	800b538 <dir_read.constprop.0+0x480>
 800b548:	e72d      	b.n	800b3a6 <dir_read.constprop.0+0x2ee>
			fs->winsect = sector;
 800b54a:	f8cb 202c 	str.w	r2, [fp, #44]	; 0x2c
		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
 800b54e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b550:	781a      	ldrb	r2, [r3, #0]
 800b552:	2ac1      	cmp	r2, #193	; 0xc1
 800b554:	f47f aefe 	bne.w	800b354 <dir_read.constprop.0+0x29c>
		if (i < MAXDIRB(_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
 800b558:	f5ba 7f18 	cmp.w	sl, #608	; 0x260
 800b55c:	f0c0 808c 	bcc.w	800b678 <dir_read.constprop.0+0x5c0>
	} while ((i += SZDIRE) < sz_ent);
 800b560:	f10a 0a20 	add.w	sl, sl, #32
 800b564:	3720      	adds	r7, #32
 800b566:	45d1      	cmp	r9, sl
 800b568:	f63f af68 	bhi.w	800b43c <dir_read.constprop.0+0x384>
	if (i <= MAXDIRB(_MAX_LFN)) {
 800b56c:	f5ba 7f18 	cmp.w	sl, #608	; 0x260
 800b570:	d823      	bhi.n	800b5ba <dir_read.constprop.0+0x502>
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
 800b572:	7871      	ldrb	r1, [r6, #1]
	for (i = sum = 0; i < szblk; i++) {
 800b574:	2300      	movs	r3, #0
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
 800b576:	3101      	adds	r1, #1
	for (i = sum = 0; i < szblk; i++) {
 800b578:	4618      	mov	r0, r3
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
 800b57a:	0149      	lsls	r1, r1, #5
		if (i == XDIR_SetSum) {	/* Skip sum field */
 800b57c:	2802      	cmp	r0, #2
 800b57e:	d10e      	bne.n	800b59e <dir_read.constprop.0+0x4e6>
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 800b580:	7932      	ldrb	r2, [r6, #4]
	for (i = sum = 0; i < szblk; i++) {
 800b582:	2006      	movs	r0, #6
 800b584:	eb02 32c3 	add.w	r2, r2, r3, lsl #15
 800b588:	b292      	uxth	r2, r2
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 800b58a:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 800b58e:	7973      	ldrb	r3, [r6, #5]
 800b590:	f3c2 074e 	ubfx	r7, r2, #1, #15
 800b594:	eb03 33c2 	add.w	r3, r3, r2, lsl #15
 800b598:	fa17 f383 	uxtah	r3, r7, r3
 800b59c:	b29b      	uxth	r3, r3
 800b59e:	5c32      	ldrb	r2, [r6, r0]
	for (i = sum = 0; i < szblk; i++) {
 800b5a0:	3001      	adds	r0, #1
 800b5a2:	eb02 32c3 	add.w	r2, r2, r3, lsl #15
 800b5a6:	4281      	cmp	r1, r0
 800b5a8:	b292      	uxth	r2, r2
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 800b5aa:	eb02 0353 	add.w	r3, r2, r3, lsr #1
 800b5ae:	b29b      	uxth	r3, r3
	for (i = sum = 0; i < szblk; i++) {
 800b5b0:	d8e4      	bhi.n	800b57c <dir_read.constprop.0+0x4c4>
		if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
 800b5b2:	8872      	ldrh	r2, [r6, #2]
 800b5b4:	429a      	cmp	r2, r3
 800b5b6:	f47f aecd 	bne.w	800b354 <dir_read.constprop.0+0x29c>
						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 800b5ba:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800b5be:	791b      	ldrb	r3, [r3, #4]
 800b5c0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b5c4:	71a3      	strb	r3, [r4, #6]
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800b5c6:	e5d0      	b.n	800b16a <dir_read.constprop.0+0xb2>
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800b5c8:	f1b9 0f00 	cmp.w	r9, #0
 800b5cc:	d148      	bne.n	800b660 <dir_read.constprop.0+0x5a8>
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800b5ce:	780a      	ldrb	r2, [r1, #0]
 800b5d0:	01d3      	lsls	r3, r2, #7
 800b5d2:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 800b5d6:	784a      	ldrb	r2, [r1, #1]
 800b5d8:	441a      	add	r2, r3
 800b5da:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b5de:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b5e2:	788a      	ldrb	r2, [r1, #2]
 800b5e4:	fa52 f283 	uxtab	r2, r2, r3
 800b5e8:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b5ec:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b5f0:	78ca      	ldrb	r2, [r1, #3]
 800b5f2:	fa52 f283 	uxtab	r2, r2, r3
 800b5f6:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b5fa:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b5fe:	790a      	ldrb	r2, [r1, #4]
 800b600:	fa52 f283 	uxtab	r2, r2, r3
 800b604:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b608:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b60c:	794a      	ldrb	r2, [r1, #5]
 800b60e:	fa52 f283 	uxtab	r2, r2, r3
 800b612:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b616:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b61a:	798a      	ldrb	r2, [r1, #6]
 800b61c:	fa52 f283 	uxtab	r2, r2, r3
 800b620:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b624:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b628:	79ca      	ldrb	r2, [r1, #7]
 800b62a:	fa52 f283 	uxtab	r2, r2, r3
 800b62e:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b632:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b636:	7a0a      	ldrb	r2, [r1, #8]
 800b638:	fa52 f283 	uxtab	r2, r2, r3
 800b63c:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b640:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b644:	7a4a      	ldrb	r2, [r1, #9]
 800b646:	7a89      	ldrb	r1, [r1, #10]
 800b648:	fa52 f283 	uxtab	r2, r2, r3
 800b64c:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800b650:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800b654:	fa51 f383 	uxtab	r3, r1, r3
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800b658:	b2db      	uxtb	r3, r3
 800b65a:	455b      	cmp	r3, fp
 800b65c:	f43f ad7d 	beq.w	800b15a <dir_read.constprop.0+0xa2>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800b660:	f04f 33ff 	mov.w	r3, #4294967295
 800b664:	2500      	movs	r5, #0
 800b666:	64e3      	str	r3, [r4, #76]	; 0x4c
 800b668:	e57f      	b.n	800b16a <dir_read.constprop.0+0xb2>
			fs->winsect = sector;
 800b66a:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800b66e:	2501      	movs	r5, #1
			fs->winsect = sector;
 800b670:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (res != FR_OK) return res;
 800b672:	e578      	b.n	800b166 <dir_read.constprop.0+0xae>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800b674:	4691      	mov	r9, r2
 800b676:	e553      	b.n	800b120 <dir_read.constprop.0+0x68>
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800b678:	1af9      	subs	r1, r7, r3
 800b67a:	1c5a      	adds	r2, r3, #1
 800b67c:	2902      	cmp	r1, #2
 800b67e:	d918      	bls.n	800b6b2 <dir_read.constprop.0+0x5fa>
			*d++ = *s++;
 800b680:	681a      	ldr	r2, [r3, #0]
 800b682:	f8c7 2001 	str.w	r2, [r7, #1]
 800b686:	685a      	ldr	r2, [r3, #4]
 800b688:	f8c7 2005 	str.w	r2, [r7, #5]
 800b68c:	689a      	ldr	r2, [r3, #8]
 800b68e:	f8c7 2009 	str.w	r2, [r7, #9]
 800b692:	68da      	ldr	r2, [r3, #12]
 800b694:	f8c7 200d 	str.w	r2, [r7, #13]
 800b698:	691a      	ldr	r2, [r3, #16]
 800b69a:	f8c7 2011 	str.w	r2, [r7, #17]
 800b69e:	695a      	ldr	r2, [r3, #20]
 800b6a0:	f8c7 2015 	str.w	r2, [r7, #21]
 800b6a4:	699a      	ldr	r2, [r3, #24]
 800b6a6:	f8c7 2019 	str.w	r2, [r7, #25]
 800b6aa:	69db      	ldr	r3, [r3, #28]
 800b6ac:	f8c7 301d 	str.w	r3, [r7, #29]
		} while (--cnt);
 800b6b0:	e756      	b.n	800b560 <dir_read.constprop.0+0x4a8>
 800b6b2:	3320      	adds	r3, #32
		if (i < MAXDIRB(_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
 800b6b4:	4639      	mov	r1, r7
			*d++ = *s++;
 800b6b6:	f812 0c01 	ldrb.w	r0, [r2, #-1]
		} while (--cnt);
 800b6ba:	429a      	cmp	r2, r3
 800b6bc:	f102 0201 	add.w	r2, r2, #1
			*d++ = *s++;
 800b6c0:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 800b6c4:	d1f7      	bne.n	800b6b6 <dir_read.constprop.0+0x5fe>
 800b6c6:	e74b      	b.n	800b560 <dir_read.constprop.0+0x4a8>
 800b6c8:	3320      	adds	r3, #32
 800b6ca:	f106 011f 	add.w	r1, r6, #31
			*d++ = *s++;
 800b6ce:	f812 0c01 	ldrb.w	r0, [r2, #-1]
		} while (--cnt);
 800b6d2:	4293      	cmp	r3, r2
 800b6d4:	f102 0201 	add.w	r2, r2, #1
			*d++ = *s++;
 800b6d8:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 800b6dc:	d1f7      	bne.n	800b6ce <dir_read.constprop.0+0x616>
 800b6de:	e69f      	b.n	800b420 <dir_read.constprop.0+0x368>
 800b6e0:	88888889 	.word	0x88888889

0800b6e4 <dir_sdi.constprop.0>:
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 800b6e4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dp->dptr = ofs;				/* Set current offset */
 800b6e8:	2300      	movs	r3, #0
	FATFS *fs = dp->obj.fs;
 800b6ea:	6807      	ldr	r7, [r0, #0]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800b6ec:	6884      	ldr	r4, [r0, #8]
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 800b6ee:	4605      	mov	r5, r0
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800b6f0:	783a      	ldrb	r2, [r7, #0]
	dp->dptr = ofs;				/* Set current offset */
 800b6f2:	6303      	str	r3, [r0, #48]	; 0x30
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800b6f4:	2c00      	cmp	r4, #0
 800b6f6:	d136      	bne.n	800b766 <dir_sdi.constprop.0+0x82>
 800b6f8:	2a02      	cmp	r2, #2
 800b6fa:	d82f      	bhi.n	800b75c <dir_sdi.constprop.0+0x78>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 800b6fc:	893b      	ldrh	r3, [r7, #8]
 800b6fe:	b343      	cbz	r3, 800b752 <dir_sdi.constprop.0+0x6e>
		dp->sect = fs->dirbase;
 800b700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b702:	63ab      	str	r3, [r5, #56]	; 0x38
	dp->clust = clst;					/* Current cluster# */
 800b704:	636c      	str	r4, [r5, #52]	; 0x34
	if (!dp->sect) return FR_INT_ERR;
 800b706:	b323      	cbz	r3, 800b752 <dir_sdi.constprop.0+0x6e>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800b708:	3730      	adds	r7, #48	; 0x30
	return FR_OK;
 800b70a:	f04f 0800 	mov.w	r8, #0
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800b70e:	63ef      	str	r7, [r5, #60]	; 0x3c
}
 800b710:	4640      	mov	r0, r8
 800b712:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800b716:	6a32      	ldr	r2, [r6, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b718:	f106 0930 	add.w	r9, r6, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b71c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800b71e:	eb02 18d4 	add.w	r8, r2, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b722:	4598      	cmp	r8, r3
 800b724:	d009      	beq.n	800b73a <dir_sdi.constprop.0+0x56>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b726:	2301      	movs	r3, #1
 800b728:	4642      	mov	r2, r8
 800b72a:	7870      	ldrb	r0, [r6, #1]
 800b72c:	4649      	mov	r1, r9
 800b72e:	f7ff f857 	bl	800a7e0 <disk_read>
 800b732:	2800      	cmp	r0, #0
 800b734:	d16e      	bne.n	800b814 <dir_sdi.constprop.0+0x130>
			fs->winsect = sector;
 800b736:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800b73a:	00a4      	lsls	r4, r4, #2
 800b73c:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800b740:	f859 4004 	ldr.w	r4, [r9, r4]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800b744:	f024 4470 	bic.w	r4, r4, #4026531840	; 0xf0000000
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800b748:	2c01      	cmp	r4, #1
 800b74a:	d902      	bls.n	800b752 <dir_sdi.constprop.0+0x6e>
 800b74c:	697b      	ldr	r3, [r7, #20]
 800b74e:	42a3      	cmp	r3, r4
 800b750:	d80d      	bhi.n	800b76e <dir_sdi.constprop.0+0x8a>
		switch (fs->fs_type) {
 800b752:	f04f 0802 	mov.w	r8, #2
}
 800b756:	4640      	mov	r0, r8
 800b758:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		clst = fs->dirbase;
 800b75c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 800b75e:	71c4      	strb	r4, [r0, #7]
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800b760:	2b00      	cmp	r3, #0
 800b762:	d0cb      	beq.n	800b6fc <dir_sdi.constprop.0+0x18>
 800b764:	461c      	mov	r4, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800b766:	897a      	ldrh	r2, [r7, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 800b768:	2a00      	cmp	r2, #0
 800b76a:	f040 809d 	bne.w	800b8a8 <dir_sdi.constprop.0+0x1c4>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800b76e:	2c01      	cmp	r4, #1
 800b770:	d9ef      	bls.n	800b752 <dir_sdi.constprop.0+0x6e>
	FATFS *fs = obj->fs;
 800b772:	682e      	ldr	r6, [r5, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800b774:	6973      	ldr	r3, [r6, #20]
 800b776:	42a3      	cmp	r3, r4
 800b778:	d9eb      	bls.n	800b752 <dir_sdi.constprop.0+0x6e>
		switch (fs->fs_type) {
 800b77a:	f896 8000 	ldrb.w	r8, [r6]
 800b77e:	f108 32ff 	add.w	r2, r8, #4294967295
 800b782:	2a03      	cmp	r2, #3
 800b784:	d8e5      	bhi.n	800b752 <dir_sdi.constprop.0+0x6e>
 800b786:	a101      	add	r1, pc, #4	; (adr r1, 800b78c <dir_sdi.constprop.0+0xa8>)
 800b788:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 800b78c:	0800b821 	.word	0x0800b821
 800b790:	0800b7f5 	.word	0x0800b7f5
 800b794:	0800b717 	.word	0x0800b717
 800b798:	0800b79d 	.word	0x0800b79d
			if (obj->objsize) {
 800b79c:	e9d5 2104 	ldrd	r2, r1, [r5, #16]
 800b7a0:	ea52 0001 	orrs.w	r0, r2, r1
 800b7a4:	d0d5      	beq.n	800b752 <dir_sdi.constprop.0+0x6e>
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800b7a6:	68a8      	ldr	r0, [r5, #8]
 800b7a8:	eba4 0c00 	sub.w	ip, r4, r0
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800b7ac:	79e8      	ldrb	r0, [r5, #7]
 800b7ae:	2802      	cmp	r0, #2
 800b7b0:	f000 808f 	beq.w	800b8d2 <dir_sdi.constprop.0+0x1ee>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800b7b4:	2803      	cmp	r0, #3
 800b7b6:	f000 8081 	beq.w	800b8bc <dir_sdi.constprop.0+0x1d8>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 800b7ba:	69ea      	ldr	r2, [r5, #28]
 800b7bc:	2a00      	cmp	r2, #0
 800b7be:	f040 8095 	bne.w	800b8ec <dir_sdi.constprop.0+0x208>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800b7c2:	6a33      	ldr	r3, [r6, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b7c4:	f106 0930 	add.w	r9, r6, #48	; 0x30
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800b7c8:	eb03 18d4 	add.w	r8, r3, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b7cc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b7ce:	4598      	cmp	r8, r3
 800b7d0:	d008      	beq.n	800b7e4 <dir_sdi.constprop.0+0x100>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b7d2:	2301      	movs	r3, #1
 800b7d4:	4642      	mov	r2, r8
 800b7d6:	7870      	ldrb	r0, [r6, #1]
 800b7d8:	4649      	mov	r1, r9
 800b7da:	f7ff f801 	bl	800a7e0 <disk_read>
 800b7de:	b9c8      	cbnz	r0, 800b814 <dir_sdi.constprop.0+0x130>
			fs->winsect = sector;
 800b7e0:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800b7e4:	00a3      	lsls	r3, r4, #2
 800b7e6:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800b7ea:	f859 4003 	ldr.w	r4, [r9, r3]
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800b7ee:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 800b7f2:	e7a9      	b.n	800b748 <dir_sdi.constprop.0+0x64>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800b7f4:	6a32      	ldr	r2, [r6, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b7f6:	f106 0930 	add.w	r9, r6, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b7fa:	6af3      	ldr	r3, [r6, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800b7fc:	eb02 2814 	add.w	r8, r2, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b800:	4598      	cmp	r8, r3
 800b802:	d04b      	beq.n	800b89c <dir_sdi.constprop.0+0x1b8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b804:	2301      	movs	r3, #1
 800b806:	4642      	mov	r2, r8
 800b808:	7870      	ldrb	r0, [r6, #1]
 800b80a:	4649      	mov	r1, r9
 800b80c:	f7fe ffe8 	bl	800a7e0 <disk_read>
 800b810:	2800      	cmp	r0, #0
 800b812:	d041      	beq.n	800b898 <dir_sdi.constprop.0+0x1b4>
			fs->winsect = sector;
 800b814:	f04f 33ff 	mov.w	r3, #4294967295
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800b818:	f04f 0801 	mov.w	r8, #1
			fs->winsect = sector;
 800b81c:	62f3      	str	r3, [r6, #44]	; 0x2c
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800b81e:	e777      	b.n	800b710 <dir_sdi.constprop.0+0x2c>
			bc = (UINT)clst; bc += bc / 2;
 800b820:	eb04 0954 	add.w	r9, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800b824:	6a31      	ldr	r1, [r6, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b826:	6af3      	ldr	r3, [r6, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800b828:	eb01 2a59 	add.w	sl, r1, r9, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b82c:	459a      	cmp	sl, r3
 800b82e:	d00f      	beq.n	800b850 <dir_sdi.constprop.0+0x16c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b830:	2301      	movs	r3, #1
 800b832:	4652      	mov	r2, sl
 800b834:	f106 0130 	add.w	r1, r6, #48	; 0x30
 800b838:	7870      	ldrb	r0, [r6, #1]
 800b83a:	f7fe ffd1 	bl	800a7e0 <disk_read>
 800b83e:	b118      	cbz	r0, 800b848 <dir_sdi.constprop.0+0x164>
			fs->winsect = sector;
 800b840:	f04f 33ff 	mov.w	r3, #4294967295
 800b844:	62f3      	str	r3, [r6, #44]	; 0x2c
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800b846:	e763      	b.n	800b710 <dir_sdi.constprop.0+0x2c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800b848:	4653      	mov	r3, sl
 800b84a:	6a31      	ldr	r1, [r6, #32]
			fs->winsect = sector;
 800b84c:	f8c6 a02c 	str.w	sl, [r6, #44]	; 0x2c
			wc = fs->win[bc++ % SS(fs)];
 800b850:	f109 0a01 	add.w	sl, r9, #1
 800b854:	f3c9 0908 	ubfx	r9, r9, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800b858:	eb01 2b5a 	add.w	fp, r1, sl, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 800b85c:	44b1      	add	r9, r6
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b85e:	459b      	cmp	fp, r3
			wc = fs->win[bc++ % SS(fs)];
 800b860:	f899 9030 	ldrb.w	r9, [r9, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800b864:	d00a      	beq.n	800b87c <dir_sdi.constprop.0+0x198>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800b866:	2301      	movs	r3, #1
 800b868:	465a      	mov	r2, fp
 800b86a:	f106 0130 	add.w	r1, r6, #48	; 0x30
 800b86e:	7870      	ldrb	r0, [r6, #1]
 800b870:	f7fe ffb6 	bl	800a7e0 <disk_read>
 800b874:	2800      	cmp	r0, #0
 800b876:	d1e3      	bne.n	800b840 <dir_sdi.constprop.0+0x15c>
			fs->winsect = sector;
 800b878:	f8c6 b02c 	str.w	fp, [r6, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 800b87c:	f3ca 0a08 	ubfx	sl, sl, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800b880:	07e2      	lsls	r2, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800b882:	4456      	add	r6, sl
 800b884:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
 800b888:	ea49 2903 	orr.w	r9, r9, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800b88c:	bf4c      	ite	mi
 800b88e:	ea4f 1419 	movmi.w	r4, r9, lsr #4
 800b892:	f3c9 040b 	ubfxpl	r4, r9, #0, #12
 800b896:	e757      	b.n	800b748 <dir_sdi.constprop.0+0x64>
			fs->winsect = sector;
 800b898:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800b89c:	0064      	lsls	r4, r4, #1
 800b89e:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 800b8a2:	f839 4004 	ldrh.w	r4, [r9, r4]
			break;
 800b8a6:	e74f      	b.n	800b748 <dir_sdi.constprop.0+0x64>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b8a8:	6979      	ldr	r1, [r7, #20]
	clst -= 2;
 800b8aa:	1ea0      	subs	r0, r4, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800b8ac:	3902      	subs	r1, #2
 800b8ae:	4288      	cmp	r0, r1
 800b8b0:	d223      	bcs.n	800b8fa <dir_sdi.constprop.0+0x216>
	return clst * fs->csize + fs->database;
 800b8b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b8b4:	fb00 3302 	mla	r3, r0, r2, r3
		dp->sect = clust2sect(fs, clst);
 800b8b8:	63ab      	str	r3, [r5, #56]	; 0x38
 800b8ba:	e723      	b.n	800b704 <dir_sdi.constprop.0+0x20>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800b8bc:	69aa      	ldr	r2, [r5, #24]
 800b8be:	4594      	cmp	ip, r2
 800b8c0:	f4bf af7b 	bcs.w	800b7ba <dir_sdi.constprop.0+0xd6>
					val = clst + 1; 	/* Generate the value */
 800b8c4:	3401      	adds	r4, #1
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800b8c6:	1c63      	adds	r3, r4, #1
 800b8c8:	f47f af3e 	bne.w	800b748 <dir_sdi.constprop.0+0x64>
 800b8cc:	f04f 0801 	mov.w	r8, #1
 800b8d0:	e71e      	b.n	800b710 <dir_sdi.constprop.0+0x2c>
				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 800b8d2:	3a01      	subs	r2, #1
 800b8d4:	f141 31ff 	adc.w	r1, r1, #4294967295
 800b8d8:	0a52      	lsrs	r2, r2, #9
 800b8da:	ea42 52c1 	orr.w	r2, r2, r1, lsl #23
 800b8de:	8971      	ldrh	r1, [r6, #10]
 800b8e0:	fbb2 f2f1 	udiv	r2, r2, r1
					if (cofs <= clen) {
 800b8e4:	4594      	cmp	ip, r2
 800b8e6:	f63f af34 	bhi.w	800b752 <dir_sdi.constprop.0+0x6e>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800b8ea:	d1eb      	bne.n	800b8c4 <dir_sdi.constprop.0+0x1e0>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800b8ec:	697a      	ldr	r2, [r7, #20]
 800b8ee:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800b8f2:	2a00      	cmp	r2, #0
 800b8f4:	f6ff af3f 	blt.w	800b776 <dir_sdi.constprop.0+0x92>
 800b8f8:	e72b      	b.n	800b752 <dir_sdi.constprop.0+0x6e>
		dp->sect = clust2sect(fs, clst);
 800b8fa:	2300      	movs	r3, #0
 800b8fc:	e9c5 430d 	strd	r4, r3, [r5, #52]	; 0x34
	if (!dp->sect) return FR_INT_ERR;
 800b900:	e727      	b.n	800b752 <dir_sdi.constprop.0+0x6e>
 800b902:	bf00      	nop

0800b904 <follow_path>:
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800b904:	680b      	ldr	r3, [r1, #0]
{
 800b906:	460a      	mov	r2, r1
 800b908:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800b90c:	2b2f      	cmp	r3, #47	; 0x2f
{
 800b90e:	460d      	mov	r5, r1
	FATFS *fs = obj->fs;
 800b910:	6801      	ldr	r1, [r0, #0]
{
 800b912:	4604      	mov	r4, r0
 800b914:	ed2d 8b02 	vpush	{d8}
 800b918:	b087      	sub	sp, #28
	FATFS *fs = obj->fs;
 800b91a:	9100      	str	r1, [sp, #0]
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800b91c:	d001      	beq.n	800b922 <follow_path+0x1e>
 800b91e:	2b5c      	cmp	r3, #92	; 0x5c
 800b920:	d106      	bne.n	800b930 <follow_path+0x2c>
 800b922:	f852 3f04 	ldr.w	r3, [r2, #4]!
 800b926:	2b2f      	cmp	r3, #47	; 0x2f
 800b928:	d0fb      	beq.n	800b922 <follow_path+0x1e>
 800b92a:	2b5c      	cmp	r3, #92	; 0x5c
 800b92c:	d0f9      	beq.n	800b922 <follow_path+0x1e>
 800b92e:	4615      	mov	r5, r2
		obj->sclust = 0;					/* Start from root directory */
 800b930:	2200      	movs	r2, #0
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800b932:	2b1f      	cmp	r3, #31
		obj->sclust = 0;					/* Start from root directory */
 800b934:	60a2      	str	r2, [r4, #8]
	obj->n_frag = 0;	/* Invalidate last fragment counter of the object */
 800b936:	61e2      	str	r2, [r4, #28]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800b938:	f240 82c1 	bls.w	800bebe <follow_path+0x5ba>
	FATFS *fs = obj->fs;
 800b93c:	9e00      	ldr	r6, [sp, #0]
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800b93e:	46ab      	mov	fp, r5
		if (w < ' ') break;				/* Break if end of the path name */
 800b940:	2b1f      	cmp	r3, #31
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 800b942:	68f7      	ldr	r7, [r6, #12]
		if (w < ' ') break;				/* Break if end of the path name */
 800b944:	d929      	bls.n	800b99a <follow_path+0x96>
 800b946:	f1a7 0e04 	sub.w	lr, r7, #4
 800b94a:	46dc      	mov	ip, fp
		w = p[si++];					/* Get a character */
 800b94c:	2001      	movs	r0, #1
 800b94e:	e008      	b.n	800b962 <follow_path+0x5e>
		lfn[di++] = w;					/* Store the Unicode character */
 800b950:	f84e 3f04 	str.w	r3, [lr, #4]!
		w = p[si++];					/* Get a character */
 800b954:	1c42      	adds	r2, r0, #1
 800b956:	f85c 3f04 	ldr.w	r3, [ip, #4]!
		if (w < ' ') break;				/* Break if end of the path name */
 800b95a:	2b1f      	cmp	r3, #31
 800b95c:	f240 81fd 	bls.w	800bd5a <follow_path+0x456>
		w = p[si++];					/* Get a character */
 800b960:	4610      	mov	r0, r2
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 800b962:	2b2f      	cmp	r3, #47	; 0x2f
 800b964:	f100 35ff 	add.w	r5, r0, #4294967295
 800b968:	d021      	beq.n	800b9ae <follow_path+0xaa>
 800b96a:	2b5c      	cmp	r3, #92	; 0x5c
 800b96c:	d01f      	beq.n	800b9ae <follow_path+0xaa>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 800b96e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 800b972:	d00a      	beq.n	800b98a <follow_path+0x86>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 800b974:	2b7f      	cmp	r3, #127	; 0x7f
 800b976:	d8eb      	bhi.n	800b950 <follow_path+0x4c>
	while (*str && *str != chr) str++;
 800b978:	2222      	movs	r2, #34	; 0x22
 800b97a:	49af      	ldr	r1, [pc, #700]	; (800bc38 <follow_path+0x334>)
 800b97c:	e003      	b.n	800b986 <follow_path+0x82>
 800b97e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800b982:	2a00      	cmp	r2, #0
 800b984:	d0e4      	beq.n	800b950 <follow_path+0x4c>
 800b986:	429a      	cmp	r2, r3
 800b988:	d1f9      	bne.n	800b97e <follow_path+0x7a>
 800b98a:	f04f 0b06 	mov.w	fp, #6
}
 800b98e:	4658      	mov	r0, fp
 800b990:	b007      	add	sp, #28
 800b992:	ecbd 8b02 	vpop	{d8}
 800b996:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 800b99a:	f04f 0b06 	mov.w	fp, #6
	lfn[di] = 0;						/* LFN is created */
 800b99e:	2300      	movs	r3, #0
}
 800b9a0:	4658      	mov	r0, fp
	lfn[di] = 0;						/* LFN is created */
 800b9a2:	603b      	str	r3, [r7, #0]
}
 800b9a4:	b007      	add	sp, #28
 800b9a6:	ecbd 8b02 	vpop	{d8}
 800b9aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800b9ae:	f85b 2020 	ldr.w	r2, [fp, r0, lsl #2]
 800b9b2:	0083      	lsls	r3, r0, #2
 800b9b4:	eb0b 0180 	add.w	r1, fp, r0, lsl #2
 800b9b8:	2a5c      	cmp	r2, #92	; 0x5c
 800b9ba:	d002      	beq.n	800b9c2 <follow_path+0xbe>
 800b9bc:	2a2f      	cmp	r2, #47	; 0x2f
 800b9be:	f040 82cc 	bne.w	800bf5a <follow_path+0x656>
 800b9c2:	3304      	adds	r3, #4
 800b9c4:	445b      	add	r3, fp
 800b9c6:	469b      	mov	fp, r3
 800b9c8:	f853 2b04 	ldr.w	r2, [r3], #4
 800b9cc:	2a2f      	cmp	r2, #47	; 0x2f
 800b9ce:	d0fa      	beq.n	800b9c6 <follow_path+0xc2>
 800b9d0:	2a5c      	cmp	r2, #92	; 0x5c
 800b9d2:	d0f8      	beq.n	800b9c6 <follow_path+0xc2>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800b9d4:	2d00      	cmp	r5, #0
 800b9d6:	d0e0      	beq.n	800b99a <follow_path+0x96>
 800b9d8:	f04f 0903 	mov.w	r9, #3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800b9dc:	f04f 0c00 	mov.w	ip, #0
 800b9e0:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 800b9e4:	e001      	b.n	800b9ea <follow_path+0xe6>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800b9e6:	3d01      	subs	r5, #1
 800b9e8:	d0d7      	beq.n	800b99a <follow_path+0x96>
		w = lfn[di - 1];
 800b9ea:	f852 3d04 	ldr.w	r3, [r2, #-4]!
		if (w != ' ' && w != '.') break;
 800b9ee:	2b20      	cmp	r3, #32
 800b9f0:	d0f9      	beq.n	800b9e6 <follow_path+0xe2>
 800b9f2:	2b2e      	cmp	r3, #46	; 0x2e
 800b9f4:	d0f7      	beq.n	800b9e6 <follow_path+0xe2>
		*d++ = (BYTE)val;
 800b9f6:	2320      	movs	r3, #32
 800b9f8:	f04f 3220 	mov.w	r2, #538976288	; 0x20202020
	lfn[di] = 0;						/* LFN is created */
 800b9fc:	2100      	movs	r1, #0
 800b9fe:	f847 1025 	str.w	r1, [r7, r5, lsl #2]
		*d++ = (BYTE)val;
 800ba02:	6422      	str	r2, [r4, #64]	; 0x40
 800ba04:	6462      	str	r2, [r4, #68]	; 0x44
 800ba06:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
 800ba0a:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
 800ba0e:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800ba12:	6838      	ldr	r0, [r7, #0]
 800ba14:	4298      	cmp	r0, r3
 800ba16:	d002      	beq.n	800ba1e <follow_path+0x11a>
 800ba18:	282e      	cmp	r0, #46	; 0x2e
 800ba1a:	f040 824c 	bne.w	800beb6 <follow_path+0x5b2>
 800ba1e:	463a      	mov	r2, r7
 800ba20:	2300      	movs	r3, #0
 800ba22:	f852 0f04 	ldr.w	r0, [r2, #4]!
 800ba26:	4698      	mov	r8, r3
 800ba28:	3301      	adds	r3, #1
 800ba2a:	2820      	cmp	r0, #32
 800ba2c:	d0f9      	beq.n	800ba22 <follow_path+0x11e>
 800ba2e:	282e      	cmp	r0, #46	; 0x2e
 800ba30:	d0f7      	beq.n	800ba22 <follow_path+0x11e>
		w = lfn[si++];					/* Get an LFN character */
 800ba32:	f108 0802 	add.w	r8, r8, #2
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800ba36:	eb07 0385 	add.w	r3, r7, r5, lsl #2
 800ba3a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800ba3e:	2a2e      	cmp	r2, #46	; 0x2e
 800ba40:	d001      	beq.n	800ba46 <follow_path+0x142>
 800ba42:	3d01      	subs	r5, #1
 800ba44:	d1f9      	bne.n	800ba3a <follow_path+0x136>
		if (!w) break;					/* Break on end of the LFN */
 800ba46:	2800      	cmp	r0, #0
 800ba48:	d03e      	beq.n	800bac8 <follow_path+0x1c4>
 800ba4a:	2300      	movs	r3, #0
 800ba4c:	f04f 0a08 	mov.w	sl, #8
 800ba50:	461e      	mov	r6, r3
 800ba52:	9301      	str	r3, [sp, #4]
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800ba54:	2820      	cmp	r0, #32
 800ba56:	d005      	beq.n	800ba64 <follow_path+0x160>
 800ba58:	282e      	cmp	r0, #46	; 0x2e
 800ba5a:	f040 80dd 	bne.w	800bc18 <follow_path+0x314>
 800ba5e:	4545      	cmp	r5, r8
 800ba60:	f000 80da 	beq.w	800bc18 <follow_path+0x314>
			cf |= NS_LOSS | NS_LFN; continue;
 800ba64:	f049 0903 	orr.w	r9, r9, #3
 800ba68:	fa5f f989 	uxtb.w	r9, r9
		w = lfn[si++];					/* Get an LFN character */
 800ba6c:	f857 0028 	ldr.w	r0, [r7, r8, lsl #2]
 800ba70:	f108 0801 	add.w	r8, r8, #1
		if (!w) break;					/* Break on end of the LFN */
 800ba74:	2800      	cmp	r0, #0
 800ba76:	d1ed      	bne.n	800ba54 <follow_path+0x150>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ba78:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800ba7c:	2be5      	cmp	r3, #229	; 0xe5
 800ba7e:	d102      	bne.n	800ba86 <follow_path+0x182>
 800ba80:	2305      	movs	r3, #5
 800ba82:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
	if (ni == 8) b <<= 2;
 800ba86:	f1ba 0f08 	cmp.w	sl, #8
 800ba8a:	f000 81aa 	beq.w	800bde2 <follow_path+0x4de>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800ba8e:	9a01      	ldr	r2, [sp, #4]
 800ba90:	f002 030c 	and.w	r3, r2, #12
 800ba94:	2b0c      	cmp	r3, #12
 800ba96:	f000 8168 	beq.w	800bd6a <follow_path+0x466>
 800ba9a:	f002 0a03 	and.w	sl, r2, #3
 800ba9e:	f1ba 0f03 	cmp.w	sl, #3
 800baa2:	f000 8162 	beq.w	800bd6a <follow_path+0x466>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800baa6:	f019 0f02 	tst.w	r9, #2
	FATFS *fs = dp->obj.fs;
 800baaa:	6826      	ldr	r6, [r4, #0]
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800baac:	d10c      	bne.n	800bac8 <follow_path+0x1c4>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800baae:	f1ba 0f01 	cmp.w	sl, #1
 800bab2:	d103      	bne.n	800babc <follow_path+0x1b8>
 800bab4:	f049 0910 	orr.w	r9, r9, #16
 800bab8:	fa5f f989 	uxtb.w	r9, r9
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 800babc:	2b04      	cmp	r3, #4
 800babe:	d103      	bne.n	800bac8 <follow_path+0x1c4>
 800bac0:	f049 0908 	orr.w	r9, r9, #8
 800bac4:	fa5f f989 	uxtb.w	r9, r9
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800bac8:	4620      	mov	r0, r4
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800baca:	f884 904b 	strb.w	r9, [r4, #75]	; 0x4b
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800bace:	f7ff fe09 	bl	800b6e4 <dir_sdi.constprop.0>
	if (res != FR_OK) return res;
 800bad2:	9001      	str	r0, [sp, #4]
 800bad4:	2800      	cmp	r0, #0
 800bad6:	f040 8156 	bne.w	800bd86 <follow_path+0x482>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800bada:	7833      	ldrb	r3, [r6, #0]
 800badc:	2b04      	cmp	r3, #4
 800bade:	f000 81a1 	beq.w	800be24 <follow_path+0x520>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800bae2:	f04f 0aff 	mov.w	sl, #255	; 0xff
 800bae6:	f04f 33ff 	mov.w	r3, #4294967295
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800baea:	f106 0830 	add.w	r8, r6, #48	; 0x30
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800baee:	4657      	mov	r7, sl
 800baf0:	64e3      	str	r3, [r4, #76]	; 0x4c
		res = move_window(fs, dp->sect);
 800baf2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if (sector != fs->winsect) {	/* Window offset changed? */
 800baf4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800baf6:	429d      	cmp	r5, r3
 800baf8:	d00d      	beq.n	800bb16 <follow_path+0x212>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800bafa:	2301      	movs	r3, #1
 800bafc:	462a      	mov	r2, r5
 800bafe:	4641      	mov	r1, r8
 800bb00:	7870      	ldrb	r0, [r6, #1]
 800bb02:	f7fe fe6d 	bl	800a7e0 <disk_read>
 800bb06:	b128      	cbz	r0, 800bb14 <follow_path+0x210>
			fs->winsect = sector;
 800bb08:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800bb0c:	f04f 0b01 	mov.w	fp, #1
			fs->winsect = sector;
 800bb10:	62f3      	str	r3, [r6, #44]	; 0x2c
				if (res == FR_NO_FILE) {	/* Object is not found */
 800bb12:	e73c      	b.n	800b98e <follow_path+0x8a>
			fs->winsect = sector;
 800bb14:	62f5      	str	r5, [r6, #44]	; 0x2c
		c = dp->dir[DIR_Name];
 800bb16:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 800bb18:	782b      	ldrb	r3, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800bb1a:	2b00      	cmp	r3, #0
 800bb1c:	f000 8245 	beq.w	800bfaa <follow_path+0x6a6>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800bb20:	7aea      	ldrb	r2, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800bb22:	2be5      	cmp	r3, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800bb24:	f002 013f 	and.w	r1, r2, #63	; 0x3f
 800bb28:	71a1      	strb	r1, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800bb2a:	d004      	beq.n	800bb36 <follow_path+0x232>
 800bb2c:	0710      	lsls	r0, r2, #28
 800bb2e:	d518      	bpl.n	800bb62 <follow_path+0x25e>
 800bb30:	290f      	cmp	r1, #15
 800bb32:	f000 8096 	beq.w	800bc62 <follow_path+0x35e>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800bb36:	f04f 33ff 	mov.w	r3, #4294967295
 800bb3a:	27ff      	movs	r7, #255	; 0xff
 800bb3c:	64e3      	str	r3, [r4, #76]	; 0x4c
		res = dir_next(dp, 0);	/* Next entry */
 800bb3e:	4620      	mov	r0, r4
 800bb40:	f7ff fa70 	bl	800b024 <dir_next.constprop.0>
	} while (res == FR_OK);
 800bb44:	2800      	cmp	r0, #0
 800bb46:	d0d4      	beq.n	800baf2 <follow_path+0x1ee>
 800bb48:	4683      	mov	fp, r0
				if (res == FR_NO_FILE) {	/* Object is not found */
 800bb4a:	f1bb 0f04 	cmp.w	fp, #4
			ns = dp->fn[NSFLAG];
 800bb4e:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
				if (res == FR_NO_FILE) {	/* Object is not found */
 800bb52:	f47f af1c 	bne.w	800b98e <follow_path+0x8a>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800bb56:	0759      	lsls	r1, r3, #29
 800bb58:	f100 821e 	bmi.w	800bf98 <follow_path+0x694>
 800bb5c:	f04f 0b05 	mov.w	fp, #5
 800bb60:	e715      	b.n	800b98e <follow_path+0x8a>
			if (a == AM_LFN) {			/* An LFN entry is found */
 800bb62:	290f      	cmp	r1, #15
 800bb64:	d07d      	beq.n	800bc62 <follow_path+0x35e>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800bb66:	2f00      	cmp	r7, #0
 800bb68:	f000 808e 	beq.w	800bc88 <follow_path+0x384>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800bb6c:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
 800bb70:	07d8      	lsls	r0, r3, #31
 800bb72:	d4e0      	bmi.n	800bb36 <follow_path+0x232>
	} while (--cnt && r == 0);
 800bb74:	7829      	ldrb	r1, [r5, #0]
 800bb76:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800bb7a:	4291      	cmp	r1, r2
 800bb7c:	d1db      	bne.n	800bb36 <follow_path+0x232>
 800bb7e:	7869      	ldrb	r1, [r5, #1]
 800bb80:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800bb84:	4291      	cmp	r1, r2
 800bb86:	d1d6      	bne.n	800bb36 <follow_path+0x232>
 800bb88:	78a9      	ldrb	r1, [r5, #2]
 800bb8a:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 800bb8e:	4291      	cmp	r1, r2
 800bb90:	d1d1      	bne.n	800bb36 <follow_path+0x232>
 800bb92:	78e9      	ldrb	r1, [r5, #3]
 800bb94:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800bb98:	4291      	cmp	r1, r2
 800bb9a:	d1cc      	bne.n	800bb36 <follow_path+0x232>
 800bb9c:	7929      	ldrb	r1, [r5, #4]
 800bb9e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 800bba2:	4291      	cmp	r1, r2
 800bba4:	d1c7      	bne.n	800bb36 <follow_path+0x232>
 800bba6:	7969      	ldrb	r1, [r5, #5]
 800bba8:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 800bbac:	4291      	cmp	r1, r2
 800bbae:	d1c2      	bne.n	800bb36 <follow_path+0x232>
 800bbb0:	79a9      	ldrb	r1, [r5, #6]
 800bbb2:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800bbb6:	4291      	cmp	r1, r2
 800bbb8:	d1bd      	bne.n	800bb36 <follow_path+0x232>
 800bbba:	79e9      	ldrb	r1, [r5, #7]
 800bbbc:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 800bbc0:	4291      	cmp	r1, r2
 800bbc2:	d1b8      	bne.n	800bb36 <follow_path+0x232>
 800bbc4:	7a29      	ldrb	r1, [r5, #8]
 800bbc6:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800bbca:	4291      	cmp	r1, r2
 800bbcc:	d1b3      	bne.n	800bb36 <follow_path+0x232>
 800bbce:	7a69      	ldrb	r1, [r5, #9]
 800bbd0:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
 800bbd4:	4291      	cmp	r1, r2
 800bbd6:	d1ae      	bne.n	800bb36 <follow_path+0x232>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800bbd8:	7aa9      	ldrb	r1, [r5, #10]
 800bbda:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
 800bbde:	4291      	cmp	r1, r2
 800bbe0:	d1a9      	bne.n	800bb36 <follow_path+0x232>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800bbe2:	075b      	lsls	r3, r3, #29
 800bbe4:	f100 809e 	bmi.w	800bd24 <follow_path+0x420>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 800bbe8:	79a3      	ldrb	r3, [r4, #6]
 800bbea:	06da      	lsls	r2, r3, #27
 800bbec:	d5b6      	bpl.n	800bb5c <follow_path+0x258>
			if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
 800bbee:	9b00      	ldr	r3, [sp, #0]
 800bbf0:	781a      	ldrb	r2, [r3, #0]
 800bbf2:	2a04      	cmp	r2, #4
 800bbf4:	f000 80c9 	beq.w	800bd8a <follow_path+0x486>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800bbf8:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800bbfa:	3330      	adds	r3, #48	; 0x30
	if (fs->fs_type == FS_FAT32) {
 800bbfc:	2a03      	cmp	r2, #3
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800bbfe:	f3c1 0108 	ubfx	r1, r1, #0, #9
 800bc02:	440b      	add	r3, r1
	cl = ld_word(dir + DIR_FstClusLO);
 800bc04:	8b59      	ldrh	r1, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800bc06:	d102      	bne.n	800bc0e <follow_path+0x30a>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800bc08:	8a9b      	ldrh	r3, [r3, #20]
 800bc0a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800bc0e:	60a1      	str	r1, [r4, #8]
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 800bc10:	6826      	ldr	r6, [r4, #0]
		w = p[si++];					/* Get a character */
 800bc12:	f8db 3000 	ldr.w	r3, [fp]
 800bc16:	e693      	b.n	800b940 <follow_path+0x3c>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 800bc18:	45b2      	cmp	sl, r6
 800bc1a:	f240 8086 	bls.w	800bd2a <follow_path+0x426>
 800bc1e:	eba5 0108 	sub.w	r1, r5, r8
 800bc22:	fab1 f181 	clz	r1, r1
 800bc26:	0949      	lsrs	r1, r1, #5
 800bc28:	2900      	cmp	r1, #0
 800bc2a:	d17e      	bne.n	800bd2a <follow_path+0x426>
		if (w >= 0x80) {				/* Non ASCII character */
 800bc2c:	287f      	cmp	r0, #127	; 0x7f
 800bc2e:	f200 80c4 	bhi.w	800bdba <follow_path+0x4b6>
	while (*str && *str != chr) str++;
 800bc32:	232b      	movs	r3, #43	; 0x2b
 800bc34:	4a01      	ldr	r2, [pc, #4]	; (800bc3c <follow_path+0x338>)
 800bc36:	e008      	b.n	800bc4a <follow_path+0x346>
 800bc38:	08021dfc 	.word	0x08021dfc
 800bc3c:	08021e08 	.word	0x08021e08
 800bc40:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	f000 80d8 	beq.w	800bdfa <follow_path+0x4f6>
 800bc4a:	4283      	cmp	r3, r0
 800bc4c:	d1f8      	bne.n	800bc40 <follow_path+0x33c>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800bc4e:	f049 0903 	orr.w	r9, r9, #3
 800bc52:	205f      	movs	r0, #95	; 0x5f
 800bc54:	fa5f f989 	uxtb.w	r9, r9
		dp->fn[i++] = (BYTE)w;
 800bc58:	19a3      	adds	r3, r4, r6
 800bc5a:	3601      	adds	r6, #1
 800bc5c:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40
 800bc60:	e704      	b.n	800ba6c <follow_path+0x168>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800bc62:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
 800bc66:	0651      	lsls	r1, r2, #25
 800bc68:	f53f af69 	bmi.w	800bb3e <follow_path+0x23a>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800bc6c:	065a      	lsls	r2, r3, #25
 800bc6e:	d571      	bpl.n	800bd54 <follow_path+0x450>
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800bc70:	f003 07bf 	and.w	r7, r3, #191	; 0xbf
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800bc74:	6b23      	ldr	r3, [r4, #48]	; 0x30
						sum = dp->dir[LDIR_Chksum];
 800bc76:	f895 a00d 	ldrb.w	sl, [r5, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800bc7a:	64e3      	str	r3, [r4, #76]	; 0x4c
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800bc7c:	7b6b      	ldrb	r3, [r5, #13]
 800bc7e:	4553      	cmp	r3, sl
 800bc80:	f000 8128 	beq.w	800bed4 <follow_path+0x5d0>
 800bc84:	27ff      	movs	r7, #255	; 0xff
 800bc86:	e75a      	b.n	800bb3e <follow_path+0x23a>
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800bc88:	782a      	ldrb	r2, [r5, #0]
 800bc8a:	01d3      	lsls	r3, r2, #7
 800bc8c:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 800bc90:	786a      	ldrb	r2, [r5, #1]
 800bc92:	441a      	add	r2, r3
 800bc94:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800bc98:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800bc9c:	78aa      	ldrb	r2, [r5, #2]
 800bc9e:	fa52 f383 	uxtab	r3, r2, r3
 800bca2:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800bca6:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800bcaa:	78eb      	ldrb	r3, [r5, #3]
 800bcac:	fa53 f382 	uxtab	r3, r3, r2
 800bcb0:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800bcb4:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800bcb8:	792b      	ldrb	r3, [r5, #4]
 800bcba:	fa53 f282 	uxtab	r2, r3, r2
 800bcbe:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800bcc2:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800bcc6:	796a      	ldrb	r2, [r5, #5]
 800bcc8:	fa52 f283 	uxtab	r2, r2, r3
 800bccc:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800bcd0:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800bcd4:	79aa      	ldrb	r2, [r5, #6]
 800bcd6:	fa52 f383 	uxtab	r3, r2, r3
 800bcda:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800bcde:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800bce2:	79eb      	ldrb	r3, [r5, #7]
 800bce4:	fa53 f382 	uxtab	r3, r3, r2
 800bce8:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800bcec:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800bcf0:	7a2b      	ldrb	r3, [r5, #8]
 800bcf2:	fa53 f282 	uxtab	r2, r3, r2
 800bcf6:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800bcfa:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800bcfe:	7a6a      	ldrb	r2, [r5, #9]
 800bd00:	fa52 f283 	uxtab	r2, r2, r3
 800bd04:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800bd08:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800bd0c:	7aaa      	ldrb	r2, [r5, #10]
 800bd0e:	fa52 f383 	uxtab	r3, r2, r3
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800bd12:	b2db      	uxtb	r3, r3
 800bd14:	4553      	cmp	r3, sl
 800bd16:	f47f af29 	bne.w	800bb6c <follow_path+0x268>
			ns = dp->fn[NSFLAG];
 800bd1a:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800bd1e:	075b      	lsls	r3, r3, #29
 800bd20:	f57f af62 	bpl.w	800bbe8 <follow_path+0x2e4>
 800bd24:	f8dd b004 	ldr.w	fp, [sp, #4]
 800bd28:	e631      	b.n	800b98e <follow_path+0x8a>
			if (ni == 11) {				/* Long extension */
 800bd2a:	f1ba 0f0b 	cmp.w	sl, #11
 800bd2e:	f000 8116 	beq.w	800bf5e <follow_path+0x65a>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800bd32:	4545      	cmp	r5, r8
 800bd34:	d005      	beq.n	800bd42 <follow_path+0x43e>
 800bd36:	f049 0903 	orr.w	r9, r9, #3
 800bd3a:	fa5f f989 	uxtb.w	r9, r9
			if (si > di) break;			/* No extension */
 800bd3e:	f4ff ae9b 	bcc.w	800ba78 <follow_path+0x174>
			b <<= 2; continue;
 800bd42:	9b01      	ldr	r3, [sp, #4]
 800bd44:	46a8      	mov	r8, r5
			si = di; i = 8; ni = 11;	/* Enter extension section */
 800bd46:	f04f 0a0b 	mov.w	sl, #11
 800bd4a:	2608      	movs	r6, #8
			b <<= 2; continue;
 800bd4c:	009b      	lsls	r3, r3, #2
 800bd4e:	b2db      	uxtb	r3, r3
 800bd50:	9301      	str	r3, [sp, #4]
 800bd52:	e68b      	b.n	800ba6c <follow_path+0x168>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800bd54:	42bb      	cmp	r3, r7
 800bd56:	d195      	bne.n	800bc84 <follow_path+0x380>
 800bd58:	e790      	b.n	800bc7c <follow_path+0x378>
	*path = &p[si];						/* Return pointer to the next segment */
 800bd5a:	eb0b 0b82 	add.w	fp, fp, r2, lsl #2
 800bd5e:	4605      	mov	r5, r0
 800bd60:	f04f 0907 	mov.w	r9, #7
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800bd64:	f04f 0c04 	mov.w	ip, #4
 800bd68:	e63a      	b.n	800b9e0 <follow_path+0xdc>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800bd6a:	f049 0902 	orr.w	r9, r9, #2
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800bd6e:	4620      	mov	r0, r4
	FATFS *fs = dp->obj.fs;
 800bd70:	6826      	ldr	r6, [r4, #0]
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800bd72:	fa5f f989 	uxtb.w	r9, r9
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800bd76:	f884 904b 	strb.w	r9, [r4, #75]	; 0x4b
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800bd7a:	f7ff fcb3 	bl	800b6e4 <dir_sdi.constprop.0>
	if (res != FR_OK) return res;
 800bd7e:	9001      	str	r0, [sp, #4]
 800bd80:	2800      	cmp	r0, #0
 800bd82:	f43f aeaa 	beq.w	800bada <follow_path+0x1d6>
 800bd86:	4683      	mov	fp, r0
 800bd88:	e6df      	b.n	800bb4a <follow_path+0x246>
 800bd8a:	461a      	mov	r2, r3
				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 800bd8c:	6923      	ldr	r3, [r4, #16]
 800bd8e:	79e5      	ldrb	r5, [r4, #7]
 800bd90:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
 800bd94:	6912      	ldr	r2, [r2, #16]
				obj->c_scl = obj->sclust;
 800bd96:	68a0      	ldr	r0, [r4, #8]
				obj->c_ofs = dp->blk_ofs;
 800bd98:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 800bd9a:	432b      	orrs	r3, r5
				obj->c_scl = obj->sclust;
 800bd9c:	6220      	str	r0, [r4, #32]
				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 800bd9e:	e9c4 3109 	strd	r3, r1, [r4, #36]	; 0x24
	rv = rv << 8 | ptr[0];
 800bda2:	6b53      	ldr	r3, [r2, #52]	; 0x34
				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
 800bda4:	60a3      	str	r3, [r4, #8]
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
 800bda6:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 800bdaa:	f003 0302 	and.w	r3, r3, #2
 800bdae:	71e3      	strb	r3, [r4, #7]
	rv = rv << 8 | ptr[0];
 800bdb0:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800bdb2:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 800bdb4:	e9c4 1304 	strd	r1, r3, [r4, #16]
 800bdb8:	e72a      	b.n	800bc10 <follow_path+0x30c>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 800bdba:	f000 fdeb 	bl	800c994 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800bdbe:	b920      	cbnz	r0, 800bdca <follow_path+0x4c6>
			cf |= NS_LFN;				/* Force create LFN entry */
 800bdc0:	f049 0902 	orr.w	r9, r9, #2
 800bdc4:	fa5f f989 	uxtb.w	r9, r9
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800bdc8:	e741      	b.n	800bc4e <follow_path+0x34a>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800bdca:	4b79      	ldr	r3, [pc, #484]	; (800bfb0 <follow_path+0x6ac>)
			cf |= NS_LFN;				/* Force create LFN entry */
 800bdcc:	f049 0902 	orr.w	r9, r9, #2
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800bdd0:	4418      	add	r0, r3
			cf |= NS_LFN;				/* Force create LFN entry */
 800bdd2:	fa5f f989 	uxtb.w	r9, r9
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800bdd6:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800bdda:	2800      	cmp	r0, #0
 800bddc:	f43f af37 	beq.w	800bc4e <follow_path+0x34a>
 800bde0:	e727      	b.n	800bc32 <follow_path+0x32e>
	if (ni == 8) b <<= 2;
 800bde2:	9b01      	ldr	r3, [sp, #4]
 800bde4:	009b      	lsls	r3, r3, #2
 800bde6:	f003 030c 	and.w	r3, r3, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800bdea:	2b0c      	cmp	r3, #12
 800bdec:	d0bd      	beq.n	800bd6a <follow_path+0x466>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800bdee:	f019 0f02 	tst.w	r9, #2
	FATFS *fs = dp->obj.fs;
 800bdf2:	6826      	ldr	r6, [r4, #0]
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800bdf4:	f43f ae62 	beq.w	800babc <follow_path+0x1b8>
 800bdf8:	e666      	b.n	800bac8 <follow_path+0x1c4>
				if (IsUpper(w)) {		/* ASCII large capital */
 800bdfa:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 800bdfe:	2b19      	cmp	r3, #25
 800be00:	d805      	bhi.n	800be0e <follow_path+0x50a>
					b |= 2;
 800be02:	9b01      	ldr	r3, [sp, #4]
		dp->fn[i++] = (BYTE)w;
 800be04:	b2c0      	uxtb	r0, r0
					b |= 2;
 800be06:	f043 0302 	orr.w	r3, r3, #2
 800be0a:	9301      	str	r3, [sp, #4]
 800be0c:	e724      	b.n	800bc58 <follow_path+0x354>
					if (IsLower(w)) {	/* ASCII small capital */
 800be0e:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 800be12:	2b19      	cmp	r3, #25
 800be14:	d804      	bhi.n	800be20 <follow_path+0x51c>
						b |= 1; w -= 0x20;
 800be16:	9b01      	ldr	r3, [sp, #4]
 800be18:	3820      	subs	r0, #32
 800be1a:	f043 0301 	orr.w	r3, r3, #1
 800be1e:	9301      	str	r3, [sp, #4]
		dp->fn[i++] = (BYTE)w;
 800be20:	b2c0      	uxtb	r0, r0
 800be22:	e719      	b.n	800bc58 <follow_path+0x354>
	while ((chr = *name++) != 0) {
 800be24:	68f5      	ldr	r5, [r6, #12]
	WORD sum = 0;
 800be26:	9f01      	ldr	r7, [sp, #4]
	while ((chr = *name++) != 0) {
 800be28:	f855 0b04 	ldr.w	r0, [r5], #4
 800be2c:	b188      	cbz	r0, 800be52 <follow_path+0x54e>
		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
 800be2e:	f000 fdcb 	bl	800c9c8 <ff_wtoupper>
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 800be32:	b2c2      	uxtb	r2, r0
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 800be34:	0a03      	lsrs	r3, r0, #8
	while ((chr = *name++) != 0) {
 800be36:	f855 0b04 	ldr.w	r0, [r5], #4
 800be3a:	eb02 0257 	add.w	r2, r2, r7, lsr #1
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 800be3e:	eb02 32c7 	add.w	r2, r2, r7, lsl #15
 800be42:	b292      	uxth	r2, r2
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 800be44:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800be48:	eb03 33c2 	add.w	r3, r3, r2, lsl #15
 800be4c:	b29f      	uxth	r7, r3
	while ((chr = *name++) != 0) {
 800be4e:	2800      	cmp	r0, #0
 800be50:	d1ed      	bne.n	800be2e <follow_path+0x52a>
		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
 800be52:	4620      	mov	r0, r4
 800be54:	f7ff f930 	bl	800b0b8 <dir_read.constprop.0>
 800be58:	2800      	cmp	r0, #0
 800be5a:	f47f ae75 	bne.w	800bb48 <follow_path+0x244>
			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 800be5e:	6933      	ldr	r3, [r6, #16]
 800be60:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 800be62:	42ba      	cmp	r2, r7
 800be64:	d1f5      	bne.n	800be52 <follow_path+0x54e>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800be66:	f893 9023 	ldrb.w	r9, [r3, #35]	; 0x23
 800be6a:	f1b9 0f00 	cmp.w	r9, #0
 800be6e:	f000 8091 	beq.w	800bf94 <follow_path+0x690>
 800be72:	4605      	mov	r5, r0
 800be74:	f04f 0840 	mov.w	r8, #64	; 0x40
 800be78:	e002      	b.n	800be80 <follow_path+0x57c>
 800be7a:	454d      	cmp	r5, r9
 800be7c:	d015      	beq.n	800beaa <follow_path+0x5a6>
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800be7e:	6933      	ldr	r3, [r6, #16]
				if ((di % SZDIRE) == 0) di += 2;
 800be80:	f018 0f1f 	tst.w	r8, #31
 800be84:	bf08      	it	eq
 800be86:	f108 0802 	addeq.w	r8, r8, #2
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800be8a:	f833 0008 	ldrh.w	r0, [r3, r8]
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800be8e:	f108 0802 	add.w	r8, r8, #2
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800be92:	f000 fd99 	bl	800c9c8 <ff_wtoupper>
 800be96:	68f3      	ldr	r3, [r6, #12]
 800be98:	4682      	mov	sl, r0
 800be9a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800be9e:	3501      	adds	r5, #1
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800bea0:	f000 fd92 	bl	800c9c8 <ff_wtoupper>
 800bea4:	4582      	cmp	sl, r0
 800bea6:	d0e8      	beq.n	800be7a <follow_path+0x576>
 800bea8:	e7d3      	b.n	800be52 <follow_path+0x54e>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 800beaa:	00ad      	lsls	r5, r5, #2
 800beac:	68f3      	ldr	r3, [r6, #12]
 800beae:	595b      	ldr	r3, [r3, r5]
 800beb0:	2b00      	cmp	r3, #0
 800beb2:	d1ce      	bne.n	800be52 <follow_path+0x54e>
 800beb4:	e731      	b.n	800bd1a <follow_path+0x416>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800beb6:	46e1      	mov	r9, ip
 800beb8:	f04f 0801 	mov.w	r8, #1
 800bebc:	e5bb      	b.n	800ba36 <follow_path+0x132>
		dp->fn[NSFLAG] = NS_NONAME;
 800bebe:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 800bec0:	4620      	mov	r0, r4
		dp->fn[NSFLAG] = NS_NONAME;
 800bec2:	f884 304b 	strb.w	r3, [r4, #75]	; 0x4b
}
 800bec6:	b007      	add	sp, #28
 800bec8:	ecbd 8b02 	vpop	{d8}
 800becc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 800bed0:	f7ff bc08 	b.w	800b6e4 <dir_sdi.constprop.0>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 800bed4:	8b6b      	ldrh	r3, [r5, #26]
 800bed6:	2b00      	cmp	r3, #0
 800bed8:	f47f aed4 	bne.w	800bc84 <follow_path+0x380>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800bedc:	f895 9000 	ldrb.w	r9, [r5]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800bee0:	2101      	movs	r1, #1
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800bee2:	68f2      	ldr	r2, [r6, #12]
 800bee4:	ee08 8a10 	vmov	s16, r8
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800bee8:	f009 093f 	and.w	r9, r9, #63	; 0x3f
 800beec:	4b31      	ldr	r3, [pc, #196]	; (800bfb4 <follow_path+0x6b0>)
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800beee:	9202      	str	r2, [sp, #8]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800bef0:	4608      	mov	r0, r1
 800bef2:	f109 39ff 	add.w	r9, r9, #4294967295
 800bef6:	f8cd b010 	str.w	fp, [sp, #16]
 800befa:	9603      	str	r6, [sp, #12]
 800befc:	46a3      	mov	fp, r4
 800befe:	eb09 0249 	add.w	r2, r9, r9, lsl #1
 800bf02:	461c      	mov	r4, r3
 800bf04:	9705      	str	r7, [sp, #20]
 800bf06:	eb09 0982 	add.w	r9, r9, r2, lsl #2
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800bf0a:	e012      	b.n	800bf32 <follow_path+0x62e>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800bf0c:	f1b9 0ffe 	cmp.w	r9, #254	; 0xfe
 800bf10:	4640      	mov	r0, r8
 800bf12:	d81a      	bhi.n	800bf4a <follow_path+0x646>
 800bf14:	f000 fd58 	bl	800c9c8 <ff_wtoupper>
 800bf18:	9b02      	ldr	r3, [sp, #8]
 800bf1a:	4606      	mov	r6, r0
 800bf1c:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
 800bf20:	46b9      	mov	r9, r7
 800bf22:	f000 fd51 	bl	800c9c8 <ff_wtoupper>
 800bf26:	4286      	cmp	r6, r0
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800bf28:	4640      	mov	r0, r8
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800bf2a:	d10e      	bne.n	800bf4a <follow_path+0x646>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800bf2c:	4b22      	ldr	r3, [pc, #136]	; (800bfb8 <follow_path+0x6b4>)
 800bf2e:	42a3      	cmp	r3, r4
 800bf30:	d022      	beq.n	800bf78 <follow_path+0x674>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800bf32:	f814 3b01 	ldrb.w	r3, [r4], #1
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800bf36:	f109 0701 	add.w	r7, r9, #1
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800bf3a:	f835 8003 	ldrh.w	r8, [r5, r3]
		if (wc) {
 800bf3e:	2800      	cmp	r0, #0
 800bf40:	d1e4      	bne.n	800bf0c <follow_path+0x608>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800bf42:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800bf46:	4598      	cmp	r8, r3
 800bf48:	d0f0      	beq.n	800bf2c <follow_path+0x628>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800bf4a:	465c      	mov	r4, fp
 800bf4c:	9e03      	ldr	r6, [sp, #12]
 800bf4e:	f8dd b010 	ldr.w	fp, [sp, #16]
 800bf52:	ee18 8a10 	vmov	r8, s16
 800bf56:	27ff      	movs	r7, #255	; 0xff
 800bf58:	e5f1      	b.n	800bb3e <follow_path+0x23a>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800bf5a:	468b      	mov	fp, r1
 800bf5c:	e53a      	b.n	800b9d4 <follow_path+0xd0>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800bf5e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
				cf |= NS_LOSS | NS_LFN; break;
 800bf62:	f049 0903 	orr.w	r9, r9, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800bf66:	2be5      	cmp	r3, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN; break;
 800bf68:	fa5f f989 	uxtb.w	r9, r9
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800bf6c:	f47f ad8f 	bne.w	800ba8e <follow_path+0x18a>
 800bf70:	2305      	movs	r3, #5
 800bf72:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
	if (ni == 8) b <<= 2;
 800bf76:	e58a      	b.n	800ba8e <follow_path+0x18a>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800bf78:	782b      	ldrb	r3, [r5, #0]
 800bf7a:	465c      	mov	r4, fp
 800bf7c:	9e03      	ldr	r6, [sp, #12]
 800bf7e:	ee18 8a10 	vmov	r8, s16
 800bf82:	065d      	lsls	r5, r3, #25
 800bf84:	9f05      	ldr	r7, [sp, #20]
 800bf86:	f8dd b010 	ldr.w	fp, [sp, #16]
 800bf8a:	d500      	bpl.n	800bf8e <follow_path+0x68a>
 800bf8c:	b938      	cbnz	r0, 800bf9e <follow_path+0x69a>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800bf8e:	3f01      	subs	r7, #1
 800bf90:	b2ff      	uxtb	r7, r7
 800bf92:	e5d4      	b.n	800bb3e <follow_path+0x23a>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800bf94:	464d      	mov	r5, r9
 800bf96:	e789      	b.n	800beac <follow_path+0x5a8>
			res = dir_find(dp);				/* Find an object with the segment name */
 800bf98:	f04f 0b04 	mov.w	fp, #4
 800bf9c:	e4f7      	b.n	800b98e <follow_path+0x8a>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800bf9e:	9b02      	ldr	r3, [sp, #8]
 800bfa0:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
 800bfa4:	2b00      	cmp	r3, #0
 800bfa6:	d0f2      	beq.n	800bf8e <follow_path+0x68a>
 800bfa8:	e66c      	b.n	800bc84 <follow_path+0x380>
			ns = dp->fn[NSFLAG];
 800bfaa:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
				if (res == FR_NO_FILE) {	/* Object is not found */
 800bfae:	e5d2      	b.n	800bb56 <follow_path+0x252>
 800bfb0:	08021e10 	.word	0x08021e10
 800bfb4:	08021e90 	.word	0x08021e90
 800bfb8:	08021e9d 	.word	0x08021e9d

0800bfbc <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800bfbc:	b510      	push	{r4, lr}
 800bfbe:	b082      	sub	sp, #8
 800bfc0:	e9cd 1000 	strd	r1, r0, [sp]
	if (*path) {	/* If the pointer is not a null */
 800bfc4:	b189      	cbz	r1, 800bfea <f_mount+0x2e>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800bfc6:	680c      	ldr	r4, [r1, #0]
 800bfc8:	2c1f      	cmp	r4, #31
 800bfca:	d911      	bls.n	800bff0 <f_mount+0x34>
 800bfcc:	2c3a      	cmp	r4, #58	; 0x3a
 800bfce:	d00f      	beq.n	800bff0 <f_mount+0x34>
 800bfd0:	4608      	mov	r0, r1
 800bfd2:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800bfd6:	2b1f      	cmp	r3, #31
 800bfd8:	d90c      	bls.n	800bff4 <f_mount+0x38>
 800bfda:	2b3a      	cmp	r3, #58	; 0x3a
 800bfdc:	d1f9      	bne.n	800bfd2 <f_mount+0x16>
			i = *tp++ - '0';
 800bfde:	3104      	adds	r1, #4
 800bfe0:	3c30      	subs	r4, #48	; 0x30
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800bfe2:	4288      	cmp	r0, r1
 800bfe4:	d101      	bne.n	800bfea <f_mount+0x2e>
 800bfe6:	2c01      	cmp	r4, #1
 800bfe8:	d907      	bls.n	800bffa <f_mount+0x3e>
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 800bfea:	200b      	movs	r0, #11

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800bfec:	b002      	add	sp, #8
 800bfee:	bd10      	pop	{r4, pc}
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800bff0:	4623      	mov	r3, r4
 800bff2:	4608      	mov	r0, r1
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 800bff4:	2b3a      	cmp	r3, #58	; 0x3a
 800bff6:	d0f2      	beq.n	800bfde <f_mount+0x22>
		vol = 0;		/* Drive 0 */
 800bff8:	2400      	movs	r4, #0
	cfs = FatFs[vol];					/* Pointer to fs object */
 800bffa:	490c      	ldr	r1, [pc, #48]	; (800c02c <f_mount+0x70>)
 800bffc:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
	if (cfs) {
 800c000:	b10b      	cbz	r3, 800c006 <f_mount+0x4a>
		cfs->fs_type = 0;				/* Clear old fs object */
 800c002:	2000      	movs	r0, #0
 800c004:	7018      	strb	r0, [r3, #0]
	if (fs) {
 800c006:	9b01      	ldr	r3, [sp, #4]
 800c008:	b15b      	cbz	r3, 800c022 <f_mount+0x66>
		fs->fs_type = 0;				/* Clear new fs object */
 800c00a:	2000      	movs	r0, #0
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800c00c:	2a01      	cmp	r2, #1
	FatFs[vol] = fs;					/* Register new fs object */
 800c00e:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
		fs->fs_type = 0;				/* Clear new fs object */
 800c012:	7018      	strb	r0, [r3, #0]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800c014:	d1ea      	bne.n	800bfec <f_mount+0x30>
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800c016:	a901      	add	r1, sp, #4
 800c018:	4668      	mov	r0, sp
 800c01a:	f7fe fd25 	bl	800aa68 <find_volume.constprop.0>
}
 800c01e:	b002      	add	sp, #8
 800c020:	bd10      	pop	{r4, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800c022:	4618      	mov	r0, r3
	FatFs[vol] = fs;					/* Register new fs object */
 800c024:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
}
 800c028:	b002      	add	sp, #8
 800c02a:	bd10      	pop	{r4, pc}
 800c02c:	20000390 	.word	0x20000390

0800c030 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800c030:	b570      	push	{r4, r5, r6, lr}
 800c032:	b098      	sub	sp, #96	; 0x60
 800c034:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800c036:	2800      	cmp	r0, #0
 800c038:	d039      	beq.n	800c0ae <f_open+0x7e>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800c03a:	4604      	mov	r4, r0
	res = find_volume(&path, &fs, mode);
 800c03c:	a903      	add	r1, sp, #12
 800c03e:	a801      	add	r0, sp, #4
 800c040:	4615      	mov	r5, r2
 800c042:	f7fe fd11 	bl	800aa68 <find_volume.constprop.0>
	if (res == FR_OK) {
 800c046:	b118      	cbz	r0, 800c050 <f_open+0x20>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800c048:	2300      	movs	r3, #0
 800c04a:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 800c04c:	b018      	add	sp, #96	; 0x60
 800c04e:	bd70      	pop	{r4, r5, r6, pc}
		dj.obj.fs = fs;
 800c050:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 800c052:	a804      	add	r0, sp, #16
 800c054:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 800c056:	9304      	str	r3, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 800c058:	f7ff fc54 	bl	800b904 <follow_path>
		if (res == FR_OK) {
 800c05c:	2800      	cmp	r0, #0
 800c05e:	d1f3      	bne.n	800c048 <f_open+0x18>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800c060:	f99d 305b 	ldrsb.w	r3, [sp, #91]	; 0x5b
 800c064:	2b00      	cmp	r3, #0
 800c066:	db25      	blt.n	800c0b4 <f_open+0x84>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 800c068:	f89d 0016 	ldrb.w	r0, [sp, #22]
 800c06c:	f010 0010 	ands.w	r0, r0, #16
 800c070:	d122      	bne.n	800c0b8 <f_open+0x88>
			if (fs->fs_type == FS_EXFAT) {
 800c072:	9b03      	ldr	r3, [sp, #12]
 800c074:	781a      	ldrb	r2, [r3, #0]
 800c076:	2a04      	cmp	r2, #4
 800c078:	d024      	beq.n	800c0c4 <f_open+0x94>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800c07a:	9913      	ldr	r1, [sp, #76]	; 0x4c
	if (fs->fs_type == FS_FAT32) {
 800c07c:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 800c07e:	8b4e      	ldrh	r6, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 800c080:	d01c      	beq.n	800c0bc <f_open+0x8c>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800c082:	60a6      	str	r6, [r4, #8]
	rv = rv << 8 | ptr[0];
 800c084:	69ca      	ldr	r2, [r1, #28]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800c086:	6122      	str	r2, [r4, #16]
 800c088:	2200      	movs	r2, #0
 800c08a:	6162      	str	r2, [r4, #20]
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800c08c:	f005 0201 	and.w	r2, r5, #1
			fp->obj.fs = fs;	 	/* Validate the file object */
 800c090:	6023      	str	r3, [r4, #0]
			fp->obj.id = fs->id;
 800c092:	88db      	ldrh	r3, [r3, #6]
			fp->cltbl = 0;			/* Disable fast seek mode */
 800c094:	2100      	movs	r1, #0
			fp->flag = mode;		/* Set file access mode */
 800c096:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
			fp->fptr = 0;			/* Set file pointer top of the file */
 800c09a:	2200      	movs	r2, #0
			fp->obj.id = fs->id;
 800c09c:	80a3      	strh	r3, [r4, #4]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800c09e:	2300      	movs	r3, #0
			fp->cltbl = 0;			/* Disable fast seek mode */
 800c0a0:	64a1      	str	r1, [r4, #72]	; 0x48
			fp->err = 0;			/* Clear error flag */
 800c0a2:	f884 1031 	strb.w	r1, [r4, #49]	; 0x31
			fp->sect = 0;			/* Invalidate current data sector */
 800c0a6:	6461      	str	r1, [r4, #68]	; 0x44
			fp->fptr = 0;			/* Set file pointer top of the file */
 800c0a8:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800c0ac:	e7ce      	b.n	800c04c <f_open+0x1c>
	if (!fp) return FR_INVALID_OBJECT;
 800c0ae:	2009      	movs	r0, #9
}
 800c0b0:	b018      	add	sp, #96	; 0x60
 800c0b2:	bd70      	pop	{r4, r5, r6, pc}
				res = FR_INVALID_NAME;
 800c0b4:	2006      	movs	r0, #6
 800c0b6:	e7c7      	b.n	800c048 <f_open+0x18>
					res = FR_NO_FILE;
 800c0b8:	2004      	movs	r0, #4
 800c0ba:	e7c5      	b.n	800c048 <f_open+0x18>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800c0bc:	8a8a      	ldrh	r2, [r1, #20]
 800c0be:	ea46 4602 	orr.w	r6, r6, r2, lsl #16
 800c0c2:	e7de      	b.n	800c082 <f_open+0x52>
				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 800c0c4:	9a06      	ldr	r2, [sp, #24]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 800c0c6:	f89d 1017 	ldrb.w	r1, [sp, #23]
				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 800c0ca:	6222      	str	r2, [r4, #32]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 800c0cc:	9a08      	ldr	r2, [sp, #32]
 800c0ce:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800c0d2:	430a      	orrs	r2, r1
 800c0d4:	6262      	str	r2, [r4, #36]	; 0x24
				fp->obj.c_ofs = dj.blk_ofs;
 800c0d6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800c0d8:	62a2      	str	r2, [r4, #40]	; 0x28
				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
 800c0da:	691a      	ldr	r2, [r3, #16]
	rv = rv << 8 | ptr[0];
 800c0dc:	6b51      	ldr	r1, [r2, #52]	; 0x34
				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
 800c0de:	60a1      	str	r1, [r4, #8]
	rv = rv << 8 | ptr[0];
 800c0e0:	6b96      	ldr	r6, [r2, #56]	; 0x38
 800c0e2:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 800c0e4:	e9c4 6104 	strd	r6, r1, [r4, #16]
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
 800c0e8:	f892 2021 	ldrb.w	r2, [r2, #33]	; 0x21
 800c0ec:	f002 0202 	and.w	r2, r2, #2
 800c0f0:	71e2      	strb	r2, [r4, #7]
 800c0f2:	e7cb      	b.n	800c08c <f_open+0x5c>

0800c0f4 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 800c0f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c0f8:	461f      	mov	r7, r3
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800c0fa:	2300      	movs	r3, #0
{
 800c0fc:	b083      	sub	sp, #12
	*br = 0;	/* Clear read byte counter */
 800c0fe:	603b      	str	r3, [r7, #0]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c100:	b150      	cbz	r0, 800c118 <f_read+0x24>
 800c102:	6803      	ldr	r3, [r0, #0]
 800c104:	4604      	mov	r4, r0
 800c106:	b13b      	cbz	r3, 800c118 <f_read+0x24>
 800c108:	4615      	mov	r5, r2
 800c10a:	781a      	ldrb	r2, [r3, #0]
 800c10c:	b122      	cbz	r2, 800c118 <f_read+0x24>
 800c10e:	460e      	mov	r6, r1
 800c110:	88da      	ldrh	r2, [r3, #6]
 800c112:	8881      	ldrh	r1, [r0, #4]
 800c114:	4291      	cmp	r1, r2
 800c116:	d005      	beq.n	800c124 <f_read+0x30>
	FRESULT res = FR_INVALID_OBJECT;
 800c118:	f04f 0809 	mov.w	r8, #9
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 800c11c:	4640      	mov	r0, r8
 800c11e:	b003      	add	sp, #12
 800c120:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800c124:	7858      	ldrb	r0, [r3, #1]
 800c126:	f7fe fb3f 	bl	800a7a8 <disk_status>
 800c12a:	07c1      	lsls	r1, r0, #31
 800c12c:	d4f4      	bmi.n	800c118 <f_read+0x24>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800c12e:	f894 8031 	ldrb.w	r8, [r4, #49]	; 0x31
 800c132:	f1b8 0f00 	cmp.w	r8, #0
 800c136:	d1f1      	bne.n	800c11c <f_read+0x28>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800c138:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800c13c:	f013 0301 	ands.w	r3, r3, #1
 800c140:	9300      	str	r3, [sp, #0]
 800c142:	f000 80e0 	beq.w	800c306 <f_read+0x212>
	remain = fp->obj.objsize - fp->fptr;
 800c146:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800c148:	6923      	ldr	r3, [r4, #16]
 800c14a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800c14c:	1a9b      	subs	r3, r3, r2
 800c14e:	6960      	ldr	r0, [r4, #20]
 800c150:	eb60 0001 	sbc.w	r0, r0, r1
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 800c154:	42ab      	cmp	r3, r5
 800c156:	f170 0000 	sbcs.w	r0, r0, #0
 800c15a:	bf38      	it	cc
 800c15c:	461d      	movcc	r5, r3
	for ( ;  btr;								/* Repeat until all data read */
 800c15e:	2d00      	cmp	r5, #0
 800c160:	d0dc      	beq.n	800c11c <f_read+0x28>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800c162:	46a2      	mov	sl, r4
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800c164:	f3c2 0008 	ubfx	r0, r2, #0, #9
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800c168:	f85a 9b4c 	ldr.w	r9, [sl], #76
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800c16c:	2800      	cmp	r0, #0
 800c16e:	d140      	bne.n	800c1f2 <f_read+0xfe>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800c170:	0a50      	lsrs	r0, r2, #9
 800c172:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 800c176:	ea4f 2c51 	mov.w	ip, r1, lsr #9
 800c17a:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
 800c17e:	3b01      	subs	r3, #1
			if (csect == 0) {					/* On the cluster boundary? */
 800c180:	4003      	ands	r3, r0
 800c182:	d069      	beq.n	800c258 <f_read+0x164>
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 800c184:	6c20      	ldr	r0, [r4, #64]	; 0x40
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c186:	f8d9 2014 	ldr.w	r2, [r9, #20]
	clst -= 2;
 800c18a:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c18c:	3a02      	subs	r2, #2
 800c18e:	4290      	cmp	r0, r2
 800c190:	d270      	bcs.n	800c274 <f_read+0x180>
	return clst * fs->csize + fs->database;
 800c192:	f8b9 100a 	ldrh.w	r1, [r9, #10]
 800c196:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
 800c19a:	fb01 2200 	mla	r2, r1, r0, r2
			if (!sect) ABORT(fs, FR_INT_ERR);
 800c19e:	2a00      	cmp	r2, #0
 800c1a0:	d068      	beq.n	800c274 <f_read+0x180>
			if (cc) {							/* Read maximum contiguous sectors directly */
 800c1a2:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
			sect += csect;
 800c1a6:	441a      	add	r2, r3
			if (cc) {							/* Read maximum contiguous sectors directly */
 800c1a8:	d36c      	bcc.n	800c284 <f_read+0x190>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800c1aa:	eb03 2055 	add.w	r0, r3, r5, lsr #9
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800c1ae:	ea4f 2b55 	mov.w	fp, r5, lsr #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800c1b2:	4288      	cmp	r0, r1
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800c1b4:	f899 0001 	ldrb.w	r0, [r9, #1]
					cc = fs->csize - csect;
 800c1b8:	bf88      	it	hi
 800c1ba:	eba1 0b03 	subhi.w	fp, r1, r3
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800c1be:	4631      	mov	r1, r6
 800c1c0:	465b      	mov	r3, fp
 800c1c2:	f7fe fb0d 	bl	800a7e0 <disk_read>
 800c1c6:	2800      	cmp	r0, #0
 800c1c8:	f040 808a 	bne.w	800c2e0 <f_read+0x1ec>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800c1cc:	ea4f 234b 	mov.w	r3, fp, lsl #9
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800c1d0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800c1d2:	441e      	add	r6, r3
 800c1d4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800c1d6:	189a      	adds	r2, r3, r2
 800c1d8:	6838      	ldr	r0, [r7, #0]
 800c1da:	f141 0100 	adc.w	r1, r1, #0
 800c1de:	4418      	add	r0, r3
	for ( ;  btr;								/* Repeat until all data read */
 800c1e0:	1aed      	subs	r5, r5, r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800c1e2:	63a2      	str	r2, [r4, #56]	; 0x38
 800c1e4:	63e1      	str	r1, [r4, #60]	; 0x3c
 800c1e6:	6038      	str	r0, [r7, #0]
	for ( ;  btr;								/* Repeat until all data read */
 800c1e8:	d098      	beq.n	800c11c <f_read+0x28>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800c1ea:	f3c2 0008 	ubfx	r0, r2, #0, #9
 800c1ee:	2800      	cmp	r0, #0
 800c1f0:	d0be      	beq.n	800c170 <f_read+0x7c>
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800c1f2:	1c41      	adds	r1, r0, #1
 800c1f4:	f5c0 7300 	rsb	r3, r0, #512	; 0x200
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800c1f8:	eb0a 0200 	add.w	r2, sl, r0
 800c1fc:	4451      	add	r1, sl
 800c1fe:	42ab      	cmp	r3, r5
 800c200:	eba6 0101 	sub.w	r1, r6, r1
 800c204:	bf28      	it	cs
 800c206:	462b      	movcs	r3, r5
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800c208:	2902      	cmp	r1, #2
 800c20a:	f103 3bff 	add.w	fp, r3, #4294967295
 800c20e:	d970      	bls.n	800c2f2 <f_read+0x1fe>
 800c210:	f1bb 0f07 	cmp.w	fp, #7
 800c214:	d96d      	bls.n	800c2f2 <f_read+0x1fe>
 800c216:	f023 0e03 	bic.w	lr, r3, #3
 800c21a:	4631      	mov	r1, r6
 800c21c:	4610      	mov	r0, r2
 800c21e:	44b6      	add	lr, r6
			*d++ = *s++;
 800c220:	f850 cb04 	ldr.w	ip, [r0], #4
 800c224:	f841 cb04 	str.w	ip, [r1], #4
		} while (--cnt);
 800c228:	458e      	cmp	lr, r1
 800c22a:	d1f9      	bne.n	800c220 <f_read+0x12c>
 800c22c:	f023 0103 	bic.w	r1, r3, #3
 800c230:	428b      	cmp	r3, r1
 800c232:	eb06 0001 	add.w	r0, r6, r1
 800c236:	eb02 0c01 	add.w	ip, r2, r1
 800c23a:	d0c9      	beq.n	800c1d0 <f_read+0xdc>
			*d++ = *s++;
 800c23c:	5c52      	ldrb	r2, [r2, r1]
 800c23e:	5472      	strb	r2, [r6, r1]
		} while (--cnt);
 800c240:	ebbb 0101 	subs.w	r1, fp, r1
 800c244:	d0c4      	beq.n	800c1d0 <f_read+0xdc>
			*d++ = *s++;
 800c246:	f89c 2001 	ldrb.w	r2, [ip, #1]
		} while (--cnt);
 800c24a:	2901      	cmp	r1, #1
			*d++ = *s++;
 800c24c:	7042      	strb	r2, [r0, #1]
		} while (--cnt);
 800c24e:	d0bf      	beq.n	800c1d0 <f_read+0xdc>
			*d++ = *s++;
 800c250:	f89c 2002 	ldrb.w	r2, [ip, #2]
 800c254:	7082      	strb	r2, [r0, #2]
		} while (--cnt);
 800c256:	e7bb      	b.n	800c1d0 <f_read+0xdc>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800c258:	430a      	orrs	r2, r1
 800c25a:	d124      	bne.n	800c2a6 <f_read+0x1b2>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800c25c:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800c25e:	2801      	cmp	r0, #1
 800c260:	d908      	bls.n	800c274 <f_read+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c262:	1c42      	adds	r2, r0, #1
 800c264:	d03c      	beq.n	800c2e0 <f_read+0x1ec>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c266:	f8d9 2014 	ldr.w	r2, [r9, #20]
				fp->clust = clst;				/* Update current cluster */
 800c26a:	6420      	str	r0, [r4, #64]	; 0x40
	clst -= 2;
 800c26c:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c26e:	3a02      	subs	r2, #2
 800c270:	4290      	cmp	r0, r2
 800c272:	d38e      	bcc.n	800c192 <f_read+0x9e>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800c274:	2302      	movs	r3, #2
 800c276:	4698      	mov	r8, r3
 800c278:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
}
 800c27c:	4640      	mov	r0, r8
 800c27e:	b003      	add	sp, #12
 800c280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 800c284:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800c286:	4293      	cmp	r3, r2
 800c288:	d008      	beq.n	800c29c <f_read+0x1a8>
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800c28a:	2301      	movs	r3, #1
 800c28c:	4651      	mov	r1, sl
 800c28e:	f899 0001 	ldrb.w	r0, [r9, #1]
 800c292:	9201      	str	r2, [sp, #4]
 800c294:	f7fe faa4 	bl	800a7e0 <disk_read>
 800c298:	9a01      	ldr	r2, [sp, #4]
 800c29a:	bb08      	cbnz	r0, 800c2e0 <f_read+0x1ec>
			fp->sect = sect;
 800c29c:	6462      	str	r2, [r4, #68]	; 0x44
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800c29e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800c2a0:	f3c2 0008 	ubfx	r0, r2, #0, #9
 800c2a4:	e7a5      	b.n	800c1f2 <f_read+0xfe>
					if (fp->cltbl) {
 800c2a6:	f8d4 b048 	ldr.w	fp, [r4, #72]	; 0x48
 800c2aa:	f1bb 0f00 	cmp.w	fp, #0
 800c2ae:	d02d      	beq.n	800c30c <f_read+0x218>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800c2b0:	6822      	ldr	r2, [r4, #0]
 800c2b2:	4661      	mov	r1, ip
 800c2b4:	9301      	str	r3, [sp, #4]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800c2b6:	f10b 0b04 	add.w	fp, fp, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800c2ba:	8952      	ldrh	r2, [r2, #10]
 800c2bc:	f7f4 fcf4 	bl	8000ca8 <__aeabi_uldivmod>
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800c2c0:	f8db 2000 	ldr.w	r2, [fp]
		if (ncl == 0) return 0;	/* End of table? (error) */
 800c2c4:	9b01      	ldr	r3, [sp, #4]
 800c2c6:	b92a      	cbnz	r2, 800c2d4 <f_read+0x1e0>
 800c2c8:	e7d4      	b.n	800c274 <f_read+0x180>
		cl -= ncl; tbl++;		/* Next fragment */
 800c2ca:	1a80      	subs	r0, r0, r2
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800c2cc:	f85b 2f08 	ldr.w	r2, [fp, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 800c2d0:	2a00      	cmp	r2, #0
 800c2d2:	d0cf      	beq.n	800c274 <f_read+0x180>
		if (cl < ncl) break;	/* In this fragment? */
 800c2d4:	4282      	cmp	r2, r0
 800c2d6:	d9f8      	bls.n	800c2ca <f_read+0x1d6>
	return cl + *tbl;	/* Return the cluster number */
 800c2d8:	f8db 2004 	ldr.w	r2, [fp, #4]
 800c2dc:	4410      	add	r0, r2
 800c2de:	e7be      	b.n	800c25e <f_read+0x16a>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c2e0:	f8dd 8000 	ldr.w	r8, [sp]
 800c2e4:	2301      	movs	r3, #1
}
 800c2e6:	4640      	mov	r0, r8
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c2e8:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
}
 800c2ec:	b003      	add	sp, #12
 800c2ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c2f2:	1e71      	subs	r1, r6, #1
 800c2f4:	eb02 0c03 	add.w	ip, r2, r3
			*d++ = *s++;
 800c2f8:	f812 0b01 	ldrb.w	r0, [r2], #1
		} while (--cnt);
 800c2fc:	4594      	cmp	ip, r2
			*d++ = *s++;
 800c2fe:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 800c302:	d1f9      	bne.n	800c2f8 <f_read+0x204>
 800c304:	e764      	b.n	800c1d0 <f_read+0xdc>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800c306:	f04f 0807 	mov.w	r8, #7
 800c30a:	e707      	b.n	800c11c <f_read+0x28>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800c30c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800c30e:	4620      	mov	r0, r4
 800c310:	9301      	str	r3, [sp, #4]
 800c312:	f7fe fdc7 	bl	800aea4 <get_fat>
 800c316:	9b01      	ldr	r3, [sp, #4]
 800c318:	e7a1      	b.n	800c25e <f_read+0x16a>
 800c31a:	bf00      	nop

0800c31c <f_close>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c31c:	b198      	cbz	r0, 800c346 <f_close+0x2a>
 800c31e:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 800c320:	b510      	push	{r4, lr}
 800c322:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c324:	b12b      	cbz	r3, 800c332 <f_close+0x16>
 800c326:	781a      	ldrb	r2, [r3, #0]
 800c328:	b11a      	cbz	r2, 800c332 <f_close+0x16>
 800c32a:	8881      	ldrh	r1, [r0, #4]
 800c32c:	88da      	ldrh	r2, [r3, #6]
 800c32e:	4291      	cmp	r1, r2
 800c330:	d001      	beq.n	800c336 <f_close+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 800c332:	2009      	movs	r0, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 800c334:	bd10      	pop	{r4, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800c336:	7858      	ldrb	r0, [r3, #1]
 800c338:	f7fe fa36 	bl	800a7a8 <disk_status>
 800c33c:	f010 0001 	ands.w	r0, r0, #1
 800c340:	d1f7      	bne.n	800c332 <f_close+0x16>
				fp->obj.fs = 0;			/* Invalidate file object */
 800c342:	6020      	str	r0, [r4, #0]
}
 800c344:	bd10      	pop	{r4, pc}
	FRESULT res = FR_INVALID_OBJECT;
 800c346:	2009      	movs	r0, #9
}
 800c348:	4770      	bx	lr
 800c34a:	bf00      	nop

0800c34c <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 800c34c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c350:	b087      	sub	sp, #28
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c352:	b140      	cbz	r0, 800c366 <f_lseek+0x1a>
 800c354:	6801      	ldr	r1, [r0, #0]
 800c356:	4604      	mov	r4, r0
 800c358:	b129      	cbz	r1, 800c366 <f_lseek+0x1a>
 800c35a:	7808      	ldrb	r0, [r1, #0]
 800c35c:	b118      	cbz	r0, 800c366 <f_lseek+0x1a>
 800c35e:	88a5      	ldrh	r5, [r4, #4]
 800c360:	88c8      	ldrh	r0, [r1, #6]
 800c362:	4285      	cmp	r5, r0
 800c364:	d004      	beq.n	800c370 <f_lseek+0x24>
#endif
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
			ofs = fp->obj.objsize;
		}
		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 800c366:	2609      	movs	r6, #9
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 800c368:	4630      	mov	r0, r6
 800c36a:	b007      	add	sp, #28
 800c36c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800c370:	7848      	ldrb	r0, [r1, #1]
 800c372:	4693      	mov	fp, r2
 800c374:	4698      	mov	r8, r3
 800c376:	f7fe fa17 	bl	800a7a8 <disk_status>
 800c37a:	07c1      	lsls	r1, r0, #31
 800c37c:	d4f3      	bmi.n	800c366 <f_lseek+0x1a>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800c37e:	6825      	ldr	r5, [r4, #0]
	if (res == FR_OK) res = (FRESULT)fp->err;
 800c380:	f894 6031 	ldrb.w	r6, [r4, #49]	; 0x31
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800c384:	46aa      	mov	sl, r5
	if (res != FR_OK) LEAVE_FF(fs, res);
 800c386:	2e00      	cmp	r6, #0
 800c388:	d1ee      	bne.n	800c368 <f_lseek+0x1c>
	if (fp->cltbl) {	/* Fast seek */
 800c38a:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800c38c:	2f00      	cmp	r7, #0
 800c38e:	d04e      	beq.n	800c42e <f_lseek+0xe2>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 800c390:	f1b8 3fff 	cmp.w	r8, #4294967295
 800c394:	bf08      	it	eq
 800c396:	f1bb 3fff 	cmpeq.w	fp, #4294967295
 800c39a:	f000 80de 	beq.w	800c55a <f_lseek+0x20e>
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 800c39e:	e9d4 9104 	ldrd	r9, r1, [r4, #16]
 800c3a2:	45cb      	cmp	fp, r9
 800c3a4:	eb78 0301 	sbcs.w	r3, r8, r1
 800c3a8:	d201      	bcs.n	800c3ae <f_lseek+0x62>
 800c3aa:	46d9      	mov	r9, fp
 800c3ac:	4641      	mov	r1, r8
			if (ofs) {
 800c3ae:	ea59 0301 	orrs.w	r3, r9, r1
			fp->fptr = ofs;				/* Set file pointer */
 800c3b2:	e9c4 910e 	strd	r9, r1, [r4, #56]	; 0x38
			if (ofs) {
 800c3b6:	d0d7      	beq.n	800c368 <f_lseek+0x1c>
				fp->clust = clmt_clust(fp, ofs - 1);
 800c3b8:	f119 3aff 	adds.w	sl, r9, #4294967295
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800c3bc:	f8b5 b00a 	ldrh.w	fp, [r5, #10]
 800c3c0:	f04f 0300 	mov.w	r3, #0
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800c3c4:	f107 0804 	add.w	r8, r7, #4
				fp->clust = clmt_clust(fp, ofs - 1);
 800c3c8:	f141 31ff 	adc.w	r1, r1, #4294967295
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800c3cc:	ea4f 2a5a 	mov.w	sl, sl, lsr #9
 800c3d0:	465a      	mov	r2, fp
 800c3d2:	ea4a 5ac1 	orr.w	sl, sl, r1, lsl #23
 800c3d6:	0a49      	lsrs	r1, r1, #9
 800c3d8:	4650      	mov	r0, sl
 800c3da:	f7f4 fc65 	bl	8000ca8 <__aeabi_uldivmod>
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800c3de:	687b      	ldr	r3, [r7, #4]
		if (ncl == 0) return 0;	/* End of table? (error) */
 800c3e0:	b933      	cbnz	r3, 800c3f0 <f_lseek+0xa4>
 800c3e2:	e168      	b.n	800c6b6 <f_lseek+0x36a>
		cl -= ncl; tbl++;		/* Next fragment */
 800c3e4:	1ac0      	subs	r0, r0, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800c3e6:	f858 3f08 	ldr.w	r3, [r8, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 800c3ea:	2b00      	cmp	r3, #0
 800c3ec:	f000 8163 	beq.w	800c6b6 <f_lseek+0x36a>
		if (cl < ncl) break;	/* In this fragment? */
 800c3f0:	4283      	cmp	r3, r0
 800c3f2:	d9f7      	bls.n	800c3e4 <f_lseek+0x98>
	return cl + *tbl;	/* Return the cluster number */
 800c3f4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800c3f8:	4403      	add	r3, r0
	clst -= 2;
 800c3fa:	1e9a      	subs	r2, r3, #2
				fp->clust = clmt_clust(fp, ofs - 1);
 800c3fc:	6423      	str	r3, [r4, #64]	; 0x40
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c3fe:	696b      	ldr	r3, [r5, #20]
 800c400:	3b02      	subs	r3, #2
 800c402:	4293      	cmp	r3, r2
 800c404:	f240 80c5 	bls.w	800c592 <f_lseek+0x246>
	return clst * fs->csize + fs->database;
 800c408:	6aaf      	ldr	r7, [r5, #40]	; 0x28
 800c40a:	fb02 770b 	mla	r7, r2, fp, r7
				if (!dsc) ABORT(fs, FR_INT_ERR);
 800c40e:	2f00      	cmp	r7, #0
 800c410:	f000 80bf 	beq.w	800c592 <f_lseek+0x246>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 800c414:	f3c9 0308 	ubfx	r3, r9, #0, #9
 800c418:	2b00      	cmp	r3, #0
 800c41a:	d0a5      	beq.n	800c368 <f_lseek+0x1c>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 800c41c:	f10b 3bff 	add.w	fp, fp, #4294967295
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 800c420:	6c63      	ldr	r3, [r4, #68]	; 0x44
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 800c422:	ea0b 0a0a 	and.w	sl, fp, sl
 800c426:	4457      	add	r7, sl
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 800c428:	42bb      	cmp	r3, r7
 800c42a:	d09d      	beq.n	800c368 <f_lseek+0x1c>
 800c42c:	e053      	b.n	800c4d6 <f_lseek+0x18a>
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
 800c42e:	7829      	ldrb	r1, [r5, #0]
 800c430:	2904      	cmp	r1, #4
 800c432:	d007      	beq.n	800c444 <f_lseek+0xf8>
 800c434:	f04f 31ff 	mov.w	r1, #4294967295
 800c438:	4559      	cmp	r1, fp
 800c43a:	eb76 0308 	sbcs.w	r3, r6, r8
 800c43e:	d201      	bcs.n	800c444 <f_lseek+0xf8>
 800c440:	468b      	mov	fp, r1
 800c442:	46b0      	mov	r8, r6
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 800c444:	6923      	ldr	r3, [r4, #16]
 800c446:	f8d4 9014 	ldr.w	r9, [r4, #20]
 800c44a:	459b      	cmp	fp, r3
 800c44c:	9301      	str	r3, [sp, #4]
 800c44e:	eb78 0309 	sbcs.w	r3, r8, r9
 800c452:	d202      	bcs.n	800c45a <f_lseek+0x10e>
 800c454:	46c1      	mov	r9, r8
 800c456:	f8cd b004 	str.w	fp, [sp, #4]
		fp->fptr = nsect = 0;
 800c45a:	2100      	movs	r1, #0
 800c45c:	2000      	movs	r0, #0
		ifptr = fp->fptr;
 800c45e:	e9d4 370e 	ldrd	r3, r7, [r4, #56]	; 0x38
		fp->fptr = nsect = 0;
 800c462:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
		if (ofs) {
 800c466:	9901      	ldr	r1, [sp, #4]
 800c468:	ea51 0209 	orrs.w	r2, r1, r9
 800c46c:	f43f af7c 	beq.w	800c368 <f_lseek+0x1c>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 800c470:	896a      	ldrh	r2, [r5, #10]
 800c472:	ea4f 2842 	mov.w	r8, r2, lsl #9
			if (ifptr > 0 &&
 800c476:	ea53 0207 	orrs.w	r2, r3, r7
 800c47a:	d037      	beq.n	800c4ec <f_lseek+0x1a0>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 800c47c:	f113 3aff 	adds.w	sl, r3, #4294967295
 800c480:	4642      	mov	r2, r8
 800c482:	f04f 0300 	mov.w	r3, #0
 800c486:	f147 37ff 	adc.w	r7, r7, #4294967295
 800c48a:	1e48      	subs	r0, r1, #1
 800c48c:	f169 0100 	sbc.w	r1, r9, #0
 800c490:	f7f4 fc0a 	bl	8000ca8 <__aeabi_uldivmod>
 800c494:	2300      	movs	r3, #0
 800c496:	468b      	mov	fp, r1
 800c498:	9002      	str	r0, [sp, #8]
 800c49a:	4642      	mov	r2, r8
 800c49c:	4650      	mov	r0, sl
 800c49e:	4639      	mov	r1, r7
 800c4a0:	f7f4 fc02 	bl	8000ca8 <__aeabi_uldivmod>
			if (ifptr > 0 &&
 800c4a4:	9b02      	ldr	r3, [sp, #8]
 800c4a6:	4283      	cmp	r3, r0
 800c4a8:	eb7b 0301 	sbcs.w	r3, fp, r1
 800c4ac:	d31e      	bcc.n	800c4ec <f_lseek+0x1a0>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 800c4ae:	f1c8 0000 	rsb	r0, r8, #0
 800c4b2:	463b      	mov	r3, r7
 800c4b4:	63e7      	str	r7, [r4, #60]	; 0x3c
 800c4b6:	ea00 000a 	and.w	r0, r0, sl
				clst = fp->clust;
 800c4ba:	6c27      	ldr	r7, [r4, #64]	; 0x40
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 800c4bc:	63a0      	str	r0, [r4, #56]	; 0x38
			if (clst != 0) {
 800c4be:	2f00      	cmp	r7, #0
 800c4c0:	f040 819b 	bne.w	800c7fa <f_lseek+0x4ae>
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 800c4c4:	f3c0 0008 	ubfx	r0, r0, #0, #9
 800c4c8:	2800      	cmp	r0, #0
 800c4ca:	f43f af4d 	beq.w	800c368 <f_lseek+0x1c>
 800c4ce:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800c4d0:	42bb      	cmp	r3, r7
 800c4d2:	f43f af49 	beq.w	800c368 <f_lseek+0x1c>
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800c4d6:	2301      	movs	r3, #1
 800c4d8:	463a      	mov	r2, r7
 800c4da:	7868      	ldrb	r0, [r5, #1]
 800c4dc:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 800c4e0:	f7fe f97e 	bl	800a7e0 <disk_read>
 800c4e4:	4606      	mov	r6, r0
 800c4e6:	bb98      	cbnz	r0, 800c550 <f_lseek+0x204>
			fp->sect = nsect;
 800c4e8:	6467      	str	r7, [r4, #68]	; 0x44
 800c4ea:	e73d      	b.n	800c368 <f_lseek+0x1c>
				clst = fp->obj.sclust;					/* start from the first cluster */
 800c4ec:	68a7      	ldr	r7, [r4, #8]
				fp->clust = clst;
 800c4ee:	6427      	str	r7, [r4, #64]	; 0x40
			if (clst != 0) {
 800c4f0:	2f00      	cmp	r7, #0
 800c4f2:	f43f af39 	beq.w	800c368 <f_lseek+0x1c>
 800c4f6:	2000      	movs	r0, #0
 800c4f8:	f8dd a004 	ldr.w	sl, [sp, #4]
 800c4fc:	46cb      	mov	fp, r9
 800c4fe:	4603      	mov	r3, r0
				while (ofs > bcs) {						/* Cluster following loop */
 800c500:	45d0      	cmp	r8, sl
 800c502:	f04f 0200 	mov.w	r2, #0
 800c506:	eb72 020b 	sbcs.w	r2, r2, fp
 800c50a:	f080 8105 	bcs.w	800c718 <f_lseek+0x3cc>
 800c50e:	4639      	mov	r1, r7
 800c510:	e00e      	b.n	800c530 <f_lseek+0x1e4>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 800c512:	2801      	cmp	r0, #1
 800c514:	d93d      	bls.n	800c592 <f_lseek+0x246>
 800c516:	696b      	ldr	r3, [r5, #20]
 800c518:	4283      	cmp	r3, r0
 800c51a:	d93a      	bls.n	800c592 <f_lseek+0x246>
				while (ofs > bcs) {						/* Cluster following loop */
 800c51c:	45d0      	cmp	r8, sl
 800c51e:	f04f 0300 	mov.w	r3, #0
					fp->clust = clst;
 800c522:	6420      	str	r0, [r4, #64]	; 0x40
				while (ofs > bcs) {						/* Cluster following loop */
 800c524:	eb73 030b 	sbcs.w	r3, r3, fp
 800c528:	f080 8135 	bcs.w	800c796 <f_lseek+0x44a>
					ofs -= bcs; fp->fptr += bcs;
 800c52c:	e9d4 030e 	ldrd	r0, r3, [r4, #56]	; 0x38
 800c530:	ebba 0a08 	subs.w	sl, sl, r8
 800c534:	f16b 0b00 	sbc.w	fp, fp, #0
 800c538:	eb18 0000 	adds.w	r0, r8, r0
 800c53c:	f143 0300 	adc.w	r3, r3, #0
 800c540:	63a0      	str	r0, [r4, #56]	; 0x38
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 800c542:	4620      	mov	r0, r4
					ofs -= bcs; fp->fptr += bcs;
 800c544:	63e3      	str	r3, [r4, #60]	; 0x3c
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 800c546:	f7fe fcad 	bl	800aea4 <get_fat>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c54a:	1c43      	adds	r3, r0, #1
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 800c54c:	4601      	mov	r1, r0
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c54e:	d1e0      	bne.n	800c512 <f_lseek+0x1c6>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c550:	2301      	movs	r3, #1
 800c552:	461e      	mov	r6, r3
 800c554:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
 800c558:	e706      	b.n	800c368 <f_lseek+0x1c>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800c55a:	463b      	mov	r3, r7
			cl = fp->obj.sclust;		/* Origin of the chain */
 800c55c:	68a2      	ldr	r2, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800c55e:	f853 1b04 	ldr.w	r1, [r3], #4
 800c562:	e9cd 1302 	strd	r1, r3, [sp, #8]
			if (cl) {
 800c566:	4613      	mov	r3, r2
 800c568:	2a00      	cmp	r2, #0
 800c56a:	f000 809a 	beq.w	800c6a2 <f_lseek+0x356>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800c56e:	2202      	movs	r2, #2
					} while (cl == pcl + 1);
 800c570:	9604      	str	r6, [sp, #16]
 800c572:	461e      	mov	r6, r3
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800c574:	9201      	str	r2, [sp, #4]
 800c576:	46b0      	mov	r8, r6
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800c578:	f04f 0b00 	mov.w	fp, #0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800c57c:	f1b8 0f01 	cmp.w	r8, #1
 800c580:	d907      	bls.n	800c592 <f_lseek+0x246>
 800c582:	f10b 0202 	add.w	r2, fp, #2
 800c586:	4647      	mov	r7, r8
 800c588:	6969      	ldr	r1, [r5, #20]
 800c58a:	42b9      	cmp	r1, r7
 800c58c:	f102 3bff 	add.w	fp, r2, #4294967295
 800c590:	d807      	bhi.n	800c5a2 <f_lseek+0x256>
				if (!dsc) ABORT(fs, FR_INT_ERR);
 800c592:	2302      	movs	r3, #2
 800c594:	461e      	mov	r6, r3
 800c596:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
}
 800c59a:	4630      	mov	r0, r6
 800c59c:	b007      	add	sp, #28
 800c59e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (fs->fs_type) {
 800c5a2:	782b      	ldrb	r3, [r5, #0]
 800c5a4:	3b01      	subs	r3, #1
 800c5a6:	2b03      	cmp	r3, #3
 800c5a8:	d8f3      	bhi.n	800c592 <f_lseek+0x246>
 800c5aa:	e8df f003 	tbb	[pc, r3]
 800c5ae:	4b59      	.short	0x4b59
 800c5b0:	0233      	.short	0x0233
			if (obj->objsize) {
 800c5b2:	e9d4 3c04 	ldrd	r3, ip, [r4, #16]
 800c5b6:	ea53 000c 	orrs.w	r0, r3, ip
 800c5ba:	d0ea      	beq.n	800c592 <f_lseek+0x246>
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800c5bc:	f894 e007 	ldrb.w	lr, [r4, #7]
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800c5c0:	68a0      	ldr	r0, [r4, #8]
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800c5c2:	f1be 0f02 	cmp.w	lr, #2
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800c5c6:	eba7 0000 	sub.w	r0, r7, r0
				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800c5ca:	f000 80ec 	beq.w	800c7a6 <f_lseek+0x45a>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800c5ce:	f1be 0f03 	cmp.w	lr, #3
 800c5d2:	f000 8101 	beq.w	800c7d8 <f_lseek+0x48c>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 800c5d6:	69e3      	ldr	r3, [r4, #28]
 800c5d8:	2b00      	cmp	r3, #0
 800c5da:	f040 8104 	bne.w	800c7e6 <f_lseek+0x49a>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800c5de:	6a2b      	ldr	r3, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c5e0:	f105 0930 	add.w	r9, r5, #48	; 0x30
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800c5e4:	eb03 18d7 	add.w	r8, r3, r7, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c5e8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800c5ea:	4598      	cmp	r8, r3
 800c5ec:	d00a      	beq.n	800c604 <f_lseek+0x2b8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c5ee:	2301      	movs	r3, #1
 800c5f0:	4642      	mov	r2, r8
 800c5f2:	7868      	ldrb	r0, [r5, #1]
 800c5f4:	4649      	mov	r1, r9
 800c5f6:	f7fe f8f3 	bl	800a7e0 <disk_read>
 800c5fa:	2800      	cmp	r0, #0
 800c5fc:	f040 80a7 	bne.w	800c74e <f_lseek+0x402>
			fs->winsect = sector;
 800c600:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800c604:	00bb      	lsls	r3, r7, #2
 800c606:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800c60a:	f859 8003 	ldr.w	r8, [r9, r3]
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800c60e:	f028 4800 	bic.w	r8, r8, #2147483648	; 0x80000000
 800c612:	e00e      	b.n	800c632 <f_lseek+0x2e6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800c614:	6a2a      	ldr	r2, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c616:	f105 0930 	add.w	r9, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c61a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800c61c:	eb02 18d7 	add.w	r8, r2, r7, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c620:	4598      	cmp	r8, r3
 800c622:	d14b      	bne.n	800c6bc <f_lseek+0x370>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800c624:	00bb      	lsls	r3, r7, #2
 800c626:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800c62a:	f859 8003 	ldr.w	r8, [r9, r3]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800c62e:	f028 4870 	bic.w	r8, r8, #4026531840	; 0xf0000000
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 800c632:	f1b8 0f01 	cmp.w	r8, #1
 800c636:	d9ac      	bls.n	800c592 <f_lseek+0x246>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800c638:	3701      	adds	r7, #1
					} while (cl == pcl + 1);
 800c63a:	4547      	cmp	r7, r8
 800c63c:	f040 808d 	bne.w	800c75a <f_lseek+0x40e>
 800c640:	6825      	ldr	r5, [r4, #0]
 800c642:	e79b      	b.n	800c57c <f_lseek+0x230>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800c644:	6a2a      	ldr	r2, [r5, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c646:	f105 0930 	add.w	r9, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c64a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800c64c:	eb02 2817 	add.w	r8, r2, r7, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c650:	4598      	cmp	r8, r3
 800c652:	d14c      	bne.n	800c6ee <f_lseek+0x3a2>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800c654:	007b      	lsls	r3, r7, #1
 800c656:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 800c65a:	f839 8003 	ldrh.w	r8, [r9, r3]
			break;
 800c65e:	e7e8      	b.n	800c632 <f_lseek+0x2e6>
			bc = (UINT)clst; bc += bc / 2;
 800c660:	eb07 0857 	add.w	r8, r7, r7, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800c664:	6a2a      	ldr	r2, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c666:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800c668:	eb02 2958 	add.w	r9, r2, r8, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c66c:	4599      	cmp	r9, r3
 800c66e:	d130      	bne.n	800c6d2 <f_lseek+0x386>
			wc = fs->win[bc++ % SS(fs)];
 800c670:	f108 0901 	add.w	r9, r8, #1
 800c674:	f3c8 0808 	ubfx	r8, r8, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800c678:	eb02 2259 	add.w	r2, r2, r9, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 800c67c:	44a8      	add	r8, r5
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c67e:	429a      	cmp	r2, r3
			wc = fs->win[bc++ % SS(fs)];
 800c680:	f898 8030 	ldrb.w	r8, [r8, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800c684:	d13d      	bne.n	800c702 <f_lseek+0x3b6>
			wc |= fs->win[bc % SS(fs)] << 8;
 800c686:	f3c9 0908 	ubfx	r9, r9, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800c68a:	07fa      	lsls	r2, r7, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800c68c:	444d      	add	r5, r9
 800c68e:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 800c692:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800c696:	bf4c      	ite	mi
 800c698:	ea4f 1818 	movmi.w	r8, r8, lsr #4
 800c69c:	f3c8 080b 	ubfxpl	r8, r8, #0, #12
 800c6a0:	e7c7      	b.n	800c632 <f_lseek+0x2e6>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 800c6a2:	2302      	movs	r3, #2
 800c6a4:	460a      	mov	r2, r1
 800c6a6:	9301      	str	r3, [sp, #4]
			if (ulen <= tlen) {
 800c6a8:	4293      	cmp	r3, r2
			*fp->cltbl = ulen;	/* Number of items used */
 800c6aa:	603b      	str	r3, [r7, #0]
			if (ulen <= tlen) {
 800c6ac:	d868      	bhi.n	800c780 <f_lseek+0x434>
				*tbl = 0;		/* Terminate table */
 800c6ae:	2300      	movs	r3, #0
 800c6b0:	9a03      	ldr	r2, [sp, #12]
 800c6b2:	6013      	str	r3, [r2, #0]
 800c6b4:	e658      	b.n	800c368 <f_lseek+0x1c>
 800c6b6:	f06f 0201 	mvn.w	r2, #1
 800c6ba:	e69f      	b.n	800c3fc <f_lseek+0xb0>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c6bc:	2301      	movs	r3, #1
 800c6be:	4642      	mov	r2, r8
 800c6c0:	7868      	ldrb	r0, [r5, #1]
 800c6c2:	4649      	mov	r1, r9
 800c6c4:	f7fe f88c 	bl	800a7e0 <disk_read>
 800c6c8:	2800      	cmp	r0, #0
 800c6ca:	d140      	bne.n	800c74e <f_lseek+0x402>
			fs->winsect = sector;
 800c6cc:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
	return res;
 800c6d0:	e7a8      	b.n	800c624 <f_lseek+0x2d8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c6d2:	2301      	movs	r3, #1
 800c6d4:	464a      	mov	r2, r9
 800c6d6:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800c6da:	7868      	ldrb	r0, [r5, #1]
 800c6dc:	f7fe f880 	bl	800a7e0 <disk_read>
 800c6e0:	2800      	cmp	r0, #0
 800c6e2:	d134      	bne.n	800c74e <f_lseek+0x402>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800c6e4:	464b      	mov	r3, r9
 800c6e6:	6a2a      	ldr	r2, [r5, #32]
			fs->winsect = sector;
 800c6e8:	f8c5 902c 	str.w	r9, [r5, #44]	; 0x2c
	return res;
 800c6ec:	e7c0      	b.n	800c670 <f_lseek+0x324>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c6ee:	2301      	movs	r3, #1
 800c6f0:	4642      	mov	r2, r8
 800c6f2:	7868      	ldrb	r0, [r5, #1]
 800c6f4:	4649      	mov	r1, r9
 800c6f6:	f7fe f873 	bl	800a7e0 <disk_read>
 800c6fa:	bb40      	cbnz	r0, 800c74e <f_lseek+0x402>
			fs->winsect = sector;
 800c6fc:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
	return res;
 800c700:	e7a8      	b.n	800c654 <f_lseek+0x308>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800c702:	2301      	movs	r3, #1
 800c704:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800c708:	7868      	ldrb	r0, [r5, #1]
 800c70a:	9205      	str	r2, [sp, #20]
 800c70c:	f7fe f868 	bl	800a7e0 <disk_read>
 800c710:	9a05      	ldr	r2, [sp, #20]
 800c712:	b9e0      	cbnz	r0, 800c74e <f_lseek+0x402>
			fs->winsect = sector;
 800c714:	62ea      	str	r2, [r5, #44]	; 0x2c
	return res;
 800c716:	e7b6      	b.n	800c686 <f_lseek+0x33a>
				while (ofs > bcs) {						/* Cluster following loop */
 800c718:	9801      	ldr	r0, [sp, #4]
 800c71a:	464b      	mov	r3, r9
				if (ofs % SS(fs)) {
 800c71c:	f3ca 0208 	ubfx	r2, sl, #0, #9
				fp->fptr += ofs;
 800c720:	e9c4 030e 	strd	r0, r3, [r4, #56]	; 0x38
				if (ofs % SS(fs)) {
 800c724:	2a00      	cmp	r2, #0
 800c726:	d05c      	beq.n	800c7e2 <f_lseek+0x496>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c728:	696a      	ldr	r2, [r5, #20]
	clst -= 2;
 800c72a:	1eb9      	subs	r1, r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800c72c:	3a02      	subs	r2, #2
 800c72e:	4291      	cmp	r1, r2
 800c730:	f4bf af2f 	bcs.w	800c592 <f_lseek+0x246>
	return clst * fs->csize + fs->database;
 800c734:	896a      	ldrh	r2, [r5, #10]
 800c736:	6aaf      	ldr	r7, [r5, #40]	; 0x28
 800c738:	fb01 7702 	mla	r7, r1, r2, r7
					if (!nsect) ABORT(fs, FR_INT_ERR);
 800c73c:	2f00      	cmp	r7, #0
 800c73e:	f43f af28 	beq.w	800c592 <f_lseek+0x246>
					nsect += (DWORD)(ofs / SS(fs));
 800c742:	ea4f 2a5a 	mov.w	sl, sl, lsr #9
 800c746:	ea4a 5acb 	orr.w	sl, sl, fp, lsl #23
 800c74a:	4457      	add	r7, sl
 800c74c:	e6ba      	b.n	800c4c4 <f_lseek+0x178>
			fs->winsect = sector;
 800c74e:	f04f 33ff 	mov.w	r3, #4294967295
 800c752:	62eb      	str	r3, [r5, #44]	; 0x2c
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 800c754:	e6fc      	b.n	800c550 <f_lseek+0x204>
					} while (cl == pcl + 1);
 800c756:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800c75a:	9b01      	ldr	r3, [sp, #4]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 800c75c:	9a02      	ldr	r2, [sp, #8]
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800c75e:	3302      	adds	r3, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 800c760:	429a      	cmp	r2, r3
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800c762:	9301      	str	r3, [sp, #4]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 800c764:	d30e      	bcc.n	800c784 <f_lseek+0x438>
						*tbl++ = ncl; *tbl++ = tcl;
 800c766:	9a03      	ldr	r2, [sp, #12]
 800c768:	4613      	mov	r3, r2
 800c76a:	f843 bb08 	str.w	fp, [r3], #8
 800c76e:	6056      	str	r6, [r2, #4]
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 800c770:	f8da 2014 	ldr.w	r2, [sl, #20]
 800c774:	4542      	cmp	r2, r8
 800c776:	d93d      	bls.n	800c7f4 <f_lseek+0x4a8>
						*tbl++ = ncl; *tbl++ = tcl;
 800c778:	9303      	str	r3, [sp, #12]
	FATFS *fs = obj->fs;
 800c77a:	4646      	mov	r6, r8
 800c77c:	6825      	ldr	r5, [r4, #0]
 800c77e:	e6fa      	b.n	800c576 <f_lseek+0x22a>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 800c780:	2611      	movs	r6, #17
 800c782:	e5f1      	b.n	800c368 <f_lseek+0x1c>
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 800c784:	f8da 3014 	ldr.w	r3, [sl, #20]
 800c788:	4543      	cmp	r3, r8
 800c78a:	d8f6      	bhi.n	800c77a <f_lseek+0x42e>
 800c78c:	9e04      	ldr	r6, [sp, #16]
			*fp->cltbl = ulen;	/* Number of items used */
 800c78e:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800c790:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 800c794:	e788      	b.n	800c6a8 <f_lseek+0x35c>
				fp->fptr += ofs;
 800c796:	4607      	mov	r7, r0
 800c798:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800c79a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800c79c:	eb1a 0000 	adds.w	r0, sl, r0
 800c7a0:	eb4b 0302 	adc.w	r3, fp, r2
 800c7a4:	e7ba      	b.n	800c71c <f_lseek+0x3d0>
				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 800c7a6:	3b01      	subs	r3, #1
 800c7a8:	f14c 3cff 	adc.w	ip, ip, #4294967295
 800c7ac:	0a5b      	lsrs	r3, r3, #9
 800c7ae:	ea43 53cc 	orr.w	r3, r3, ip, lsl #23
 800c7b2:	f8b5 c00a 	ldrh.w	ip, [r5, #10]
 800c7b6:	fbb3 f3fc 	udiv	r3, r3, ip
					if (cofs <= clen) {
 800c7ba:	4298      	cmp	r0, r3
 800c7bc:	f63f aee9 	bhi.w	800c592 <f_lseek+0x246>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800c7c0:	d011      	beq.n	800c7e6 <f_lseek+0x49a>
					val = clst + 1; 	/* Generate the value */
 800c7c2:	f107 0801 	add.w	r8, r7, #1
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 800c7c6:	f1b8 0f01 	cmp.w	r8, #1
 800c7ca:	f67f aee2 	bls.w	800c592 <f_lseek+0x246>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800c7ce:	f1b8 3fff 	cmp.w	r8, #4294967295
 800c7d2:	f47f aed3 	bne.w	800c57c <f_lseek+0x230>
 800c7d6:	e6bb      	b.n	800c550 <f_lseek+0x204>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800c7d8:	69a3      	ldr	r3, [r4, #24]
 800c7da:	4298      	cmp	r0, r3
 800c7dc:	f4bf aefb 	bcs.w	800c5d6 <f_lseek+0x28a>
 800c7e0:	e7ef      	b.n	800c7c2 <f_lseek+0x476>
		fp->fptr = nsect = 0;
 800c7e2:	4617      	mov	r7, r2
 800c7e4:	e66e      	b.n	800c4c4 <f_lseek+0x178>
					} while (cl == pcl + 1);
 800c7e6:	4b08      	ldr	r3, [pc, #32]	; (800c808 <f_lseek+0x4bc>)
 800c7e8:	429f      	cmp	r7, r3
 800c7ea:	d1b4      	bne.n	800c756 <f_lseek+0x40a>
 800c7ec:	3201      	adds	r2, #1
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800c7ee:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
 800c7f2:	e6ca      	b.n	800c58a <f_lseek+0x23e>
						*tbl++ = ncl; *tbl++ = tcl;
 800c7f4:	9e04      	ldr	r6, [sp, #16]
 800c7f6:	9303      	str	r3, [sp, #12]
 800c7f8:	e7c9      	b.n	800c78e <f_lseek+0x442>
				ofs -= fp->fptr;
 800c7fa:	9a01      	ldr	r2, [sp, #4]
 800c7fc:	ebb2 0a00 	subs.w	sl, r2, r0
 800c800:	eb69 0b03 	sbc.w	fp, r9, r3
 800c804:	e67c      	b.n	800c500 <f_lseek+0x1b4>
 800c806:	bf00      	nop
 800c808:	7ffffffe 	.word	0x7ffffffe

0800c80c <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 800c80c:	b530      	push	{r4, r5, lr}
 800c80e:	b085      	sub	sp, #20
 800c810:	9101      	str	r1, [sp, #4]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 800c812:	2800      	cmp	r0, #0
 800c814:	d032      	beq.n	800c87c <f_opendir+0x70>

	/* Get logical drive */
	obj = &dp->obj;
 800c816:	4604      	mov	r4, r0
	res = find_volume(&path, &fs, 0);
 800c818:	a903      	add	r1, sp, #12
 800c81a:	a801      	add	r0, sp, #4
 800c81c:	f7fe f924 	bl	800aa68 <find_volume.constprop.0>
	if (res == FR_OK) {
 800c820:	b118      	cbz	r0, 800c82a <f_opendir+0x1e>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 800c822:	2300      	movs	r3, #0
 800c824:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 800c826:	b005      	add	sp, #20
 800c828:	bd30      	pop	{r4, r5, pc}
		obj->fs = fs;
 800c82a:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800c82c:	4620      	mov	r0, r4
 800c82e:	9901      	ldr	r1, [sp, #4]
		obj->fs = fs;
 800c830:	6023      	str	r3, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800c832:	f7ff f867 	bl	800b904 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 800c836:	b9e8      	cbnz	r0, 800c874 <f_opendir+0x68>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 800c838:	f994 304b 	ldrsb.w	r3, [r4, #75]	; 0x4b
 800c83c:	2b00      	cmp	r3, #0
 800c83e:	db20      	blt.n	800c882 <f_opendir+0x76>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 800c840:	79a3      	ldrb	r3, [r4, #6]
 800c842:	06db      	lsls	r3, r3, #27
 800c844:	d518      	bpl.n	800c878 <f_opendir+0x6c>
					if (fs->fs_type == FS_EXFAT) {
 800c846:	9b03      	ldr	r3, [sp, #12]
 800c848:	781a      	ldrb	r2, [r3, #0]
 800c84a:	2a04      	cmp	r2, #4
 800c84c:	d01b      	beq.n	800c886 <f_opendir+0x7a>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800c84e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
	if (fs->fs_type == FS_FAT32) {
 800c850:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 800c852:	8b41      	ldrh	r1, [r0, #26]
	if (fs->fs_type == FS_FAT32) {
 800c854:	d102      	bne.n	800c85c <f_opendir+0x50>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800c856:	8a82      	ldrh	r2, [r0, #20]
 800c858:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800c85c:	60a1      	str	r1, [r4, #8]
				obj->id = fs->id;
 800c85e:	88db      	ldrh	r3, [r3, #6]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 800c860:	4620      	mov	r0, r4
				obj->id = fs->id;
 800c862:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 800c864:	f7fe ff3e 	bl	800b6e4 <dir_sdi.constprop.0>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800c868:	2804      	cmp	r0, #4
 800c86a:	d005      	beq.n	800c878 <f_opendir+0x6c>
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 800c86c:	2800      	cmp	r0, #0
 800c86e:	d1d8      	bne.n	800c822 <f_opendir+0x16>
}
 800c870:	b005      	add	sp, #20
 800c872:	bd30      	pop	{r4, r5, pc}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800c874:	2804      	cmp	r0, #4
 800c876:	d1d4      	bne.n	800c822 <f_opendir+0x16>
					res = FR_NO_PATH;
 800c878:	2005      	movs	r0, #5
 800c87a:	e7d2      	b.n	800c822 <f_opendir+0x16>
	if (!dp) return FR_INVALID_OBJECT;
 800c87c:	2009      	movs	r0, #9
}
 800c87e:	b005      	add	sp, #20
 800c880:	bd30      	pop	{r4, r5, pc}
					if (fs->fs_type == FS_EXFAT) {
 800c882:	9b03      	ldr	r3, [sp, #12]
 800c884:	e7eb      	b.n	800c85e <f_opendir+0x52>
						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 800c886:	6922      	ldr	r2, [r4, #16]
 800c888:	79e0      	ldrb	r0, [r4, #7]
 800c88a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
 800c88e:	6919      	ldr	r1, [r3, #16]
						obj->c_scl = obj->sclust;							/* Get containing directory inforamation */
 800c890:	68a5      	ldr	r5, [r4, #8]
						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 800c892:	4302      	orrs	r2, r0
						obj->c_ofs = dp->blk_ofs;
 800c894:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
						obj->c_scl = obj->sclust;							/* Get containing directory inforamation */
 800c896:	6225      	str	r5, [r4, #32]
						obj->c_ofs = dp->blk_ofs;
 800c898:	e9c4 2009 	strd	r2, r0, [r4, #36]	; 0x24
	rv = rv << 8 | ptr[0];
 800c89c:	6b4a      	ldr	r2, [r1, #52]	; 0x34
						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
 800c89e:	60a2      	str	r2, [r4, #8]
	rv = rv << 8 | ptr[0];
 800c8a0:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 800c8a2:	6b88      	ldr	r0, [r1, #56]	; 0x38
						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 800c8a4:	e9c4 0204 	strd	r0, r2, [r4, #16]
						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
 800c8a8:	f891 2021 	ldrb.w	r2, [r1, #33]	; 0x21
 800c8ac:	f002 0202 	and.w	r2, r2, #2
 800c8b0:	71e2      	strb	r2, [r4, #7]
 800c8b2:	e7d4      	b.n	800c85e <f_opendir+0x52>

0800c8b4 <f_closedir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c8b4:	b198      	cbz	r0, 800c8de <f_closedir+0x2a>
 800c8b6:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 800c8b8:	b510      	push	{r4, lr}
 800c8ba:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c8bc:	b12b      	cbz	r3, 800c8ca <f_closedir+0x16>
 800c8be:	781a      	ldrb	r2, [r3, #0]
 800c8c0:	b11a      	cbz	r2, 800c8ca <f_closedir+0x16>
 800c8c2:	8881      	ldrh	r1, [r0, #4]
 800c8c4:	88da      	ldrh	r2, [r3, #6]
 800c8c6:	4291      	cmp	r1, r2
 800c8c8:	d001      	beq.n	800c8ce <f_closedir+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 800c8ca:	2009      	movs	r0, #9
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 800c8cc:	bd10      	pop	{r4, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800c8ce:	7858      	ldrb	r0, [r3, #1]
 800c8d0:	f7fd ff6a 	bl	800a7a8 <disk_status>
 800c8d4:	f010 0001 	ands.w	r0, r0, #1
 800c8d8:	d1f7      	bne.n	800c8ca <f_closedir+0x16>
			dp->obj.fs = 0;			/* Invalidate directory object */
 800c8da:	6020      	str	r0, [r4, #0]
}
 800c8dc:	bd10      	pop	{r4, pc}
	FRESULT res = FR_INVALID_OBJECT;
 800c8de:	2009      	movs	r0, #9
}
 800c8e0:	4770      	bx	lr
 800c8e2:	bf00      	nop

0800c8e4 <f_readdir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c8e4:	b318      	cbz	r0, 800c92e <f_readdir+0x4a>

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800c8e6:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800c8e8:	6803      	ldr	r3, [r0, #0]
 800c8ea:	4604      	mov	r4, r0
 800c8ec:	b133      	cbz	r3, 800c8fc <f_readdir+0x18>
 800c8ee:	781a      	ldrb	r2, [r3, #0]
 800c8f0:	b122      	cbz	r2, 800c8fc <f_readdir+0x18>
 800c8f2:	460d      	mov	r5, r1
 800c8f4:	88da      	ldrh	r2, [r3, #6]
 800c8f6:	8881      	ldrh	r1, [r0, #4]
 800c8f8:	4291      	cmp	r1, r2
 800c8fa:	d001      	beq.n	800c900 <f_readdir+0x1c>
	FRESULT res = FR_INVALID_OBJECT;
 800c8fc:	2009      	movs	r0, #9
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 800c8fe:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800c900:	7858      	ldrb	r0, [r3, #1]
 800c902:	f7fd ff51 	bl	800a7a8 <disk_status>
 800c906:	07c3      	lsls	r3, r0, #31
 800c908:	d4f8      	bmi.n	800c8fc <f_readdir+0x18>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 800c90a:	4620      	mov	r0, r4
		if (!fno) {
 800c90c:	b18d      	cbz	r5, 800c932 <f_readdir+0x4e>
			res = dir_read(dp, 0);			/* Read an item */
 800c90e:	f7fe fbd3 	bl	800b0b8 <dir_read.constprop.0>
			if (res == FR_OK) {				/* A valid entry is found */
 800c912:	f010 0ffb 	tst.w	r0, #251	; 0xfb
 800c916:	d1f2      	bne.n	800c8fe <f_readdir+0x1a>
				get_fileinfo(dp, fno);		/* Get the object information */
 800c918:	4629      	mov	r1, r5
 800c91a:	4620      	mov	r0, r4
 800c91c:	f7fd ff6e 	bl	800a7fc <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 800c920:	4620      	mov	r0, r4
 800c922:	f7fe fb7f 	bl	800b024 <dir_next.constprop.0>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 800c926:	2804      	cmp	r0, #4
 800c928:	bf08      	it	eq
 800c92a:	2000      	moveq	r0, #0
}
 800c92c:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_INVALID_OBJECT;
 800c92e:	2009      	movs	r0, #9
}
 800c930:	4770      	bx	lr
 800c932:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 800c936:	f7fe bed5 	b.w	800b6e4 <dir_sdi.constprop.0>
 800c93a:	bf00      	nop

0800c93c <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 800c93c:	4b14      	ldr	r3, [pc, #80]	; (800c990 <FATFS_LinkDriver+0x54>)
 800c93e:	7b9a      	ldrb	r2, [r3, #14]
 800c940:	2a01      	cmp	r2, #1
 800c942:	d901      	bls.n	800c948 <FATFS_LinkDriver+0xc>
  uint8_t ret = 1;
 800c944:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
 800c946:	4770      	bx	lr
    disk.is_initialized[disk.nbr] = 0;
 800c948:	f893 c00e 	ldrb.w	ip, [r3, #14]
 800c94c:	2200      	movs	r2, #0
 800c94e:	fa5f fc8c 	uxtb.w	ip, ip
 800c952:	f803 200c 	strb.w	r2, [r3, ip]
    disk.drv[disk.nbr] = drv;
 800c956:	f893 c00e 	ldrb.w	ip, [r3, #14]
 800c95a:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 800c95e:	f8cc 0004 	str.w	r0, [ip, #4]
    disk.lun[disk.nbr] = lun;
 800c962:	f893 c00e 	ldrb.w	ip, [r3, #14]
    DiskNum = disk.nbr++;
 800c966:	7b98      	ldrb	r0, [r3, #14]
    disk.lun[disk.nbr] = lun;
 800c968:	449c      	add	ip, r3
 800c96a:	f88c 200c 	strb.w	r2, [ip, #12]
    DiskNum = disk.nbr++;
 800c96e:	f100 0c01 	add.w	ip, r0, #1
    path[0] = DiskNum + '0';
 800c972:	3030      	adds	r0, #48	; 0x30
    DiskNum = disk.nbr++;
 800c974:	fa5f fc8c 	uxtb.w	ip, ip
 800c978:	f883 c00e 	strb.w	ip, [r3, #14]
    path[1] = ':';
 800c97c:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    path[2] = '/';
 800c980:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 800c982:	7008      	strb	r0, [r1, #0]
    path[1] = ':';
 800c984:	f881 c001 	strb.w	ip, [r1, #1]
    path[3] = 0;
 800c988:	4610      	mov	r0, r2
    path[2] = '/';
 800c98a:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 800c98c:	70ca      	strb	r2, [r1, #3]
  return ret;
 800c98e:	4770      	bx	lr
 800c990:	2000079c 	.word	0x2000079c

0800c994 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 800c994:	287f      	cmp	r0, #127	; 0x7f
 800c996:	d90f      	bls.n	800c9b8 <ff_convert+0x24>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 800c998:	b959      	cbnz	r1, 800c9b2 <ff_convert+0x1e>
 800c99a:	4b0a      	ldr	r3, [pc, #40]	; (800c9c4 <ff_convert+0x30>)
 800c99c:	e002      	b.n	800c9a4 <ff_convert+0x10>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 800c99e:	3101      	adds	r1, #1
 800c9a0:	2980      	cmp	r1, #128	; 0x80
 800c9a2:	d008      	beq.n	800c9b6 <ff_convert+0x22>
				if (chr == Tbl[c]) break;
 800c9a4:	f853 2b04 	ldr.w	r2, [r3], #4
 800c9a8:	4282      	cmp	r2, r0
 800c9aa:	d1f8      	bne.n	800c99e <ff_convert+0xa>
			}
			c = (c + 0x80) & 0xFF;
 800c9ac:	f101 0080 	add.w	r0, r1, #128	; 0x80
 800c9b0:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 800c9b2:	28ff      	cmp	r0, #255	; 0xff
 800c9b4:	d901      	bls.n	800c9ba <ff_convert+0x26>
 800c9b6:	2000      	movs	r0, #0
		}
	}

	return c;
}
 800c9b8:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 800c9ba:	4b02      	ldr	r3, [pc, #8]	; (800c9c4 <ff_convert+0x30>)
 800c9bc:	3880      	subs	r0, #128	; 0x80
 800c9be:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800c9c2:	4770      	bx	lr
 800c9c4:	08021ea0 	.word	0x08021ea0

0800c9c8 <ff_wtoupper>:
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 800c9c8:	4b1e      	ldr	r3, [pc, #120]	; (800ca44 <ff_wtoupper+0x7c>)
 800c9ca:	4a1f      	ldr	r2, [pc, #124]	; (800ca48 <ff_wtoupper+0x80>)
 800c9cc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 800c9d0:	bf28      	it	cs
 800c9d2:	4613      	movcs	r3, r2
{
 800c9d4:	b510      	push	{r4, lr}
 800c9d6:	3308      	adds	r3, #8
 800c9d8:	e001      	b.n	800c9de <ff_wtoupper+0x16>
			case 7: chr -= 80; break;				/* Shift -80 */
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
			}
			break;
		}
		if (!cmd) p += nc;
 800c9da:	3308      	adds	r3, #8
 800c9dc:	b1da      	cbz	r2, 800ca16 <ff_wtoupper+0x4e>
		bc = *p++;								/* Get block base */
 800c9de:	f853 1c08 	ldr.w	r1, [r3, #-8]
		if (!bc || chr < bc) break;
 800c9e2:	461c      	mov	r4, r3
 800c9e4:	b1b1      	cbz	r1, 800ca14 <ff_wtoupper+0x4c>
 800c9e6:	4288      	cmp	r0, r1
 800c9e8:	d314      	bcc.n	800ca14 <ff_wtoupper+0x4c>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 800c9ea:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800c9ee:	fa5f fc82 	uxtb.w	ip, r2
 800c9f2:	0a12      	lsrs	r2, r2, #8
		if (chr < bc + nc) {	/* In the block? */
 800c9f4:	eb01 0e0c 	add.w	lr, r1, ip
 800c9f8:	4586      	cmp	lr, r0
 800c9fa:	d9ee      	bls.n	800c9da <ff_wtoupper+0x12>
			switch (cmd) {
 800c9fc:	2a08      	cmp	r2, #8
 800c9fe:	d809      	bhi.n	800ca14 <ff_wtoupper+0x4c>
 800ca00:	e8df f002 	tbb	[pc, r2]
 800ca04:	16140f05 	.word	0x16140f05
 800ca08:	1e1c1a18 	.word	0x1e1c1a18
 800ca0c:	0c          	.byte	0x0c
 800ca0d:	00          	.byte	0x00
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 800ca0e:	1a41      	subs	r1, r0, r1
 800ca10:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
	}

	return chr;
}
 800ca14:	bd10      	pop	{r4, pc}
		if (!cmd) p += nc;
 800ca16:	eb04 038c 	add.w	r3, r4, ip, lsl #2
 800ca1a:	e7dc      	b.n	800c9d6 <ff_wtoupper+0xe>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 800ca1c:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
}
 800ca20:	bd10      	pop	{r4, pc}
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 800ca22:	1a43      	subs	r3, r0, r1
 800ca24:	f003 0301 	and.w	r3, r3, #1
 800ca28:	1ac0      	subs	r0, r0, r3
}
 800ca2a:	bd10      	pop	{r4, pc}
			case 2: chr -= 16; break;				/* Shift -16 */
 800ca2c:	3810      	subs	r0, #16
}
 800ca2e:	bd10      	pop	{r4, pc}
			case 3:	chr -= 32; break;				/* Shift -32 */
 800ca30:	3820      	subs	r0, #32
}
 800ca32:	bd10      	pop	{r4, pc}
			case 4:	chr -= 48; break;				/* Shift -48 */
 800ca34:	3830      	subs	r0, #48	; 0x30
}
 800ca36:	bd10      	pop	{r4, pc}
			case 5:	chr -= 26; break;				/* Shift -26 */
 800ca38:	381a      	subs	r0, #26
}
 800ca3a:	bd10      	pop	{r4, pc}
			case 6:	chr += 8; break;				/* Shift +8 */
 800ca3c:	3008      	adds	r0, #8
}
 800ca3e:	bd10      	pop	{r4, pc}
			case 7: chr -= 80; break;				/* Shift -80 */
 800ca40:	3850      	subs	r0, #80	; 0x50
}
 800ca42:	bd10      	pop	{r4, pc}
 800ca44:	080220a0 	.word	0x080220a0
 800ca48:	08022484 	.word	0x08022484

0800ca4c <MP3InitDecoder>:
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 800ca4c:	f001 bcc0 	b.w	800e3d0 <xmp3fixpt_AllocateBuffers>

0800ca50 <MP3FindSyncWord>:
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 800ca50:	2901      	cmp	r1, #1
 800ca52:	dd13      	ble.n	800ca7c <MP3FindSyncWord+0x2c>
 800ca54:	1e82      	subs	r2, r0, #2
 800ca56:	1e43      	subs	r3, r0, #1
 800ca58:	f1c0 0c01 	rsb	ip, r0, #1
 800ca5c:	4411      	add	r1, r2
 800ca5e:	e001      	b.n	800ca64 <MP3FindSyncWord+0x14>
 800ca60:	428b      	cmp	r3, r1
 800ca62:	d00b      	beq.n	800ca7c <MP3FindSyncWord+0x2c>
 800ca64:	eb0c 0003 	add.w	r0, ip, r3
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 800ca68:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 800ca6c:	2aff      	cmp	r2, #255	; 0xff
 800ca6e:	d1f7      	bne.n	800ca60 <MP3FindSyncWord+0x10>
 800ca70:	785a      	ldrb	r2, [r3, #1]
 800ca72:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 800ca76:	2ae0      	cmp	r2, #224	; 0xe0
 800ca78:	d1f2      	bne.n	800ca60 <MP3FindSyncWord+0x10>
			return i;
	}
	
	return -1;
}
 800ca7a:	4770      	bx	lr
	return -1;
 800ca7c:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ca80:	4770      	bx	lr
 800ca82:	bf00      	nop

0800ca84 <MP3GetLastFrameInfo>:
 **************************************************************************************/
void MP3GetLastFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo || mp3DecInfo->layer != 3) {
 800ca84:	b118      	cbz	r0, 800ca8e <MP3GetLastFrameInfo+0xa>
 800ca86:	f8d0 37d0 	ldr.w	r3, [r0, #2000]	; 0x7d0
 800ca8a:	2b03      	cmp	r3, #3
 800ca8c:	d008      	beq.n	800caa0 <MP3GetLastFrameInfo+0x1c>
		mp3FrameInfo->bitrate = 0;
 800ca8e:	2300      	movs	r3, #0
		mp3FrameInfo->nChans = 0;
 800ca90:	e9c1 3300 	strd	r3, r3, [r1]
		mp3FrameInfo->samprate = 0;
		mp3FrameInfo->bitsPerSample = 0;
 800ca94:	e9c1 3302 	strd	r3, r3, [r1, #8]
		mp3FrameInfo->outputSamps = 0;
		mp3FrameInfo->layer = 0;
 800ca98:	e9c1 3304 	strd	r3, r3, [r1, #16]
		mp3FrameInfo->version = 0;
 800ca9c:	618b      	str	r3, [r1, #24]
 800ca9e:	4770      	bx	lr
	} else {
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 800caa0:	f8d0 27b8 	ldr.w	r2, [r0, #1976]	; 0x7b8
{
 800caa4:	b410      	push	{r4}
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800caa6:	f8d0 47bc 	ldr.w	r4, [r0, #1980]	; 0x7bc
 800caaa:	e9c1 2400 	strd	r2, r4, [r1]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 800caae:	f8d0 27c0 	ldr.w	r2, [r0, #1984]	; 0x7c0
 800cab2:	608a      	str	r2, [r1, #8]
		mp3FrameInfo->bitsPerSample = 16;
 800cab4:	2210      	movs	r2, #16
 800cab6:	60ca      	str	r2, [r1, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800cab8:	f890 07d4 	ldrb.w	r0, [r0, #2004]	; 0x7d4
 800cabc:	4a07      	ldr	r2, [pc, #28]	; (800cadc <MP3GetLastFrameInfo+0x58>)
		mp3FrameInfo->layer = mp3DecInfo->layer;
 800cabe:	614b      	str	r3, [r1, #20]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800cac0:	eb00 0340 	add.w	r3, r0, r0, lsl #1
		mp3FrameInfo->version = mp3DecInfo->version;
 800cac4:	6188      	str	r0, [r1, #24]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800cac6:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 800caca:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
 800cace:	fb04 f303 	mul.w	r3, r4, r3
	}
}
 800cad2:	f85d 4b04 	ldr.w	r4, [sp], #4
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800cad6:	610b      	str	r3, [r1, #16]
}
 800cad8:	4770      	bx	lr
 800cada:	bf00      	nop
 800cadc:	08022730 	.word	0x08022730

0800cae0 <MP3Decode>:
	int prevBitOffset, sfBlockBits, huffBlockBits;
	unsigned char *mainPtr;
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
//mw	ULONG32 ulTime;
//mw	StartYield(&ulTime); 
	if (!mp3DecInfo)
 800cae0:	2800      	cmp	r0, #0
 800cae2:	f000 8223 	beq.w	800cf2c <MP3Decode+0x44c>
{
 800cae6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800caea:	4689      	mov	r9, r1
		return ERR_MP3_NULL_POINTER;

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 800caec:	6809      	ldr	r1, [r1, #0]
 800caee:	4692      	mov	sl, r2
 800caf0:	4680      	mov	r8, r0
{
 800caf2:	ed2d 8b02 	vpush	{d8}
 800caf6:	b087      	sub	sp, #28
 800caf8:	ee08 3a10 	vmov	s16, r3
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 800cafc:	f000 fadc 	bl	800d0b8 <xmp3fixpt_UnpackFrameHeader>
	if (fhBytes < 0)	
 800cb00:	1e07      	subs	r7, r0, #0
 800cb02:	f2c0 81cd 	blt.w	800cea0 <MP3Decode+0x3c0>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
	*inbuf += fhBytes;
 800cb06:	f8d9 1000 	ldr.w	r1, [r9]
	
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 800cb0a:	4640      	mov	r0, r8
	*inbuf += fhBytes;
 800cb0c:	4439      	add	r1, r7
 800cb0e:	f8c9 1000 	str.w	r1, [r9]
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 800cb12:	f000 fbbf 	bl	800d294 <xmp3fixpt_UnpackSideInfo>
	if (siBytes < 0) {
 800cb16:	2800      	cmp	r0, #0
 800cb18:	f2c0 8220 	blt.w	800cf5c <MP3Decode+0x47c>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
		return ERR_MP3_INVALID_SIDEINFO;
	}
	*inbuf += siBytes;
	*bytesLeft -= (fhBytes + siBytes);
 800cb1c:	f8da 3000 	ldr.w	r3, [sl]
 800cb20:	1839      	adds	r1, r7, r0
	*inbuf += siBytes;
 800cb22:	f8d9 2000 	ldr.w	r2, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 800cb26:	1a59      	subs	r1, r3, r1
	*inbuf += siBytes;
 800cb28:	eb02 0e00 	add.w	lr, r2, r0
 800cb2c:	f8c9 e000 	str.w	lr, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 800cb30:	f8ca 1000 	str.w	r1, [sl]
	
	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 800cb34:	f8d8 37b8 	ldr.w	r3, [r8, #1976]	; 0x7b8
 800cb38:	2b00      	cmp	r3, #0
 800cb3a:	f000 8095 	beq.w	800cc68 <MP3Decode+0x188>
 800cb3e:	f8d8 37b0 	ldr.w	r3, [r8, #1968]	; 0x7b0
 800cb42:	b14b      	cbz	r3, 800cb58 <MP3Decode+0x78>
				return ERR_MP3_FREE_BITRATE_SYNC;
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 800cb44:	f8d8 47b4 	ldr.w	r4, [r8, #1972]	; 0x7b4
 800cb48:	4640      	mov	r0, r8
 800cb4a:	f000 faa9 	bl	800d0a0 <xmp3fixpt_CheckPadBit>
 800cb4e:	4404      	add	r4, r0
 800cb50:	f8c8 47cc 	str.w	r4, [r8, #1996]	; 0x7cc
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
		mp3DecInfo->nSlots = *bytesLeft;
 800cb54:	f8da 1000 	ldr.w	r1, [sl]
	if (useSize) {
 800cb58:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800cb5a:	2b00      	cmp	r3, #0
 800cb5c:	f000 80f3 	beq.w	800cd46 <MP3Decode+0x266>
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800cb60:	f8d8 37d8 	ldr.w	r3, [r8, #2008]	; 0x7d8
		mp3DecInfo->nSlots = *bytesLeft;
 800cb64:	f8c8 17cc 	str.w	r1, [r8, #1996]	; 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800cb68:	2b00      	cmp	r3, #0
 800cb6a:	f040 8187 	bne.w	800ce7c <MP3Decode+0x39c>
 800cb6e:	2900      	cmp	r1, #0
 800cb70:	f340 8184 	ble.w	800ce7c <MP3Decode+0x39c>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_FRAMEHEADER;
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 800cb74:	f8c8 17dc 	str.w	r1, [r8, #2012]	; 0x7dc
		mainPtr = *inbuf;
 800cb78:	f8d9 7000 	ldr.w	r7, [r9]
		*inbuf += mp3DecInfo->nSlots;
		*bytesLeft -= (mp3DecInfo->nSlots);
 800cb7c:	f8da 3000 	ldr.w	r3, [sl]
 800cb80:	1a5b      	subs	r3, r3, r1
		*inbuf += mp3DecInfo->nSlots;
 800cb82:	4439      	add	r1, r7
 800cb84:	f8c9 1000 	str.w	r1, [r9]
		*bytesLeft -= (mp3DecInfo->nSlots);
 800cb88:	f8ca 3000 	str.w	r3, [sl]
			*bytesLeft -= (mp3DecInfo->nSlots);
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_MAINDATA_UNDERFLOW;
		}
	}
	bitOffset = 0;
 800cb8c:	2000      	movs	r0, #0
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800cb8e:	f8d8 37c4 	ldr.w	r3, [r8, #1988]	; 0x7c4
	mainBits = mp3DecInfo->mainDataBytes * 8;
 800cb92:	f8d8 57dc 	ldr.w	r5, [r8, #2012]	; 0x7dc
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800cb96:	4283      	cmp	r3, r0
	bitOffset = 0;
 800cb98:	9005      	str	r0, [sp, #20]
	mainBits = mp3DecInfo->mainDataBytes * 8;
 800cb9a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800cb9e:	dd5e      	ble.n	800cc5e <MP3Decode+0x17e>
 800cba0:	f508 63fc 	add.w	r3, r8, #2016	; 0x7e0
 800cba4:	4682      	mov	sl, r0
 800cba6:	46b9      	mov	r9, r7
 800cba8:	9303      	str	r3, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbaa:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cbae:	2b00      	cmp	r3, #0
 800cbb0:	f340 80fa 	ble.w	800cda8 <MP3Decode+0x2c8>
 800cbb4:	f04f 0b00 	mov.w	fp, #0
			/* unpack scale factors and compute size of scale factor block */
			prevBitOffset = bitOffset;
 800cbb8:	9b03      	ldr	r3, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbba:	f8cd a008 	str.w	sl, [sp, #8]
 800cbbe:	46ca      	mov	sl, r9
 800cbc0:	465f      	mov	r7, fp
			prevBitOffset = bitOffset;
 800cbc2:	9c05      	ldr	r4, [sp, #20]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbc4:	469b      	mov	fp, r3
 800cbc6:	e008      	b.n	800cbda <MP3Decode+0xfa>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
				return ERR_MP3_INVALID_HUFFCODES;
			}

			mainPtr += offset;
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800cbc8:	9c05      	ldr	r4, [sp, #20]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbca:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800cbce:	4426      	add	r6, r4
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbd0:	42bb      	cmp	r3, r7
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800cbd2:	eba9 0506 	sub.w	r5, r9, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cbd6:	f340 80e4 	ble.w	800cda2 <MP3Decode+0x2c2>
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 800cbda:	9e02      	ldr	r6, [sp, #8]
 800cbdc:	4651      	mov	r1, sl
 800cbde:	462b      	mov	r3, r5
 800cbe0:	aa05      	add	r2, sp, #20
 800cbe2:	9600      	str	r6, [sp, #0]
 800cbe4:	4640      	mov	r0, r8
 800cbe6:	9701      	str	r7, [sp, #4]
 800cbe8:	f006 f8ca 	bl	8012d80 <xmp3fixpt_UnpackScaleFactors>
 800cbec:	4686      	mov	lr, r0
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800cbee:	9e05      	ldr	r6, [sp, #20]
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800cbf0:	aa05      	add	r2, sp, #20
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800cbf2:	ebc4 09ce 	rsb	r9, r4, lr, lsl #3
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 800cbf6:	f85b cb04 	ldr.w	ip, [fp], #4
			mainPtr += offset;
 800cbfa:	44f2      	add	sl, lr
			if (offset < 0 || mainBits < huffBlockBits) {
 800cbfc:	f1be 0f00 	cmp.w	lr, #0
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800cc00:	44b1      	add	r9, r6
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800cc02:	4640      	mov	r0, r8
 800cc04:	4651      	mov	r1, sl
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 800cc06:	ebac 0309 	sub.w	r3, ip, r9
			mainBits -= sfBlockBits;
 800cc0a:	eba5 0909 	sub.w	r9, r5, r9
			if (offset < 0 || mainBits < huffBlockBits) {
 800cc0e:	f2c0 80fd 	blt.w	800ce0c <MP3Decode+0x32c>
 800cc12:	45ac      	cmp	ip, r5
 800cc14:	bfd4      	ite	le
 800cc16:	2500      	movle	r5, #0
 800cc18:	2501      	movgt	r5, #1
 800cc1a:	2d00      	cmp	r5, #0
 800cc1c:	f040 80f6 	bne.w	800ce0c <MP3Decode+0x32c>
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800cc20:	9c02      	ldr	r4, [sp, #8]
 800cc22:	9701      	str	r7, [sp, #4]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cc24:	3701      	adds	r7, #1
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800cc26:	9400      	str	r4, [sp, #0]
 800cc28:	f002 fd0a 	bl	800f640 <xmp3fixpt_DecodeHuffman>
			if (offset < 0) {
 800cc2c:	2800      	cmp	r0, #0
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800cc2e:	ebc6 06c0 	rsb	r6, r6, r0, lsl #3
			mainPtr += offset;
 800cc32:	4482      	add	sl, r0
			if (offset < 0) {
 800cc34:	dac8      	bge.n	800cbc8 <MP3Decode+0xe8>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cc36:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cc3a:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cc3e:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cc42:	fb01 f202 	mul.w	r2, r1, r2
 800cc46:	fb03 f202 	mul.w	r2, r3, r2
 800cc4a:	2a00      	cmp	r2, #0
 800cc4c:	dd05      	ble.n	800cc5a <MP3Decode+0x17a>
		outbuf[i] = 0;
 800cc4e:	0052      	lsls	r2, r2, #1
 800cc50:	4629      	mov	r1, r5
 800cc52:	ee18 0a10 	vmov	r0, s16
 800cc56:	f013 fa41 	bl	80200dc <memset>
				return ERR_MP3_INVALID_HUFFCODES;
 800cc5a:	f06f 0008 	mvn.w	r0, #8
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_SUBBAND;			
		}
	}
	return ERR_MP3_NONE;
}
 800cc5e:	b007      	add	sp, #28
 800cc60:	ecbd 8b02 	vpop	{d8}
 800cc64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!mp3DecInfo->freeBitrateFlag) {
 800cc68:	f8d8 37b0 	ldr.w	r3, [r8, #1968]	; 0x7b0
 800cc6c:	2b00      	cmp	r3, #0
 800cc6e:	f47f af69 	bne.w	800cb44 <MP3Decode+0x64>
			mp3DecInfo->freeBitrateFlag = 1;
 800cc72:	2301      	movs	r3, #1
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800cc74:	eba2 0c07 	sub.w	ip, r2, r7
			mp3DecInfo->freeBitrateFlag = 1;
 800cc78:	f8c8 37b0 	str.w	r3, [r8, #1968]	; 0x7b0
	unsigned char *bufPtr = buf;
 800cc7c:	4673      	mov	r3, lr
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800cc7e:	f8da 1000 	ldr.w	r1, [sl]
	for (i = 0; i < nBytes - 1; i++) {
 800cc82:	1e4e      	subs	r6, r1, #1
 800cc84:	2e00      	cmp	r6, #0
 800cc86:	dd18      	ble.n	800ccba <MP3Decode+0x1da>
 800cc88:	2500      	movs	r5, #0
 800cc8a:	e002      	b.n	800cc92 <MP3Decode+0x1b2>
 800cc8c:	3501      	adds	r5, #1
 800cc8e:	42b5      	cmp	r5, r6
 800cc90:	d013      	beq.n	800ccba <MP3Decode+0x1da>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 800cc92:	461c      	mov	r4, r3
 800cc94:	f813 2b01 	ldrb.w	r2, [r3], #1
 800cc98:	2aff      	cmp	r2, #255	; 0xff
 800cc9a:	d1f7      	bne.n	800cc8c <MP3Decode+0x1ac>
 800cc9c:	7862      	ldrb	r2, [r4, #1]
 800cc9e:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 800cca2:	2ae0      	cmp	r2, #224	; 0xe0
 800cca4:	d1f2      	bne.n	800cc8c <MP3Decode+0x1ac>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800cca6:	f89c 3000 	ldrb.w	r3, [ip]
 800ccaa:	2bff      	cmp	r3, #255	; 0xff
 800ccac:	d023      	beq.n	800ccf6 <MP3Decode+0x216>
		nBytes -= (offset + 3);
 800ccae:	3503      	adds	r5, #3
		bufPtr += 3;
 800ccb0:	1ce3      	adds	r3, r4, #3
		nBytes -= (offset + 3);
 800ccb2:	1b49      	subs	r1, r1, r5
	for (i = 0; i < nBytes - 1; i++) {
 800ccb4:	1e4e      	subs	r6, r1, #1
 800ccb6:	2e00      	cmp	r6, #0
 800ccb8:	dce6      	bgt.n	800cc88 <MP3Decode+0x1a8>
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800ccba:	f04f 33ff 	mov.w	r3, #4294967295
 800ccbe:	f8c8 37b4 	str.w	r3, [r8, #1972]	; 0x7b4
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ccc2:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800ccc6:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800ccca:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800ccce:	fb01 f202 	mul.w	r2, r1, r2
 800ccd2:	fb03 f202 	mul.w	r2, r3, r2
 800ccd6:	2a00      	cmp	r2, #0
 800ccd8:	f340 80cd 	ble.w	800ce76 <MP3Decode+0x396>
		outbuf[i] = 0;
 800ccdc:	0052      	lsls	r2, r2, #1
 800ccde:	2100      	movs	r1, #0
 800cce0:	ee18 0a10 	vmov	r0, s16
 800cce4:	f013 f9fa 	bl	80200dc <memset>
				return ERR_MP3_FREE_BITRATE_SYNC;
 800cce8:	f06f 0002 	mvn.w	r0, #2
}
 800ccec:	b007      	add	sp, #28
 800ccee:	ecbd 8b02 	vpop	{d8}
 800ccf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800ccf6:	7862      	ldrb	r2, [r4, #1]
 800ccf8:	f89c 3001 	ldrb.w	r3, [ip, #1]
 800ccfc:	429a      	cmp	r2, r3
 800ccfe:	d1d6      	bne.n	800ccae <MP3Decode+0x1ce>
 800cd00:	f89c 2002 	ldrb.w	r2, [ip, #2]
 800cd04:	78a3      	ldrb	r3, [r4, #2]
 800cd06:	4053      	eors	r3, r2
 800cd08:	f013 0ffc 	tst.w	r3, #252	; 0xfc
 800cd0c:	d1cf      	bne.n	800ccae <MP3Decode+0x1ce>
			if ((firstFH[2] >> 1) & 0x01)
 800cd0e:	0793      	lsls	r3, r2, #30
				bufPtr--;
 800cd10:	bf48      	it	mi
 800cd12:	f104 34ff 	addmi.w	r4, r4, #4294967295
			return bufPtr - buf;
 800cd16:	eba4 040e 	sub.w	r4, r4, lr
			if (mp3DecInfo->freeBitrateSlots < 0) {
 800cd1a:	2c00      	cmp	r4, #0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800cd1c:	f8c8 47b4 	str.w	r4, [r8, #1972]	; 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 800cd20:	dbcf      	blt.n	800ccc2 <MP3Decode+0x1e2>
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 800cd22:	193b      	adds	r3, r7, r4
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 800cd24:	f8d8 27c0 	ldr.w	r2, [r8, #1984]	; 0x7c0
 800cd28:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 800cd2c:	4403      	add	r3, r0
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 800cd2e:	fb02 f303 	mul.w	r3, r2, r3
 800cd32:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cd36:	00db      	lsls	r3, r3, #3
 800cd38:	fb01 f202 	mul.w	r2, r1, r2
 800cd3c:	fb93 f3f2 	sdiv	r3, r3, r2
 800cd40:	f8c8 37b8 	str.w	r3, [r8, #1976]	; 0x7b8
 800cd44:	e700      	b.n	800cb48 <MP3Decode+0x68>
		if (mp3DecInfo->nSlots > *bytesLeft) {
 800cd46:	f8d8 07cc 	ldr.w	r0, [r8, #1996]	; 0x7cc
 800cd4a:	4288      	cmp	r0, r1
 800cd4c:	f300 80f1 	bgt.w	800cf32 <MP3Decode+0x452>
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 800cd50:	f8d8 37dc 	ldr.w	r3, [r8, #2012]	; 0x7dc
 800cd54:	f8d8 27d8 	ldr.w	r2, [r8, #2008]	; 0x7d8
 800cd58:	4293      	cmp	r3, r2
 800cd5a:	f2c0 80a4 	blt.w	800cea6 <MP3Decode+0x3c6>
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 800cd5e:	1a9b      	subs	r3, r3, r2
 800cd60:	f108 071c 	add.w	r7, r8, #28
 800cd64:	18f9      	adds	r1, r7, r3
 800cd66:	4638      	mov	r0, r7
 800cd68:	f013 f99e 	bl	80200a8 <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 800cd6c:	f8d8 07d8 	ldr.w	r0, [r8, #2008]	; 0x7d8
 800cd70:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800cd74:	4438      	add	r0, r7
 800cd76:	f8d9 1000 	ldr.w	r1, [r9]
 800cd7a:	f013 f987 	bl	802008c <memcpy>
			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 800cd7e:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800cd82:	f8d8 37d8 	ldr.w	r3, [r8, #2008]	; 0x7d8
 800cd86:	4413      	add	r3, r2
 800cd88:	f8c8 37dc 	str.w	r3, [r8, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 800cd8c:	f8d9 3000 	ldr.w	r3, [r9]
 800cd90:	4413      	add	r3, r2
 800cd92:	f8c9 3000 	str.w	r3, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 800cd96:	f8da 3000 	ldr.w	r3, [sl]
 800cd9a:	1a9b      	subs	r3, r3, r2
 800cd9c:	f8ca 3000 	str.w	r3, [sl]
			mainPtr = mp3DecInfo->mainBuf;
 800cda0:	e6f4      	b.n	800cb8c <MP3Decode+0xac>
 800cda2:	46d1      	mov	r9, sl
 800cda4:	f8dd a008 	ldr.w	sl, [sp, #8]
		if (Dequantize(mp3DecInfo, gr) < 0) {
 800cda8:	4651      	mov	r1, sl
 800cdaa:	4640      	mov	r0, r8
 800cdac:	f002 f83e 	bl	800ee2c <xmp3fixpt_Dequantize>
 800cdb0:	2800      	cmp	r0, #0
 800cdb2:	f2c0 80a6 	blt.w	800cf02 <MP3Decode+0x422>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800cdb6:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cdba:	2b00      	cmp	r3, #0
 800cdbc:	dd3f      	ble.n	800ce3e <MP3Decode+0x35e>
 800cdbe:	2400      	movs	r4, #0
 800cdc0:	e003      	b.n	800cdca <MP3Decode+0x2ea>
 800cdc2:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cdc6:	42a3      	cmp	r3, r4
 800cdc8:	dd39      	ble.n	800ce3e <MP3Decode+0x35e>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 800cdca:	4622      	mov	r2, r4
 800cdcc:	4651      	mov	r1, sl
 800cdce:	4640      	mov	r0, r8
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800cdd0:	3401      	adds	r4, #1
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 800cdd2:	f003 fad1 	bl	8010378 <xmp3fixpt_IMDCT>
 800cdd6:	2800      	cmp	r0, #0
 800cdd8:	daf3      	bge.n	800cdc2 <MP3Decode+0x2e2>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cdda:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800cdde:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800cde2:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cde6:	fb01 f202 	mul.w	r2, r1, r2
 800cdea:	fb03 f202 	mul.w	r2, r3, r2
 800cdee:	2a00      	cmp	r2, #0
 800cdf0:	dd05      	ble.n	800cdfe <MP3Decode+0x31e>
		outbuf[i] = 0;
 800cdf2:	0052      	lsls	r2, r2, #1
 800cdf4:	2100      	movs	r1, #0
 800cdf6:	ee18 0a10 	vmov	r0, s16
 800cdfa:	f013 f96f 	bl	80200dc <memset>
				return ERR_MP3_INVALID_IMDCT;			
 800cdfe:	f06f 000a 	mvn.w	r0, #10
}
 800ce02:	b007      	add	sp, #28
 800ce04:	ecbd 8b02 	vpop	{d8}
 800ce08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ce0c:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800ce10:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800ce14:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800ce18:	fb01 f202 	mul.w	r2, r1, r2
 800ce1c:	fb03 f202 	mul.w	r2, r3, r2
 800ce20:	2a00      	cmp	r2, #0
 800ce22:	dd05      	ble.n	800ce30 <MP3Decode+0x350>
		outbuf[i] = 0;
 800ce24:	0052      	lsls	r2, r2, #1
 800ce26:	2100      	movs	r1, #0
 800ce28:	ee18 0a10 	vmov	r0, s16
 800ce2c:	f013 f956 	bl	80200dc <memset>
				return ERR_MP3_INVALID_SCALEFACT;
 800ce30:	f06f 0007 	mvn.w	r0, #7
}
 800ce34:	b007      	add	sp, #28
 800ce36:	ecbd 8b02 	vpop	{d8}
 800ce3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 800ce3e:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800ce42:	4640      	mov	r0, r8
 800ce44:	fb02 f20a 	mul.w	r2, r2, sl
 800ce48:	fb02 f303 	mul.w	r3, r2, r3
 800ce4c:	ee18 2a10 	vmov	r2, s16
 800ce50:	eb02 0143 	add.w	r1, r2, r3, lsl #1
 800ce54:	f006 ff32 	bl	8013cbc <xmp3fixpt_Subband>
 800ce58:	2800      	cmp	r0, #0
 800ce5a:	f2c0 8094 	blt.w	800cf86 <MP3Decode+0x4a6>
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800ce5e:	9b03      	ldr	r3, [sp, #12]
 800ce60:	f10a 0a01 	add.w	sl, sl, #1
 800ce64:	3308      	adds	r3, #8
 800ce66:	9303      	str	r3, [sp, #12]
 800ce68:	f8d8 37c4 	ldr.w	r3, [r8, #1988]	; 0x7c4
 800ce6c:	4553      	cmp	r3, sl
 800ce6e:	f73f ae9c 	bgt.w	800cbaa <MP3Decode+0xca>
	return ERR_MP3_NONE;
 800ce72:	2000      	movs	r0, #0
 800ce74:	e6f3      	b.n	800cc5e <MP3Decode+0x17e>
				return ERR_MP3_FREE_BITRATE_SYNC;
 800ce76:	f06f 0002 	mvn.w	r0, #2
 800ce7a:	e6f0      	b.n	800cc5e <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ce7c:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800ce80:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800ce84:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800ce88:	fb01 f202 	mul.w	r2, r1, r2
 800ce8c:	fb03 f202 	mul.w	r2, r3, r2
 800ce90:	2a00      	cmp	r2, #0
 800ce92:	dd05      	ble.n	800cea0 <MP3Decode+0x3c0>
		outbuf[i] = 0;
 800ce94:	0052      	lsls	r2, r2, #1
 800ce96:	2100      	movs	r1, #0
 800ce98:	ee18 0a10 	vmov	r0, s16
 800ce9c:	f013 f91e 	bl	80200dc <memset>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 800cea0:	f06f 0005 	mvn.w	r0, #5
 800cea4:	e6db      	b.n	800cc5e <MP3Decode+0x17e>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 800cea6:	4602      	mov	r2, r0
 800cea8:	f108 001c 	add.w	r0, r8, #28
 800ceac:	f8d9 1000 	ldr.w	r1, [r9]
 800ceb0:	4418      	add	r0, r3
 800ceb2:	f013 f8eb 	bl	802008c <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 800ceb6:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800ceba:	f8d8 37dc 	ldr.w	r3, [r8, #2012]	; 0x7dc
 800cebe:	4413      	add	r3, r2
 800cec0:	f8c8 37dc 	str.w	r3, [r8, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 800cec4:	f8d9 3000 	ldr.w	r3, [r9]
 800cec8:	4413      	add	r3, r2
 800ceca:	f8c9 3000 	str.w	r3, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 800cece:	f8da 3000 	ldr.w	r3, [sl]
 800ced2:	1a9b      	subs	r3, r3, r2
 800ced4:	f8ca 3000 	str.w	r3, [sl]
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ced8:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cedc:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cee0:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cee4:	fb01 f202 	mul.w	r2, r1, r2
 800cee8:	fb03 f202 	mul.w	r2, r3, r2
 800ceec:	2a00      	cmp	r2, #0
 800ceee:	dd05      	ble.n	800cefc <MP3Decode+0x41c>
		outbuf[i] = 0;
 800cef0:	0052      	lsls	r2, r2, #1
 800cef2:	9912      	ldr	r1, [sp, #72]	; 0x48
 800cef4:	ee18 0a10 	vmov	r0, s16
 800cef8:	f013 f8f0 	bl	80200dc <memset>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 800cefc:	f06f 0001 	mvn.w	r0, #1
 800cf00:	e6ad      	b.n	800cc5e <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cf02:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800cf06:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800cf0a:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cf0e:	fb01 f202 	mul.w	r2, r1, r2
 800cf12:	fb03 f202 	mul.w	r2, r3, r2
 800cf16:	2a00      	cmp	r2, #0
 800cf18:	dd05      	ble.n	800cf26 <MP3Decode+0x446>
		outbuf[i] = 0;
 800cf1a:	0052      	lsls	r2, r2, #1
 800cf1c:	2100      	movs	r1, #0
 800cf1e:	ee18 0a10 	vmov	r0, s16
 800cf22:	f013 f8db 	bl	80200dc <memset>
			return ERR_MP3_INVALID_DEQUANTIZE;			
 800cf26:	f06f 0009 	mvn.w	r0, #9
 800cf2a:	e698      	b.n	800cc5e <MP3Decode+0x17e>
		return ERR_MP3_NULL_POINTER;
 800cf2c:	f06f 0004 	mvn.w	r0, #4
}
 800cf30:	4770      	bx	lr
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cf32:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cf36:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cf3a:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cf3e:	fb01 f202 	mul.w	r2, r1, r2
 800cf42:	fb03 f202 	mul.w	r2, r3, r2
 800cf46:	2a00      	cmp	r2, #0
 800cf48:	dd05      	ble.n	800cf56 <MP3Decode+0x476>
		outbuf[i] = 0;
 800cf4a:	0052      	lsls	r2, r2, #1
 800cf4c:	9912      	ldr	r1, [sp, #72]	; 0x48
 800cf4e:	ee18 0a10 	vmov	r0, s16
 800cf52:	f013 f8c3 	bl	80200dc <memset>
			return ERR_MP3_INDATA_UNDERFLOW;	
 800cf56:	f04f 30ff 	mov.w	r0, #4294967295
 800cf5a:	e680      	b.n	800cc5e <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cf5c:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cf60:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cf64:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cf68:	fb01 f202 	mul.w	r2, r1, r2
 800cf6c:	fb03 f202 	mul.w	r2, r3, r2
 800cf70:	2a00      	cmp	r2, #0
 800cf72:	dd05      	ble.n	800cf80 <MP3Decode+0x4a0>
		outbuf[i] = 0;
 800cf74:	0052      	lsls	r2, r2, #1
 800cf76:	2100      	movs	r1, #0
 800cf78:	ee18 0a10 	vmov	r0, s16
 800cf7c:	f013 f8ae 	bl	80200dc <memset>
		return ERR_MP3_INVALID_SIDEINFO;
 800cf80:	f06f 0006 	mvn.w	r0, #6
 800cf84:	e66b      	b.n	800cc5e <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cf86:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800cf8a:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800cf8e:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cf92:	fb01 f202 	mul.w	r2, r1, r2
 800cf96:	fb03 f202 	mul.w	r2, r3, r2
 800cf9a:	2a00      	cmp	r2, #0
 800cf9c:	dd05      	ble.n	800cfaa <MP3Decode+0x4ca>
		outbuf[i] = 0;
 800cf9e:	0052      	lsls	r2, r2, #1
 800cfa0:	2100      	movs	r1, #0
 800cfa2:	ee18 0a10 	vmov	r0, s16
 800cfa6:	f013 f899 	bl	80200dc <memset>
			return ERR_MP3_INVALID_SUBBAND;			
 800cfaa:	f06f 000b 	mvn.w	r0, #11
 800cfae:	e656      	b.n	800cc5e <MP3Decode+0x17e>

0800cfb0 <xmp3fixpt_SetBitstreamPointer>:
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
	/* init bitstream */
	bsi->bytePtr = buf;
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800cfb0:	2300      	movs	r3, #0
 800cfb2:	e9c0 2300 	strd	r2, r3, [r0]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
	bsi->nBytes = nBytes;
 800cfb6:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800cfba:	4770      	bx	lr

0800cfbc <xmp3fixpt_GetBits>:
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 800cfbc:	f001 011f 	and.w	r1, r1, #31
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cfc0:	6843      	ldr	r3, [r0, #4]
{
 800cfc2:	b4f0      	push	{r4, r5, r6, r7}
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cfc4:	f1c1 041f 	rsb	r4, r1, #31
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfc8:	fa03 f201 	lsl.w	r2, r3, r1
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cfcc:	40e3      	lsrs	r3, r4
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfce:	6884      	ldr	r4, [r0, #8]
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfd0:	6042      	str	r2, [r0, #4]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfd2:	1a62      	subs	r2, r4, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cfd4:	085b      	lsrs	r3, r3, #1

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 800cfd6:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfd8:	6082      	str	r2, [r0, #8]
	if (bsi->cachedBits < 0) {
 800cfda:	db02      	blt.n	800cfe2 <xmp3fixpt_GetBits+0x26>
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
		bsi->iCache <<= lowBits;			/* left-justify cache */
	}

	return data;
}
 800cfdc:	4618      	mov	r0, r3
 800cfde:	bcf0      	pop	{r4, r5, r6, r7}
 800cfe0:	4770      	bx	lr
	int nBytes = bsi->nBytes;
 800cfe2:	68c5      	ldr	r5, [r0, #12]
		lowBits = -bsi->cachedBits;
 800cfe4:	1b09      	subs	r1, r1, r4
	if (nBytes >= 4) {
 800cfe6:	2d03      	cmp	r5, #3
 800cfe8:	dc2f      	bgt.n	800d04a <xmp3fixpt_GetBits+0x8e>
		bsi->iCache = 0;
 800cfea:	2400      	movs	r4, #0
 800cfec:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800cfee:	2d00      	cmp	r5, #0
 800cff0:	d04a      	beq.n	800d088 <xmp3fixpt_GetBits+0xcc>
			bsi->iCache |= (*bsi->bytePtr++);
 800cff2:	6806      	ldr	r6, [r0, #0]
		while (nBytes--) {
 800cff4:	2d01      	cmp	r5, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800cff6:	f106 0401 	add.w	r4, r6, #1
 800cffa:	6004      	str	r4, [r0, #0]
 800cffc:	7834      	ldrb	r4, [r6, #0]
			bsi->iCache <<= 8;
 800cffe:	ea4f 2404 	mov.w	r4, r4, lsl #8
 800d002:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800d004:	d00e      	beq.n	800d024 <xmp3fixpt_GetBits+0x68>
			bsi->iCache |= (*bsi->bytePtr++);
 800d006:	1cb7      	adds	r7, r6, #2
		while (nBytes--) {
 800d008:	2d02      	cmp	r5, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d00a:	6007      	str	r7, [r0, #0]
 800d00c:	7877      	ldrb	r7, [r6, #1]
 800d00e:	ea44 0407 	orr.w	r4, r4, r7
			bsi->iCache <<= 8;
 800d012:	ea4f 2404 	mov.w	r4, r4, lsl #8
 800d016:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800d018:	d004      	beq.n	800d024 <xmp3fixpt_GetBits+0x68>
			bsi->iCache |= (*bsi->bytePtr++);
 800d01a:	1cf7      	adds	r7, r6, #3
 800d01c:	6007      	str	r7, [r0, #0]
 800d01e:	78b6      	ldrb	r6, [r6, #2]
 800d020:	4334      	orrs	r4, r6
			bsi->iCache <<= 8;
 800d022:	0224      	lsls	r4, r4, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d024:	f1c5 0603 	rsb	r6, r5, #3
 800d028:	00f6      	lsls	r6, r6, #3
 800d02a:	40b4      	lsls	r4, r6
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d02c:	f102 0620 	add.w	r6, r2, #32
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d030:	fa04 f101 	lsl.w	r1, r4, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d034:	40f4      	lsrs	r4, r6
 800d036:	4323      	orrs	r3, r4
		bsi->nBytes = 0;
 800d038:	2400      	movs	r4, #0
 800d03a:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800d03e:	60c4      	str	r4, [r0, #12]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d040:	e9c0 1201 	strd	r1, r2, [r0, #4]
}
 800d044:	bcf0      	pop	{r4, r5, r6, r7}
 800d046:	4618      	mov	r0, r3
 800d048:	4770      	bx	lr
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d04a:	6806      	ldr	r6, [r0, #0]
 800d04c:	3220      	adds	r2, #32
		bsi->nBytes -= 4;
 800d04e:	3d04      	subs	r5, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d050:	4637      	mov	r7, r6
 800d052:	1c74      	adds	r4, r6, #1
 800d054:	6004      	str	r4, [r0, #0]
 800d056:	f817 4b02 	ldrb.w	r4, [r7], #2
 800d05a:	0624      	lsls	r4, r4, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d05c:	6007      	str	r7, [r0, #0]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d05e:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d060:	7877      	ldrb	r7, [r6, #1]
 800d062:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d066:	1cf7      	adds	r7, r6, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d068:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d06a:	6007      	str	r7, [r0, #0]
 800d06c:	78b7      	ldrb	r7, [r6, #2]
 800d06e:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d072:	1d37      	adds	r7, r6, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d074:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++);
 800d076:	6007      	str	r7, [r0, #0]
 800d078:	78f6      	ldrb	r6, [r6, #3]
		bsi->nBytes -= 4;
 800d07a:	60c5      	str	r5, [r0, #12]
		bsi->iCache |= (*bsi->bytePtr++);
 800d07c:	4334      	orrs	r4, r6
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d07e:	fa04 f101 	lsl.w	r1, r4, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d082:	40d4      	lsrs	r4, r2
 800d084:	4323      	orrs	r3, r4
 800d086:	e7db      	b.n	800d040 <xmp3fixpt_GetBits+0x84>
		while (nBytes--) {
 800d088:	4629      	mov	r1, r5
 800d08a:	e7d5      	b.n	800d038 <xmp3fixpt_GetBits+0x7c>

0800d08c <xmp3fixpt_CalcBitsUsed>:
 * Outputs:     none
 *
 * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
 800d08c:	b410      	push	{r4}
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 800d08e:	6804      	ldr	r4, [r0, #0]
	bitsUsed -= bsi->cachedBits;
 800d090:	6883      	ldr	r3, [r0, #8]
	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 800d092:	1a61      	subs	r1, r4, r1
	bitsUsed -= startOffset;

	return bitsUsed;
}
 800d094:	f85d 4b04 	ldr.w	r4, [sp], #4
	bitsUsed -= bsi->cachedBits;
 800d098:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
}
 800d09c:	1a98      	subs	r0, r3, r2
 800d09e:	4770      	bx	lr

0800d0a0 <xmp3fixpt_CheckPadBit>:
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 800d0a0:	b130      	cbz	r0, 800d0b0 <xmp3fixpt_CheckPadBit+0x10>
 800d0a2:	6803      	ldr	r3, [r0, #0]
 800d0a4:	b123      	cbz	r3, 800d0b0 <xmp3fixpt_CheckPadBit+0x10>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	return (fh->paddingBit ? 1 : 0);
 800d0a6:	6958      	ldr	r0, [r3, #20]
 800d0a8:	3800      	subs	r0, #0
 800d0aa:	bf18      	it	ne
 800d0ac:	2001      	movne	r0, #1
 800d0ae:	4770      	bx	lr
		return -1;
 800d0b0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d0b4:	4770      	bx	lr
 800d0b6:	bf00      	nop

0800d0b8 <xmp3fixpt_UnpackFrameHeader>:

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800d0b8:	2800      	cmp	r0, #0
 800d0ba:	f000 80db 	beq.w	800d274 <xmp3fixpt_UnpackFrameHeader+0x1bc>
 800d0be:	6803      	ldr	r3, [r0, #0]
 800d0c0:	2b00      	cmp	r3, #0
 800d0c2:	f000 80d7 	beq.w	800d274 <xmp3fixpt_UnpackFrameHeader+0x1bc>
 800d0c6:	780a      	ldrb	r2, [r1, #0]
 800d0c8:	2aff      	cmp	r2, #255	; 0xff
 800d0ca:	f040 80d3 	bne.w	800d274 <xmp3fixpt_UnpackFrameHeader+0x1bc>
{
 800d0ce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800d0d2:	784c      	ldrb	r4, [r1, #1]
 800d0d4:	f004 02e0 	and.w	r2, r4, #224	; 0xe0
 800d0d8:	2ae0      	cmp	r2, #224	; 0xe0
 800d0da:	f040 80c8 	bne.w	800d26e <xmp3fixpt_UnpackFrameHeader+0x1b6>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 800d0de:	f014 0f18 	tst.w	r4, #24
	verIdx =         (buf[1] >> 3) & 0x03;
 800d0e2:	ea4f 02d4 	mov.w	r2, r4, lsr #3
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 800d0e6:	f040 80b7 	bne.w	800d258 <xmp3fixpt_UnpackFrameHeader+0x1a0>
 800d0ea:	2202      	movs	r2, #2
 800d0ec:	701a      	strb	r2, [r3, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 800d0ee:	f891 c001 	ldrb.w	ip, [r1, #1]
 800d0f2:	f3cc 0c41 	ubfx	ip, ip, #1, #2
 800d0f6:	f1cc 0904 	rsb	r9, ip, #4
 800d0fa:	f8c3 9004 	str.w	r9, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 800d0fe:	784d      	ldrb	r5, [r1, #1]
 800d100:	43ed      	mvns	r5, r5
 800d102:	f005 0501 	and.w	r5, r5, #1
 800d106:	609d      	str	r5, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 800d108:	788c      	ldrb	r4, [r1, #2]
 800d10a:	0927      	lsrs	r7, r4, #4
 800d10c:	60df      	str	r7, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 800d10e:	788c      	ldrb	r4, [r1, #2]
 800d110:	f3c4 0481 	ubfx	r4, r4, #2, #2
 800d114:	611c      	str	r4, [r3, #16]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
	fh->origFlag =   (buf[3] >> 2) & 0x01;
	fh->emphasis =   (buf[3] >> 0) & 0x03;

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 800d116:	2c03      	cmp	r4, #3
 800d118:	bf18      	it	ne
 800d11a:	2f0f      	cmpne	r7, #15
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 800d11c:	788e      	ldrb	r6, [r1, #2]
 800d11e:	f3c6 0640 	ubfx	r6, r6, #1, #1
 800d122:	615e      	str	r6, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 800d124:	f891 e002 	ldrb.w	lr, [r1, #2]
 800d128:	f00e 0e01 	and.w	lr, lr, #1
 800d12c:	f8c3 e018 	str.w	lr, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 800d130:	f891 e003 	ldrb.w	lr, [r1, #3]
 800d134:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800d138:	f883 e01c 	strb.w	lr, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 800d13c:	f891 8003 	ldrb.w	r8, [r1, #3]
 800d140:	f3c8 1801 	ubfx	r8, r8, #4, #2
 800d144:	f8c3 8020 	str.w	r8, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 800d148:	f891 8003 	ldrb.w	r8, [r1, #3]
 800d14c:	f3c8 08c0 	ubfx	r8, r8, #3, #1
 800d150:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 800d154:	f891 8003 	ldrb.w	r8, [r1, #3]
 800d158:	f3c8 0880 	ubfx	r8, r8, #2, #1
 800d15c:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 800d160:	f891 8003 	ldrb.w	r8, [r1, #3]
 800d164:	f008 0803 	and.w	r8, r8, #3
 800d168:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 800d16c:	d07f      	beq.n	800d26e <xmp3fixpt_UnpackFrameHeader+0x1b6>
 800d16e:	f1a9 0a04 	sub.w	sl, r9, #4
 800d172:	faba fa8a 	clz	sl, sl
 800d176:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
 800d17a:	f1ba 0f00 	cmp.w	sl, #0
 800d17e:	d176      	bne.n	800d26e <xmp3fixpt_UnpackFrameHeader+0x1b6>
		return -1;

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 800d180:	f04f 08de 	mov.w	r8, #222	; 0xde
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 800d184:	f1be 0f01 	cmp.w	lr, #1
	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 800d188:	fb08 fb02 	mul.w	fp, r8, r2
 800d18c:	f04f 084a 	mov.w	r8, #74	; 0x4a
 800d190:	fb18 b804 	smlabb	r8, r8, r4, fp
 800d194:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 800d28c <xmp3fixpt_UnpackFrameHeader+0x1d4>
 800d198:	44d8      	add	r8, fp
 800d19a:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 800d19e:	d05f      	beq.n	800d260 <xmp3fixpt_UnpackFrameHeader+0x1a8>
		fh->modeExt = 0;

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800d1a0:	f1be 0f03 	cmp.w	lr, #3
		fh->modeExt = 0;
 800d1a4:	f8c3 a020 	str.w	sl, [r3, #32]
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800d1a8:	d15a      	bne.n	800d260 <xmp3fixpt_UnpackFrameHeader+0x1a8>
 800d1aa:	f04f 0801 	mov.w	r8, #1
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800d1ae:	f1cc 0c03 	rsb	ip, ip, #3
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800d1b2:	f8c0 87bc 	str.w	r8, [r0, #1980]	; 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800d1b6:	eb02 0842 	add.w	r8, r2, r2, lsl #1
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800d1ba:	2a00      	cmp	r2, #0
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800d1bc:	ea4f 0a42 	mov.w	sl, r2, lsl #1
	mp3DecInfo->layer = fh->layer;
 800d1c0:	f8c0 97d0 	str.w	r9, [r0, #2000]	; 0x7d0
	mp3DecInfo->version = fh->ver;
 800d1c4:	f880 27d4 	strb.w	r2, [r0, #2004]	; 0x7d4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800d1c8:	eb08 090c 	add.w	r9, r8, ip
 800d1cc:	4a2b      	ldr	r2, [pc, #172]	; (800d27c <xmp3fixpt_UnpackFrameHeader+0x1c4>)
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800d1ce:	bf0c      	ite	eq
 800d1d0:	f04f 0b02 	moveq.w	fp, #2
 800d1d4:	f04f 0b01 	movne.w	fp, #1
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800d1d8:	f932 9019 	ldrsh.w	r9, [r2, r9, lsl #1]
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800d1dc:	f8c0 b7c4 	str.w	fp, [r0, #1988]	; 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800d1e0:	fb99 f2fb 	sdiv	r2, r9, fp
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800d1e4:	eb08 0904 	add.w	r9, r8, r4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800d1e8:	f8c0 27c8 	str.w	r2, [r0, #1992]	; 0x7c8
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800d1ec:	4a24      	ldr	r2, [pc, #144]	; (800d280 <xmp3fixpt_UnpackFrameHeader+0x1c8>)
 800d1ee:	f852 2029 	ldr.w	r2, [r2, r9, lsl #2]
 800d1f2:	f8c0 27c0 	str.w	r2, [r0, #1984]	; 0x7c0
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 800d1f6:	b33f      	cbz	r7, 800d248 <xmp3fixpt_UnpackFrameHeader+0x190>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d1f8:	ebc8 1808 	rsb	r8, r8, r8, lsl #4
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800d1fc:	f1be 0f03 	cmp.w	lr, #3
 800d200:	bf0c      	ite	eq
 800d202:	4652      	moveq	r2, sl
 800d204:	f10a 0201 	addne.w	r2, sl, #1
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d208:	ebcc 1c0c 	rsb	ip, ip, ip, lsl #4
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d20c:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d210:	44c4      	add	ip, r8
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d212:	4444      	add	r4, r8
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d214:	44bc      	add	ip, r7
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d216:	443c      	add	r4, r7
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d218:	4f1a      	ldr	r7, [pc, #104]	; (800d284 <xmp3fixpt_UnpackFrameHeader+0x1cc>)
 800d21a:	f937 701c 	ldrsh.w	r7, [r7, ip, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d21e:	f8df c070 	ldr.w	ip, [pc, #112]	; 800d290 <xmp3fixpt_UnpackFrameHeader+0x1d8>
 800d222:	f93c 4014 	ldrsh.w	r4, [ip, r4, lsl #1]
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800d226:	ebc7 1c47 	rsb	ip, r7, r7, lsl #5
 800d22a:	eb07 078c 	add.w	r7, r7, ip, lsl #2
 800d22e:	00ff      	lsls	r7, r7, #3
 800d230:	f8c0 77b8 	str.w	r7, [r0, #1976]	; 0x7b8
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800d234:	4f14      	ldr	r7, [pc, #80]	; (800d288 <xmp3fixpt_UnpackFrameHeader+0x1d0>)
 800d236:	f937 2012 	ldrsh.w	r2, [r7, r2, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d23a:	1aa2      	subs	r2, r4, r2
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800d23c:	1f14      	subs	r4, r2, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 800d23e:	b105      	cbz	r5, 800d242 <xmp3fixpt_UnpackFrameHeader+0x18a>
 800d240:	1f94      	subs	r4, r2, #6
 800d242:	4426      	add	r6, r4
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800d244:	f8c0 67cc 	str.w	r6, [r0, #1996]	; 0x7cc
	}

	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
 800d248:	b16d      	cbz	r5, 800d266 <xmp3fixpt_UnpackFrameHeader+0x1ae>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 800d24a:	888a      	ldrh	r2, [r1, #4]
		return 6;
 800d24c:	2006      	movs	r0, #6
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 800d24e:	ba52      	rev16	r2, r2
 800d250:	b292      	uxth	r2, r2
 800d252:	631a      	str	r2, [r3, #48]	; 0x30
	} else {
		fh->CRCWord = 0;
		return 4;
	}
}
 800d254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d258:	43d2      	mvns	r2, r2
 800d25a:	f002 0201 	and.w	r2, r2, #1
 800d25e:	e745      	b.n	800d0ec <xmp3fixpt_UnpackFrameHeader+0x34>
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800d260:	f04f 0802 	mov.w	r8, #2
 800d264:	e7a3      	b.n	800d1ae <xmp3fixpt_UnpackFrameHeader+0xf6>
		return 4;
 800d266:	2004      	movs	r0, #4
		fh->CRCWord = 0;
 800d268:	631d      	str	r5, [r3, #48]	; 0x30
}
 800d26a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -1;
 800d26e:	f04f 30ff 	mov.w	r0, #4294967295
 800d272:	e7ef      	b.n	800d254 <xmp3fixpt_UnpackFrameHeader+0x19c>
 800d274:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d278:	4770      	bx	lr
 800d27a:	bf00      	nop
 800d27c:	08022730 	.word	0x08022730
 800d280:	0802270c 	.word	0x0802270c
 800d284:	080225fc 	.word	0x080225fc
 800d288:	080229e0 	.word	0x080229e0
 800d28c:	08022744 	.word	0x08022744
 800d290:	080229ec 	.word	0x080229ec

0800d294 <xmp3fixpt_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 800d294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d298:	b08b      	sub	sp, #44	; 0x2c
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 800d29a:	2800      	cmp	r0, #0
 800d29c:	f001 806d 	beq.w	800e37a <xmp3fixpt_UnpackSideInfo+0x10e6>
 800d2a0:	f8d0 b000 	ldr.w	fp, [r0]
 800d2a4:	4606      	mov	r6, r0
 800d2a6:	f1bb 0f00 	cmp.w	fp, #0
 800d2aa:	f001 8066 	beq.w	800e37a <xmp3fixpt_UnpackSideInfo+0x10e6>
 800d2ae:	6844      	ldr	r4, [r0, #4]
 800d2b0:	9404      	str	r4, [sp, #16]
 800d2b2:	2c00      	cmp	r4, #0
 800d2b4:	f001 8061 	beq.w	800e37a <xmp3fixpt_UnpackSideInfo+0x10e6>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));

	bsi = &bitStreamInfo;
	if (fh->ver == MPEG1) {
 800d2b8:	f89b 8000 	ldrb.w	r8, [fp]
 800d2bc:	f1b8 0f00 	cmp.w	r8, #0
 800d2c0:	f000 80eb 	beq.w	800d49a <xmp3fixpt_UnpackSideInfo+0x206>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
			for (bd = 0; bd < MAX_SCFBD; bd++)
				si->scfsi[ch][bd] = GetBits(bsi, 1);
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800d2c4:	f89b 201c 	ldrb.w	r2, [fp, #28]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800d2c8:	2300      	movs	r3, #0
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 8);
 800d2ca:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 800d2cc:	9106      	str	r1, [sp, #24]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800d2ce:	2a03      	cmp	r2, #3
		si->mainDataBegin = GetBits(bsi, 8);
 800d2d0:	f04f 0108 	mov.w	r1, #8
 800d2d4:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 800d2d6:	e9cd 3307 	strd	r3, r3, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800d2da:	bf0c      	ite	eq
 800d2dc:	2309      	moveq	r3, #9
 800d2de:	2311      	movne	r3, #17
 800d2e0:	9305      	str	r3, [sp, #20]
	bsi->nBytes = nBytes;
 800d2e2:	9309      	str	r3, [sp, #36]	; 0x24
		si->mainDataBegin = GetBits(bsi, 8);
 800d2e4:	f7ff fe6a 	bl	800cfbc <xmp3fixpt_GetBits>
 800d2e8:	9c04      	ldr	r4, [sp, #16]
 800d2ea:	6020      	str	r0, [r4, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 800d2ec:	4628      	mov	r0, r5
 800d2ee:	f89b 301c 	ldrb.w	r3, [fp, #28]
 800d2f2:	2b03      	cmp	r3, #3
 800d2f4:	bf0c      	ite	eq
 800d2f6:	2101      	moveq	r1, #1
 800d2f8:	2102      	movne	r1, #2
 800d2fa:	f7ff fe5f 	bl	800cfbc <xmp3fixpt_GetBits>
 800d2fe:	6060      	str	r0, [r4, #4]
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800d300:	f8d6 37c4 	ldr.w	r3, [r6, #1988]	; 0x7c4
 800d304:	2b00      	cmp	r3, #0
 800d306:	f340 80c0 	ble.w	800d48a <xmp3fixpt_UnpackSideInfo+0x1f6>
 800d30a:	9a04      	ldr	r2, [sp, #16]
 800d30c:	46b2      	mov	sl, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d30e:	f8d6 37bc 	ldr.w	r3, [r6, #1980]	; 0x7bc
 800d312:	9202      	str	r2, [sp, #8]
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800d314:	2200      	movs	r2, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d316:	2b00      	cmp	r3, #0
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800d318:	9203      	str	r2, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d31a:	f340 80b5 	ble.w	800d488 <xmp3fixpt_UnpackSideInfo+0x1f4>
 800d31e:	9c02      	ldr	r4, [sp, #8]
 800d320:	2600      	movs	r6, #0
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */

			sis->part23Length =    GetBits(bsi, 12);
 800d322:	210c      	movs	r1, #12
 800d324:	4628      	mov	r0, r5
 800d326:	f7ff fe49 	bl	800cfbc <xmp3fixpt_GetBits>
			sis->nBigvals =        GetBits(bsi, 9);
 800d32a:	2109      	movs	r1, #9
			sis->part23Length =    GetBits(bsi, 12);
 800d32c:	62a0      	str	r0, [r4, #40]	; 0x28
			sis->nBigvals =        GetBits(bsi, 9);
 800d32e:	4628      	mov	r0, r5
 800d330:	f7ff fe44 	bl	800cfbc <xmp3fixpt_GetBits>
			sis->globalGain =      GetBits(bsi, 8);
 800d334:	2108      	movs	r1, #8
			sis->nBigvals =        GetBits(bsi, 9);
 800d336:	62e0      	str	r0, [r4, #44]	; 0x2c
			sis->globalGain =      GetBits(bsi, 8);
 800d338:	4628      	mov	r0, r5
 800d33a:	f7ff fe3f 	bl	800cfbc <xmp3fixpt_GetBits>
 800d33e:	6320      	str	r0, [r4, #48]	; 0x30
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 800d340:	f89b 3000 	ldrb.w	r3, [fp]
 800d344:	4628      	mov	r0, r5
 800d346:	2b00      	cmp	r3, #0
 800d348:	bf0c      	ite	eq
 800d34a:	2104      	moveq	r1, #4
 800d34c:	2109      	movne	r1, #9
 800d34e:	f7ff fe35 	bl	800cfbc <xmp3fixpt_GetBits>
 800d352:	6360      	str	r0, [r4, #52]	; 0x34
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d354:	e9dd 0107 	ldrd	r0, r1, [sp, #28]
 800d358:	f101 3eff 	add.w	lr, r1, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d35c:	0043      	lsls	r3, r0, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d35e:	0fc0      	lsrs	r0, r0, #31
	if (bsi->cachedBits < 0) {
 800d360:	f1be 0f00 	cmp.w	lr, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d364:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d366:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d36a:	f2c0 8155 	blt.w	800d618 <xmp3fixpt_UnpackSideInfo+0x384>
			sis->winSwitchFlag =   GetBits(bsi, 1);
 800d36e:	63a0      	str	r0, [r4, #56]	; 0x38

			if(sis->winSwitchFlag) {
 800d370:	2800      	cmp	r0, #0
 800d372:	f000 80d1 	beq.w	800d518 <xmp3fixpt_UnpackSideInfo+0x284>
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 800d376:	2102      	movs	r1, #2
 800d378:	4628      	mov	r0, r5
 800d37a:	f7ff fe1f 	bl	800cfbc <xmp3fixpt_GetBits>
 800d37e:	63e0      	str	r0, [r4, #60]	; 0x3c
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d380:	e9dd 3e07 	ldrd	r3, lr, [sp, #28]
 800d384:	f10e 31ff 	add.w	r1, lr, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d388:	005a      	lsls	r2, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d38a:	0fdf      	lsrs	r7, r3, #31
	if (bsi->cachedBits < 0) {
 800d38c:	2900      	cmp	r1, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d38e:	9207      	str	r2, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d390:	9108      	str	r1, [sp, #32]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d392:	9701      	str	r7, [sp, #4]
	if (bsi->cachedBits < 0) {
 800d394:	f2c0 821a 	blt.w	800d7cc <xmp3fixpt_UnpackSideInfo+0x538>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d398:	ea4f 6cd2 	mov.w	ip, r2, lsr #27
 800d39c:	463a      	mov	r2, r7
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d39e:	019b      	lsls	r3, r3, #6
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 800d3a0:	6422      	str	r2, [r4, #64]	; 0x40
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3a2:	1f4a      	subs	r2, r1, #5
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3a4:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d3a6:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3a8:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d3aa:	f2c0 81d8 	blt.w	800d75e <xmp3fixpt_UnpackSideInfo+0x4ca>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d3ae:	ea4f 6ed3 	mov.w	lr, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3b2:	015b      	lsls	r3, r3, #5
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3b4:	1f51      	subs	r1, r2, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800d3b6:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3ba:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d3bc:	2900      	cmp	r1, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3be:	9108      	str	r1, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d3c0:	f2c0 83c9 	blt.w	800db56 <xmp3fixpt_UnpackSideInfo+0x8c2>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d3c4:	0f5a      	lsrs	r2, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3c6:	00db      	lsls	r3, r3, #3
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800d3c8:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3cc:	f1a1 0c03 	sub.w	ip, r1, #3
				sis->tableSelect[2] =  0;					/* unused */
 800d3d0:	f04f 0e00 	mov.w	lr, #0
	if (bsi->cachedBits < 0) {
 800d3d4:	45f4      	cmp	ip, lr
				sis->tableSelect[2] =  0;					/* unused */
 800d3d6:	f8c4 e04c 	str.w	lr, [r4, #76]	; 0x4c
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3da:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3dc:	f8cd c020 	str.w	ip, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d3e0:	f2c0 8382 	blt.w	800dae8 <xmp3fixpt_UnpackSideInfo+0x854>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d3e4:	ea4f 7e53 	mov.w	lr, r3, lsr #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3e8:	00db      	lsls	r3, r3, #3
				sis->subBlockGain[0] = GetBits(bsi, 3);
 800d3ea:	6522      	str	r2, [r4, #80]	; 0x50
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3ec:	f1ac 0203 	sub.w	r2, ip, #3
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3f0:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d3f2:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d3f4:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d3f6:	f2c0 8341 	blt.w	800da7c <xmp3fixpt_UnpackSideInfo+0x7e8>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d3fa:	0f59      	lsrs	r1, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3fc:	00db      	lsls	r3, r3, #3
				sis->subBlockGain[1] = GetBits(bsi, 3);
 800d3fe:	f8c4 e054 	str.w	lr, [r4, #84]	; 0x54
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d402:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d404:	1ed3      	subs	r3, r2, #3
	if (bsi->cachedBits < 0) {
 800d406:	2b00      	cmp	r3, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d408:	9308      	str	r3, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d40a:	f2c0 82fe 	blt.w	800da0a <xmp3fixpt_UnpackSideInfo+0x776>
				sis->subBlockGain[2] = GetBits(bsi, 3);
 800d40e:	65a1      	str	r1, [r4, #88]	; 0x58

				/* TODO - check logic */
				if (sis->blockType == 0) {
 800d410:	2800      	cmp	r0, #0
 800d412:	f040 819a 	bne.w	800d74a <xmp3fixpt_UnpackSideInfo+0x4b6>
					sis->region0Count = 8;
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
				}
				sis->region1Count = 20 - sis->region0Count;
 800d416:	6de3      	ldr	r3, [r4, #92]	; 0x5c
					sis->sfCompress = 0;
 800d418:	6360      	str	r0, [r4, #52]	; 0x34
				sis->region1Count = 20 - sis->region0Count;
 800d41a:	f1c3 0314 	rsb	r3, r3, #20
					sis->part23Length = 0;
 800d41e:	e9c4 000a 	strd	r0, r0, [r4, #40]	; 0x28
				sis->region1Count = 20 - sis->region0Count;
 800d422:	6623      	str	r3, [r4, #96]	; 0x60
				sis->tableSelect[1] =  GetBits(bsi, 5);
				sis->tableSelect[2] =  GetBits(bsi, 5);
				sis->region0Count =    GetBits(bsi, 4);
				sis->region1Count =    GetBits(bsi, 3);
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800d424:	f89b 2000 	ldrb.w	r2, [fp]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d428:	e9dd 3c07 	ldrd	r3, ip, [sp, #28]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d42c:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d42e:	005b      	lsls	r3, r3, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800d430:	2a00      	cmp	r2, #0
 800d432:	f000 80ae 	beq.w	800d592 <xmp3fixpt_UnpackSideInfo+0x2fe>
 800d436:	2200      	movs	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d438:	f10c 37ff 	add.w	r7, ip, #4294967295
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800d43c:	6662      	str	r2, [r4, #100]	; 0x64
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d43e:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d440:	2f00      	cmp	r7, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d442:	9708      	str	r7, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d444:	f2c0 8147 	blt.w	800d6d6 <xmp3fixpt_UnpackSideInfo+0x442>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d448:	0fd8      	lsrs	r0, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d44a:	005b      	lsls	r3, r3, #1
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d44c:	1e7a      	subs	r2, r7, #1
			sis->sfactScale =        GetBits(bsi, 1);
 800d44e:	66a1      	str	r1, [r4, #104]	; 0x68
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d450:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d452:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d454:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d456:	f2c0 810f 	blt.w	800d678 <xmp3fixpt_UnpackSideInfo+0x3e4>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d45a:	3601      	adds	r6, #1
 800d45c:	f8da 37bc 	ldr.w	r3, [sl, #1980]	; 0x7bc
			sis->count1TableSelect = GetBits(bsi, 1);
 800d460:	66e0      	str	r0, [r4, #108]	; 0x6c
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d462:	3448      	adds	r4, #72	; 0x48
 800d464:	42b3      	cmp	r3, r6
 800d466:	f73f af5c 	bgt.w	800d322 <xmp3fixpt_UnpackSideInfo+0x8e>
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800d46a:	9a03      	ldr	r2, [sp, #12]
 800d46c:	3201      	adds	r2, #1
 800d46e:	4611      	mov	r1, r2
 800d470:	9203      	str	r2, [sp, #12]
 800d472:	f8da 27c4 	ldr.w	r2, [sl, #1988]	; 0x7c4
 800d476:	4291      	cmp	r1, r2
 800d478:	da06      	bge.n	800d488 <xmp3fixpt_UnpackSideInfo+0x1f4>
 800d47a:	9a02      	ldr	r2, [sp, #8]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d47c:	2b00      	cmp	r3, #0
 800d47e:	f102 0290 	add.w	r2, r2, #144	; 0x90
 800d482:	9202      	str	r2, [sp, #8]
 800d484:	f73f af4b 	bgt.w	800d31e <xmp3fixpt_UnpackSideInfo+0x8a>
 800d488:	4656      	mov	r6, sl
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 800d48a:	9b04      	ldr	r3, [sp, #16]
 800d48c:	681b      	ldr	r3, [r3, #0]
 800d48e:	f8c6 37d8 	str.w	r3, [r6, #2008]	; 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
}
 800d492:	9805      	ldr	r0, [sp, #20]
 800d494:	b00b      	add	sp, #44	; 0x2c
 800d496:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d49a:	f89b 301c 	ldrb.w	r3, [fp, #28]
		si->mainDataBegin = GetBits(bsi, 9);
 800d49e:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 800d4a0:	9106      	str	r1, [sp, #24]
		si->mainDataBegin = GetBits(bsi, 9);
 800d4a2:	2109      	movs	r1, #9
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d4a4:	2b03      	cmp	r3, #3
		si->mainDataBegin = GetBits(bsi, 9);
 800d4a6:	4628      	mov	r0, r5
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d4a8:	bf0c      	ite	eq
 800d4aa:	2311      	moveq	r3, #17
 800d4ac:	2320      	movne	r3, #32
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 800d4ae:	e9cd 8807 	strd	r8, r8, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d4b2:	9305      	str	r3, [sp, #20]
	bsi->nBytes = nBytes;
 800d4b4:	9309      	str	r3, [sp, #36]	; 0x24
		si->mainDataBegin = GetBits(bsi, 9);
 800d4b6:	f7ff fd81 	bl	800cfbc <xmp3fixpt_GetBits>
 800d4ba:	6020      	str	r0, [r4, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 800d4bc:	4628      	mov	r0, r5
 800d4be:	f89b 301c 	ldrb.w	r3, [fp, #28]
 800d4c2:	2b03      	cmp	r3, #3
 800d4c4:	bf0c      	ite	eq
 800d4c6:	2105      	moveq	r1, #5
 800d4c8:	2103      	movne	r1, #3
 800d4ca:	f7ff fd77 	bl	800cfbc <xmp3fixpt_GetBits>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d4ce:	f8d6 37bc 	ldr.w	r3, [r6, #1980]	; 0x7bc
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 800d4d2:	6060      	str	r0, [r4, #4]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d4d4:	2b00      	cmp	r3, #0
 800d4d6:	f77f af13 	ble.w	800d300 <xmp3fixpt_UnpackSideInfo+0x6c>
 800d4da:	3418      	adds	r4, #24
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d4dc:	46b4      	mov	ip, r6
 800d4de:	4646      	mov	r6, r8
 800d4e0:	eb04 1e03 	add.w	lr, r4, r3, lsl #4
 800d4e4:	e9dd a207 	ldrd	sl, r2, [sp, #28]
 800d4e8:	4653      	mov	r3, sl
 800d4ea:	f1a4 0010 	sub.w	r0, r4, #16
 800d4ee:	ee07 5a90 	vmov	s15, r5
 800d4f2:	1e51      	subs	r1, r2, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d4f4:	0fdf      	lsrs	r7, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d4f6:	005b      	lsls	r3, r3, #1
	if (bsi->cachedBits < 0) {
 800d4f8:	2900      	cmp	r1, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d4fa:	9108      	str	r1, [sp, #32]
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d4fc:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d4fe:	db56      	blt.n	800d5ae <xmp3fixpt_UnpackSideInfo+0x31a>
 800d500:	460a      	mov	r2, r1
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 800d502:	f840 7b04 	str.w	r7, [r0], #4
			for (bd = 0; bd < MAX_SCFBD; bd++)
 800d506:	4284      	cmp	r4, r0
 800d508:	d1f3      	bne.n	800d4f2 <xmp3fixpt_UnpackSideInfo+0x25e>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d50a:	3410      	adds	r4, #16
 800d50c:	ee17 5a90 	vmov	r5, s15
 800d510:	4574      	cmp	r4, lr
 800d512:	d1ea      	bne.n	800d4ea <xmp3fixpt_UnpackSideInfo+0x256>
 800d514:	4666      	mov	r6, ip
 800d516:	e6f3      	b.n	800d300 <xmp3fixpt_UnpackSideInfo+0x6c>
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d518:	f1ae 0705 	sub.w	r7, lr, #5
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d51c:	0159      	lsls	r1, r3, #5
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d51e:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	if (bsi->cachedBits < 0) {
 800d522:	2f00      	cmp	r7, #0
				sis->mixedBlock = 0;
 800d524:	e9c4 000f 	strd	r0, r0, [r4, #60]	; 0x3c
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d528:	9107      	str	r1, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d52a:	9708      	str	r7, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d52c:	f2c0 83e3 	blt.w	800dcf6 <xmp3fixpt_UnpackSideInfo+0xa62>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d530:	0ec9      	lsrs	r1, r1, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d532:	029b      	lsls	r3, r3, #10
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d534:	1f7a      	subs	r2, r7, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800d536:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d53a:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d53c:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d53e:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d540:	f2c0 8375 	blt.w	800dc2e <xmp3fixpt_UnpackSideInfo+0x99a>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d544:	0ed8      	lsrs	r0, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d546:	015b      	lsls	r3, r3, #5
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d548:	f1a2 0e05 	sub.w	lr, r2, #5
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800d54c:	64a1      	str	r1, [r4, #72]	; 0x48
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d54e:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d550:	f1be 0f00 	cmp.w	lr, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d554:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d558:	f2c0 839a 	blt.w	800dc90 <xmp3fixpt_UnpackSideInfo+0x9fc>
				sis->region0Count =    GetBits(bsi, 4);
 800d55c:	2104      	movs	r1, #4
				sis->tableSelect[2] =  GetBits(bsi, 5);
 800d55e:	64e0      	str	r0, [r4, #76]	; 0x4c
				sis->region0Count =    GetBits(bsi, 4);
 800d560:	4628      	mov	r0, r5
 800d562:	f7ff fd2b 	bl	800cfbc <xmp3fixpt_GetBits>
 800d566:	65e0      	str	r0, [r4, #92]	; 0x5c
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d568:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
 800d56c:	f1a2 0c03 	sub.w	ip, r2, #3
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d570:	00d9      	lsls	r1, r3, #3
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d572:	0f58      	lsrs	r0, r3, #29
	if (bsi->cachedBits < 0) {
 800d574:	f1bc 0f00 	cmp.w	ip, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d578:	9107      	str	r1, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d57a:	f8cd c020 	str.w	ip, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d57e:	f2c0 8322 	blt.w	800dbc6 <xmp3fixpt_UnpackSideInfo+0x932>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d582:	0fc9      	lsrs	r1, r1, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d584:	011b      	lsls	r3, r3, #4
				sis->region1Count =    GetBits(bsi, 3);
 800d586:	6620      	str	r0, [r4, #96]	; 0x60
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800d588:	f89b 2000 	ldrb.w	r2, [fp]
 800d58c:	2a00      	cmp	r2, #0
 800d58e:	f47f af52 	bne.w	800d436 <xmp3fixpt_UnpackSideInfo+0x1a2>
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d592:	f10c 3eff 	add.w	lr, ip, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d596:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d598:	f1be 0f00 	cmp.w	lr, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d59c:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d5a0:	f2c0 83dd 	blt.w	800dd5e <xmp3fixpt_UnpackSideInfo+0xaca>
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d5a4:	460a      	mov	r2, r1
 800d5a6:	46f4      	mov	ip, lr
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d5a8:	0fd9      	lsrs	r1, r3, #31
 800d5aa:	005b      	lsls	r3, r3, #1
 800d5ac:	e744      	b.n	800d438 <xmp3fixpt_UnpackSideInfo+0x1a4>
	int nBytes = bsi->nBytes;
 800d5ae:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d5b2:	f1c2 0801 	rsb	r8, r2, #1
	if (nBytes >= 4) {
 800d5b6:	f1b9 0f03 	cmp.w	r9, #3
 800d5ba:	f340 81f1 	ble.w	800d9a0 <xmp3fixpt_UnpackSideInfo+0x70c>
		bsi->nBytes -= 4;
 800d5be:	f1a9 0304 	sub.w	r3, r9, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d5c2:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800d5c6:	321f      	adds	r2, #31
 800d5c8:	46ca      	mov	sl, r9
 800d5ca:	f109 0101 	add.w	r1, r9, #1
 800d5ce:	9106      	str	r1, [sp, #24]
 800d5d0:	f81a 1b02 	ldrb.w	r1, [sl], #2
 800d5d4:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5d6:	f8cd a018 	str.w	sl, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d5da:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5dc:	f899 a001 	ldrb.w	sl, [r9, #1]
 800d5e0:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5e4:	f109 0a03 	add.w	sl, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5e8:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5ea:	f8cd a018 	str.w	sl, [sp, #24]
 800d5ee:	f899 a002 	ldrb.w	sl, [r9, #2]
 800d5f2:	ea41 2a0a 	orr.w	sl, r1, sl, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d5f6:	f109 0104 	add.w	r1, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5fa:	f8cd a01c 	str.w	sl, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d5fe:	9106      	str	r1, [sp, #24]
 800d600:	f899 1003 	ldrb.w	r1, [r9, #3]
		bsi->nBytes -= 4;
 800d604:	9309      	str	r3, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d606:	ea41 010a 	orr.w	r1, r1, sl
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d60a:	fa01 f308 	lsl.w	r3, r1, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d60e:	40d1      	lsrs	r1, r2
 800d610:	430f      	orrs	r7, r1
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d612:	e9cd 3207 	strd	r3, r2, [sp, #28]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d616:	e774      	b.n	800d502 <xmp3fixpt_UnpackSideInfo+0x26e>
	int nBytes = bsi->nBytes;
 800d618:	9a09      	ldr	r2, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d61a:	f1c1 0301 	rsb	r3, r1, #1
	if (nBytes >= 4) {
 800d61e:	2a03      	cmp	r2, #3
 800d620:	f340 814c 	ble.w	800d8bc <xmp3fixpt_UnpackSideInfo+0x628>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d624:	9f06      	ldr	r7, [sp, #24]
 800d626:	f101 0e1f 	add.w	lr, r1, #31
		bsi->nBytes -= 4;
 800d62a:	1f11      	subs	r1, r2, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d62c:	46bc      	mov	ip, r7
 800d62e:	1c7a      	adds	r2, r7, #1
 800d630:	9206      	str	r2, [sp, #24]
 800d632:	f81c 2b02 	ldrb.w	r2, [ip], #2
 800d636:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d638:	f8cd c018 	str.w	ip, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d63c:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d63e:	f897 c001 	ldrb.w	ip, [r7, #1]
 800d642:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d646:	f107 0c03 	add.w	ip, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d64a:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d64c:	f8cd c018 	str.w	ip, [sp, #24]
 800d650:	f897 c002 	ldrb.w	ip, [r7, #2]
 800d654:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d658:	f107 0c04 	add.w	ip, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d65c:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d65e:	f8cd c018 	str.w	ip, [sp, #24]
 800d662:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d664:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d666:	433a      	orrs	r2, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d668:	fa02 f303 	lsl.w	r3, r2, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d66c:	fa22 f20e 	lsr.w	r2, r2, lr
 800d670:	4310      	orrs	r0, r2
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d672:	e9cd 3e07 	strd	r3, lr, [sp, #28]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d676:	e67a      	b.n	800d36e <xmp3fixpt_UnpackSideInfo+0xda>
	int nBytes = bsi->nBytes;
 800d678:	9909      	ldr	r1, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d67a:	f1c7 0c01 	rsb	ip, r7, #1
	if (nBytes >= 4) {
 800d67e:	2903      	cmp	r1, #3
 800d680:	f340 8154 	ble.w	800d92c <xmp3fixpt_UnpackSideInfo+0x698>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d684:	f107 021f 	add.w	r2, r7, #31
 800d688:	9f06      	ldr	r7, [sp, #24]
		bsi->nBytes -= 4;
 800d68a:	3904      	subs	r1, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d68c:	46be      	mov	lr, r7
 800d68e:	1c7b      	adds	r3, r7, #1
 800d690:	9306      	str	r3, [sp, #24]
 800d692:	f81e 3b02 	ldrb.w	r3, [lr], #2
 800d696:	061b      	lsls	r3, r3, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d698:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d69c:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d69e:	f897 e001 	ldrb.w	lr, [r7, #1]
 800d6a2:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6a6:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d6aa:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6ac:	f8cd e018 	str.w	lr, [sp, #24]
 800d6b0:	f897 e002 	ldrb.w	lr, [r7, #2]
 800d6b4:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d6b8:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6bc:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d6be:	f8cd e018 	str.w	lr, [sp, #24]
 800d6c2:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d6c4:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d6c6:	433b      	orrs	r3, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d6c8:	fa03 f70c 	lsl.w	r7, r3, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d6cc:	40d3      	lsrs	r3, r2
 800d6ce:	4318      	orrs	r0, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d6d0:	e9cd 7207 	strd	r7, r2, [sp, #28]
 800d6d4:	e6c1      	b.n	800d45a <xmp3fixpt_UnpackSideInfo+0x1c6>
	int nBytes = bsi->nBytes;
 800d6d6:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d6da:	f1cc 0001 	rsb	r0, ip, #1
	if (nBytes >= 4) {
 800d6de:	f1be 0f03 	cmp.w	lr, #3
 800d6e2:	f340 80b0 	ble.w	800d846 <xmp3fixpt_UnpackSideInfo+0x5b2>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d6e6:	f10c 021f 	add.w	r2, ip, #31
 800d6ea:	f8dd c018 	ldr.w	ip, [sp, #24]
		bsi->nBytes -= 4;
 800d6ee:	f1ae 0704 	sub.w	r7, lr, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d6f2:	4663      	mov	r3, ip
 800d6f4:	f10c 0e01 	add.w	lr, ip, #1
 800d6f8:	f8cd e018 	str.w	lr, [sp, #24]
 800d6fc:	f813 8b02 	ldrb.w	r8, [r3], #2
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d700:	9306      	str	r3, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d702:	ea4f 6308 	mov.w	r3, r8, lsl #24
 800d706:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d708:	f89c 8001 	ldrb.w	r8, [ip, #1]
 800d70c:	ea43 4808 	orr.w	r8, r3, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d710:	f10c 0303 	add.w	r3, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d714:	f8cd 801c 	str.w	r8, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d718:	9306      	str	r3, [sp, #24]
 800d71a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800d71e:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d722:	f10c 0304 	add.w	r3, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d726:	f8cd 801c 	str.w	r8, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d72a:	9306      	str	r3, [sp, #24]
 800d72c:	f89c 3003 	ldrb.w	r3, [ip, #3]
		bsi->nBytes -= 4;
 800d730:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d732:	4617      	mov	r7, r2
		bsi->iCache |= (*bsi->bytePtr++);
 800d734:	ea43 0808 	orr.w	r8, r3, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d738:	fa08 f300 	lsl.w	r3, r8, r0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d73c:	fa28 f802 	lsr.w	r8, r8, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d740:	0fd8      	lsrs	r0, r3, #31
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d742:	ea41 0108 	orr.w	r1, r1, r8
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d746:	005b      	lsls	r3, r3, #1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d748:	e680      	b.n	800d44c <xmp3fixpt_UnpackSideInfo+0x1b8>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 800d74a:	2802      	cmp	r0, #2
 800d74c:	d103      	bne.n	800d756 <xmp3fixpt_UnpackSideInfo+0x4c2>
 800d74e:	9b01      	ldr	r3, [sp, #4]
 800d750:	2b00      	cmp	r3, #0
 800d752:	f000 85fc 	beq.w	800e34e <xmp3fixpt_UnpackSideInfo+0x10ba>
					sis->region0Count = 7;
 800d756:	2307      	movs	r3, #7
 800d758:	65e3      	str	r3, [r4, #92]	; 0x5c
 800d75a:	230d      	movs	r3, #13
 800d75c:	e661      	b.n	800d422 <xmp3fixpt_UnpackSideInfo+0x18e>
	int nBytes = bsi->nBytes;
 800d75e:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d762:	f1c1 0305 	rsb	r3, r1, #5
	if (nBytes >= 4) {
 800d766:	f1b8 0f03 	cmp.w	r8, #3
 800d76a:	f340 84eb 	ble.w	800e144 <xmp3fixpt_UnpackSideInfo+0xeb0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d76e:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800d772:	f101 021b 	add.w	r2, r1, #27
		bsi->nBytes -= 4;
 800d776:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d77a:	46ce      	mov	lr, r9
 800d77c:	f109 0101 	add.w	r1, r9, #1
 800d780:	9106      	str	r1, [sp, #24]
 800d782:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800d786:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d788:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d78c:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d78e:	f899 e001 	ldrb.w	lr, [r9, #1]
 800d792:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d796:	f109 0e03 	add.w	lr, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d79a:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d79c:	f8cd e018 	str.w	lr, [sp, #24]
 800d7a0:	f899 e002 	ldrb.w	lr, [r9, #2]
 800d7a4:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d7a8:	f109 0e04 	add.w	lr, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d7ac:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d7ae:	f8cd e018 	str.w	lr, [sp, #24]
 800d7b2:	f899 e003 	ldrb.w	lr, [r9, #3]
		bsi->nBytes -= 4;
 800d7b6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d7ba:	ea4e 0e01 	orr.w	lr, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d7be:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d7c2:	fa2e fe02 	lsr.w	lr, lr, r2
 800d7c6:	ea4c 0c0e 	orr.w	ip, ip, lr
 800d7ca:	e5f0      	b.n	800d3ae <xmp3fixpt_UnpackSideInfo+0x11a>
	int nBytes = bsi->nBytes;
 800d7cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d7ce:	f1ce 0301 	rsb	r3, lr, #1
	if (nBytes >= 4) {
 800d7d2:	2a03      	cmp	r2, #3
 800d7d4:	f340 84fa 	ble.w	800e1cc <xmp3fixpt_UnpackSideInfo+0xf38>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7d8:	f10e 011f 	add.w	r1, lr, #31
 800d7dc:	f8dd e018 	ldr.w	lr, [sp, #24]
		bsi->nBytes -= 4;
 800d7e0:	3a04      	subs	r2, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7e2:	46f0      	mov	r8, lr
 800d7e4:	f10e 0c01 	add.w	ip, lr, #1
 800d7e8:	f8cd c018 	str.w	ip, [sp, #24]
 800d7ec:	f818 cb02 	ldrb.w	ip, [r8], #2
 800d7f0:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d7f4:	f8cd 8018 	str.w	r8, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7f8:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d7fc:	f89e 8001 	ldrb.w	r8, [lr, #1]
 800d800:	ea4c 4c08 	orr.w	ip, ip, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d804:	f10e 0803 	add.w	r8, lr, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d808:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d80c:	f8cd 8018 	str.w	r8, [sp, #24]
 800d810:	f89e 8002 	ldrb.w	r8, [lr, #2]
 800d814:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d818:	f10e 0804 	add.w	r8, lr, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d81c:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d820:	f8cd 8018 	str.w	r8, [sp, #24]
 800d824:	f89e e003 	ldrb.w	lr, [lr, #3]
		bsi->nBytes -= 4;
 800d828:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d82a:	ea4e 0c0c 	orr.w	ip, lr, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d82e:	9a01      	ldr	r2, [sp, #4]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d830:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d834:	fa2c fc01 	lsr.w	ip, ip, r1
 800d838:	ea42 020c 	orr.w	r2, r2, ip
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d83c:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d840:	015b      	lsls	r3, r3, #5
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d842:	9201      	str	r2, [sp, #4]
 800d844:	e5ac      	b.n	800d3a0 <xmp3fixpt_UnpackSideInfo+0x10c>
		bsi->iCache = 0;
 800d846:	2300      	movs	r3, #0
 800d848:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d84a:	f1be 0f00 	cmp.w	lr, #0
 800d84e:	f000 8583 	beq.w	800e358 <xmp3fixpt_UnpackSideInfo+0x10c4>
			bsi->iCache |= (*bsi->bytePtr++);
 800d852:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d854:	f1be 0f01 	cmp.w	lr, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d858:	f103 0201 	add.w	r2, r3, #1
 800d85c:	9206      	str	r2, [sp, #24]
 800d85e:	f893 8000 	ldrb.w	r8, [r3]
			bsi->iCache <<= 8;
 800d862:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800d866:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800d86a:	d012      	beq.n	800d892 <xmp3fixpt_UnpackSideInfo+0x5fe>
			bsi->iCache |= (*bsi->bytePtr++);
 800d86c:	1c9a      	adds	r2, r3, #2
		while (nBytes--) {
 800d86e:	f1be 0f02 	cmp.w	lr, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d872:	9206      	str	r2, [sp, #24]
 800d874:	785a      	ldrb	r2, [r3, #1]
 800d876:	ea42 0808 	orr.w	r8, r2, r8
			bsi->iCache <<= 8;
 800d87a:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800d87e:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800d882:	d006      	beq.n	800d892 <xmp3fixpt_UnpackSideInfo+0x5fe>
			bsi->iCache |= (*bsi->bytePtr++);
 800d884:	1cda      	adds	r2, r3, #3
 800d886:	9206      	str	r2, [sp, #24]
 800d888:	789b      	ldrb	r3, [r3, #2]
 800d88a:	ea43 0808 	orr.w	r8, r3, r8
			bsi->iCache <<= 8;
 800d88e:	ea4f 2808 	mov.w	r8, r8, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d892:	f1ce 0303 	rsb	r3, lr, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d896:	f10c 021f 	add.w	r2, ip, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d89a:	00db      	lsls	r3, r3, #3
 800d89c:	fa08 f803 	lsl.w	r8, r8, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d8a0:	fa08 f300 	lsl.w	r3, r8, r0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d8a4:	fa28 f802 	lsr.w	r8, r8, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d8a8:	0fd8      	lsrs	r0, r3, #31
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d8aa:	ea41 0108 	orr.w	r1, r1, r8
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d8ae:	005b      	lsls	r3, r3, #1
		bsi->nBytes = 0;
 800d8b0:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 800d8b4:	2700      	movs	r7, #0
 800d8b6:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d8b8:	4617      	mov	r7, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d8ba:	e5c7      	b.n	800d44c <xmp3fixpt_UnpackSideInfo+0x1b8>
		bsi->iCache = 0;
 800d8bc:	2700      	movs	r7, #0
 800d8be:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800d8c0:	2a00      	cmp	r2, #0
 800d8c2:	f000 8550 	beq.w	800e366 <xmp3fixpt_UnpackSideInfo+0x10d2>
			bsi->iCache |= (*bsi->bytePtr++);
 800d8c6:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800d8ca:	2a01      	cmp	r2, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d8cc:	f108 0701 	add.w	r7, r8, #1
 800d8d0:	9706      	str	r7, [sp, #24]
 800d8d2:	f898 7000 	ldrb.w	r7, [r8]
			bsi->iCache <<= 8;
 800d8d6:	ea4f 2c07 	mov.w	ip, r7, lsl #8
 800d8da:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d8de:	d015      	beq.n	800d90c <xmp3fixpt_UnpackSideInfo+0x678>
			bsi->iCache |= (*bsi->bytePtr++);
 800d8e0:	f108 0702 	add.w	r7, r8, #2
		while (nBytes--) {
 800d8e4:	2a02      	cmp	r2, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d8e6:	9706      	str	r7, [sp, #24]
 800d8e8:	f898 7001 	ldrb.w	r7, [r8, #1]
 800d8ec:	ea47 070c 	orr.w	r7, r7, ip
			bsi->iCache <<= 8;
 800d8f0:	ea4f 2c07 	mov.w	ip, r7, lsl #8
 800d8f4:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d8f8:	d008      	beq.n	800d90c <xmp3fixpt_UnpackSideInfo+0x678>
			bsi->iCache |= (*bsi->bytePtr++);
 800d8fa:	f108 0703 	add.w	r7, r8, #3
 800d8fe:	9706      	str	r7, [sp, #24]
 800d900:	f898 7002 	ldrb.w	r7, [r8, #2]
 800d904:	ea47 070c 	orr.w	r7, r7, ip
			bsi->iCache <<= 8;
 800d908:	ea4f 2c07 	mov.w	ip, r7, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d90c:	f1c2 0703 	rsb	r7, r2, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d910:	311f      	adds	r1, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d912:	00ff      	lsls	r7, r7, #3
 800d914:	fa0c f707 	lsl.w	r7, ip, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d918:	fa27 f101 	lsr.w	r1, r7, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d91c:	fa07 f303 	lsl.w	r3, r7, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d920:	4308      	orrs	r0, r1
		bsi->nBytes = 0;
 800d922:	eb0e 0ec2 	add.w	lr, lr, r2, lsl #3
 800d926:	2200      	movs	r2, #0
 800d928:	9209      	str	r2, [sp, #36]	; 0x24
 800d92a:	e6a2      	b.n	800d672 <xmp3fixpt_UnpackSideInfo+0x3de>
		bsi->iCache = 0;
 800d92c:	2300      	movs	r3, #0
 800d92e:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d930:	2900      	cmp	r1, #0
 800d932:	f000 8515 	beq.w	800e360 <xmp3fixpt_UnpackSideInfo+0x10cc>
			bsi->iCache |= (*bsi->bytePtr++);
 800d936:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d938:	2901      	cmp	r1, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d93a:	f103 0e01 	add.w	lr, r3, #1
 800d93e:	f8cd e018 	str.w	lr, [sp, #24]
 800d942:	f893 e000 	ldrb.w	lr, [r3]
			bsi->iCache <<= 8;
 800d946:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800d94a:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800d94e:	d016      	beq.n	800d97e <xmp3fixpt_UnpackSideInfo+0x6ea>
			bsi->iCache |= (*bsi->bytePtr++);
 800d950:	f103 0802 	add.w	r8, r3, #2
		while (nBytes--) {
 800d954:	2902      	cmp	r1, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d956:	f8cd 8018 	str.w	r8, [sp, #24]
 800d95a:	f893 8001 	ldrb.w	r8, [r3, #1]
 800d95e:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800d962:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800d966:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800d96a:	d008      	beq.n	800d97e <xmp3fixpt_UnpackSideInfo+0x6ea>
			bsi->iCache |= (*bsi->bytePtr++);
 800d96c:	f103 0803 	add.w	r8, r3, #3
 800d970:	f8cd 8018 	str.w	r8, [sp, #24]
 800d974:	789b      	ldrb	r3, [r3, #2]
 800d976:	ea43 0e0e 	orr.w	lr, r3, lr
			bsi->iCache <<= 8;
 800d97a:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d97e:	f107 031f 	add.w	r3, r7, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d982:	f1c1 0703 	rsb	r7, r1, #3
 800d986:	00ff      	lsls	r7, r7, #3
 800d988:	fa0e f707 	lsl.w	r7, lr, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d98c:	fa27 f303 	lsr.w	r3, r7, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d990:	fa07 f70c 	lsl.w	r7, r7, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d994:	4318      	orrs	r0, r3
		bsi->nBytes = 0;
 800d996:	2300      	movs	r3, #0
 800d998:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800d99c:	9309      	str	r3, [sp, #36]	; 0x24
 800d99e:	e697      	b.n	800d6d0 <xmp3fixpt_UnpackSideInfo+0x43c>
		bsi->iCache = 0;
 800d9a0:	9607      	str	r6, [sp, #28]
		while (nBytes--) {
 800d9a2:	f1b9 0f00 	cmp.w	r9, #0
 800d9a6:	f000 84e1 	beq.w	800e36c <xmp3fixpt_UnpackSideInfo+0x10d8>
			bsi->iCache |= (*bsi->bytePtr++);
 800d9aa:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d9ac:	f1b9 0f01 	cmp.w	r9, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d9b0:	f103 0a01 	add.w	sl, r3, #1
 800d9b4:	f8cd a018 	str.w	sl, [sp, #24]
 800d9b8:	f893 a000 	ldrb.w	sl, [r3]
			bsi->iCache <<= 8;
 800d9bc:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 800d9c0:	f8cd a01c 	str.w	sl, [sp, #28]
		while (nBytes--) {
 800d9c4:	d012      	beq.n	800d9ec <xmp3fixpt_UnpackSideInfo+0x758>
			bsi->iCache |= (*bsi->bytePtr++);
 800d9c6:	1c9d      	adds	r5, r3, #2
		while (nBytes--) {
 800d9c8:	f1b9 0f02 	cmp.w	r9, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d9cc:	9506      	str	r5, [sp, #24]
 800d9ce:	785d      	ldrb	r5, [r3, #1]
 800d9d0:	ea45 0a0a 	orr.w	sl, r5, sl
			bsi->iCache <<= 8;
 800d9d4:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 800d9d8:	f8cd a01c 	str.w	sl, [sp, #28]
		while (nBytes--) {
 800d9dc:	d006      	beq.n	800d9ec <xmp3fixpt_UnpackSideInfo+0x758>
			bsi->iCache |= (*bsi->bytePtr++);
 800d9de:	1cdd      	adds	r5, r3, #3
 800d9e0:	9506      	str	r5, [sp, #24]
 800d9e2:	789b      	ldrb	r3, [r3, #2]
 800d9e4:	ea43 030a 	orr.w	r3, r3, sl
			bsi->iCache <<= 8;
 800d9e8:	ea4f 2a03 	mov.w	sl, r3, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d9ec:	f1c9 0303 	rsb	r3, r9, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d9f0:	321f      	adds	r2, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d9f2:	00db      	lsls	r3, r3, #3
 800d9f4:	fa0a f303 	lsl.w	r3, sl, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d9f8:	fa23 f202 	lsr.w	r2, r3, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d9fc:	fa03 f308 	lsl.w	r3, r3, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800da00:	4317      	orrs	r7, r2
		bsi->nBytes = 0;
 800da02:	eb01 02c9 	add.w	r2, r1, r9, lsl #3
 800da06:	9609      	str	r6, [sp, #36]	; 0x24
 800da08:	e603      	b.n	800d612 <xmp3fixpt_UnpackSideInfo+0x37e>
	int nBytes = bsi->nBytes;
 800da0a:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800da0e:	f1c2 0903 	rsb	r9, r2, #3
	if (nBytes >= 4) {
 800da12:	f1be 0f03 	cmp.w	lr, #3
 800da16:	f340 81df 	ble.w	800ddd8 <xmp3fixpt_UnpackSideInfo+0xb44>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800da1a:	f8dd c018 	ldr.w	ip, [sp, #24]
 800da1e:	f102 031d 	add.w	r3, r2, #29
		bsi->nBytes -= 4;
 800da22:	f1ae 0e04 	sub.w	lr, lr, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800da26:	46e0      	mov	r8, ip
 800da28:	f10c 0201 	add.w	r2, ip, #1
 800da2c:	9206      	str	r2, [sp, #24]
 800da2e:	f818 2b02 	ldrb.w	r2, [r8], #2
 800da32:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800da34:	f8cd 8018 	str.w	r8, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800da38:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800da3a:	f89c 8001 	ldrb.w	r8, [ip, #1]
 800da3e:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800da42:	f10c 0803 	add.w	r8, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800da46:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800da48:	f8cd 8018 	str.w	r8, [sp, #24]
 800da4c:	f89c 8002 	ldrb.w	r8, [ip, #2]
 800da50:	ea42 2208 	orr.w	r2, r2, r8, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800da54:	f10c 0804 	add.w	r8, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800da58:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800da5a:	f8cd 8018 	str.w	r8, [sp, #24]
 800da5e:	f89c c003 	ldrb.w	ip, [ip, #3]
		bsi->nBytes -= 4;
 800da62:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800da66:	ea4c 0e02 	orr.w	lr, ip, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800da6a:	fa0e f209 	lsl.w	r2, lr, r9
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800da6e:	fa2e fe03 	lsr.w	lr, lr, r3
 800da72:	ea41 010e 	orr.w	r1, r1, lr
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800da76:	e9cd 2307 	strd	r2, r3, [sp, #28]
 800da7a:	e4c8      	b.n	800d40e <xmp3fixpt_UnpackSideInfo+0x17a>
	int nBytes = bsi->nBytes;
 800da7c:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800da80:	f1cc 0303 	rsb	r3, ip, #3
	if (nBytes >= 4) {
 800da84:	f1b8 0f03 	cmp.w	r8, #3
 800da88:	f340 81e8 	ble.w	800de5c <xmp3fixpt_UnpackSideInfo+0xbc8>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800da8c:	f10c 021d 	add.w	r2, ip, #29
 800da90:	f8dd c018 	ldr.w	ip, [sp, #24]
		bsi->nBytes -= 4;
 800da94:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800da98:	46e1      	mov	r9, ip
 800da9a:	f10c 0101 	add.w	r1, ip, #1
 800da9e:	9106      	str	r1, [sp, #24]
 800daa0:	f819 1b02 	ldrb.w	r1, [r9], #2
 800daa4:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800daa6:	f8cd 9018 	str.w	r9, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800daaa:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800daac:	f89c 9001 	ldrb.w	r9, [ip, #1]
 800dab0:	ea41 4109 	orr.w	r1, r1, r9, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dab4:	f10c 0903 	add.w	r9, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dab8:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800daba:	f8cd 9018 	str.w	r9, [sp, #24]
 800dabe:	f89c 9002 	ldrb.w	r9, [ip, #2]
 800dac2:	ea41 2909 	orr.w	r9, r1, r9, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dac6:	f10c 0104 	add.w	r1, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800daca:	f8cd 901c 	str.w	r9, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dace:	9106      	str	r1, [sp, #24]
 800dad0:	f89c 1003 	ldrb.w	r1, [ip, #3]
		bsi->nBytes -= 4;
 800dad4:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dad8:	ea41 0109 	orr.w	r1, r1, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dadc:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dae0:	40d1      	lsrs	r1, r2
 800dae2:	ea4e 0e01 	orr.w	lr, lr, r1
 800dae6:	e488      	b.n	800d3fa <xmp3fixpt_UnpackSideInfo+0x166>
	int nBytes = bsi->nBytes;
 800dae8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800daec:	f1c1 0303 	rsb	r3, r1, #3
	if (nBytes >= 4) {
 800daf0:	f1b8 0f03 	cmp.w	r8, #3
 800daf4:	f340 81f2 	ble.w	800dedc <xmp3fixpt_UnpackSideInfo+0xc48>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800daf8:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800dafc:	f101 0c1d 	add.w	ip, r1, #29
		bsi->nBytes -= 4;
 800db00:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800db04:	46ce      	mov	lr, r9
 800db06:	f109 0101 	add.w	r1, r9, #1
 800db0a:	9106      	str	r1, [sp, #24]
 800db0c:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800db10:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db12:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800db16:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db18:	f899 e001 	ldrb.w	lr, [r9, #1]
 800db1c:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800db20:	f109 0e03 	add.w	lr, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db24:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800db26:	f8cd e018 	str.w	lr, [sp, #24]
 800db2a:	f899 e002 	ldrb.w	lr, [r9, #2]
 800db2e:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800db32:	f109 0e04 	add.w	lr, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800db36:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800db38:	f8cd e018 	str.w	lr, [sp, #24]
 800db3c:	f899 e003 	ldrb.w	lr, [r9, #3]
		bsi->nBytes -= 4;
 800db40:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800db44:	ea4e 0e01 	orr.w	lr, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800db48:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800db4c:	fa2e fe0c 	lsr.w	lr, lr, ip
 800db50:	ea42 020e 	orr.w	r2, r2, lr
 800db54:	e446      	b.n	800d3e4 <xmp3fixpt_UnpackSideInfo+0x150>
	int nBytes = bsi->nBytes;
 800db56:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800db5a:	f1c2 0305 	rsb	r3, r2, #5
	if (nBytes >= 4) {
 800db5e:	f1bc 0f03 	cmp.w	ip, #3
 800db62:	f340 81fc 	ble.w	800df5e <xmp3fixpt_UnpackSideInfo+0xcca>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800db66:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800db6a:	f102 011b 	add.w	r1, r2, #27
		bsi->nBytes -= 4;
 800db6e:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800db72:	46c1      	mov	r9, r8
 800db74:	f108 0201 	add.w	r2, r8, #1
 800db78:	9206      	str	r2, [sp, #24]
 800db7a:	f819 2b02 	ldrb.w	r2, [r9], #2
 800db7e:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db80:	f8cd 9018 	str.w	r9, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800db84:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db86:	f898 9001 	ldrb.w	r9, [r8, #1]
 800db8a:	ea42 4209 	orr.w	r2, r2, r9, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800db8e:	f108 0903 	add.w	r9, r8, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800db92:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800db94:	f8cd 9018 	str.w	r9, [sp, #24]
 800db98:	f898 9002 	ldrb.w	r9, [r8, #2]
 800db9c:	ea42 2909 	orr.w	r9, r2, r9, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dba0:	f108 0204 	add.w	r2, r8, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dba4:	f8cd 901c 	str.w	r9, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dba8:	9206      	str	r2, [sp, #24]
 800dbaa:	f898 2003 	ldrb.w	r2, [r8, #3]
		bsi->nBytes -= 4;
 800dbae:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dbb2:	ea42 0c09 	orr.w	ip, r2, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dbb6:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dbba:	fa2c fc01 	lsr.w	ip, ip, r1
 800dbbe:	ea4e 0e0c 	orr.w	lr, lr, ip
 800dbc2:	f7ff bbff 	b.w	800d3c4 <xmp3fixpt_UnpackSideInfo+0x130>
	int nBytes = bsi->nBytes;
 800dbc6:	9f09      	ldr	r7, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800dbc8:	f1c2 0303 	rsb	r3, r2, #3
	if (nBytes >= 4) {
 800dbcc:	2f03      	cmp	r7, #3
 800dbce:	f340 8249 	ble.w	800e064 <xmp3fixpt_UnpackSideInfo+0xdd0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dbd2:	f8dd c018 	ldr.w	ip, [sp, #24]
 800dbd6:	321d      	adds	r2, #29
		bsi->nBytes -= 4;
 800dbd8:	3f04      	subs	r7, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dbda:	46e6      	mov	lr, ip
 800dbdc:	f10c 0101 	add.w	r1, ip, #1
 800dbe0:	9106      	str	r1, [sp, #24]
 800dbe2:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800dbe6:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dbe8:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dbec:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dbee:	f89c e001 	ldrb.w	lr, [ip, #1]
 800dbf2:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dbf6:	f10c 0e03 	add.w	lr, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dbfa:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dbfc:	f8cd e018 	str.w	lr, [sp, #24]
 800dc00:	f89c e002 	ldrb.w	lr, [ip, #2]
 800dc04:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dc08:	f10c 0e04 	add.w	lr, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dc0c:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dc0e:	f8cd e018 	str.w	lr, [sp, #24]
 800dc12:	f89c c003 	ldrb.w	ip, [ip, #3]
		bsi->nBytes -= 4;
 800dc16:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dc18:	ea4c 0101 	orr.w	r1, ip, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dc1c:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dc20:	40d1      	lsrs	r1, r2
 800dc22:	4308      	orrs	r0, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dc24:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dc26:	005b      	lsls	r3, r3, #1
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800dc28:	4694      	mov	ip, r2
 800dc2a:	9208      	str	r2, [sp, #32]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dc2c:	e4ab      	b.n	800d586 <xmp3fixpt_UnpackSideInfo+0x2f2>
	int nBytes = bsi->nBytes;
 800dc2e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800dc32:	f1c7 0305 	rsb	r3, r7, #5
	if (nBytes >= 4) {
 800dc36:	f1bc 0f03 	cmp.w	ip, #3
 800dc3a:	f340 81d5 	ble.w	800dfe8 <xmp3fixpt_UnpackSideInfo+0xd54>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dc3e:	f107 021b 	add.w	r2, r7, #27
 800dc42:	9f06      	ldr	r7, [sp, #24]
		bsi->nBytes -= 4;
 800dc44:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dc48:	46be      	mov	lr, r7
 800dc4a:	1c78      	adds	r0, r7, #1
 800dc4c:	9006      	str	r0, [sp, #24]
 800dc4e:	f81e 0b02 	ldrb.w	r0, [lr], #2
 800dc52:	0600      	lsls	r0, r0, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dc54:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dc58:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dc5a:	f897 e001 	ldrb.w	lr, [r7, #1]
 800dc5e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dc62:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dc66:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dc68:	f8cd e018 	str.w	lr, [sp, #24]
 800dc6c:	f897 e002 	ldrb.w	lr, [r7, #2]
 800dc70:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dc74:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dc78:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dc7a:	f8cd e018 	str.w	lr, [sp, #24]
 800dc7e:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800dc80:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dc84:	4338      	orrs	r0, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dc86:	fa00 f303 	lsl.w	r3, r0, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dc8a:	40d0      	lsrs	r0, r2
 800dc8c:	4301      	orrs	r1, r0
 800dc8e:	e459      	b.n	800d544 <xmp3fixpt_UnpackSideInfo+0x2b0>
	int nBytes = bsi->nBytes;
 800dc90:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800dc94:	f1c2 0105 	rsb	r1, r2, #5
	if (nBytes >= 4) {
 800dc98:	f1bc 0f03 	cmp.w	ip, #3
 800dc9c:	f340 821c 	ble.w	800e0d8 <xmp3fixpt_UnpackSideInfo+0xe44>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dca0:	9f06      	ldr	r7, [sp, #24]
 800dca2:	f102 031b 	add.w	r3, r2, #27
		bsi->nBytes -= 4;
 800dca6:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dcaa:	46be      	mov	lr, r7
 800dcac:	1c7a      	adds	r2, r7, #1
 800dcae:	9206      	str	r2, [sp, #24]
 800dcb0:	f81e 2b02 	ldrb.w	r2, [lr], #2
 800dcb4:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dcb6:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dcba:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dcbc:	f897 e001 	ldrb.w	lr, [r7, #1]
 800dcc0:	ea42 420e 	orr.w	r2, r2, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dcc4:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dcc8:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dcca:	f8cd e018 	str.w	lr, [sp, #24]
 800dcce:	f897 e002 	ldrb.w	lr, [r7, #2]
 800dcd2:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dcd6:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dcda:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dcdc:	f8cd e018 	str.w	lr, [sp, #24]
 800dce0:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800dce2:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dce6:	433a      	orrs	r2, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dce8:	fa02 f101 	lsl.w	r1, r2, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dcec:	40da      	lsrs	r2, r3
 800dcee:	4310      	orrs	r0, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dcf0:	e9cd 1307 	strd	r1, r3, [sp, #28]
 800dcf4:	e432      	b.n	800d55c <xmp3fixpt_UnpackSideInfo+0x2c8>
	int nBytes = bsi->nBytes;
 800dcf6:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800dcfa:	f1ce 0205 	rsb	r2, lr, #5
	if (nBytes >= 4) {
 800dcfe:	f1b8 0f03 	cmp.w	r8, #3
 800dd02:	f340 82aa 	ble.w	800e25a <xmp3fixpt_UnpackSideInfo+0xfc6>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dd06:	9906      	ldr	r1, [sp, #24]
 800dd08:	f10e 071b 	add.w	r7, lr, #27
		bsi->nBytes -= 4;
 800dd0c:	f1a8 0004 	sub.w	r0, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dd10:	468e      	mov	lr, r1
 800dd12:	1c4b      	adds	r3, r1, #1
 800dd14:	9306      	str	r3, [sp, #24]
 800dd16:	f81e 3b02 	ldrb.w	r3, [lr], #2
 800dd1a:	061b      	lsls	r3, r3, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dd1c:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800dd20:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dd22:	f891 e001 	ldrb.w	lr, [r1, #1]
 800dd26:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dd2a:	f101 0e03 	add.w	lr, r1, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800dd2e:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dd30:	f8cd e018 	str.w	lr, [sp, #24]
 800dd34:	f891 e002 	ldrb.w	lr, [r1, #2]
 800dd38:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800dd3c:	f101 0e04 	add.w	lr, r1, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800dd40:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800dd42:	f8cd e018 	str.w	lr, [sp, #24]
 800dd46:	78c9      	ldrb	r1, [r1, #3]
		bsi->nBytes -= 4;
 800dd48:	9009      	str	r0, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800dd4a:	4319      	orrs	r1, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dd4c:	fa01 f302 	lsl.w	r3, r1, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dd50:	40f9      	lsrs	r1, r7
 800dd52:	ea4c 0c01 	orr.w	ip, ip, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dd56:	0ed9      	lsrs	r1, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dd58:	015b      	lsls	r3, r3, #5
 800dd5a:	f7ff bbeb 	b.w	800d534 <xmp3fixpt_UnpackSideInfo+0x2a0>
	int nBytes = bsi->nBytes;
 800dd5e:	9809      	ldr	r0, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800dd60:	f1cc 0701 	rsb	r7, ip, #1
	if (nBytes >= 4) {
 800dd64:	2803      	cmp	r0, #3
 800dd66:	f300 82ab 	bgt.w	800e2c0 <xmp3fixpt_UnpackSideInfo+0x102c>
		bsi->iCache = 0;
 800dd6a:	9207      	str	r2, [sp, #28]
		while (nBytes--) {
 800dd6c:	2800      	cmp	r0, #0
 800dd6e:	f000 8300 	beq.w	800e372 <xmp3fixpt_UnpackSideInfo+0x10de>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd72:	9a06      	ldr	r2, [sp, #24]
		while (nBytes--) {
 800dd74:	2801      	cmp	r0, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dd76:	f102 0301 	add.w	r3, r2, #1
 800dd7a:	9306      	str	r3, [sp, #24]
 800dd7c:	7813      	ldrb	r3, [r2, #0]
			bsi->iCache <<= 8;
 800dd7e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800dd82:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800dd84:	d013      	beq.n	800ddae <xmp3fixpt_UnpackSideInfo+0xb1a>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd86:	f102 0802 	add.w	r8, r2, #2
		while (nBytes--) {
 800dd8a:	2802      	cmp	r0, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dd8c:	f8cd 8018 	str.w	r8, [sp, #24]
 800dd90:	f892 8001 	ldrb.w	r8, [r2, #1]
 800dd94:	ea48 0303 	orr.w	r3, r8, r3
			bsi->iCache <<= 8;
 800dd98:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800dd9c:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800dd9e:	d006      	beq.n	800ddae <xmp3fixpt_UnpackSideInfo+0xb1a>
			bsi->iCache |= (*bsi->bytePtr++);
 800dda0:	f102 0803 	add.w	r8, r2, #3
 800dda4:	f8cd 8018 	str.w	r8, [sp, #24]
 800dda8:	7892      	ldrb	r2, [r2, #2]
 800ddaa:	4313      	orrs	r3, r2
			bsi->iCache <<= 8;
 800ddac:	021b      	lsls	r3, r3, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800ddae:	f1c0 0803 	rsb	r8, r0, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800ddb2:	f10c 021f 	add.w	r2, ip, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800ddb6:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800ddba:	fa03 f308 	lsl.w	r3, r3, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800ddbe:	fa03 f707 	lsl.w	r7, r3, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800ddc2:	fa23 f202 	lsr.w	r2, r3, r2
	bsi->iCache <<= nBits;					/* left-justify cache */
 800ddc6:	007b      	lsls	r3, r7, #1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800ddc8:	430a      	orrs	r2, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800ddca:	0ff9      	lsrs	r1, r7, #31
		bsi->nBytes = 0;
 800ddcc:	eb0e 0cc0 	add.w	ip, lr, r0, lsl #3
 800ddd0:	2000      	movs	r0, #0
 800ddd2:	9009      	str	r0, [sp, #36]	; 0x24
	return data;
 800ddd4:	f7ff bb30 	b.w	800d438 <xmp3fixpt_UnpackSideInfo+0x1a4>
		bsi->iCache = 0;
 800ddd8:	f04f 0c00 	mov.w	ip, #0
 800dddc:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800dde0:	f1be 0f00 	cmp.w	lr, #0
 800dde4:	f000 8297 	beq.w	800e316 <xmp3fixpt_UnpackSideInfo+0x1082>
			bsi->iCache |= (*bsi->bytePtr++);
 800dde8:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800ddec:	f1be 0f01 	cmp.w	lr, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800ddf0:	f108 0c01 	add.w	ip, r8, #1
 800ddf4:	f8cd c018 	str.w	ip, [sp, #24]
 800ddf8:	f898 c000 	ldrb.w	ip, [r8]
			bsi->iCache <<= 8;
 800ddfc:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800de00:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800de04:	d016      	beq.n	800de34 <xmp3fixpt_UnpackSideInfo+0xba0>
			bsi->iCache |= (*bsi->bytePtr++);
 800de06:	f108 0702 	add.w	r7, r8, #2
		while (nBytes--) {
 800de0a:	f1be 0f02 	cmp.w	lr, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800de0e:	9706      	str	r7, [sp, #24]
 800de10:	f898 7001 	ldrb.w	r7, [r8, #1]
 800de14:	ea47 0c0c 	orr.w	ip, r7, ip
			bsi->iCache <<= 8;
 800de18:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800de1c:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800de20:	d008      	beq.n	800de34 <xmp3fixpt_UnpackSideInfo+0xba0>
			bsi->iCache |= (*bsi->bytePtr++);
 800de22:	f108 0703 	add.w	r7, r8, #3
 800de26:	9706      	str	r7, [sp, #24]
 800de28:	f898 8002 	ldrb.w	r8, [r8, #2]
 800de2c:	ea48 0c0c 	orr.w	ip, r8, ip
			bsi->iCache <<= 8;
 800de30:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800de34:	f1ce 0803 	rsb	r8, lr, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800de38:	321d      	adds	r2, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800de3a:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800de3e:	fa0c fc08 	lsl.w	ip, ip, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800de42:	fa2c f802 	lsr.w	r8, ip, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800de46:	fa0c f209 	lsl.w	r2, ip, r9
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800de4a:	ea41 0108 	orr.w	r1, r1, r8
		bsi->nBytes = 0;
 800de4e:	f04f 0c00 	mov.w	ip, #0
 800de52:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 800de56:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 800de5a:	e60c      	b.n	800da76 <xmp3fixpt_UnpackSideInfo+0x7e2>
		bsi->iCache = 0;
 800de5c:	2100      	movs	r1, #0
 800de5e:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800de60:	f1b8 0f00 	cmp.w	r8, #0
 800de64:	f000 826a 	beq.w	800e33c <xmp3fixpt_UnpackSideInfo+0x10a8>
			bsi->iCache |= (*bsi->bytePtr++);
 800de68:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800de6c:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800de70:	f109 0101 	add.w	r1, r9, #1
 800de74:	9106      	str	r1, [sp, #24]
 800de76:	f899 1000 	ldrb.w	r1, [r9]
			bsi->iCache <<= 8;
 800de7a:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800de7e:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800de80:	d014      	beq.n	800deac <xmp3fixpt_UnpackSideInfo+0xc18>
			bsi->iCache |= (*bsi->bytePtr++);
 800de82:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800de86:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800de8a:	9706      	str	r7, [sp, #24]
 800de8c:	f899 7001 	ldrb.w	r7, [r9, #1]
 800de90:	ea41 0107 	orr.w	r1, r1, r7
			bsi->iCache <<= 8;
 800de94:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800de98:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800de9a:	d007      	beq.n	800deac <xmp3fixpt_UnpackSideInfo+0xc18>
			bsi->iCache |= (*bsi->bytePtr++);
 800de9c:	f109 0703 	add.w	r7, r9, #3
 800dea0:	9706      	str	r7, [sp, #24]
 800dea2:	f899 9002 	ldrb.w	r9, [r9, #2]
 800dea6:	ea49 0101 	orr.w	r1, r9, r1
			bsi->iCache <<= 8;
 800deaa:	0209      	lsls	r1, r1, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800deac:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800deb0:	f10c 0c1d 	add.w	ip, ip, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800deb4:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800deb8:	fa01 f109 	lsl.w	r1, r1, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800debc:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dec0:	fa21 f10c 	lsr.w	r1, r1, ip
 800dec4:	ea4e 0e01 	orr.w	lr, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dec8:	0f59      	lsrs	r1, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800deca:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800decc:	f04f 0c00 	mov.w	ip, #0
 800ded0:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800ded4:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800ded8:	f7ff ba91 	b.w	800d3fe <xmp3fixpt_UnpackSideInfo+0x16a>
		bsi->iCache = 0;
 800dedc:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dee0:	f1b8 0f00 	cmp.w	r8, #0
 800dee4:	f000 8227 	beq.w	800e336 <xmp3fixpt_UnpackSideInfo+0x10a2>
			bsi->iCache |= (*bsi->bytePtr++);
 800dee8:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800deec:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800def0:	f109 0e01 	add.w	lr, r9, #1
 800def4:	f8cd e018 	str.w	lr, [sp, #24]
 800def8:	f899 e000 	ldrb.w	lr, [r9]
			bsi->iCache <<= 8;
 800defc:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800df00:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800df04:	d016      	beq.n	800df34 <xmp3fixpt_UnpackSideInfo+0xca0>
			bsi->iCache |= (*bsi->bytePtr++);
 800df06:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800df0a:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800df0e:	9706      	str	r7, [sp, #24]
 800df10:	f899 7001 	ldrb.w	r7, [r9, #1]
 800df14:	ea47 0e0e 	orr.w	lr, r7, lr
			bsi->iCache <<= 8;
 800df18:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800df1c:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800df20:	d008      	beq.n	800df34 <xmp3fixpt_UnpackSideInfo+0xca0>
			bsi->iCache |= (*bsi->bytePtr++);
 800df22:	f109 0703 	add.w	r7, r9, #3
 800df26:	9706      	str	r7, [sp, #24]
 800df28:	f899 9002 	ldrb.w	r9, [r9, #2]
 800df2c:	ea49 0e0e 	orr.w	lr, r9, lr
			bsi->iCache <<= 8;
 800df30:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800df34:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800df38:	311d      	adds	r1, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800df3a:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800df3e:	fa0e fe09 	lsl.w	lr, lr, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800df42:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800df46:	fa2e f101 	lsr.w	r1, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800df4a:	ea4f 7e53 	mov.w	lr, r3, lsr #29
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800df4e:	430a      	orrs	r2, r1
	bsi->iCache <<= nBits;					/* left-justify cache */
 800df50:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800df52:	2100      	movs	r1, #0
 800df54:	eb0c 0cc8 	add.w	ip, ip, r8, lsl #3
 800df58:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800df5a:	f7ff ba46 	b.w	800d3ea <xmp3fixpt_UnpackSideInfo+0x156>
		bsi->iCache = 0;
 800df5e:	f04f 0800 	mov.w	r8, #0
 800df62:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800df66:	f1bc 0f00 	cmp.w	ip, #0
 800df6a:	f000 81ed 	beq.w	800e348 <xmp3fixpt_UnpackSideInfo+0x10b4>
			bsi->iCache |= (*bsi->bytePtr++);
 800df6e:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800df72:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800df76:	f109 0801 	add.w	r8, r9, #1
 800df7a:	f8cd 8018 	str.w	r8, [sp, #24]
 800df7e:	f899 8000 	ldrb.w	r8, [r9]
			bsi->iCache <<= 8;
 800df82:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800df86:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800df8a:	d016      	beq.n	800dfba <xmp3fixpt_UnpackSideInfo+0xd26>
			bsi->iCache |= (*bsi->bytePtr++);
 800df8c:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800df90:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800df94:	9706      	str	r7, [sp, #24]
 800df96:	f899 7001 	ldrb.w	r7, [r9, #1]
 800df9a:	ea47 0808 	orr.w	r8, r7, r8
			bsi->iCache <<= 8;
 800df9e:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800dfa2:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800dfa6:	d008      	beq.n	800dfba <xmp3fixpt_UnpackSideInfo+0xd26>
			bsi->iCache |= (*bsi->bytePtr++);
 800dfa8:	f109 0703 	add.w	r7, r9, #3
 800dfac:	9706      	str	r7, [sp, #24]
 800dfae:	f899 9002 	ldrb.w	r9, [r9, #2]
 800dfb2:	ea49 0808 	orr.w	r8, r9, r8
			bsi->iCache <<= 8;
 800dfb6:	ea4f 2808 	mov.w	r8, r8, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dfba:	f1cc 0903 	rsb	r9, ip, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dfbe:	321b      	adds	r2, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dfc0:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800dfc4:	fa08 f809 	lsl.w	r8, r8, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dfc8:	fa08 f303 	lsl.w	r3, r8, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dfcc:	fa28 f202 	lsr.w	r2, r8, r2
 800dfd0:	ea4e 0e02 	orr.w	lr, lr, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dfd4:	0f5a      	lsrs	r2, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dfd6:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800dfd8:	eb01 01cc 	add.w	r1, r1, ip, lsl #3
 800dfdc:	f04f 0c00 	mov.w	ip, #0
 800dfe0:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dfe4:	f7ff b9f0 	b.w	800d3c8 <xmp3fixpt_UnpackSideInfo+0x134>
		bsi->iCache = 0;
 800dfe8:	2000      	movs	r0, #0
 800dfea:	9007      	str	r0, [sp, #28]
		while (nBytes--) {
 800dfec:	f1bc 0f00 	cmp.w	ip, #0
 800dff0:	f000 81a7 	beq.w	800e342 <xmp3fixpt_UnpackSideInfo+0x10ae>
			bsi->iCache |= (*bsi->bytePtr++);
 800dff4:	9806      	ldr	r0, [sp, #24]
		while (nBytes--) {
 800dff6:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dffa:	f100 0e01 	add.w	lr, r0, #1
 800dffe:	f8cd e018 	str.w	lr, [sp, #24]
 800e002:	f890 e000 	ldrb.w	lr, [r0]
			bsi->iCache <<= 8;
 800e006:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e00a:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e00e:	d017      	beq.n	800e040 <xmp3fixpt_UnpackSideInfo+0xdac>
			bsi->iCache |= (*bsi->bytePtr++);
 800e010:	f100 0802 	add.w	r8, r0, #2
		while (nBytes--) {
 800e014:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e018:	f8cd 8018 	str.w	r8, [sp, #24]
 800e01c:	f890 8001 	ldrb.w	r8, [r0, #1]
 800e020:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800e024:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e028:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e02c:	d008      	beq.n	800e040 <xmp3fixpt_UnpackSideInfo+0xdac>
			bsi->iCache |= (*bsi->bytePtr++);
 800e02e:	f100 0803 	add.w	r8, r0, #3
 800e032:	f8cd 8018 	str.w	r8, [sp, #24]
 800e036:	7880      	ldrb	r0, [r0, #2]
 800e038:	ea40 000e 	orr.w	r0, r0, lr
			bsi->iCache <<= 8;
 800e03c:	ea4f 2e00 	mov.w	lr, r0, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e040:	f1cc 0003 	rsb	r0, ip, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e044:	371b      	adds	r7, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e046:	00c0      	lsls	r0, r0, #3
 800e048:	fa0e f000 	lsl.w	r0, lr, r0
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e04c:	fa00 f303 	lsl.w	r3, r0, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e050:	40f8      	lsrs	r0, r7
 800e052:	4301      	orrs	r1, r0
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e054:	0ed8      	lsrs	r0, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e056:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800e058:	2700      	movs	r7, #0
 800e05a:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
 800e05e:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e060:	f7ff ba72 	b.w	800d548 <xmp3fixpt_UnpackSideInfo+0x2b4>
		bsi->iCache = 0;
 800e064:	2100      	movs	r1, #0
 800e066:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800e068:	2f00      	cmp	r7, #0
 800e06a:	f000 815b 	beq.w	800e324 <xmp3fixpt_UnpackSideInfo+0x1090>
			bsi->iCache |= (*bsi->bytePtr++);
 800e06e:	9906      	ldr	r1, [sp, #24]
		while (nBytes--) {
 800e070:	2f01      	cmp	r7, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800e072:	f101 0e01 	add.w	lr, r1, #1
 800e076:	f8cd e018 	str.w	lr, [sp, #24]
 800e07a:	f891 e000 	ldrb.w	lr, [r1]
			bsi->iCache <<= 8;
 800e07e:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e082:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e086:	d016      	beq.n	800e0b6 <xmp3fixpt_UnpackSideInfo+0xe22>
			bsi->iCache |= (*bsi->bytePtr++);
 800e088:	f101 0802 	add.w	r8, r1, #2
		while (nBytes--) {
 800e08c:	2f02      	cmp	r7, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e08e:	f8cd 8018 	str.w	r8, [sp, #24]
 800e092:	f891 8001 	ldrb.w	r8, [r1, #1]
 800e096:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800e09a:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e09e:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e0a2:	d008      	beq.n	800e0b6 <xmp3fixpt_UnpackSideInfo+0xe22>
			bsi->iCache |= (*bsi->bytePtr++);
 800e0a4:	f101 0803 	add.w	r8, r1, #3
 800e0a8:	f8cd 8018 	str.w	r8, [sp, #24]
 800e0ac:	7889      	ldrb	r1, [r1, #2]
 800e0ae:	ea41 010e 	orr.w	r1, r1, lr
			bsi->iCache <<= 8;
 800e0b2:	ea4f 2e01 	mov.w	lr, r1, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e0b6:	f1c7 0103 	rsb	r1, r7, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e0ba:	321d      	adds	r2, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e0bc:	00c9      	lsls	r1, r1, #3
 800e0be:	fa0e f101 	lsl.w	r1, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e0c2:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e0c6:	40d1      	lsrs	r1, r2
 800e0c8:	4308      	orrs	r0, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e0ca:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e0cc:	005b      	lsls	r3, r3, #1
		bsi->nBytes = 0;
 800e0ce:	eb0c 02c7 	add.w	r2, ip, r7, lsl #3
 800e0d2:	2700      	movs	r7, #0
 800e0d4:	9709      	str	r7, [sp, #36]	; 0x24
 800e0d6:	e5a7      	b.n	800dc28 <xmp3fixpt_UnpackSideInfo+0x994>
		bsi->iCache = 0;
 800e0d8:	2300      	movs	r3, #0
 800e0da:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800e0dc:	f1bc 0f00 	cmp.w	ip, #0
 800e0e0:	f000 811e 	beq.w	800e320 <xmp3fixpt_UnpackSideInfo+0x108c>
			bsi->iCache |= (*bsi->bytePtr++);
 800e0e4:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800e0e6:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800e0ea:	f103 0701 	add.w	r7, r3, #1
 800e0ee:	9706      	str	r7, [sp, #24]
 800e0f0:	781f      	ldrb	r7, [r3, #0]
			bsi->iCache <<= 8;
 800e0f2:	ea4f 2707 	mov.w	r7, r7, lsl #8
 800e0f6:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800e0f8:	d014      	beq.n	800e124 <xmp3fixpt_UnpackSideInfo+0xe90>
			bsi->iCache |= (*bsi->bytePtr++);
 800e0fa:	f103 0802 	add.w	r8, r3, #2
		while (nBytes--) {
 800e0fe:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e102:	f8cd 8018 	str.w	r8, [sp, #24]
 800e106:	f893 8001 	ldrb.w	r8, [r3, #1]
 800e10a:	ea48 0707 	orr.w	r7, r8, r7
			bsi->iCache <<= 8;
 800e10e:	ea4f 2707 	mov.w	r7, r7, lsl #8
 800e112:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800e114:	d006      	beq.n	800e124 <xmp3fixpt_UnpackSideInfo+0xe90>
			bsi->iCache |= (*bsi->bytePtr++);
 800e116:	f103 0803 	add.w	r8, r3, #3
 800e11a:	f8cd 8018 	str.w	r8, [sp, #24]
 800e11e:	789b      	ldrb	r3, [r3, #2]
 800e120:	431f      	orrs	r7, r3
			bsi->iCache <<= 8;
 800e122:	023f      	lsls	r7, r7, #8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e124:	f102 031b 	add.w	r3, r2, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e128:	f1cc 0203 	rsb	r2, ip, #3
 800e12c:	00d2      	lsls	r2, r2, #3
 800e12e:	4097      	lsls	r7, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e130:	fa27 f303 	lsr.w	r3, r7, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e134:	fa07 f101 	lsl.w	r1, r7, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e138:	4318      	orrs	r0, r3
		bsi->nBytes = 0;
 800e13a:	2200      	movs	r2, #0
 800e13c:	eb0e 03cc 	add.w	r3, lr, ip, lsl #3
 800e140:	9209      	str	r2, [sp, #36]	; 0x24
 800e142:	e5d5      	b.n	800dcf0 <xmp3fixpt_UnpackSideInfo+0xa5c>
		bsi->iCache = 0;
 800e144:	f04f 0e00 	mov.w	lr, #0
 800e148:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e14c:	f1b8 0f00 	cmp.w	r8, #0
 800e150:	f000 80ee 	beq.w	800e330 <xmp3fixpt_UnpackSideInfo+0x109c>
			bsi->iCache |= (*bsi->bytePtr++);
 800e154:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800e158:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800e15c:	f109 0e01 	add.w	lr, r9, #1
 800e160:	f8cd e018 	str.w	lr, [sp, #24]
 800e164:	f899 e000 	ldrb.w	lr, [r9]
			bsi->iCache <<= 8;
 800e168:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e16c:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e170:	d016      	beq.n	800e1a0 <xmp3fixpt_UnpackSideInfo+0xf0c>
			bsi->iCache |= (*bsi->bytePtr++);
 800e172:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800e176:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e17a:	9706      	str	r7, [sp, #24]
 800e17c:	f899 7001 	ldrb.w	r7, [r9, #1]
 800e180:	ea47 0e0e 	orr.w	lr, r7, lr
			bsi->iCache <<= 8;
 800e184:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800e188:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800e18c:	d008      	beq.n	800e1a0 <xmp3fixpt_UnpackSideInfo+0xf0c>
			bsi->iCache |= (*bsi->bytePtr++);
 800e18e:	f109 0703 	add.w	r7, r9, #3
 800e192:	9706      	str	r7, [sp, #24]
 800e194:	f899 9002 	ldrb.w	r9, [r9, #2]
 800e198:	ea49 0e0e 	orr.w	lr, r9, lr
			bsi->iCache <<= 8;
 800e19c:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e1a0:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e1a4:	311b      	adds	r1, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e1a6:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800e1aa:	fa0e fe09 	lsl.w	lr, lr, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e1ae:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e1b2:	fa2e f101 	lsr.w	r1, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e1b6:	ea4f 6ed3 	mov.w	lr, r3, lsr #27
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e1ba:	ea4c 0c01 	orr.w	ip, ip, r1
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e1be:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800e1c0:	2100      	movs	r1, #0
 800e1c2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800e1c6:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e1c8:	f7ff b8f4 	b.w	800d3b4 <xmp3fixpt_UnpackSideInfo+0x120>
		bsi->iCache = 0;
 800e1cc:	f04f 0c00 	mov.w	ip, #0
 800e1d0:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800e1d4:	2a00      	cmp	r2, #0
 800e1d6:	f000 80a8 	beq.w	800e32a <xmp3fixpt_UnpackSideInfo+0x1096>
			bsi->iCache |= (*bsi->bytePtr++);
 800e1da:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800e1de:	2a01      	cmp	r2, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800e1e0:	f108 0c01 	add.w	ip, r8, #1
 800e1e4:	f8cd c018 	str.w	ip, [sp, #24]
 800e1e8:	f898 c000 	ldrb.w	ip, [r8]
			bsi->iCache <<= 8;
 800e1ec:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800e1f0:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800e1f4:	d017      	beq.n	800e226 <xmp3fixpt_UnpackSideInfo+0xf92>
			bsi->iCache |= (*bsi->bytePtr++);
 800e1f6:	f108 0902 	add.w	r9, r8, #2
		while (nBytes--) {
 800e1fa:	2a02      	cmp	r2, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e1fc:	f8cd 9018 	str.w	r9, [sp, #24]
 800e200:	f898 9001 	ldrb.w	r9, [r8, #1]
 800e204:	ea49 0c0c 	orr.w	ip, r9, ip
			bsi->iCache <<= 8;
 800e208:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800e20c:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800e210:	d009      	beq.n	800e226 <xmp3fixpt_UnpackSideInfo+0xf92>
			bsi->iCache |= (*bsi->bytePtr++);
 800e212:	f108 0903 	add.w	r9, r8, #3
 800e216:	f8cd 9018 	str.w	r9, [sp, #24]
 800e21a:	f898 8002 	ldrb.w	r8, [r8, #2]
 800e21e:	ea48 0c0c 	orr.w	ip, r8, ip
			bsi->iCache <<= 8;
 800e222:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e226:	f1c2 0803 	rsb	r8, r2, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e22a:	f10e 0e1f 	add.w	lr, lr, #31
 800e22e:	9f01      	ldr	r7, [sp, #4]
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e230:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800e234:	fa0c fc08 	lsl.w	ip, ip, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e238:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e23c:	fa2c fc0e 	lsr.w	ip, ip, lr
 800e240:	ea47 070c 	orr.w	r7, r7, ip
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e244:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e248:	015b      	lsls	r3, r3, #5
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e24a:	9701      	str	r7, [sp, #4]
		bsi->nBytes = 0;
 800e24c:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 800e250:	2200      	movs	r2, #0
 800e252:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e254:	9a01      	ldr	r2, [sp, #4]
 800e256:	f7ff b8a3 	b.w	800d3a0 <xmp3fixpt_UnpackSideInfo+0x10c>
		bsi->iCache = 0;
 800e25a:	9007      	str	r0, [sp, #28]
		while (nBytes--) {
 800e25c:	f1b8 0f00 	cmp.w	r8, #0
 800e260:	d05b      	beq.n	800e31a <xmp3fixpt_UnpackSideInfo+0x1086>
			bsi->iCache |= (*bsi->bytePtr++);
 800e262:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800e264:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800e268:	f103 0101 	add.w	r1, r3, #1
 800e26c:	9106      	str	r1, [sp, #24]
 800e26e:	7819      	ldrb	r1, [r3, #0]
			bsi->iCache <<= 8;
 800e270:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800e274:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800e276:	d00f      	beq.n	800e298 <xmp3fixpt_UnpackSideInfo+0x1004>
			bsi->iCache |= (*bsi->bytePtr++);
 800e278:	1c98      	adds	r0, r3, #2
		while (nBytes--) {
 800e27a:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800e27e:	9006      	str	r0, [sp, #24]
 800e280:	7858      	ldrb	r0, [r3, #1]
 800e282:	ea41 0100 	orr.w	r1, r1, r0
			bsi->iCache <<= 8;
 800e286:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800e28a:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800e28c:	d004      	beq.n	800e298 <xmp3fixpt_UnpackSideInfo+0x1004>
			bsi->iCache |= (*bsi->bytePtr++);
 800e28e:	1cd8      	adds	r0, r3, #3
 800e290:	9006      	str	r0, [sp, #24]
 800e292:	789b      	ldrb	r3, [r3, #2]
 800e294:	4319      	orrs	r1, r3
			bsi->iCache <<= 8;
 800e296:	0209      	lsls	r1, r1, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e298:	f1c8 0303 	rsb	r3, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e29c:	f10e 0e1b 	add.w	lr, lr, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800e2a0:	00db      	lsls	r3, r3, #3
 800e2a2:	4099      	lsls	r1, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e2a4:	fa01 f302 	lsl.w	r3, r1, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e2a8:	fa21 f10e 	lsr.w	r1, r1, lr
 800e2ac:	ea4c 0c01 	orr.w	ip, ip, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e2b0:	0ed9      	lsrs	r1, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e2b2:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800e2b4:	2200      	movs	r2, #0
 800e2b6:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
 800e2ba:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e2bc:	f7ff b93a 	b.w	800d534 <xmp3fixpt_UnpackSideInfo+0x2a0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800e2c0:	9a06      	ldr	r2, [sp, #24]
		bsi->nBytes -= 4;
 800e2c2:	1f03      	subs	r3, r0, #4
 800e2c4:	f10c 0c1f 	add.w	ip, ip, #31
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800e2c8:	4696      	mov	lr, r2
 800e2ca:	1c50      	adds	r0, r2, #1
 800e2cc:	9006      	str	r0, [sp, #24]
 800e2ce:	f81e 0b02 	ldrb.w	r0, [lr], #2
 800e2d2:	0600      	lsls	r0, r0, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800e2d4:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800e2d8:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800e2da:	f892 e001 	ldrb.w	lr, [r2, #1]
 800e2de:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800e2e2:	f102 0e03 	add.w	lr, r2, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800e2e6:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800e2e8:	f8cd e018 	str.w	lr, [sp, #24]
 800e2ec:	f892 e002 	ldrb.w	lr, [r2, #2]
 800e2f0:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800e2f4:	f102 0e04 	add.w	lr, r2, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800e2f8:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800e2fa:	f8cd e018 	str.w	lr, [sp, #24]
 800e2fe:	78d2      	ldrb	r2, [r2, #3]
		bsi->nBytes -= 4;
 800e300:	9309      	str	r3, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800e302:	4310      	orrs	r0, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800e304:	fa00 f707 	lsl.w	r7, r0, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e308:	fa20 f20c 	lsr.w	r2, r0, ip
	bsi->iCache <<= nBits;					/* left-justify cache */
 800e30c:	007b      	lsls	r3, r7, #1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800e30e:	430a      	orrs	r2, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800e310:	0ff9      	lsrs	r1, r7, #31
 800e312:	f7ff b891 	b.w	800d438 <xmp3fixpt_UnpackSideInfo+0x1a4>
		while (nBytes--) {
 800e316:	4672      	mov	r2, lr
 800e318:	e599      	b.n	800de4e <xmp3fixpt_UnpackSideInfo+0xbba>
 800e31a:	4603      	mov	r3, r0
 800e31c:	4601      	mov	r1, r0
 800e31e:	e7c9      	b.n	800e2b4 <xmp3fixpt_UnpackSideInfo+0x1020>
 800e320:	4661      	mov	r1, ip
 800e322:	e70a      	b.n	800e13a <xmp3fixpt_UnpackSideInfo+0xea6>
 800e324:	463b      	mov	r3, r7
 800e326:	4639      	mov	r1, r7
 800e328:	e6d1      	b.n	800e0ce <xmp3fixpt_UnpackSideInfo+0xe3a>
 800e32a:	4613      	mov	r3, r2
 800e32c:	4694      	mov	ip, r2
 800e32e:	e78d      	b.n	800e24c <xmp3fixpt_UnpackSideInfo+0xfb8>
 800e330:	4643      	mov	r3, r8
 800e332:	46c6      	mov	lr, r8
 800e334:	e744      	b.n	800e1c0 <xmp3fixpt_UnpackSideInfo+0xf2c>
 800e336:	4643      	mov	r3, r8
 800e338:	46c6      	mov	lr, r8
 800e33a:	e60a      	b.n	800df52 <xmp3fixpt_UnpackSideInfo+0xcbe>
 800e33c:	4643      	mov	r3, r8
 800e33e:	4641      	mov	r1, r8
 800e340:	e5c4      	b.n	800decc <xmp3fixpt_UnpackSideInfo+0xc38>
 800e342:	4663      	mov	r3, ip
 800e344:	4660      	mov	r0, ip
 800e346:	e687      	b.n	800e058 <xmp3fixpt_UnpackSideInfo+0xdc4>
 800e348:	4663      	mov	r3, ip
 800e34a:	4662      	mov	r2, ip
 800e34c:	e644      	b.n	800dfd8 <xmp3fixpt_UnpackSideInfo+0xd44>
					sis->region0Count = 8;
 800e34e:	2308      	movs	r3, #8
 800e350:	65e3      	str	r3, [r4, #92]	; 0x5c
 800e352:	230c      	movs	r3, #12
 800e354:	f7ff b865 	b.w	800d422 <xmp3fixpt_UnpackSideInfo+0x18e>
		while (nBytes--) {
 800e358:	4673      	mov	r3, lr
 800e35a:	4670      	mov	r0, lr
 800e35c:	f7ff baa8 	b.w	800d8b0 <xmp3fixpt_UnpackSideInfo+0x61c>
 800e360:	460f      	mov	r7, r1
 800e362:	f7ff bb18 	b.w	800d996 <xmp3fixpt_UnpackSideInfo+0x702>
 800e366:	4613      	mov	r3, r2
 800e368:	f7ff badb 	b.w	800d922 <xmp3fixpt_UnpackSideInfo+0x68e>
 800e36c:	464b      	mov	r3, r9
 800e36e:	f7ff bb48 	b.w	800da02 <xmp3fixpt_UnpackSideInfo+0x76e>
 800e372:	460a      	mov	r2, r1
 800e374:	4603      	mov	r3, r0
 800e376:	4601      	mov	r1, r0
 800e378:	e528      	b.n	800ddcc <xmp3fixpt_UnpackSideInfo+0xb38>
		return -1;
 800e37a:	f04f 33ff 	mov.w	r3, #4294967295
 800e37e:	9305      	str	r3, [sp, #20]
 800e380:	f7ff b887 	b.w	800d492 <xmp3fixpt_UnpackSideInfo+0x1fe>

0800e384 <xmp3fixpt_FreeBuffers>:
 *
 * Notes:       safe to call even if some buffers were not allocated (uses SAFE_FREE)
 **************************************************************************************/
void FreeBuffers(MP3DecInfo *mp3DecInfo)
{
	if (!mp3DecInfo)
 800e384:	b310      	cbz	r0, 800e3cc <xmp3fixpt_FreeBuffers+0x48>
{
 800e386:	b510      	push	{r4, lr}
 800e388:	4604      	mov	r4, r0
		return;

	SAFE_FREE(mp3DecInfo->FrameHeaderPS);
 800e38a:	6800      	ldr	r0, [r0, #0]
 800e38c:	b108      	cbz	r0, 800e392 <xmp3fixpt_FreeBuffers+0xe>
 800e38e:	f011 fe75 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->SideInfoPS);
 800e392:	6860      	ldr	r0, [r4, #4]
 800e394:	b108      	cbz	r0, 800e39a <xmp3fixpt_FreeBuffers+0x16>
 800e396:	f011 fe71 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->ScaleFactorInfoPS);
 800e39a:	68a0      	ldr	r0, [r4, #8]
 800e39c:	b108      	cbz	r0, 800e3a2 <xmp3fixpt_FreeBuffers+0x1e>
 800e39e:	f011 fe6d 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->HuffmanInfoPS);
 800e3a2:	68e0      	ldr	r0, [r4, #12]
 800e3a4:	b108      	cbz	r0, 800e3aa <xmp3fixpt_FreeBuffers+0x26>
 800e3a6:	f011 fe69 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->DequantInfoPS);
 800e3aa:	6920      	ldr	r0, [r4, #16]
 800e3ac:	b108      	cbz	r0, 800e3b2 <xmp3fixpt_FreeBuffers+0x2e>
 800e3ae:	f011 fe65 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
 800e3b2:	6960      	ldr	r0, [r4, #20]
 800e3b4:	b108      	cbz	r0, 800e3ba <xmp3fixpt_FreeBuffers+0x36>
 800e3b6:	f011 fe61 	bl	802007c <free>
	SAFE_FREE(mp3DecInfo->SubbandInfoPS);
 800e3ba:	69a0      	ldr	r0, [r4, #24]
 800e3bc:	b108      	cbz	r0, 800e3c2 <xmp3fixpt_FreeBuffers+0x3e>
 800e3be:	f011 fe5d 	bl	802007c <free>

	SAFE_FREE(mp3DecInfo);
 800e3c2:	4620      	mov	r0, r4
}
 800e3c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SAFE_FREE(mp3DecInfo);
 800e3c8:	f011 be58 	b.w	802007c <free>
 800e3cc:	4770      	bx	lr
 800e3ce:	bf00      	nop

0800e3d0 <xmp3fixpt_AllocateBuffers>:
{
 800e3d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	mp3DecInfo = (MP3DecInfo *)malloc(sizeof(MP3DecInfo));
 800e3d4:	2101      	movs	r1, #1
 800e3d6:	f44f 60fe 	mov.w	r0, #2032	; 0x7f0
 800e3da:	f011 fe15 	bl	8020008 <calloc>
	if (!mp3DecInfo)
 800e3de:	4604      	mov	r4, r0
 800e3e0:	b3d8      	cbz	r0, 800e45a <xmp3fixpt_AllocateBuffers+0x8a>
	fh =  (FrameHeader *)     malloc(sizeof(FrameHeader));
 800e3e2:	2101      	movs	r1, #1
 800e3e4:	2038      	movs	r0, #56	; 0x38
 800e3e6:	f011 fe0f 	bl	8020008 <calloc>
	si =  (SideInfo *)        malloc(sizeof(SideInfo));
 800e3ea:	2101      	movs	r1, #1
	fh =  (FrameHeader *)     malloc(sizeof(FrameHeader));
 800e3ec:	4607      	mov	r7, r0
	si =  (SideInfo *)        malloc(sizeof(SideInfo));
 800e3ee:	f44f 70a4 	mov.w	r0, #328	; 0x148
 800e3f2:	f011 fe09 	bl	8020008 <calloc>
	sfi = (ScaleFactorInfo *) malloc(sizeof(ScaleFactorInfo));
 800e3f6:	2101      	movs	r1, #1
	si =  (SideInfo *)        malloc(sizeof(SideInfo));
 800e3f8:	4606      	mov	r6, r0
	sfi = (ScaleFactorInfo *) malloc(sizeof(ScaleFactorInfo));
 800e3fa:	f44f 708e 	mov.w	r0, #284	; 0x11c
 800e3fe:	f011 fe03 	bl	8020008 <calloc>
	hi =  (HuffmanInfo *)     malloc(sizeof(HuffmanInfo));
 800e402:	2101      	movs	r1, #1
	sfi = (ScaleFactorInfo *) malloc(sizeof(ScaleFactorInfo));
 800e404:	4605      	mov	r5, r0
	hi =  (HuffmanInfo *)     malloc(sizeof(HuffmanInfo));
 800e406:	f241 2010 	movw	r0, #4624	; 0x1210
 800e40a:	f011 fdfd 	bl	8020008 <calloc>
	di =  (DequantInfo *)     malloc(sizeof(DequantInfo));
 800e40e:	2101      	movs	r1, #1
	hi =  (HuffmanInfo *)     malloc(sizeof(HuffmanInfo));
 800e410:	4682      	mov	sl, r0
	di =  (DequantInfo *)     malloc(sizeof(DequantInfo));
 800e412:	f44f 7052 	mov.w	r0, #840	; 0x348
 800e416:	f011 fdf7 	bl	8020008 <calloc>
	mi =  (IMDCTInfo *)       malloc(sizeof(IMDCTInfo));
 800e41a:	2101      	movs	r1, #1
	di =  (DequantInfo *)     malloc(sizeof(DequantInfo));
 800e41c:	4681      	mov	r9, r0
	mi =  (IMDCTInfo *)       malloc(sizeof(IMDCTInfo));
 800e41e:	f44f 50d9 	mov.w	r0, #6944	; 0x1b20
 800e422:	f011 fdf1 	bl	8020008 <calloc>
 800e426:	4680      	mov	r8, r0
	sbi = (SubbandInfo *)     malloc(sizeof(SubbandInfo));
 800e428:	2101      	movs	r1, #1
 800e42a:	f242 2004 	movw	r0, #8708	; 0x2204
 800e42e:	f011 fdeb 	bl	8020008 <calloc>
	mp3DecInfo->SubbandInfoPS =     (void *)sbi;
 800e432:	61a0      	str	r0, [r4, #24]
	mp3DecInfo->SideInfoPS =        (void *)si;
 800e434:	e9c4 7600 	strd	r7, r6, [r4]
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 800e438:	e9c4 5a02 	strd	r5, sl, [r4, #8]
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 800e43c:	e9c4 9804 	strd	r9, r8, [r4, #16]
	if (!fh || !si || !sfi || !hi || !di || !mi || !sbi) {
 800e440:	b177      	cbz	r7, 800e460 <xmp3fixpt_AllocateBuffers+0x90>
 800e442:	b16e      	cbz	r6, 800e460 <xmp3fixpt_AllocateBuffers+0x90>
 800e444:	b165      	cbz	r5, 800e460 <xmp3fixpt_AllocateBuffers+0x90>
 800e446:	f1ba 0f00 	cmp.w	sl, #0
 800e44a:	d009      	beq.n	800e460 <xmp3fixpt_AllocateBuffers+0x90>
 800e44c:	f1b8 0f00 	cmp.w	r8, #0
 800e450:	bf18      	it	ne
 800e452:	f1b9 0f00 	cmpne.w	r9, #0
 800e456:	d003      	beq.n	800e460 <xmp3fixpt_AllocateBuffers+0x90>
 800e458:	b110      	cbz	r0, 800e460 <xmp3fixpt_AllocateBuffers+0x90>
}
 800e45a:	4620      	mov	r0, r4
 800e45c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		FreeBuffers(mp3DecInfo);	/* safe to call - only frees memory that was successfully allocated */
 800e460:	4620      	mov	r0, r4
		return 0;
 800e462:	2400      	movs	r4, #0
		FreeBuffers(mp3DecInfo);	/* safe to call - only frees memory that was successfully allocated */
 800e464:	f7ff ff8e 	bl	800e384 <xmp3fixpt_FreeBuffers>
		return 0;
 800e468:	e7f7      	b.n	800e45a <xmp3fixpt_AllocateBuffers+0x8a>
 800e46a:	bf00      	nop

0800e46c <xmp3fixpt_FDCT32>:
 * TODO:        code organization and optimization for ARM
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 800e46c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e470:	b087      	sub	sp, #28
 800e472:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800e474:	9303      	str	r3, [sp, #12]
	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
	if (gb < 6) {
 800e476:	2c05      	cmp	r4, #5
{
 800e478:	e9cd 1201 	strd	r1, r2, [sp, #4]
	if (gb < 6) {
 800e47c:	f300 84d1 	bgt.w	800ee22 <xmp3fixpt_FDCT32+0x9b6>
		es = 6 - gb;
 800e480:	f1c4 0b06 	rsb	fp, r4, #6
		for (i = 0; i < 32; i++)
 800e484:	1f03      	subs	r3, r0, #4
 800e486:	f100 017c 	add.w	r1, r0, #124	; 0x7c
			buf[i] >>= es;
 800e48a:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800e48e:	fa42 f20b 	asr.w	r2, r2, fp
		for (i = 0; i < 32; i++)
 800e492:	4299      	cmp	r1, r3
			buf[i] >>= es;
 800e494:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 32; i++)
 800e496:	d1f8      	bne.n	800e48a <xmp3fixpt_FDCT32+0x1e>
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 800e498:	6801      	ldr	r1, [r0, #0]
 800e49a:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 800e49c:	e9d0 450f 	ldrd	r4, r5, [r0, #60]	; 0x3c
 800e4a0:	1a8b      	subs	r3, r1, r2
 800e4a2:	440a      	add	r2, r1
	 * For inline assembly, x and y are not assumed to be R0, R1 so it shouldn't matter
	 *   which one is returned. (If this were a function call, returning y (R1) would 
	 *   require an extra "mov r0, r1")
     */
    int zlow;
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800e4a4:	49c9      	ldr	r1, [pc, #804]	; (800e7cc <xmp3fixpt_FDCT32+0x360>)
 800e4a6:	fb81 6303 	smull	r6, r3, r1, r3
 800e4aa:	1b61      	subs	r1, r4, r5
 800e4ac:	005b      	lsls	r3, r3, #1
 800e4ae:	442c      	add	r4, r5
 800e4b0:	4dc7      	ldr	r5, [pc, #796]	; (800e7d0 <xmp3fixpt_FDCT32+0x364>)
 800e4b2:	fb85 6101 	smull	r6, r1, r5, r1
 800e4b6:	1915      	adds	r5, r2, r4
 800e4b8:	0149      	lsls	r1, r1, #5
 800e4ba:	1b12      	subs	r2, r2, r4
 800e4bc:	4cc5      	ldr	r4, [pc, #788]	; (800e7d4 <xmp3fixpt_FDCT32+0x368>)
 800e4be:	6005      	str	r5, [r0, #0]
 800e4c0:	fb84 5202 	smull	r5, r2, r4, r2
 800e4c4:	0052      	lsls	r2, r2, #1
 800e4c6:	63c2      	str	r2, [r0, #60]	; 0x3c
 800e4c8:	185a      	adds	r2, r3, r1
 800e4ca:	1a5b      	subs	r3, r3, r1
 800e4cc:	6402      	str	r2, [r0, #64]	; 0x40
 800e4ce:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(1, 1, 3, 1);
 800e4d2:	6846      	ldr	r6, [r0, #4]
	D32FP(0, 1, 5, 1);
 800e4d4:	005b      	lsls	r3, r3, #1
	D32FP(1, 1, 3, 1);
 800e4d6:	6f82      	ldr	r2, [r0, #120]	; 0x78
	D32FP(0, 1, 5, 1);
 800e4d8:	67c3      	str	r3, [r0, #124]	; 0x7c
	D32FP(1, 1, 3, 1);
 800e4da:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800e4dc:	1ab3      	subs	r3, r6, r2
 800e4de:	6c45      	ldr	r5, [r0, #68]	; 0x44
 800e4e0:	4432      	add	r2, r6
 800e4e2:	49bd      	ldr	r1, [pc, #756]	; (800e7d8 <xmp3fixpt_FDCT32+0x36c>)
 800e4e4:	fb81 6303 	smull	r6, r3, r1, r3
 800e4e8:	1b61      	subs	r1, r4, r5
 800e4ea:	005b      	lsls	r3, r3, #1
 800e4ec:	442c      	add	r4, r5
 800e4ee:	4dbb      	ldr	r5, [pc, #748]	; (800e7dc <xmp3fixpt_FDCT32+0x370>)
 800e4f0:	fb85 6101 	smull	r6, r1, r5, r1
 800e4f4:	1915      	adds	r5, r2, r4
 800e4f6:	00c9      	lsls	r1, r1, #3
 800e4f8:	1b12      	subs	r2, r2, r4
 800e4fa:	4cb9      	ldr	r4, [pc, #740]	; (800e7e0 <xmp3fixpt_FDCT32+0x374>)
 800e4fc:	6045      	str	r5, [r0, #4]
 800e4fe:	fb84 5202 	smull	r5, r2, r4, r2
 800e502:	0052      	lsls	r2, r2, #1
 800e504:	6382      	str	r2, [r0, #56]	; 0x38
 800e506:	185a      	adds	r2, r3, r1
 800e508:	1a5b      	subs	r3, r3, r1
 800e50a:	6442      	str	r2, [r0, #68]	; 0x44
 800e50c:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(2, 1, 3, 1);
 800e510:	6886      	ldr	r6, [r0, #8]
	D32FP(1, 1, 3, 1);
 800e512:	005b      	lsls	r3, r3, #1
	D32FP(2, 1, 3, 1);
 800e514:	6f42      	ldr	r2, [r0, #116]	; 0x74
	D32FP(1, 1, 3, 1);
 800e516:	6783      	str	r3, [r0, #120]	; 0x78
	D32FP(2, 1, 3, 1);
 800e518:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800e51a:	1ab3      	subs	r3, r6, r2
 800e51c:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800e51e:	4432      	add	r2, r6
 800e520:	49b0      	ldr	r1, [pc, #704]	; (800e7e4 <xmp3fixpt_FDCT32+0x378>)
 800e522:	fb81 6303 	smull	r6, r3, r1, r3
 800e526:	1b61      	subs	r1, r4, r5
 800e528:	005b      	lsls	r3, r3, #1
 800e52a:	442c      	add	r4, r5
 800e52c:	4dae      	ldr	r5, [pc, #696]	; (800e7e8 <xmp3fixpt_FDCT32+0x37c>)
 800e52e:	fb85 6101 	smull	r6, r1, r5, r1
 800e532:	1915      	adds	r5, r2, r4
 800e534:	00c9      	lsls	r1, r1, #3
 800e536:	1b12      	subs	r2, r2, r4
 800e538:	4cac      	ldr	r4, [pc, #688]	; (800e7ec <xmp3fixpt_FDCT32+0x380>)
 800e53a:	6085      	str	r5, [r0, #8]
 800e53c:	fb84 5202 	smull	r5, r2, r4, r2
 800e540:	0052      	lsls	r2, r2, #1
 800e542:	6342      	str	r2, [r0, #52]	; 0x34
 800e544:	185a      	adds	r2, r3, r1
 800e546:	1a5b      	subs	r3, r3, r1
 800e548:	6482      	str	r2, [r0, #72]	; 0x48
 800e54a:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(3, 1, 2, 1);
 800e54e:	68c6      	ldr	r6, [r0, #12]
	D32FP(2, 1, 3, 1);
 800e550:	005b      	lsls	r3, r3, #1
	D32FP(3, 1, 2, 1);
 800e552:	6f02      	ldr	r2, [r0, #112]	; 0x70
	D32FP(2, 1, 3, 1);
 800e554:	6743      	str	r3, [r0, #116]	; 0x74
	D32FP(3, 1, 2, 1);
 800e556:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800e558:	1ab3      	subs	r3, r6, r2
 800e55a:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
 800e55c:	4432      	add	r2, r6
 800e55e:	49a4      	ldr	r1, [pc, #656]	; (800e7f0 <xmp3fixpt_FDCT32+0x384>)
 800e560:	fb81 6303 	smull	r6, r3, r1, r3
 800e564:	1b61      	subs	r1, r4, r5
 800e566:	005b      	lsls	r3, r3, #1
 800e568:	442c      	add	r4, r5
 800e56a:	4da2      	ldr	r5, [pc, #648]	; (800e7f4 <xmp3fixpt_FDCT32+0x388>)
 800e56c:	fb85 6101 	smull	r6, r1, r5, r1
 800e570:	1915      	adds	r5, r2, r4
 800e572:	0089      	lsls	r1, r1, #2
 800e574:	1b12      	subs	r2, r2, r4
 800e576:	4ca0      	ldr	r4, [pc, #640]	; (800e7f8 <xmp3fixpt_FDCT32+0x38c>)
 800e578:	60c5      	str	r5, [r0, #12]
 800e57a:	fb84 5202 	smull	r5, r2, r4, r2
 800e57e:	0052      	lsls	r2, r2, #1
 800e580:	6302      	str	r2, [r0, #48]	; 0x30
 800e582:	185a      	adds	r2, r3, r1
 800e584:	1a5b      	subs	r3, r3, r1
 800e586:	64c2      	str	r2, [r0, #76]	; 0x4c
 800e588:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(4, 1, 2, 1);
 800e58c:	6906      	ldr	r6, [r0, #16]
	D32FP(3, 1, 2, 1);
 800e58e:	005b      	lsls	r3, r3, #1
	D32FP(4, 1, 2, 1);
 800e590:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
	D32FP(3, 1, 2, 1);
 800e592:	6703      	str	r3, [r0, #112]	; 0x70
	D32FP(4, 1, 2, 1);
 800e594:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800e596:	1ab3      	subs	r3, r6, r2
 800e598:	6d05      	ldr	r5, [r0, #80]	; 0x50
 800e59a:	4432      	add	r2, r6
 800e59c:	4997      	ldr	r1, [pc, #604]	; (800e7fc <xmp3fixpt_FDCT32+0x390>)
 800e59e:	fb81 6303 	smull	r6, r3, r1, r3
 800e5a2:	1b61      	subs	r1, r4, r5
 800e5a4:	005b      	lsls	r3, r3, #1
 800e5a6:	442c      	add	r4, r5
 800e5a8:	4d95      	ldr	r5, [pc, #596]	; (800e800 <xmp3fixpt_FDCT32+0x394>)
 800e5aa:	fb85 6101 	smull	r6, r1, r5, r1
 800e5ae:	1915      	adds	r5, r2, r4
 800e5b0:	0089      	lsls	r1, r1, #2
 800e5b2:	1b12      	subs	r2, r2, r4
 800e5b4:	4c93      	ldr	r4, [pc, #588]	; (800e804 <xmp3fixpt_FDCT32+0x398>)
 800e5b6:	6105      	str	r5, [r0, #16]
 800e5b8:	fb84 5202 	smull	r5, r2, r4, r2
 800e5bc:	0052      	lsls	r2, r2, #1
 800e5be:	62c2      	str	r2, [r0, #44]	; 0x2c
 800e5c0:	185a      	adds	r2, r3, r1
 800e5c2:	1a5b      	subs	r3, r3, r1
 800e5c4:	6502      	str	r2, [r0, #80]	; 0x50
 800e5c6:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(5, 1, 1, 2);
 800e5ca:	6946      	ldr	r6, [r0, #20]
	D32FP(4, 1, 2, 1);
 800e5cc:	005b      	lsls	r3, r3, #1
	D32FP(5, 1, 1, 2);
 800e5ce:	6e82      	ldr	r2, [r0, #104]	; 0x68
	D32FP(4, 1, 2, 1);
 800e5d0:	66c3      	str	r3, [r0, #108]	; 0x6c
	D32FP(5, 1, 1, 2);
 800e5d2:	6a84      	ldr	r4, [r0, #40]	; 0x28
 800e5d4:	1ab3      	subs	r3, r6, r2
 800e5d6:	6d45      	ldr	r5, [r0, #84]	; 0x54
 800e5d8:	4432      	add	r2, r6
 800e5da:	498b      	ldr	r1, [pc, #556]	; (800e808 <xmp3fixpt_FDCT32+0x39c>)
 800e5dc:	fb81 6303 	smull	r6, r3, r1, r3
 800e5e0:	1b61      	subs	r1, r4, r5
 800e5e2:	005b      	lsls	r3, r3, #1
 800e5e4:	442c      	add	r4, r5
 800e5e6:	4d89      	ldr	r5, [pc, #548]	; (800e80c <xmp3fixpt_FDCT32+0x3a0>)
 800e5e8:	fb85 6101 	smull	r6, r1, r5, r1
 800e5ec:	1915      	adds	r5, r2, r4
 800e5ee:	0049      	lsls	r1, r1, #1
 800e5f0:	1b12      	subs	r2, r2, r4
 800e5f2:	4c87      	ldr	r4, [pc, #540]	; (800e810 <xmp3fixpt_FDCT32+0x3a4>)
 800e5f4:	6145      	str	r5, [r0, #20]
 800e5f6:	fb84 5202 	smull	r5, r2, r4, r2
 800e5fa:	0092      	lsls	r2, r2, #2
 800e5fc:	6282      	str	r2, [r0, #40]	; 0x28
 800e5fe:	185a      	adds	r2, r3, r1
 800e600:	1a5b      	subs	r3, r3, r1
 800e602:	6542      	str	r2, [r0, #84]	; 0x54
 800e604:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(6, 1, 1, 2);
 800e608:	6986      	ldr	r6, [r0, #24]
	D32FP(5, 1, 1, 2);
 800e60a:	009b      	lsls	r3, r3, #2
	D32FP(6, 1, 1, 2);
 800e60c:	6e42      	ldr	r2, [r0, #100]	; 0x64
	D32FP(5, 1, 1, 2);
 800e60e:	6683      	str	r3, [r0, #104]	; 0x68
	D32FP(6, 1, 1, 2);
 800e610:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800e612:	1ab3      	subs	r3, r6, r2
 800e614:	6d85      	ldr	r5, [r0, #88]	; 0x58
 800e616:	4432      	add	r2, r6
 800e618:	497e      	ldr	r1, [pc, #504]	; (800e814 <xmp3fixpt_FDCT32+0x3a8>)
 800e61a:	fb81 6303 	smull	r6, r3, r1, r3
 800e61e:	1b61      	subs	r1, r4, r5
 800e620:	005b      	lsls	r3, r3, #1
 800e622:	442c      	add	r4, r5
 800e624:	4d7c      	ldr	r5, [pc, #496]	; (800e818 <xmp3fixpt_FDCT32+0x3ac>)
 800e626:	fb85 6101 	smull	r6, r1, r5, r1
 800e62a:	1915      	adds	r5, r2, r4
 800e62c:	0049      	lsls	r1, r1, #1
 800e62e:	1b12      	subs	r2, r2, r4
 800e630:	4c7a      	ldr	r4, [pc, #488]	; (800e81c <xmp3fixpt_FDCT32+0x3b0>)
 800e632:	6185      	str	r5, [r0, #24]
 800e634:	fb84 5202 	smull	r5, r2, r4, r2
 800e638:	0092      	lsls	r2, r2, #2
 800e63a:	6242      	str	r2, [r0, #36]	; 0x24
 800e63c:	185a      	adds	r2, r3, r1
 800e63e:	1a5b      	subs	r3, r3, r1
 800e640:	6582      	str	r2, [r0, #88]	; 0x58
 800e642:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(7, 1, 1, 4);
 800e646:	69c6      	ldr	r6, [r0, #28]
	D32FP(6, 1, 1, 2);
 800e648:	009b      	lsls	r3, r3, #2
	D32FP(7, 1, 1, 4);
 800e64a:	6e02      	ldr	r2, [r0, #96]	; 0x60
	D32FP(6, 1, 1, 2);
 800e64c:	6643      	str	r3, [r0, #100]	; 0x64
	D32FP(7, 1, 1, 4);
 800e64e:	6a04      	ldr	r4, [r0, #32]
 800e650:	1ab3      	subs	r3, r6, r2
 800e652:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 800e654:	4432      	add	r2, r6
 800e656:	4972      	ldr	r1, [pc, #456]	; (800e820 <xmp3fixpt_FDCT32+0x3b4>)
 800e658:	fb81 6303 	smull	r6, r3, r1, r3
 800e65c:	1b61      	subs	r1, r4, r5
 800e65e:	005b      	lsls	r3, r3, #1
 800e660:	442c      	add	r4, r5
 800e662:	4d70      	ldr	r5, [pc, #448]	; (800e824 <xmp3fixpt_FDCT32+0x3b8>)
 800e664:	fb85 6101 	smull	r6, r1, r5, r1
 800e668:	1915      	adds	r5, r2, r4
 800e66a:	0049      	lsls	r1, r1, #1
 800e66c:	1b12      	subs	r2, r2, r4
 800e66e:	4c6e      	ldr	r4, [pc, #440]	; (800e828 <xmp3fixpt_FDCT32+0x3bc>)
 800e670:	61c5      	str	r5, [r0, #28]
 800e672:	fb84 5202 	smull	r5, r2, r4, r2
 800e676:	0112      	lsls	r2, r2, #4
 800e678:	6202      	str	r2, [r0, #32]
 800e67a:	185a      	adds	r2, r3, r1
 800e67c:	1a5b      	subs	r3, r3, r1
 800e67e:	65c2      	str	r2, [r0, #92]	; 0x5c
 800e680:	fb84 2303 	smull	r2, r3, r4, r3
 800e684:	011b      	lsls	r3, r3, #4
 800e686:	f100 02a0 	add.w	r2, r0, #160	; 0xa0
 800e68a:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 800e830 <xmp3fixpt_FDCT32+0x3c4>
 800e68e:	6603      	str	r3, [r0, #96]	; 0x60

	/* second pass */
	for (i = 4; i > 0; i--) {
 800e690:	f100 0320 	add.w	r3, r0, #32
 800e694:	9200      	str	r2, [sp, #0]
 800e696:	e9cd b004 	strd	fp, r0, [sp, #16]
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 800e69a:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800e69e:	f853 6c20 	ldr.w	r6, [r3, #-32]
 800e6a2:	e953 5705 	ldrd	r5, r7, [r3, #-20]
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 800e6a6:	1ab1      	subs	r1, r6, r2
 800e6a8:	4416      	add	r6, r2
 800e6aa:	f8da 2060 	ldr.w	r2, [sl, #96]	; 0x60
 800e6ae:	fb82 4101 	smull	r4, r1, r2, r1
 800e6b2:	004c      	lsls	r4, r1, #1
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800e6b4:	1bea      	subs	r2, r5, r7
 800e6b6:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
 800e6ba:	443d      	add	r5, r7
 800e6bc:	fb81 7202 	smull	r7, r2, r1, r2
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e6c0:	eba6 0e05 	sub.w	lr, r6, r5
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800e6c4:	00d1      	lsls	r1, r2, #3
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e6c6:	442e      	add	r6, r5
 800e6c8:	f8da 5068 	ldr.w	r5, [sl, #104]	; 0x68
 800e6cc:	fb85 2e0e 	smull	r2, lr, r5, lr
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e6d0:	1a62      	subs	r2, r4, r1
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e6d2:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e6d6:	4421      	add	r1, r4
 800e6d8:	fb85 4202 	smull	r4, r2, r5, r2

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e6dc:	f853 9c1c 	ldr.w	r9, [r3, #-28]
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e6e0:	0052      	lsls	r2, r2, #1
		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e6e2:	f853 cc08 	ldr.w	ip, [r3, #-8]
 800e6e6:	f853 4c18 	ldr.w	r4, [r3, #-24]
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800e6ea:	eba9 050c 	sub.w	r5, r9, ip
		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e6ee:	f853 7c0c 	ldr.w	r7, [r3, #-12]
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800e6f2:	44e1      	add	r9, ip
 800e6f4:	f8da 006c 	ldr.w	r0, [sl, #108]	; 0x6c
 800e6f8:	fb80 c505 	smull	ip, r5, r0, r5
 800e6fc:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800e700:	1be5      	subs	r5, r4, r7
 800e702:	4427      	add	r7, r4
 800e704:	f8da 4070 	ldr.w	r4, [sl, #112]	; 0x70
 800e708:	fb84 8505 	smull	r8, r5, r4, r5
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e70c:	eba9 0407 	sub.w	r4, r9, r7
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800e710:	006d      	lsls	r5, r5, #1
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e712:	44b9      	add	r9, r7
 800e714:	f8da 8074 	ldr.w	r8, [sl, #116]	; 0x74
 800e718:	fb88 7404 	smull	r7, r4, r8, r4
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800e71c:	ebac 0705 	sub.w	r7, ip, r5
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e720:	00a4      	lsls	r4, r4, #2
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800e722:	4465      	add	r5, ip
 800e724:	fb88 c707 	smull	ip, r7, r8, r7
 800e728:	4840      	ldr	r0, [pc, #256]	; (800e82c <xmp3fixpt_FDCT32+0x3c0>)
 800e72a:	00bf      	lsls	r7, r7, #2

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e72c:	eba6 0809 	sub.w	r8, r6, r9
 800e730:	fb80 c808 	smull	ip, r8, r0, r8
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800e734:	ebae 0c04 	sub.w	ip, lr, r4
 800e738:	fb80 bc0c 	smull	fp, ip, r0, ip
 800e73c:	4474      	add	r4, lr
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e73e:	444e      	add	r6, r9
		buf[0] = b0;	    buf[1] = b1;
		buf[2] = b2 + b3;	buf[3] = b3;
 800e740:	eb04 044c 	add.w	r4, r4, ip, lsl #1
		buf[0] = b0;	    buf[1] = b1;
 800e744:	f843 6c20 	str.w	r6, [r3, #-32]
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e748:	ea4f 0648 	mov.w	r6, r8, lsl #1
		buf[2] = b2 + b3;	buf[3] = b3;
 800e74c:	f843 4c18 	str.w	r4, [r3, #-24]
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800e750:	ea4f 044c 	mov.w	r4, ip, lsl #1
		buf[0] = b0;	    buf[1] = b1;
 800e754:	f843 6c1c 	str.w	r6, [r3, #-28]
		buf[2] = b2 + b3;	buf[3] = b3;
 800e758:	f843 4c14 	str.w	r4, [r3, #-20]

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e75c:	1b4c      	subs	r4, r1, r5
 800e75e:	fb80 6404 	smull	r6, r4, r0, r4
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e762:	1bd6      	subs	r6, r2, r7
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e764:	0064      	lsls	r4, r4, #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e766:	443a      	add	r2, r7
 800e768:	fb80 7606 	smull	r7, r6, r0, r6
		b6 += b7;
 800e76c:	eb02 0246 	add.w	r2, r2, r6, lsl #1
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e770:	4429      	add	r1, r5
	for (i = 4; i > 0; i--) {
 800e772:	3320      	adds	r3, #32
 800e774:	f10a 0a18 	add.w	sl, sl, #24
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e778:	4411      	add	r1, r2
		buf[6] = b5 + b6;	buf[7] = b7;
 800e77a:	4422      	add	r2, r4
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e77c:	eb04 0446 	add.w	r4, r4, r6, lsl #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e780:	0076      	lsls	r6, r6, #1
		buf[6] = b5 + b6;	buf[7] = b7;
 800e782:	f843 2c28 	str.w	r2, [r3, #-40]
	for (i = 4; i > 0; i--) {
 800e786:	9a00      	ldr	r2, [sp, #0]
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e788:	f843 1c30 	str.w	r1, [r3, #-48]
 800e78c:	f843 4c2c 	str.w	r4, [r3, #-44]
		buf[6] = b5 + b6;	buf[7] = b7;
 800e790:	f843 6c24 	str.w	r6, [r3, #-36]
	for (i = 4; i > 0; i--) {
 800e794:	4293      	cmp	r3, r2
 800e796:	d180      	bne.n	800e69a <xmp3fixpt_FDCT32+0x22e>
		buf += 8;
	}
	buf -= 32;	/* reset */

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e798:	e9dd 3102 	ldrd	r3, r1, [sp, #8]
 800e79c:	e9dd b004 	ldrd	fp, r0, [sp, #16]
 800e7a0:	1a5b      	subs	r3, r3, r1
 800e7a2:	f003 0307 	and.w	r3, r3, #7
 800e7a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800e7aa:	009a      	lsls	r2, r3, #2
 800e7ac:	2900      	cmp	r1, #0
 800e7ae:	f000 832c 	beq.w	800ee0a <xmp3fixpt_FDCT32+0x99e>
 800e7b2:	9d01      	ldr	r5, [sp, #4]
	s = buf[ 0];				d[0] = d[8] = s;
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e7b4:	9902      	ldr	r1, [sp, #8]
	s = buf[ 0];				d[0] = d[8] = s;
 800e7b6:	6804      	ldr	r4, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e7b8:	18ae      	adds	r6, r5, r2
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e7ba:	0089      	lsls	r1, r1, #2
 800e7bc:	462f      	mov	r7, r5
	s = buf[ 0];				d[0] = d[8] = s;
 800e7be:	6234      	str	r4, [r6, #32]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e7c0:	f501 5188 	add.w	r1, r1, #4352	; 0x1100
	s = buf[ 0];				d[0] = d[8] = s;
 800e7c4:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e7c8:	2400      	movs	r4, #0
 800e7ca:	e033      	b.n	800e834 <xmp3fixpt_FDCT32+0x3c8>
 800e7cc:	4013c251 	.word	0x4013c251
 800e7d0:	518522fb 	.word	0x518522fb
 800e7d4:	404f4672 	.word	0x404f4672
 800e7d8:	40b345bd 	.word	0x40b345bd
 800e7dc:	6d0b20cf 	.word	0x6d0b20cf
 800e7e0:	42e13c10 	.word	0x42e13c10
 800e7e4:	41fa2d6d 	.word	0x41fa2d6d
 800e7e8:	41d95790 	.word	0x41d95790
 800e7ec:	48919f44 	.word	0x48919f44
 800e7f0:	43f93421 	.word	0x43f93421
 800e7f4:	5efc8d96 	.word	0x5efc8d96
 800e7f8:	52cb0e63 	.word	0x52cb0e63
 800e7fc:	46cc1bc4 	.word	0x46cc1bc4
 800e800:	4ad81a97 	.word	0x4ad81a97
 800e804:	64e2402e 	.word	0x64e2402e
 800e808:	4a9d9cf0 	.word	0x4a9d9cf0
 800e80c:	7c7d1db3 	.word	0x7c7d1db3
 800e810:	43e224a9 	.word	0x43e224a9
 800e814:	4fae3711 	.word	0x4fae3711
 800e818:	6b6fcf26 	.word	0x6b6fcf26
 800e81c:	6e3c92c1 	.word	0x6e3c92c1
 800e820:	56601ea7 	.word	0x56601ea7
 800e824:	5f4cf6eb 	.word	0x5f4cf6eb
 800e828:	519e4e04 	.word	0x519e4e04
 800e82c:	5a82799a 	.word	0x5a82799a
 800e830:	08022afc 	.word	0x08022afc
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
	s = buf[15];				d[0] = d[8] = s;	d += 64;
	s = tmp;					d[0] = d[8] = s;

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e834:	f5a2 627c 	sub.w	r2, r2, #4032	; 0xfc0
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e838:	187b      	adds	r3, r7, r1
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e83a:	4414      	add	r4, r2
	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800e83c:	6842      	ldr	r2, [r0, #4]
 800e83e:	621a      	str	r2, [r3, #32]
 800e840:	507a      	str	r2, [r7, r1]
	tmp = buf[25] + buf[29];
 800e842:	6f41      	ldr	r1, [r0, #116]	; 0x74
 800e844:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800e846:	440a      	add	r2, r1
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e848:	6c41      	ldr	r1, [r0, #68]	; 0x44
 800e84a:	4411      	add	r1, r2
 800e84c:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
 800e850:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 800e854:	6b45      	ldr	r5, [r0, #52]	; 0x34
 800e856:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800e858:	4429      	add	r1, r5
 800e85a:	f8c3 1220 	str.w	r1, [r3, #544]	; 0x220
 800e85e:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800e862:	6d41      	ldr	r1, [r0, #84]	; 0x54
 800e864:	440a      	add	r2, r1
 800e866:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
 800e86a:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
	tmp = buf[29] + buf[27];
 800e86e:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 800e870:	6f42      	ldr	r2, [r0, #116]	; 0x74
 800e872:	440a      	add	r2, r1
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 800e874:	6941      	ldr	r1, [r0, #20]
 800e876:	f8c3 1420 	str.w	r1, [r3, #1056]	; 0x420
 800e87a:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800e87e:	6d41      	ldr	r1, [r0, #84]	; 0x54
 800e880:	4411      	add	r1, r2
 800e882:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
 800e886:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 800e88a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800e88c:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800e88e:	4429      	add	r1, r5
 800e890:	f8c3 1620 	str.w	r1, [r3, #1568]	; 0x620
 800e894:	f8c3 1600 	str.w	r1, [r3, #1536]	; 0x600
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800e898:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800e89a:	440a      	add	r2, r1
 800e89c:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
 800e8a0:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
	tmp = buf[27] + buf[31];
 800e8a4:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800e8a6:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 800e8a8:	440a      	add	r2, r1
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 800e8aa:	68c1      	ldr	r1, [r0, #12]
 800e8ac:	f8c3 1820 	str.w	r1, [r3, #2080]	; 0x820
 800e8b0:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800e8b4:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800e8b6:	4411      	add	r1, r2
 800e8b8:	f8c3 1920 	str.w	r1, [r3, #2336]	; 0x920
 800e8bc:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 800e8c0:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 800e8c2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800e8c4:	4429      	add	r1, r5
 800e8c6:	f8c3 1a20 	str.w	r1, [r3, #2592]	; 0xa20
 800e8ca:	f8c3 1a00 	str.w	r1, [r3, #2560]	; 0xa00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800e8ce:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 800e8d0:	440a      	add	r2, r1
 800e8d2:	f8c3 2b20 	str.w	r2, [r3, #2848]	; 0xb20
 800e8d6:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800e8da:	69c2      	ldr	r2, [r0, #28]
	tmp = buf[31];
 800e8dc:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800e8de:	f8c3 2c20 	str.w	r2, [r3, #3104]	; 0xc20
 800e8e2:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800e8e6:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800e8e8:	440a      	add	r2, r1
 800e8ea:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800e8ee:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800e8f2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
	s = tmp;					d[0] = d[8] = s;
 800e8f4:	f8c3 1f20 	str.w	r1, [r3, #3872]	; 0xf20
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800e8f8:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
 800e8fc:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e900:	193a      	adds	r2, r7, r4
	s = tmp;					d[0] = d[8] = s;
 800e902:	f8c3 1f00 	str.w	r1, [r3, #3840]	; 0xf00

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800e906:	6841      	ldr	r1, [r0, #4]
 800e908:	6211      	str	r1, [r2, #32]
 800e90a:	5139      	str	r1, [r7, r4]

	tmp = buf[30] + buf[25];
 800e90c:	6e45      	ldr	r5, [r0, #100]	; 0x64
 800e90e:	6f81      	ldr	r1, [r0, #120]	; 0x78
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e910:	6c47      	ldr	r7, [r0, #68]	; 0x44
	tmp = buf[30] + buf[25];
 800e912:	4429      	add	r1, r5
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e914:	440f      	add	r7, r1
 800e916:	f8c2 7120 	str.w	r7, [r2, #288]	; 0x120
 800e91a:	f8c2 7100 	str.w	r7, [r2, #256]	; 0x100
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 800e91e:	6a47      	ldr	r7, [r0, #36]	; 0x24
 800e920:	6b85      	ldr	r5, [r0, #56]	; 0x38
 800e922:	443d      	add	r5, r7
 800e924:	f8c2 5220 	str.w	r5, [r2, #544]	; 0x220
 800e928:	f8c2 5200 	str.w	r5, [r2, #512]	; 0x200
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e92c:	6d87      	ldr	r7, [r0, #88]	; 0x58
 800e92e:	4439      	add	r1, r7
 800e930:	f8c2 1320 	str.w	r1, [r2, #800]	; 0x320
 800e934:	f8c2 1300 	str.w	r1, [r2, #768]	; 0x300
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 800e938:	6981      	ldr	r1, [r0, #24]
 800e93a:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
 800e93e:	f8c2 1400 	str.w	r1, [r2, #1024]	; 0x400

	tmp = buf[26] + buf[30];
 800e942:	6f85      	ldr	r5, [r0, #120]	; 0x78
 800e944:	6e81      	ldr	r1, [r0, #104]	; 0x68
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e946:	6d87      	ldr	r7, [r0, #88]	; 0x58
	tmp = buf[26] + buf[30];
 800e948:	4429      	add	r1, r5
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e94a:	440f      	add	r7, r1
 800e94c:	f8c2 7520 	str.w	r7, [r2, #1312]	; 0x520
 800e950:	f8c2 7500 	str.w	r7, [r2, #1280]	; 0x500
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 800e954:	6b87      	ldr	r7, [r0, #56]	; 0x38
 800e956:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800e958:	443d      	add	r5, r7
 800e95a:	f8c2 5620 	str.w	r5, [r2, #1568]	; 0x620
 800e95e:	f8c2 5600 	str.w	r5, [r2, #1536]	; 0x600
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e962:	6c87      	ldr	r7, [r0, #72]	; 0x48
 800e964:	4439      	add	r1, r7
 800e966:	f8c2 1720 	str.w	r1, [r2, #1824]	; 0x720
 800e96a:	f8c2 1700 	str.w	r1, [r2, #1792]	; 0x700
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 800e96e:	6881      	ldr	r1, [r0, #8]
 800e970:	f8c2 1820 	str.w	r1, [r2, #2080]	; 0x820
 800e974:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800

	tmp = buf[28] + buf[26];
 800e978:	6e85      	ldr	r5, [r0, #104]	; 0x68
 800e97a:	6f01      	ldr	r1, [r0, #112]	; 0x70
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e97c:	6c87      	ldr	r7, [r0, #72]	; 0x48
	tmp = buf[28] + buf[26];
 800e97e:	4429      	add	r1, r5
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e980:	440f      	add	r7, r1
 800e982:	f8c2 7920 	str.w	r7, [r2, #2336]	; 0x920
 800e986:	f8c2 7900 	str.w	r7, [r2, #2304]	; 0x900
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 800e98a:	6a87      	ldr	r7, [r0, #40]	; 0x28
 800e98c:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800e98e:	443d      	add	r5, r7
 800e990:	f8c2 5a20 	str.w	r5, [r2, #2592]	; 0xa20
 800e994:	f8c2 5a00 	str.w	r5, [r2, #2560]	; 0xa00
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e998:	6d07      	ldr	r7, [r0, #80]	; 0x50
 800e99a:	4439      	add	r1, r7
 800e99c:	f8c2 1b20 	str.w	r1, [r2, #2848]	; 0xb20
 800e9a0:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 800e9a4:	6901      	ldr	r1, [r0, #16]
 800e9a6:	f8c2 1c20 	str.w	r1, [r2, #3104]	; 0xc20
 800e9aa:	f8c2 1c00 	str.w	r1, [r2, #3072]	; 0xc00

	tmp = buf[24] + buf[28];
 800e9ae:	6f05      	ldr	r5, [r0, #112]	; 0x70
 800e9b0:	6e01      	ldr	r1, [r0, #96]	; 0x60
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e9b2:	6d07      	ldr	r7, [r0, #80]	; 0x50
	tmp = buf[24] + buf[28];
 800e9b4:	4429      	add	r1, r5
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e9b6:	440f      	add	r7, r1
 800e9b8:	f8c2 7d20 	str.w	r7, [r2, #3360]	; 0xd20
 800e9bc:	f8c2 7d00 	str.w	r7, [r2, #3328]	; 0xd00
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 800e9c0:	6a05      	ldr	r5, [r0, #32]
 800e9c2:	6b07      	ldr	r7, [r0, #48]	; 0x30
 800e9c4:	443d      	add	r5, r7
 800e9c6:	f8c2 5e20 	str.w	r5, [r2, #3616]	; 0xe20
 800e9ca:	f8c2 5e00 	str.w	r5, [r2, #3584]	; 0xe00
	s = buf[16] + tmp;			d[0] = d[8] = s;
 800e9ce:	6c05      	ldr	r5, [r0, #64]	; 0x40
 800e9d0:	4429      	add	r1, r5
 800e9d2:	f8c2 1f20 	str.w	r1, [r2, #3872]	; 0xf20
 800e9d6:	f8c2 1f00 	str.w	r1, [r2, #3840]	; 0xf00

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 800e9da:	f1bb 0f00 	cmp.w	fp, #0
 800e9de:	f000 8211 	beq.w	800ee04 <xmp3fixpt_FDCT32+0x998>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 800e9e2:	f1cb 011f 	rsb	r1, fp, #31
 800e9e6:	6835      	ldr	r5, [r6, #0]
 800e9e8:	fa45 f001 	asr.w	r0, r5, r1
 800e9ec:	17ef      	asrs	r7, r5, #31
 800e9ee:	ebb0 7fe5 	cmp.w	r0, r5, asr #31
 800e9f2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800e9f6:	fa20 f00b 	lsr.w	r0, r0, fp
 800e9fa:	f100 30ff 	add.w	r0, r0, #4294967295
 800e9fe:	bf18      	it	ne
 800ea00:	ea80 0507 	eorne.w	r5, r0, r7
 800ea04:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea08:	6235      	str	r5, [r6, #32]
 800ea0a:	6035      	str	r5, [r6, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
		for (i = 16; i <= 31; i++) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800ea0c:	681d      	ldr	r5, [r3, #0]
 800ea0e:	fa45 f601 	asr.w	r6, r5, r1
 800ea12:	17ef      	asrs	r7, r5, #31
 800ea14:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ea18:	bf18      	it	ne
 800ea1a:	ea80 0507 	eorne.w	r5, r0, r7
 800ea1e:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea22:	621d      	str	r5, [r3, #32]
 800ea24:	601d      	str	r5, [r3, #0]
 800ea26:	f8d3 5100 	ldr.w	r5, [r3, #256]	; 0x100
 800ea2a:	fa45 f601 	asr.w	r6, r5, r1
 800ea2e:	17ef      	asrs	r7, r5, #31
 800ea30:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ea34:	bf18      	it	ne
 800ea36:	ea80 0507 	eorne.w	r5, r0, r7
 800ea3a:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea3e:	f8c3 5120 	str.w	r5, [r3, #288]	; 0x120
 800ea42:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
 800ea46:	f8d3 5200 	ldr.w	r5, [r3, #512]	; 0x200
 800ea4a:	fa45 f601 	asr.w	r6, r5, r1
 800ea4e:	17ef      	asrs	r7, r5, #31
 800ea50:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ea54:	bf18      	it	ne
 800ea56:	ea80 0507 	eorne.w	r5, r0, r7
 800ea5a:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea5e:	f8c3 5220 	str.w	r5, [r3, #544]	; 0x220
 800ea62:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
 800ea66:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
 800ea6a:	fa45 f601 	asr.w	r6, r5, r1
 800ea6e:	17ef      	asrs	r7, r5, #31
 800ea70:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ea74:	bf18      	it	ne
 800ea76:	ea80 0507 	eorne.w	r5, r0, r7
 800ea7a:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea7e:	f8c3 5320 	str.w	r5, [r3, #800]	; 0x320
 800ea82:	f8c3 5300 	str.w	r5, [r3, #768]	; 0x300
 800ea86:	f8d3 5400 	ldr.w	r5, [r3, #1024]	; 0x400
 800ea8a:	fa45 f601 	asr.w	r6, r5, r1
 800ea8e:	17ef      	asrs	r7, r5, #31
 800ea90:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ea94:	bf18      	it	ne
 800ea96:	ea80 0507 	eorne.w	r5, r0, r7
 800ea9a:	fa05 f50b 	lsl.w	r5, r5, fp
 800ea9e:	f8c3 5420 	str.w	r5, [r3, #1056]	; 0x420
 800eaa2:	f8c3 5400 	str.w	r5, [r3, #1024]	; 0x400
 800eaa6:	f8d3 5500 	ldr.w	r5, [r3, #1280]	; 0x500
 800eaaa:	fa45 f601 	asr.w	r6, r5, r1
 800eaae:	17ef      	asrs	r7, r5, #31
 800eab0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eab4:	bf18      	it	ne
 800eab6:	ea80 0507 	eorne.w	r5, r0, r7
 800eaba:	fa05 f50b 	lsl.w	r5, r5, fp
 800eabe:	f8c3 5520 	str.w	r5, [r3, #1312]	; 0x520
 800eac2:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
 800eac6:	f8d3 5600 	ldr.w	r5, [r3, #1536]	; 0x600
 800eaca:	fa45 f601 	asr.w	r6, r5, r1
 800eace:	17ef      	asrs	r7, r5, #31
 800ead0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ead4:	bf18      	it	ne
 800ead6:	ea80 0507 	eorne.w	r5, r0, r7
 800eada:	fa05 f50b 	lsl.w	r5, r5, fp
 800eade:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
 800eae2:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
 800eae6:	f8d3 5700 	ldr.w	r5, [r3, #1792]	; 0x700
 800eaea:	fa45 f601 	asr.w	r6, r5, r1
 800eaee:	17ef      	asrs	r7, r5, #31
 800eaf0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eaf4:	bf18      	it	ne
 800eaf6:	ea80 0507 	eorne.w	r5, r0, r7
 800eafa:	fa05 f50b 	lsl.w	r5, r5, fp
 800eafe:	f8c3 5720 	str.w	r5, [r3, #1824]	; 0x720
 800eb02:	f8c3 5700 	str.w	r5, [r3, #1792]	; 0x700
 800eb06:	f8d3 5800 	ldr.w	r5, [r3, #2048]	; 0x800
 800eb0a:	fa45 f601 	asr.w	r6, r5, r1
 800eb0e:	17ef      	asrs	r7, r5, #31
 800eb10:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eb14:	bf18      	it	ne
 800eb16:	ea80 0507 	eorne.w	r5, r0, r7
 800eb1a:	fa05 f50b 	lsl.w	r5, r5, fp
 800eb1e:	f8c3 5820 	str.w	r5, [r3, #2080]	; 0x820
 800eb22:	f8c3 5800 	str.w	r5, [r3, #2048]	; 0x800
 800eb26:	f8d3 5900 	ldr.w	r5, [r3, #2304]	; 0x900
 800eb2a:	fa45 f601 	asr.w	r6, r5, r1
 800eb2e:	17ef      	asrs	r7, r5, #31
 800eb30:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eb34:	bf18      	it	ne
 800eb36:	ea80 0507 	eorne.w	r5, r0, r7
 800eb3a:	fa05 f50b 	lsl.w	r5, r5, fp
 800eb3e:	f8c3 5920 	str.w	r5, [r3, #2336]	; 0x920
 800eb42:	f8c3 5900 	str.w	r5, [r3, #2304]	; 0x900
 800eb46:	f8d3 5a00 	ldr.w	r5, [r3, #2560]	; 0xa00
 800eb4a:	fa45 f601 	asr.w	r6, r5, r1
 800eb4e:	17ef      	asrs	r7, r5, #31
 800eb50:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eb54:	bf18      	it	ne
 800eb56:	ea80 0507 	eorne.w	r5, r0, r7
 800eb5a:	fa05 f50b 	lsl.w	r5, r5, fp
 800eb5e:	f8c3 5a20 	str.w	r5, [r3, #2592]	; 0xa20
 800eb62:	f8c3 5a00 	str.w	r5, [r3, #2560]	; 0xa00
 800eb66:	f8d3 5b00 	ldr.w	r5, [r3, #2816]	; 0xb00
 800eb6a:	fa45 f601 	asr.w	r6, r5, r1
 800eb6e:	17ef      	asrs	r7, r5, #31
 800eb70:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eb74:	bf18      	it	ne
 800eb76:	ea80 0507 	eorne.w	r5, r0, r7
 800eb7a:	fa05 f50b 	lsl.w	r5, r5, fp
 800eb7e:	f8c3 5b20 	str.w	r5, [r3, #2848]	; 0xb20
 800eb82:	f8c3 5b00 	str.w	r5, [r3, #2816]	; 0xb00
 800eb86:	f8d3 5c00 	ldr.w	r5, [r3, #3072]	; 0xc00
 800eb8a:	fa45 f601 	asr.w	r6, r5, r1
 800eb8e:	17ef      	asrs	r7, r5, #31
 800eb90:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800eb94:	bf18      	it	ne
 800eb96:	ea80 0507 	eorne.w	r5, r0, r7
 800eb9a:	fa05 f50b 	lsl.w	r5, r5, fp
 800eb9e:	f8c3 5c20 	str.w	r5, [r3, #3104]	; 0xc20
 800eba2:	f8c3 5c00 	str.w	r5, [r3, #3072]	; 0xc00
 800eba6:	f8d3 5d00 	ldr.w	r5, [r3, #3328]	; 0xd00
 800ebaa:	fa45 f601 	asr.w	r6, r5, r1
 800ebae:	17ef      	asrs	r7, r5, #31
 800ebb0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ebb4:	bf18      	it	ne
 800ebb6:	ea80 0507 	eorne.w	r5, r0, r7
 800ebba:	fa05 f50b 	lsl.w	r5, r5, fp
 800ebbe:	f8c3 5d20 	str.w	r5, [r3, #3360]	; 0xd20
 800ebc2:	f8c3 5d00 	str.w	r5, [r3, #3328]	; 0xd00
 800ebc6:	f8d3 5e00 	ldr.w	r5, [r3, #3584]	; 0xe00
 800ebca:	fa45 f601 	asr.w	r6, r5, r1
 800ebce:	17ef      	asrs	r7, r5, #31
 800ebd0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ebd4:	bf18      	it	ne
 800ebd6:	ea80 0507 	eorne.w	r5, r0, r7
 800ebda:	fa05 f50b 	lsl.w	r5, r5, fp
 800ebde:	f8c3 5e20 	str.w	r5, [r3, #3616]	; 0xe20
 800ebe2:	f8c3 5e00 	str.w	r5, [r3, #3584]	; 0xe00
 800ebe6:	f8d3 5f00 	ldr.w	r5, [r3, #3840]	; 0xf00
 800ebea:	fa45 f601 	asr.w	r6, r5, r1
 800ebee:	17ef      	asrs	r7, r5, #31
 800ebf0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800ebf4:	bf18      	it	ne
 800ebf6:	ea80 0507 	eorne.w	r5, r0, r7
 800ebfa:	fa05 f50b 	lsl.w	r5, r5, fp
 800ebfe:	f8c3 5f20 	str.w	r5, [r3, #3872]	; 0xf20
 800ec02:	f8c3 5f00 	str.w	r5, [r3, #3840]	; 0xf00
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		for (i = 15; i >= 0; i--) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800ec06:	9b01      	ldr	r3, [sp, #4]
 800ec08:	591b      	ldr	r3, [r3, r4]
 800ec0a:	fa43 f501 	asr.w	r5, r3, r1
 800ec0e:	17de      	asrs	r6, r3, #31
 800ec10:	ebb5 7fe3 	cmp.w	r5, r3, asr #31
 800ec14:	9d01      	ldr	r5, [sp, #4]
 800ec16:	bf18      	it	ne
 800ec18:	ea80 0306 	eorne.w	r3, r0, r6
 800ec1c:	fa03 f30b 	lsl.w	r3, r3, fp
 800ec20:	6213      	str	r3, [r2, #32]
 800ec22:	512b      	str	r3, [r5, r4]
 800ec24:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 800ec28:	fa43 f401 	asr.w	r4, r3, r1
 800ec2c:	17dd      	asrs	r5, r3, #31
 800ec2e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ec32:	bf18      	it	ne
 800ec34:	ea80 0305 	eorne.w	r3, r0, r5
 800ec38:	fa03 f30b 	lsl.w	r3, r3, fp
 800ec3c:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
 800ec40:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 800ec44:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800ec48:	fa43 f401 	asr.w	r4, r3, r1
 800ec4c:	17dd      	asrs	r5, r3, #31
 800ec4e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ec52:	bf18      	it	ne
 800ec54:	ea85 0300 	eorne.w	r3, r5, r0
 800ec58:	fa03 f30b 	lsl.w	r3, r3, fp
 800ec5c:	f8c2 3220 	str.w	r3, [r2, #544]	; 0x220
 800ec60:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
 800ec64:	f8d2 3300 	ldr.w	r3, [r2, #768]	; 0x300
 800ec68:	fa43 f401 	asr.w	r4, r3, r1
 800ec6c:	17dd      	asrs	r5, r3, #31
 800ec6e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ec72:	bf18      	it	ne
 800ec74:	ea80 0305 	eorne.w	r3, r0, r5
 800ec78:	fa03 f30b 	lsl.w	r3, r3, fp
 800ec7c:	f8c2 3320 	str.w	r3, [r2, #800]	; 0x320
 800ec80:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
 800ec84:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 800ec88:	fa43 f401 	asr.w	r4, r3, r1
 800ec8c:	17dd      	asrs	r5, r3, #31
 800ec8e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ec92:	bf18      	it	ne
 800ec94:	ea80 0305 	eorne.w	r3, r0, r5
 800ec98:	fa03 f30b 	lsl.w	r3, r3, fp
 800ec9c:	f8c2 3420 	str.w	r3, [r2, #1056]	; 0x420
 800eca0:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 800eca4:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
 800eca8:	fa43 f401 	asr.w	r4, r3, r1
 800ecac:	17dd      	asrs	r5, r3, #31
 800ecae:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ecb2:	bf18      	it	ne
 800ecb4:	ea80 0305 	eorne.w	r3, r0, r5
 800ecb8:	fa03 f30b 	lsl.w	r3, r3, fp
 800ecbc:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
 800ecc0:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
 800ecc4:	f8d2 3600 	ldr.w	r3, [r2, #1536]	; 0x600
 800ecc8:	fa43 f401 	asr.w	r4, r3, r1
 800eccc:	17dd      	asrs	r5, r3, #31
 800ecce:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ecd2:	bf18      	it	ne
 800ecd4:	ea80 0305 	eorne.w	r3, r0, r5
 800ecd8:	fa03 f30b 	lsl.w	r3, r3, fp
 800ecdc:	f8c2 3620 	str.w	r3, [r2, #1568]	; 0x620
 800ece0:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
 800ece4:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
 800ece8:	fa43 f401 	asr.w	r4, r3, r1
 800ecec:	17dd      	asrs	r5, r3, #31
 800ecee:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ecf2:	bf18      	it	ne
 800ecf4:	ea80 0305 	eorne.w	r3, r0, r5
 800ecf8:	fa03 f30b 	lsl.w	r3, r3, fp
 800ecfc:	f8c2 3720 	str.w	r3, [r2, #1824]	; 0x720
 800ed00:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
 800ed04:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 800ed08:	fa43 f401 	asr.w	r4, r3, r1
 800ed0c:	17dd      	asrs	r5, r3, #31
 800ed0e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ed12:	bf18      	it	ne
 800ed14:	ea80 0305 	eorne.w	r3, r0, r5
 800ed18:	fa03 f30b 	lsl.w	r3, r3, fp
 800ed1c:	f8c2 3820 	str.w	r3, [r2, #2080]	; 0x820
 800ed20:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 800ed24:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 800ed28:	fa43 f401 	asr.w	r4, r3, r1
 800ed2c:	17dd      	asrs	r5, r3, #31
 800ed2e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ed32:	bf18      	it	ne
 800ed34:	ea80 0305 	eorne.w	r3, r0, r5
 800ed38:	fa03 f30b 	lsl.w	r3, r3, fp
 800ed3c:	f8c2 3920 	str.w	r3, [r2, #2336]	; 0x920
 800ed40:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
 800ed44:	f8d2 3a00 	ldr.w	r3, [r2, #2560]	; 0xa00
 800ed48:	fa43 f401 	asr.w	r4, r3, r1
 800ed4c:	17dd      	asrs	r5, r3, #31
 800ed4e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ed52:	bf18      	it	ne
 800ed54:	ea80 0305 	eorne.w	r3, r0, r5
 800ed58:	fa03 f30b 	lsl.w	r3, r3, fp
 800ed5c:	f8c2 3a20 	str.w	r3, [r2, #2592]	; 0xa20
 800ed60:	f8c2 3a00 	str.w	r3, [r2, #2560]	; 0xa00
 800ed64:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800ed68:	fa43 f401 	asr.w	r4, r3, r1
 800ed6c:	17dd      	asrs	r5, r3, #31
 800ed6e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ed72:	bf18      	it	ne
 800ed74:	ea80 0305 	eorne.w	r3, r0, r5
 800ed78:	fa03 f30b 	lsl.w	r3, r3, fp
 800ed7c:	f8c2 3b20 	str.w	r3, [r2, #2848]	; 0xb20
 800ed80:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800ed84:	f8d2 3c00 	ldr.w	r3, [r2, #3072]	; 0xc00
 800ed88:	fa43 f401 	asr.w	r4, r3, r1
 800ed8c:	17dd      	asrs	r5, r3, #31
 800ed8e:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800ed92:	bf18      	it	ne
 800ed94:	ea85 0300 	eorne.w	r3, r5, r0
 800ed98:	fa03 f30b 	lsl.w	r3, r3, fp
 800ed9c:	f8c2 3c20 	str.w	r3, [r2, #3104]	; 0xc20
 800eda0:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800eda4:	f8d2 3d00 	ldr.w	r3, [r2, #3328]	; 0xd00
 800eda8:	fa43 f401 	asr.w	r4, r3, r1
 800edac:	17dd      	asrs	r5, r3, #31
 800edae:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800edb2:	bf18      	it	ne
 800edb4:	ea80 0305 	eorne.w	r3, r0, r5
 800edb8:	fa03 f30b 	lsl.w	r3, r3, fp
 800edbc:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
 800edc0:	f8c2 3d00 	str.w	r3, [r2, #3328]	; 0xd00
 800edc4:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 800edc8:	fa43 f401 	asr.w	r4, r3, r1
 800edcc:	17dd      	asrs	r5, r3, #31
 800edce:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800edd2:	bf18      	it	ne
 800edd4:	ea80 0305 	eorne.w	r3, r0, r5
 800edd8:	fa03 f30b 	lsl.w	r3, r3, fp
 800eddc:	f8c2 3e20 	str.w	r3, [r2, #3616]	; 0xe20
 800ede0:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
 800ede4:	f8d2 3f00 	ldr.w	r3, [r2, #3840]	; 0xf00
 800ede8:	fa43 f101 	asr.w	r1, r3, r1
 800edec:	17dc      	asrs	r4, r3, #31
 800edee:	ebb1 7fe3 	cmp.w	r1, r3, asr #31
 800edf2:	bf18      	it	ne
 800edf4:	ea80 0304 	eorne.w	r3, r0, r4
 800edf8:	fa03 f30b 	lsl.w	r3, r3, fp
 800edfc:	f8c2 3f20 	str.w	r3, [r2, #3872]	; 0xf20
 800ee00:	f8c2 3f00 	str.w	r3, [r2, #3840]	; 0xf00
		}
	}
}
 800ee04:	b007      	add	sp, #28
 800ee06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ee0a:	9b02      	ldr	r3, [sp, #8]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ee0c:	f44f 5488 	mov.w	r4, #4352	; 0x1100
 800ee10:	9f01      	ldr	r7, [sp, #4]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ee12:	0099      	lsls	r1, r3, #2
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ee14:	f502 5388 	add.w	r3, r2, #4352	; 0x1100
	s = buf[ 0];				d[0] = d[8] = s;
 800ee18:	6805      	ldr	r5, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ee1a:	18fe      	adds	r6, r7, r3
	s = buf[ 0];				d[0] = d[8] = s;
 800ee1c:	6235      	str	r5, [r6, #32]
 800ee1e:	50fd      	str	r5, [r7, r3]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ee20:	e508      	b.n	800e834 <xmp3fixpt_FDCT32+0x3c8>
	es = 0;
 800ee22:	f04f 0b00 	mov.w	fp, #0
 800ee26:	f7ff bb37 	b.w	800e498 <xmp3fixpt_FDCT32+0x2c>
 800ee2a:	bf00      	nop

0800ee2c <xmp3fixpt_Dequantize>:
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ee2c:	2800      	cmp	r0, #0
 800ee2e:	f000 819e 	beq.w	800f16e <xmp3fixpt_Dequantize+0x342>
{
 800ee32:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ee36:	6807      	ldr	r7, [r0, #0]
{
 800ee38:	b08f      	sub	sp, #60	; 0x3c
 800ee3a:	4604      	mov	r4, r0
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ee3c:	2f00      	cmp	r7, #0
 800ee3e:	f000 8193 	beq.w	800f168 <xmp3fixpt_Dequantize+0x33c>
 800ee42:	6843      	ldr	r3, [r0, #4]
 800ee44:	9306      	str	r3, [sp, #24]
 800ee46:	2b00      	cmp	r3, #0
 800ee48:	f000 818e 	beq.w	800f168 <xmp3fixpt_Dequantize+0x33c>
 800ee4c:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800ee50:	f1ba 0f00 	cmp.w	sl, #0
 800ee54:	f000 8188 	beq.w	800f168 <xmp3fixpt_Dequantize+0x33c>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800ee58:	68c6      	ldr	r6, [r0, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ee5a:	2e00      	cmp	r6, #0
 800ee5c:	f000 8184 	beq.w	800f168 <xmp3fixpt_Dequantize+0x33c>
 800ee60:	460d      	mov	r5, r1
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800ee62:	6901      	ldr	r1, [r0, #16]
 800ee64:	2900      	cmp	r1, #0
 800ee66:	f000 817f 	beq.w	800f168 <xmp3fixpt_Dequantize+0x33c>
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ee6a:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
	cbi = di->cbi;
 800ee6e:	f501 7246 	add.w	r2, r1, #792	; 0x318
	mOut[0] = mOut[1] = 0;
 800ee72:	f04f 0800 	mov.w	r8, #0
 800ee76:	f04f 0900 	mov.w	r9, #0
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ee7a:	2b00      	cmp	r3, #0
	cbi = di->cbi;
 800ee7c:	9207      	str	r2, [sp, #28]
	mOut[0] = mOut[1] = 0;
 800ee7e:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ee82:	f340 8092 	ble.w	800efaa <xmp3fixpt_Dequantize+0x17e>
 800ee86:	eb05 09c5 	add.w	r9, r5, r5, lsl #3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ee8a:	9806      	ldr	r0, [sp, #24]
 800ee8c:	9202      	str	r2, [sp, #8]
 800ee8e:	ebc5 1b45 	rsb	fp, r5, r5, lsl #5
 800ee92:	ea4f 1909 	mov.w	r9, r9, lsl #4
 800ee96:	f506 5890 	add.w	r8, r6, #4608	; 0x1200
 800ee9a:	463b      	mov	r3, r7
 800ee9c:	9109      	str	r1, [sp, #36]	; 0x24
 800ee9e:	f109 0228 	add.w	r2, r9, #40	; 0x28
 800eea2:	4402      	add	r2, r0
 800eea4:	4630      	mov	r0, r6
 800eea6:	9200      	str	r2, [sp, #0]
 800eea8:	eb0a 028b 	add.w	r2, sl, fp, lsl #2
 800eeac:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800eeb0:	9201      	str	r2, [sp, #4]
 800eeb2:	4642      	mov	r2, r8
 800eeb4:	f000 fa58 	bl	800f368 <xmp3fixpt_DequantChannel>
 800eeb8:	f506 5380 	add.w	r3, r6, #4096	; 0x1000
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eebc:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eebe:	9308      	str	r3, [sp, #32]
 800eec0:	f8c3 0208 	str.w	r0, [r3, #520]	; 0x208
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eec4:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800eec8:	2b01      	cmp	r3, #1
 800eeca:	dd6e      	ble.n	800efaa <xmp3fixpt_Dequantize+0x17e>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eecc:	f10b 033e 	add.w	r3, fp, #62	; 0x3e
 800eed0:	9806      	ldr	r0, [sp, #24]
 800eed2:	f241 2204 	movw	r2, #4612	; 0x1204
 800eed6:	4453      	add	r3, sl
 800eed8:	4432      	add	r2, r6
 800eeda:	9301      	str	r3, [sp, #4]
 800eedc:	f109 0370 	add.w	r3, r9, #112	; 0x70
 800eee0:	4403      	add	r3, r0
 800eee2:	f506 6010 	add.w	r0, r6, #2304	; 0x900
 800eee6:	9300      	str	r3, [sp, #0]
 800eee8:	f501 734c 	add.w	r3, r1, #816	; 0x330
 800eeec:	9302      	str	r3, [sp, #8]
 800eeee:	463b      	mov	r3, r7
 800eef0:	f000 fa3a 	bl	800f368 <xmp3fixpt_DequantChannel>
 800eef4:	9b08      	ldr	r3, [sp, #32]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eef6:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eef8:	f8c3 020c 	str.w	r0, [r3, #524]	; 0x20c
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eefc:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800ef00:	2b02      	cmp	r3, #2
 800ef02:	dd52      	ble.n	800efaa <xmp3fixpt_Dequantize+0x17e>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ef04:	f10b 037c 	add.w	r3, fp, #124	; 0x7c
 800ef08:	9a06      	ldr	r2, [sp, #24]
 800ef0a:	4640      	mov	r0, r8
 800ef0c:	4453      	add	r3, sl
 800ef0e:	9301      	str	r3, [sp, #4]
 800ef10:	f109 03b8 	add.w	r3, r9, #184	; 0xb8
 800ef14:	4413      	add	r3, r2
 800ef16:	f241 2208 	movw	r2, #4616	; 0x1208
 800ef1a:	9300      	str	r3, [sp, #0]
 800ef1c:	f501 7352 	add.w	r3, r1, #840	; 0x348
 800ef20:	4432      	add	r2, r6
 800ef22:	9302      	str	r3, [sp, #8]
 800ef24:	463b      	mov	r3, r7
 800ef26:	f000 fa1f 	bl	800f368 <xmp3fixpt_DequantChannel>
 800ef2a:	9b08      	ldr	r3, [sp, #32]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ef2c:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ef2e:	f8c3 0210 	str.w	r0, [r3, #528]	; 0x210
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ef32:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800ef36:	2b03      	cmp	r3, #3
 800ef38:	dd37      	ble.n	800efaa <xmp3fixpt_Dequantize+0x17e>
 800ef3a:	f10b 08ba 	add.w	r8, fp, #186	; 0xba
 800ef3e:	f509 7980 	add.w	r9, r9, #256	; 0x100
 800ef42:	9a06      	ldr	r2, [sp, #24]
 800ef44:	f506 5bd8 	add.w	fp, r6, #6912	; 0x1b00
 800ef48:	950b      	str	r5, [sp, #44]	; 0x2c
 800ef4a:	4625      	mov	r5, r4
 800ef4c:	eb02 0309 	add.w	r3, r2, r9
 800ef50:	eb0a 0208 	add.w	r2, sl, r8
 800ef54:	f241 2914 	movw	r9, #4628	; 0x1214
 800ef58:	f04f 0803 	mov.w	r8, #3
 800ef5c:	9208      	str	r2, [sp, #32]
 800ef5e:	f501 7258 	add.w	r2, r1, #864	; 0x360
 800ef62:	44b1      	add	r9, r6
 800ef64:	4614      	mov	r4, r2
 800ef66:	e9cd a609 	strd	sl, r6, [sp, #36]	; 0x24
 800ef6a:	468a      	mov	sl, r1
 800ef6c:	461e      	mov	r6, r3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ef6e:	9b08      	ldr	r3, [sp, #32]
 800ef70:	f1a9 0208 	sub.w	r2, r9, #8
 800ef74:	4658      	mov	r0, fp
 800ef76:	9402      	str	r4, [sp, #8]
 800ef78:	4651      	mov	r1, sl
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ef7a:	f108 0801 	add.w	r8, r8, #1
 800ef7e:	3418      	adds	r4, #24
 800ef80:	f50b 6b10 	add.w	fp, fp, #2304	; 0x900
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ef84:	e9cd 6300 	strd	r6, r3, [sp]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ef88:	333e      	adds	r3, #62	; 0x3e
 800ef8a:	3648      	adds	r6, #72	; 0x48
 800ef8c:	9308      	str	r3, [sp, #32]
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ef8e:	463b      	mov	r3, r7
 800ef90:	f000 f9ea 	bl	800f368 <xmp3fixpt_DequantChannel>
 800ef94:	f849 0b04 	str.w	r0, [r9], #4
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ef98:	f8d5 27bc 	ldr.w	r2, [r5, #1980]	; 0x7bc
 800ef9c:	4542      	cmp	r2, r8
 800ef9e:	dce6      	bgt.n	800ef6e <xmp3fixpt_Dequantize+0x142>
 800efa0:	4651      	mov	r1, sl
 800efa2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800efa4:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 800efa8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 800efaa:	6a38      	ldr	r0, [r7, #32]
 800efac:	2800      	cmp	r0, #0
 800efae:	d06a      	beq.n	800f086 <xmp3fixpt_Dequantize+0x25a>
 800efb0:	f506 5480 	add.w	r4, r6, #4096	; 0x1000
 800efb4:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 800efb8:	2b00      	cmp	r3, #0
 800efba:	dd67      	ble.n	800f08c <xmp3fixpt_Dequantize+0x260>
 800efbc:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 800efc0:	2b00      	cmp	r3, #0
 800efc2:	dd63      	ble.n	800f08c <xmp3fixpt_Dequantize+0x260>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 800efc4:	0843      	lsrs	r3, r0, #1
 800efc6:	f000 80d5 	beq.w	800f174 <xmp3fixpt_Dequantize+0x348>
		if (fh->modeExt & 0x01) {
 800efca:	07c2      	lsls	r2, r0, #31
 800efcc:	d50b      	bpl.n	800efe6 <xmp3fixpt_Dequantize+0x1ba>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 800efce:	f8d1 3330 	ldr.w	r3, [r1, #816]	; 0x330
 800efd2:	2b00      	cmp	r3, #0
 800efd4:	f040 80b0 	bne.w	800f138 <xmp3fixpt_Dequantize+0x30c>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 800efd8:	f8d1 3344 	ldr.w	r3, [r1, #836]	; 0x344
 800efdc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800efde:	3301      	adds	r3, #1
 800efe0:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800efe4:	e004      	b.n	800eff0 <xmp3fixpt_Dequantize+0x1c4>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800efe6:	e9d4 3180 	ldrd	r3, r1, [r4, #512]	; 0x200
 800efea:	4299      	cmp	r1, r3
 800efec:	bfb8      	it	lt
 800efee:	4619      	movlt	r1, r3
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 800eff0:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800eff4:	4630      	mov	r0, r6
 800eff6:	4642      	mov	r2, r8
 800eff8:	f004 fb34 	bl	8013664 <xmp3fixpt_MidSideProc>
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 800effc:	6a38      	ldr	r0, [r7, #32]
 800effe:	07c3      	lsls	r3, r0, #31
 800f000:	d51e      	bpl.n	800f040 <xmp3fixpt_Dequantize+0x214>
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
 800f002:	783b      	ldrb	r3, [r7, #0]
		nSamps = hi->nonZeroBound[0];
 800f004:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
		if (fh->ver == MPEG1) {
 800f008:	2b00      	cmp	r3, #0
 800f00a:	d179      	bne.n	800f100 <xmp3fixpt_Dequantize+0x2d4>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 800f00c:	9b06      	ldr	r3, [sp, #24]
 800f00e:	eb05 02c5 	add.w	r2, r5, r5, lsl #3
 800f012:	ebc5 1545 	rsb	r5, r5, r5, lsl #5
 800f016:	f8cd 800c 	str.w	r8, [sp, #12]
 800f01a:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800f01e:	ea4f 0c60 	mov.w	ip, r0, asr #1
 800f022:	4630      	mov	r0, r6
 800f024:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800f028:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
 800f02c:	9d07      	ldr	r5, [sp, #28]
 800f02e:	9202      	str	r2, [sp, #8]
 800f030:	333e      	adds	r3, #62	; 0x3e
 800f032:	463a      	mov	r2, r7
 800f034:	f8cd c004 	str.w	ip, [sp, #4]
 800f038:	9500      	str	r5, [sp, #0]
 800f03a:	f004 fb47 	bl	80136cc <xmp3fixpt_IntensityProcMPEG1>
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 800f03e:	6a38      	ldr	r0, [r7, #32]
 800f040:	b308      	cbz	r0, 800f086 <xmp3fixpt_Dequantize+0x25a>
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800f042:	9b0c      	ldr	r3, [sp, #48]	; 0x30

static __inline int CLZ(int x)
{
	int numZeros;

	if (!x)
 800f044:	2b00      	cmp	r3, #0
 800f046:	f000 8081 	beq.w	800f14c <xmp3fixpt_Dequantize+0x320>
		return (sizeof(int) * 8);

	numZeros = 0;
	while (!(x & 0x80000000)) {
 800f04a:	f2c0 8087 	blt.w	800f15c <xmp3fixpt_Dequantize+0x330>
	numZeros = 0;
 800f04e:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 800f050:	005b      	lsls	r3, r3, #1
 800f052:	4611      	mov	r1, r2
		numZeros++;
 800f054:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 800f058:	d5fa      	bpl.n	800f050 <xmp3fixpt_Dequantize+0x224>
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800f05a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800f05c:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
	if (!x)
 800f060:	2b00      	cmp	r3, #0
 800f062:	d079      	beq.n	800f158 <xmp3fixpt_Dequantize+0x32c>
	while (!(x & 0x80000000)) {
 800f064:	db7d      	blt.n	800f162 <xmp3fixpt_Dequantize+0x336>
	numZeros = 0;
 800f066:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 800f068:	005b      	lsls	r3, r3, #1
 800f06a:	4611      	mov	r1, r2
		numZeros++;
 800f06c:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 800f070:	d5fa      	bpl.n	800f068 <xmp3fixpt_Dequantize+0x23c>
		hi->nonZeroBound[0] = nSamps;
		hi->nonZeroBound[1] = nSamps;
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 800f072:	2000      	movs	r0, #0
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800f074:	f8c4 120c 	str.w	r1, [r4, #524]	; 0x20c
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800f078:	e9d4 2380 	ldrd	r2, r3, [r4, #512]	; 0x200
 800f07c:	4293      	cmp	r3, r2
 800f07e:	bfb8      	it	lt
 800f080:	4613      	movlt	r3, r2
		hi->nonZeroBound[1] = nSamps;
 800f082:	e9c4 3380 	strd	r3, r3, [r4, #512]	; 0x200
}
 800f086:	b00f      	add	sp, #60	; 0x3c
 800f088:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800f08c:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 800f090:	2a00      	cmp	r2, #0
 800f092:	dd17      	ble.n	800f0c4 <xmp3fixpt_Dequantize+0x298>
 800f094:	1f33      	subs	r3, r6, #4
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800f096:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800f09a:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 800f17c <xmp3fixpt_Dequantize+0x350>
 800f09e:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 800f0a2:	e003      	b.n	800f0ac <xmp3fixpt_Dequantize+0x280>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800f0a4:	4563      	cmp	r3, ip
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800f0a6:	f8c3 e000 	str.w	lr, [r3]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800f0aa:	d00b      	beq.n	800f0c4 <xmp3fixpt_Dequantize+0x298>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800f0ac:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800f0b0:	f1b2 4f40 	cmp.w	r2, #3221225472	; 0xc0000000
 800f0b4:	ddf6      	ble.n	800f0a4 <xmp3fixpt_Dequantize+0x278>
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800f0b6:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800f0ba:	bfa8      	it	ge
 800f0bc:	f8c3 8000 	strge.w	r8, [r3]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800f0c0:	4563      	cmp	r3, ip
 800f0c2:	d1f3      	bne.n	800f0ac <xmp3fixpt_Dequantize+0x280>
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800f0c4:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
 800f0c8:	2a00      	cmp	r2, #0
 800f0ca:	f77f af7b 	ble.w	800efc4 <xmp3fixpt_Dequantize+0x198>
 800f0ce:	f606 03fc 	addw	r3, r6, #2300	; 0x8fc
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800f0d2:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800f0d6:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 800f17c <xmp3fixpt_Dequantize+0x350>
 800f0da:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 800f0de:	e004      	b.n	800f0ea <xmp3fixpt_Dequantize+0x2be>
 800f0e0:	f8c3 e000 	str.w	lr, [r3]
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800f0e4:	459c      	cmp	ip, r3
 800f0e6:	f43f af6d 	beq.w	800efc4 <xmp3fixpt_Dequantize+0x198>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800f0ea:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800f0ee:	f1b2 4f40 	cmp.w	r2, #3221225472	; 0xc0000000
 800f0f2:	ddf5      	ble.n	800f0e0 <xmp3fixpt_Dequantize+0x2b4>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800f0f4:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800f0f8:	bfa8      	it	ge
 800f0fa:	f8c3 8000 	strge.w	r8, [r3]
 800f0fe:	e7f1      	b.n	800f0e4 <xmp3fixpt_Dequantize+0x2b8>
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 800f100:	1042      	asrs	r2, r0, #1
 800f102:	4630      	mov	r0, r6
 800f104:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 800f108:	9e06      	ldr	r6, [sp, #24]
 800f10a:	f8cd 8010 	str.w	r8, [sp, #16]
 800f10e:	ebc5 1545 	rsb	r5, r5, r5, lsl #5
 800f112:	eb06 1303 	add.w	r3, r6, r3, lsl #4
 800f116:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800f11a:	9202      	str	r2, [sp, #8]
 800f11c:	9a07      	ldr	r2, [sp, #28]
 800f11e:	9303      	str	r3, [sp, #12]
 800f120:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
 800f124:	9200      	str	r2, [sp, #0]
 800f126:	f10a 02f8 	add.w	r2, sl, #248	; 0xf8
 800f12a:	333e      	adds	r3, #62	; 0x3e
 800f12c:	9201      	str	r2, [sp, #4]
 800f12e:	463a      	mov	r2, r7
 800f130:	f004 fc84 	bl	8013a3c <xmp3fixpt_IntensityProcMPEG2>
	if (fh->modeExt) {
 800f134:	6a38      	ldr	r0, [r7, #32]
 800f136:	e783      	b.n	800f040 <xmp3fixpt_Dequantize+0x214>
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 800f138:	f8d1 2340 	ldr.w	r2, [r1, #832]	; 0x340
 800f13c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f13e:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800f142:	f9b3 1030 	ldrsh.w	r1, [r3, #48]	; 0x30
 800f146:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800f14a:	e751      	b.n	800eff0 <xmp3fixpt_Dequantize+0x1c4>
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800f14c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f14e:	211f      	movs	r1, #31
	if (!x)
 800f150:	2b00      	cmp	r3, #0
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800f152:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
 800f156:	d185      	bne.n	800f064 <xmp3fixpt_Dequantize+0x238>
 800f158:	211f      	movs	r1, #31
 800f15a:	e78a      	b.n	800f072 <xmp3fixpt_Dequantize+0x246>
	while (!(x & 0x80000000)) {
 800f15c:	f04f 31ff 	mov.w	r1, #4294967295
 800f160:	e77b      	b.n	800f05a <xmp3fixpt_Dequantize+0x22e>
 800f162:	f04f 31ff 	mov.w	r1, #4294967295
 800f166:	e784      	b.n	800f072 <xmp3fixpt_Dequantize+0x246>
		return -1;
 800f168:	f04f 30ff 	mov.w	r0, #4294967295
 800f16c:	e78b      	b.n	800f086 <xmp3fixpt_Dequantize+0x25a>
 800f16e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800f172:	4770      	bx	lr
 800f174:	2001      	movs	r0, #1
 800f176:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800f17a:	e742      	b.n	800f002 <xmp3fixpt_Dequantize+0x1d6>
 800f17c:	c0000001 	.word	0xc0000001

0800f180 <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 800f180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int mask = 0;
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
	scalef = pow14[scale & 0x3];
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800f184:	ea4f 08a3 	mov.w	r8, r3, asr #2
	tab16 = pow43_14[scale & 0x3];
 800f188:	f003 0503 	and.w	r5, r3, #3
 800f18c:	4b63      	ldr	r3, [pc, #396]	; (800f31c <DequantBlock+0x19c>)
{
 800f18e:	b089      	sub	sp, #36	; 0x24

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 800f190:	4644      	mov	r4, r8
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800f192:	46c3      	mov	fp, r8
	tab16 = pow43_14[scale & 0x3];
 800f194:	eb03 1985 	add.w	r9, r3, r5, lsl #6
	scalef = pow14[scale & 0x3];
 800f198:	4b61      	ldr	r3, [pc, #388]	; (800f320 <DequantBlock+0x1a0>)
	shift = MIN(scalei + 3, 31);
 800f19a:	2c1c      	cmp	r4, #28
{
 800f19c:	4686      	mov	lr, r0
	scalef = pow14[scale & 0x3];
 800f19e:	f853 a025 	ldr.w	sl, [r3, r5, lsl #2]
	shift = MAX(shift, 0);
	tab4[0] = 0;
 800f1a2:	f04f 0000 	mov.w	r0, #0
	shift = MIN(scalei + 3, 31);
 800f1a6:	bfa8      	it	ge
 800f1a8:	241c      	movge	r4, #28
	tab4[1] = tab16[1] >> shift;
 800f1aa:	f8d9 3004 	ldr.w	r3, [r9, #4]
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800f1ae:	f1b8 0f1f 	cmp.w	r8, #31
	tab4[0] = 0;
 800f1b2:	9004      	str	r0, [sp, #16]
	shift = MIN(scalei + 3, 31);
 800f1b4:	f104 0403 	add.w	r4, r4, #3
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800f1b8:	bfa8      	it	ge
 800f1ba:	f04f 0b1f 	movge.w	fp, #31
	shift = MAX(shift, 0);
 800f1be:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
	tab4[1] = tab16[1] >> shift;
 800f1c2:	4123      	asrs	r3, r4
 800f1c4:	9305      	str	r3, [sp, #20]
	tab4[2] = tab16[2] >> shift;
 800f1c6:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800f1ca:	4123      	asrs	r3, r4
 800f1cc:	9306      	str	r3, [sp, #24]
	tab4[3] = tab16[3] >> shift;
 800f1ce:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800f1d2:	4123      	asrs	r3, r4
 800f1d4:	9307      	str	r3, [sp, #28]
				if (x < 0x20000000)
					x <<= 2, shift += 2;
				if (x < 0x40000000)
					x <<= 1, shift += 1;

				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 800f1d6:	465b      	mov	r3, fp
 800f1d8:	46c3      	mov	fp, r8
 800f1da:	46c8      	mov	r8, r9
 800f1dc:	46d1      	mov	r9, sl
 800f1de:	469a      	mov	sl, r3
 800f1e0:	e00e      	b.n	800f200 <DequantBlock+0x80>
			y = tab4[x];
 800f1e2:	ac08      	add	r4, sp, #32
 800f1e4:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800f1e8:	f855 4c10 	ldr.w	r4, [r5, #-16]
			}
		}

		/* sign and store */
		mask |= y;
		*outbuf++ = (sx < 0) ? -y : y;
 800f1ec:	2b00      	cmp	r3, #0
		mask |= y;
 800f1ee:	ea40 0004 	orr.w	r0, r0, r4
		*outbuf++ = (sx < 0) ? -y : y;
 800f1f2:	bfb8      	it	lt
 800f1f4:	4264      	neglt	r4, r4

	} while (--num);
 800f1f6:	3a01      	subs	r2, #1
		*outbuf++ = (sx < 0) ? -y : y;
 800f1f8:	f841 4b04 	str.w	r4, [r1], #4
	} while (--num);
 800f1fc:	f000 8083 	beq.w	800f306 <DequantBlock+0x186>
		sx = *inbuf++;
 800f200:	f85e 3b04 	ldr.w	r3, [lr], #4
		if (x < 4) {
 800f204:	4c47      	ldr	r4, [pc, #284]	; (800f324 <DequantBlock+0x1a4>)
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 800f206:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
		if (x < 4) {
 800f20a:	401c      	ands	r4, r3
 800f20c:	2c00      	cmp	r4, #0
 800f20e:	d0e8      	beq.n	800f1e2 <DequantBlock+0x62>
		} else if (x < 16) {
 800f210:	4c45      	ldr	r4, [pc, #276]	; (800f328 <DequantBlock+0x1a8>)
 800f212:	401c      	ands	r4, r3
 800f214:	b93c      	cbnz	r4, 800f226 <DequantBlock+0xa6>
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800f216:	f1bb 0f00 	cmp.w	fp, #0
			y = tab16[x];
 800f21a:	f858 4025 	ldr.w	r4, [r8, r5, lsl #2]
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800f21e:	db75      	blt.n	800f30c <DequantBlock+0x18c>
 800f220:	fa44 f40a 	asr.w	r4, r4, sl
 800f224:	e7e2      	b.n	800f1ec <DequantBlock+0x6c>
			if (x < 64) {
 800f226:	4c41      	ldr	r4, [pc, #260]	; (800f32c <DequantBlock+0x1ac>)
 800f228:	401c      	ands	r4, r3
 800f22a:	b974      	cbnz	r4, 800f24a <DequantBlock+0xca>
				y = pow43[x-16];
 800f22c:	4c40      	ldr	r4, [pc, #256]	; (800f330 <DequantBlock+0x1b0>)
 800f22e:	3d10      	subs	r5, #16
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800f230:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
 800f234:	464c      	mov	r4, r9
 800f236:	fb85 6404 	smull	r6, r4, r5, r4
 800f23a:	4625      	mov	r5, r4
				shift = scalei - 3;
 800f23c:	f1aa 0403 	sub.w	r4, sl, #3
			if (shift < 0) {
 800f240:	2c00      	cmp	r4, #0
 800f242:	db55      	blt.n	800f2f0 <DequantBlock+0x170>
				y >>= shift;
 800f244:	fa45 f404 	asr.w	r4, r5, r4
 800f248:	e7d0      	b.n	800f1ec <DequantBlock+0x6c>
				x <<= 17;
 800f24a:	046c      	lsls	r4, r5, #17
				if (x < 0x08000000)
 800f24c:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
 800f250:	da60      	bge.n	800f314 <DequantBlock+0x194>
					x <<= 4, shift += 4;
 800f252:	056c      	lsls	r4, r5, #21
 800f254:	2604      	movs	r6, #4
 800f256:	2506      	movs	r5, #6
 800f258:	9600      	str	r6, [sp, #0]
				if (x < 0x20000000)
 800f25a:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 800f25e:	da01      	bge.n	800f264 <DequantBlock+0xe4>
					x <<= 2, shift += 2;
 800f260:	00a4      	lsls	r4, r4, #2
 800f262:	9500      	str	r5, [sp, #0]
				if (x < 0x40000000)
 800f264:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800f268:	da03      	bge.n	800f272 <DequantBlock+0xf2>
					x <<= 1, shift += 1;
 800f26a:	9d00      	ldr	r5, [sp, #0]
 800f26c:	0064      	lsls	r4, r4, #1
 800f26e:	3501      	adds	r5, #1
 800f270:	9500      	str	r5, [sp, #0]
				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 800f272:	4d30      	ldr	r5, [pc, #192]	; (800f334 <DequantBlock+0x1b4>)
 800f274:	4e30      	ldr	r6, [pc, #192]	; (800f338 <DequantBlock+0x1b8>)
 800f276:	42ac      	cmp	r4, r5
 800f278:	4d30      	ldr	r5, [pc, #192]	; (800f33c <DequantBlock+0x1bc>)
 800f27a:	4f31      	ldr	r7, [pc, #196]	; (800f340 <DequantBlock+0x1c0>)
 800f27c:	bfc8      	it	gt
 800f27e:	46ac      	movgt	ip, r5
 800f280:	4d30      	ldr	r5, [pc, #192]	; (800f344 <DequantBlock+0x1c4>)
 800f282:	bfd8      	it	le
 800f284:	46b4      	movle	ip, r6
 800f286:	4e30      	ldr	r6, [pc, #192]	; (800f348 <DequantBlock+0x1c8>)
 800f288:	bfd8      	it	le
 800f28a:	462e      	movle	r6, r5
 800f28c:	4d2f      	ldr	r5, [pc, #188]	; (800f34c <DequantBlock+0x1cc>)
 800f28e:	bfd8      	it	le
 800f290:	462f      	movle	r7, r5
 800f292:	4d2f      	ldr	r5, [pc, #188]	; (800f350 <DequantBlock+0x1d0>)
 800f294:	9703      	str	r7, [sp, #12]
 800f296:	4f2f      	ldr	r7, [pc, #188]	; (800f354 <DequantBlock+0x1d4>)
 800f298:	bfd8      	it	le
 800f29a:	462f      	movle	r7, r5
 800f29c:	4d2e      	ldr	r5, [pc, #184]	; (800f358 <DequantBlock+0x1d8>)
 800f29e:	9702      	str	r7, [sp, #8]
 800f2a0:	4f2e      	ldr	r7, [pc, #184]	; (800f35c <DequantBlock+0x1dc>)
 800f2a2:	bfd8      	it	le
 800f2a4:	462f      	movle	r7, r5
 800f2a6:	4625      	mov	r5, r4
 800f2a8:	9701      	str	r7, [sp, #4]
 800f2aa:	fb86 7505 	smull	r7, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[1];
 800f2ae:	4465      	add	r5, ip
 800f2b0:	4626      	mov	r6, r4
 800f2b2:	fb85 c606 	smull	ip, r6, r5, r6
				y = MULSHIFT32(y, x) + coef[2];
 800f2b6:	9f01      	ldr	r7, [sp, #4]
 800f2b8:	4625      	mov	r5, r4
 800f2ba:	443e      	add	r6, r7
 800f2bc:	fb86 c505 	smull	ip, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[3];
 800f2c0:	9f02      	ldr	r7, [sp, #8]
 800f2c2:	443d      	add	r5, r7
 800f2c4:	fb85 6404 	smull	r6, r4, r5, r4
				y = MULSHIFT32(y, x) + coef[4];
 800f2c8:	9f03      	ldr	r7, [sp, #12]
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800f2ca:	4d25      	ldr	r5, [pc, #148]	; (800f360 <DequantBlock+0x1e0>)
				y = MULSHIFT32(y, x) + coef[4];
 800f2cc:	443c      	add	r4, r7
 800f2ce:	9f00      	ldr	r7, [sp, #0]
 800f2d0:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 800f2d4:	fb84 6505 	smull	r6, r5, r4, r5
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800f2d8:	00ed      	lsls	r5, r5, #3
 800f2da:	464c      	mov	r4, r9
 800f2dc:	fb85 6404 	smull	r6, r4, r5, r4
 800f2e0:	4625      	mov	r5, r4
				shift = scalei - pow2exp[shift];
 800f2e2:	4c20      	ldr	r4, [pc, #128]	; (800f364 <DequantBlock+0x1e4>)
 800f2e4:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
 800f2e8:	ebaa 0404 	sub.w	r4, sl, r4
			if (shift < 0) {
 800f2ec:	2c00      	cmp	r4, #0
 800f2ee:	daa9      	bge.n	800f244 <DequantBlock+0xc4>
				shift = -shift;
 800f2f0:	4266      	negs	r6, r4
				if (y > (0x7fffffff >> shift))
 800f2f2:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800f2f6:	fa44 f706 	asr.w	r7, r4, r6
 800f2fa:	42af      	cmp	r7, r5
 800f2fc:	f6ff af76 	blt.w	800f1ec <DequantBlock+0x6c>
					y <<= shift;
 800f300:	fa05 f406 	lsl.w	r4, r5, r6
 800f304:	e772      	b.n	800f1ec <DequantBlock+0x6c>

	return mask;
}
 800f306:	b009      	add	sp, #36	; 0x24
 800f308:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800f30c:	f1ca 0500 	rsb	r5, sl, #0
 800f310:	40ac      	lsls	r4, r5
 800f312:	e76b      	b.n	800f1ec <DequantBlock+0x6c>
				shift = 0;
 800f314:	2600      	movs	r6, #0
 800f316:	2502      	movs	r5, #2
 800f318:	9600      	str	r6, [sp, #0]
 800f31a:	e79e      	b.n	800f25a <DequantBlock+0xda>
 800f31c:	08022ccc 	.word	0x08022ccc
 800f320:	08022bbc 	.word	0x08022bbc
 800f324:	7ffffffc 	.word	0x7ffffffc
 800f328:	7ffffff0 	.word	0x7ffffff0
 800f32c:	7fffffc0 	.word	0x7fffffc0
 800f330:	08022c0c 	.word	0x08022c0c
 800f334:	5a827999 	.word	0x5a827999
 800f338:	b02e4828 	.word	0xb02e4828
 800f33c:	d333f6a4 	.word	0xd333f6a4
 800f340:	fef577b4 	.word	0xfef577b4
 800f344:	29a0bda9 	.word	0x29a0bda9
 800f348:	10852163 	.word	0x10852163
 800f34c:	ff581859 	.word	0xff581859
 800f350:	236c498d 	.word	0x236c498d
 800f354:	27c2cef0 	.word	0x27c2cef0
 800f358:	5957aa1b 	.word	0x5957aa1b
 800f35c:	46e9408b 	.word	0x46e9408b
 800f360:	08022bec 	.word	0x08022bec
 800f364:	08022bcc 	.word	0x08022bcc

0800f368 <xmp3fixpt_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 800f368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f36c:	b091      	sub	sp, #68	; 0x44
 800f36e:	930a      	str	r3, [sp, #40]	; 0x28
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 800f370:	9b1a      	ldr	r3, [sp, #104]	; 0x68
{
 800f372:	9007      	str	r0, [sp, #28]
	if (sis->blockType == 2) {
 800f374:	695b      	ldr	r3, [r3, #20]
{
 800f376:	9109      	str	r1, [sp, #36]	; 0x24
	if (sis->blockType == 2) {
 800f378:	2b02      	cmp	r3, #2
{
 800f37a:	9206      	str	r2, [sp, #24]
	if (sis->blockType == 2) {
 800f37c:	f000 8146 	beq.w	800f60c <xmp3fixpt_DequantChannel+0x2a4>
		cbEndS = 13;
	} else {
		/* long block */
		cbStartL = 0;
		cbEndL =   22;
		cbStartS = 13;
 800f380:	230d      	movs	r3, #13
		cbEndL =   22;
 800f382:	f04f 0a16 	mov.w	sl, #22
		cbStartS = 13;
 800f386:	9303      	str	r3, [sp, #12]

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800f388:	9b1a      	ldr	r3, [sp, #104]	; 0x68

	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
 800f38a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800f38c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	globalGain = sis->globalGain;
 800f38e:	6892      	ldr	r2, [r2, #8]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800f390:	3301      	adds	r3, #1
	globalGain = sis->globalGain;
 800f392:	9208      	str	r2, [sp, #32]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800f394:	005b      	lsls	r3, r3, #1
 800f396:	9301      	str	r3, [sp, #4]
	if (fh->modeExt >> 1)
 800f398:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f39a:	6a1b      	ldr	r3, [r3, #32]
 800f39c:	085b      	lsrs	r3, r3, #1
 800f39e:	d101      	bne.n	800f3a4 <xmp3fixpt_DequantChannel+0x3c>
		 globalGain -= 2;
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 800f3a0:	3202      	adds	r2, #2
 800f3a2:	9208      	str	r2, [sp, #32]

	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {
 800f3a4:	2300      	movs	r3, #0
 800f3a6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f3a8:	f8cd a010 	str.w	sl, [sp, #16]
 800f3ac:	461c      	mov	r4, r3
 800f3ae:	461e      	mov	r6, r3
 800f3b0:	f102 38ff 	add.w	r8, r2, #4294967295
 800f3b4:	9305      	str	r3, [sp, #20]

		nonZero = 0;
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3b6:	9a08      	ldr	r2, [sp, #32]
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f3b8:	f104 0901 	add.w	r9, r4, #1
 800f3bc:	9302      	str	r3, [sp, #8]
	for (cb = 0; cb < cbEndL; cb++) {
 800f3be:	9b04      	ldr	r3, [sp, #16]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3c0:	f1c2 07d2 	rsb	r7, r2, #210	; 0xd2
 800f3c4:	4d9d      	ldr	r5, [pc, #628]	; (800f63c <xmp3fixpt_DequantChannel+0x2d4>)
	for (cb = 0; cb < cbEndL; cb++) {
 800f3c6:	429c      	cmp	r4, r3
 800f3c8:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 800f3cc:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3d0:	9700      	str	r7, [sp, #0]
	for (cb = 0; cb < cbEndL; cb++) {
 800f3d2:	d02e      	beq.n	800f432 <xmp3fixpt_DequantChannel+0xca>
 800f3d4:	f8da 2034 	ldr.w	r2, [sl, #52]	; 0x34

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f3d8:	9b07      	ldr	r3, [sp, #28]
 800f3da:	eb02 0e44 	add.w	lr, r2, r4, lsl #1
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f3de:	f932 c014 	ldrsh.w	ip, [r2, r4, lsl #1]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3e2:	f8db 003c 	ldr.w	r0, [fp, #60]	; 0x3c
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f3e6:	eb03 0186 	add.w	r1, r3, r6, lsl #2
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f3ea:	f9be 2002 	ldrsh.w	r2, [lr, #2]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3ee:	f818 3f01 	ldrb.w	r3, [r8, #1]!
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f3f2:	eba2 020c 	sub.w	r2, r2, ip
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f3f6:	b108      	cbz	r0, 800f3fc <xmp3fixpt_DequantChannel+0x94>
 800f3f8:	7828      	ldrb	r0, [r5, #0]
 800f3fa:	4403      	add	r3, r0
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f3fc:	9801      	ldr	r0, [sp, #4]
		i += nSamps;
 800f3fe:	4416      	add	r6, r2
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f400:	fb03 7300 	mla	r3, r3, r0, r7
 800f404:	4608      	mov	r0, r1
 800f406:	f7ff febb 	bl	800f180 <DequantBlock>

		/* update highest non-zero critical band */
		if (nonZero) 
 800f40a:	2800      	cmp	r0, #0
 800f40c:	f000 80c9 	beq.w	800f5a2 <xmp3fixpt_DequantChannel+0x23a>
			cbMax[0] = cb;
		gbMask |= nonZero;
 800f410:	9b02      	ldr	r3, [sp, #8]

		if (i >= *nonZeroBound) 
 800f412:	3501      	adds	r5, #1
 800f414:	9405      	str	r4, [sp, #20]
		gbMask |= nonZero;
 800f416:	4303      	orrs	r3, r0
 800f418:	9302      	str	r3, [sp, #8]
		if (i >= *nonZeroBound) 
 800f41a:	9b06      	ldr	r3, [sp, #24]
 800f41c:	681b      	ldr	r3, [r3, #0]
 800f41e:	42b3      	cmp	r3, r6
 800f420:	f340 80d7 	ble.w	800f5d2 <xmp3fixpt_DequantChannel+0x26a>
	for (cb = 0; cb < cbEndL; cb++) {
 800f424:	464c      	mov	r4, r9
 800f426:	9b04      	ldr	r3, [sp, #16]
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f428:	f104 0901 	add.w	r9, r4, #1
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f42c:	9700      	str	r7, [sp, #0]
	for (cb = 0; cb < cbEndL; cb++) {
 800f42e:	429c      	cmp	r4, r3
 800f430:	d1d0      	bne.n	800f3d4 <xmp3fixpt_DequantChannel+0x6c>
			break;
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
	cbi->cbEndL  = cbMax[0];
 800f432:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800f434:	9a05      	ldr	r2, [sp, #20]
 800f436:	f8dd b008 	ldr.w	fp, [sp, #8]
 800f43a:	615a      	str	r2, [r3, #20]
	cbi->cbType = 0;			/* long only */
 800f43c:	2300      	movs	r3, #0
 800f43e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800f440:	6013      	str	r3, [r2, #0]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f442:	6053      	str	r3, [r2, #4]
	cbi->cbEndSMax = 0;
 800f444:	6113      	str	r3, [r2, #16]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f446:	e9c2 3302 	strd	r3, r3, [r2, #8]

	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 800f44a:	9b03      	ldr	r3, [sp, #12]
 800f44c:	2b0b      	cmp	r3, #11
 800f44e:	f300 80b0 	bgt.w	800f5b2 <xmp3fixpt_DequantChannel+0x24a>
 800f452:	9b08      	ldr	r3, [sp, #32]
 800f454:	f1c3 03d2 	rsb	r3, r3, #210	; 0xd2
 800f458:	9300      	str	r3, [sp, #0]
		return CLZ(gbMask) - 1;
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 800f45a:	9b03      	ldr	r3, [sp, #12]
 800f45c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f45e:	930e      	str	r3, [sp, #56]	; 0x38
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f460:	9602      	str	r6, [sp, #8]
 800f462:	f8cd b010 	str.w	fp, [sp, #16]
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 800f466:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 800f46a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f46e:	3317      	adds	r3, #23
 800f470:	18d3      	adds	r3, r2, r3
 800f472:	9305      	str	r3, [sp, #20]
 800f474:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f476:	3328      	adds	r3, #40	; 0x28
 800f478:	930b      	str	r3, [sp, #44]	; 0x2c

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f47a:	9b03      	ldr	r3, [sp, #12]
 800f47c:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800f480:	9902      	ldr	r1, [sp, #8]
 800f482:	461a      	mov	r2, r3
 800f484:	9308      	str	r3, [sp, #32]
 800f486:	3301      	adds	r3, #1
 800f488:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
		for (w = 0; w < 3; w++) {
			nonZero =  0;
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f48c:	9e09      	ldr	r6, [sp, #36]	; 0x24
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f48e:	9303      	str	r3, [sp, #12]
 800f490:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f492:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800f496:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f498:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800f49c:	9a07      	ldr	r2, [sp, #28]
 800f49e:	eb02 0481 	add.w	r4, r2, r1, lsl #2
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f4a2:	f9b3 1030 	ldrsh.w	r1, [r3, #48]	; 0x30
 800f4a6:	f9b3 202e 	ldrsh.w	r2, [r3, #46]	; 0x2e
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f4aa:	4627      	mov	r7, r4
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f4ac:	eba1 0b02 	sub.w	fp, r1, r2
		for (w = 0; w < 3; w++) {
 800f4b0:	ea4f 058b 	mov.w	r5, fp, lsl #2
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 800f4b4:	9900      	ldr	r1, [sp, #0]
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f4b6:	4638      	mov	r0, r7
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 800f4b8:	f85a 3b04 	ldr.w	r3, [sl], #4
 800f4bc:	f819 2b01 	ldrb.w	r2, [r9], #1
 800f4c0:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f4c4:	9901      	ldr	r1, [sp, #4]
 800f4c6:	fb01 3302 	mla	r3, r1, r2, r3
 800f4ca:	465a      	mov	r2, fp
 800f4cc:	4631      	mov	r1, r6
 800f4ce:	f7ff fe57 	bl	800f180 <DequantBlock>

			/* update highest non-zero critical band */
			if (nonZero)
 800f4d2:	2800      	cmp	r0, #0
 800f4d4:	f000 8091 	beq.w	800f5fa <xmp3fixpt_DequantChannel+0x292>
				cbMax[w] = cb;
 800f4d8:	9b08      	ldr	r3, [sp, #32]
		for (w = 0; w < 3; w++) {
 800f4da:	442f      	add	r7, r5
 800f4dc:	442e      	add	r6, r5
				cbMax[w] = cb;
 800f4de:	f848 3b04 	str.w	r3, [r8], #4
			gbMask |= nonZero;
 800f4e2:	9b04      	ldr	r3, [sp, #16]
 800f4e4:	4303      	orrs	r3, r0
 800f4e6:	9304      	str	r3, [sp, #16]
		for (w = 0; w < 3; w++) {
 800f4e8:	ab0f      	add	r3, sp, #60	; 0x3c
 800f4ea:	4598      	cmp	r8, r3
 800f4ec:	d1e2      	bne.n	800f4b4 <xmp3fixpt_DequantChannel+0x14c>
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
		i += 3*nSamps;
 800f4ee:	9a02      	ldr	r2, [sp, #8]
 800f4f0:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
		for (j = 0; j < nSamps; j++) {
 800f4f4:	f1bb 0f00 	cmp.w	fp, #0
		i += 3*nSamps;
 800f4f8:	ea4f 014b 	mov.w	r1, fp, lsl #1
 800f4fc:	441a      	add	r2, r3
 800f4fe:	9202      	str	r2, [sp, #8]
		for (j = 0; j < nSamps; j++) {
 800f500:	dd1b      	ble.n	800f53a <xmp3fixpt_DequantChannel+0x1d2>
 800f502:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
 800f506:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800f50a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f50c:	445a      	add	r2, fp
 800f50e:	3901      	subs	r1, #1
 800f510:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800f514:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800f518:	3b04      	subs	r3, #4
 800f51a:	441d      	add	r5, r3
			buf[j][0] = workBuf[0*nSamps + j];
 800f51c:	f853 0f04 	ldr.w	r0, [r3, #4]!
		for (j = 0; j < nSamps; j++) {
 800f520:	340c      	adds	r4, #12
			buf[j][0] = workBuf[0*nSamps + j];
 800f522:	f844 0c0c 	str.w	r0, [r4, #-12]
		for (j = 0; j < nSamps; j++) {
 800f526:	429d      	cmp	r5, r3
			buf[j][1] = workBuf[1*nSamps + j];
 800f528:	f852 0f04 	ldr.w	r0, [r2, #4]!
 800f52c:	f844 0c08 	str.w	r0, [r4, #-8]
			buf[j][2] = workBuf[2*nSamps + j];
 800f530:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800f534:	f844 0c04 	str.w	r0, [r4, #-4]
		for (j = 0; j < nSamps; j++) {
 800f538:	d1f0      	bne.n	800f51c <xmp3fixpt_DequantChannel+0x1b4>
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f53a:	9b05      	ldr	r3, [sp, #20]
 800f53c:	9a02      	ldr	r2, [sp, #8]
 800f53e:	3303      	adds	r3, #3
 800f540:	9305      	str	r3, [sp, #20]
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 800f542:	9b06      	ldr	r3, [sp, #24]
 800f544:	681b      	ldr	r3, [r3, #0]
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f546:	4293      	cmp	r3, r2
 800f548:	dd02      	ble.n	800f550 <xmp3fixpt_DequantChannel+0x1e8>
 800f54a:	9b03      	ldr	r3, [sp, #12]
 800f54c:	2b0c      	cmp	r3, #12
 800f54e:	dd94      	ble.n	800f47a <xmp3fixpt_DequantChannel+0x112>
	 * however, the original nzb is no longer necessarily true
	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
     * so update nonZeroBound to i
	 */
	*nonZeroBound = i;
 800f550:	9b06      	ldr	r3, [sp, #24]
 800f552:	f8dd b010 	ldr.w	fp, [sp, #16]
 800f556:	601a      	str	r2, [r3, #0]

	ASSERT(*nonZeroBound <= MAX_NSAMP);

	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f558:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f55a:	6999      	ldr	r1, [r3, #24]

	cbi->cbEndS[0] = cbMax[0];
	cbi->cbEndS[1] = cbMax[1];
 800f55c:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f560:	2900      	cmp	r1, #0
	cbi->cbEndS[0] = cbMax[0];
 800f562:	991c      	ldr	r1, [sp, #112]	; 0x70
	cbi->cbEndS[1] = cbMax[1];
 800f564:	e9c1 3201 	strd	r3, r2, [r1, #4]
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f568:	bf14      	ite	ne
 800f56a:	2102      	movne	r1, #2
 800f56c:	2101      	moveq	r1, #1
	cbi->cbEndS[2] = cbMax[2];

	cbi->cbEndSMax = cbMax[0];
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 800f56e:	4293      	cmp	r3, r2
 800f570:	bfb8      	it	lt
 800f572:	4613      	movlt	r3, r2
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f574:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800f576:	6011      	str	r1, [r2, #0]
	cbi->cbEndS[2] = cbMax[2];
 800f578:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800f57a:	991c      	ldr	r1, [sp, #112]	; 0x70
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800f57c:	4293      	cmp	r3, r2
	cbi->cbEndS[2] = cbMax[2];
 800f57e:	60ca      	str	r2, [r1, #12]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800f580:	bfb8      	it	lt
 800f582:	4613      	movlt	r3, r2
	if (!x)
 800f584:	f1bb 0f00 	cmp.w	fp, #0
 800f588:	610b      	str	r3, [r1, #16]
 800f58a:	d032      	beq.n	800f5f2 <xmp3fixpt_DequantChannel+0x28a>
	while (!(x & 0x80000000)) {
 800f58c:	db53      	blt.n	800f636 <xmp3fixpt_DequantChannel+0x2ce>
	numZeros = 0;
 800f58e:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 800f590:	ea5f 0b4b 	movs.w	fp, fp, lsl #1
 800f594:	4618      	mov	r0, r3
		numZeros++;
 800f596:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 800f59a:	d5f9      	bpl.n	800f590 <xmp3fixpt_DequantChannel+0x228>

	return CLZ(gbMask) - 1;
}
 800f59c:	b011      	add	sp, #68	; 0x44
 800f59e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (i >= *nonZeroBound) 
 800f5a2:	9b06      	ldr	r3, [sp, #24]
 800f5a4:	3501      	adds	r5, #1
 800f5a6:	681b      	ldr	r3, [r3, #0]
 800f5a8:	42b3      	cmp	r3, r6
 800f5aa:	f77f af42 	ble.w	800f432 <xmp3fixpt_DequantChannel+0xca>
	for (cb = 0; cb < cbEndL; cb++) {
 800f5ae:	464c      	mov	r4, r9
 800f5b0:	e739      	b.n	800f426 <xmp3fixpt_DequantChannel+0xbe>
	if (!x)
 800f5b2:	f1bb 0f00 	cmp.w	fp, #0
 800f5b6:	d01c      	beq.n	800f5f2 <xmp3fixpt_DequantChannel+0x28a>
	while (!(x & 0x80000000)) {
 800f5b8:	f1bb 0f00 	cmp.w	fp, #0
 800f5bc:	db3b      	blt.n	800f636 <xmp3fixpt_DequantChannel+0x2ce>
	numZeros = 0;
 800f5be:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 800f5c0:	ea5f 0b4b 	movs.w	fp, fp, lsl #1
 800f5c4:	4618      	mov	r0, r3
		numZeros++;
 800f5c6:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 800f5ca:	d5f9      	bpl.n	800f5c0 <xmp3fixpt_DequantChannel+0x258>
}
 800f5cc:	b011      	add	sp, #68	; 0x44
 800f5ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	cbi->cbEndL  = cbMax[0];
 800f5d2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
	cbi->cbType = 0;			/* long only */
 800f5d4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
	cbi->cbEndL  = cbMax[0];
 800f5d6:	615c      	str	r4, [r3, #20]
	cbi->cbType = 0;			/* long only */
 800f5d8:	2300      	movs	r3, #0
	cbi->cbEndL  = cbMax[0];
 800f5da:	f8dd b008 	ldr.w	fp, [sp, #8]
	cbi->cbType = 0;			/* long only */
 800f5de:	6013      	str	r3, [r2, #0]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f5e0:	6053      	str	r3, [r2, #4]
	cbi->cbEndSMax = 0;
 800f5e2:	6113      	str	r3, [r2, #16]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f5e4:	e9c2 3302 	strd	r3, r3, [r2, #8]
	if (cbStartS >= 12) 
 800f5e8:	9b03      	ldr	r3, [sp, #12]
 800f5ea:	2b0b      	cmp	r3, #11
 800f5ec:	f77f af35 	ble.w	800f45a <xmp3fixpt_DequantChannel+0xf2>
 800f5f0:	e7e2      	b.n	800f5b8 <xmp3fixpt_DequantChannel+0x250>
 800f5f2:	201f      	movs	r0, #31
}
 800f5f4:	b011      	add	sp, #68	; 0x44
 800f5f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (w = 0; w < 3; w++) {
 800f5fa:	f108 0804 	add.w	r8, r8, #4
 800f5fe:	ab0f      	add	r3, sp, #60	; 0x3c
 800f600:	442f      	add	r7, r5
 800f602:	442e      	add	r6, r5
 800f604:	4543      	cmp	r3, r8
 800f606:	f47f af55 	bne.w	800f4b4 <xmp3fixpt_DequantChannel+0x14c>
 800f60a:	e770      	b.n	800f4ee <xmp3fixpt_DequantChannel+0x186>
		if (sis->mixedBlock) { 
 800f60c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f60e:	f8d3 a018 	ldr.w	sl, [r3, #24]
 800f612:	f1ba 0f00 	cmp.w	sl, #0
 800f616:	d00b      	beq.n	800f630 <xmp3fixpt_DequantChannel+0x2c8>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 800f618:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f61a:	781b      	ldrb	r3, [r3, #0]
			cbStartS = 3; 
 800f61c:	2b00      	cmp	r3, #0
 800f61e:	f04f 0303 	mov.w	r3, #3
 800f622:	bf0c      	ite	eq
 800f624:	f04f 0a08 	moveq.w	sl, #8
 800f628:	f04f 0a06 	movne.w	sl, #6
 800f62c:	9303      	str	r3, [sp, #12]
 800f62e:	e6ab      	b.n	800f388 <xmp3fixpt_DequantChannel+0x20>
			cbStartS = 0;
 800f630:	f8cd a00c 	str.w	sl, [sp, #12]
 800f634:	e6a8      	b.n	800f388 <xmp3fixpt_DequantChannel+0x20>
 800f636:	f04f 30ff 	mov.w	r0, #4294967295
	return CLZ(gbMask) - 1;
 800f63a:	e7af      	b.n	800f59c <xmp3fixpt_DequantChannel+0x234>
 800f63c:	08022dcc 	.word	0x08022dcc

0800f640 <xmp3fixpt_DecodeHuffman>:
 *                byte located at buf + offset)
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 800f640:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f644:	b097      	sub	sp, #92	; 0x5c
 800f646:	910e      	str	r1, [sp, #56]	; 0x38
 800f648:	9208      	str	r2, [sp, #32]
 800f64a:	9306      	str	r3, [sp, #24]
	SideInfoSub *sis;
	ScaleFactorInfo *sfi;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS) {
 800f64c:	2800      	cmp	r0, #0
 800f64e:	f000 82b0 	beq.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
 800f652:	6801      	ldr	r1, [r0, #0]
 800f654:	2900      	cmp	r1, #0
 800f656:	f000 82ac 	beq.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
 800f65a:	6844      	ldr	r4, [r0, #4]
 800f65c:	9409      	str	r4, [sp, #36]	; 0x24
 800f65e:	2c00      	cmp	r4, #0
 800f660:	f000 82a7 	beq.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
 800f664:	6883      	ldr	r3, [r0, #8]
 800f666:	2b00      	cmp	r3, #0
 800f668:	f000 82a3 	beq.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
	sis = &si->sis[gr][ch];
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);

	if (huffBlockBits < 0) {
 800f66c:	9a06      	ldr	r2, [sp, #24]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS) {
 800f66e:	68c3      	ldr	r3, [r0, #12]
	if (huffBlockBits < 0) {
 800f670:	2a00      	cmp	r2, #0
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS) {
 800f672:	930d      	str	r3, [sp, #52]	; 0x34
	if (huffBlockBits < 0) {
 800f674:	f2c0 829d 	blt.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
 800f678:	2b00      	cmp	r3, #0
 800f67a:	f000 829a 	beq.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
		i = 1;
		return -1;
	}

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800f67e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800f680:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800f684:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f686:	0112      	lsls	r2, r2, #4
 800f688:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800f68c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800f690:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f692:	00db      	lsls	r3, r3, #3
 800f694:	4422      	add	r2, r4
 800f696:	930c      	str	r3, [sp, #48]	; 0x30
 800f698:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800f69a:	00db      	lsls	r3, r3, #3
 800f69c:	930b      	str	r3, [sp, #44]	; 0x2c
 800f69e:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800f6a0:	2b00      	cmp	r3, #0
 800f6a2:	f040 82cb 	bne.w	800fc3c <xmp3fixpt_DecodeHuffman+0x5fc>
				r1Start = fh->sfBand->l[6] + 2*w;
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f6a6:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800f6a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f6aa:	9920      	ldr	r1, [sp, #128]	; 0x80
 800f6ac:	9821      	ldr	r0, [sp, #132]	; 0x84
 800f6ae:	440b      	add	r3, r1
 800f6b0:	990c      	ldr	r1, [sp, #48]	; 0x30
 800f6b2:	011b      	lsls	r3, r3, #4
 800f6b4:	4401      	add	r1, r0
 800f6b6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800f6ba:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f6bc:	440b      	add	r3, r1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f6be:	e9d3 1317 	ldrd	r1, r3, [r3, #92]	; 0x5c
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f6c2:	3101      	adds	r1, #1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f6c4:	440b      	add	r3, r1
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f6c6:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f6ca:	3301      	adds	r3, #1
 800f6cc:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f6d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f6d2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800f6d4:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800f6d6:	189c      	adds	r4, r3, r2
 800f6d8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f6da:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800f6dc:	0124      	lsls	r4, r4, #4
 800f6de:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800f6e0:	189a      	adds	r2, r3, r2
 800f6e2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f6e4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	rEnd[2] = MIN(r2Start, rEnd[3]);
	rEnd[1] = MIN(r1Start, rEnd[3]);
	rEnd[0] = 0;

	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];
 800f6e8:	f503 5680 	add.w	r6, r3, #4096	; 0x1000
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f6ec:	eb04 03c2 	add.w	r3, r4, r2, lsl #3
 800f6f0:	461c      	mov	r4, r3
 800f6f2:	443b      	add	r3, r7
	hi->nonZeroBound[ch] = rEnd[3];
 800f6f4:	9610      	str	r6, [sp, #64]	; 0x40
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f6f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f6f8:	3444      	adds	r4, #68	; 0x44
 800f6fa:	005b      	lsls	r3, r3, #1
 800f6fc:	193c      	adds	r4, r7, r4
 800f6fe:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 800f702:	9407      	str	r4, [sp, #28]
 800f704:	bfa8      	it	ge
 800f706:	f44f 7310 	movge.w	r3, #576	; 0x240
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f70a:	4298      	cmp	r0, r3
	hi->nonZeroBound[ch] = rEnd[3];
 800f70c:	f8c6 3200 	str.w	r3, [r6, #512]	; 0x200
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f710:	9311      	str	r3, [sp, #68]	; 0x44
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f712:	bfa8      	it	ge
 800f714:	4618      	movge	r0, r3
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f716:	4299      	cmp	r1, r3
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f718:	9315      	str	r3, [sp, #84]	; 0x54
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f71a:	bfa8      	it	ge
 800f71c:	4619      	movge	r1, r3
	rEnd[0] = 0;
 800f71e:	2300      	movs	r3, #0
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f720:	9014      	str	r0, [sp, #80]	; 0x50
	rEnd[0] = 0;
 800f722:	9312      	str	r3, [sp, #72]	; 0x48

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
	for (i = 0; i < 3; i++) {
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f724:	eb05 2302 	add.w	r3, r5, r2, lsl #8
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f728:	9113      	str	r1, [sp, #76]	; 0x4c
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f72a:	930a      	str	r3, [sp, #40]	; 0x28
 800f72c:	0193      	lsls	r3, r2, #6
 800f72e:	930f      	str	r3, [sp, #60]	; 0x3c
 800f730:	9b08      	ldr	r3, [sp, #32]
 800f732:	681a      	ldr	r2, [r3, #0]
 800f734:	ab12      	add	r3, sp, #72	; 0x48
 800f736:	9305      	str	r3, [sp, #20]
 800f738:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f73a:	9304      	str	r3, [sp, #16]
 800f73c:	9b05      	ldr	r3, [sp, #20]
 800f73e:	681c      	ldr	r4, [r3, #0]
 800f740:	f853 6f04 	ldr.w	r6, [r3, #4]!
 800f744:	1b36      	subs	r6, r6, r4
 800f746:	9305      	str	r3, [sp, #20]
	if(nVals <= 0) 
 800f748:	2e00      	cmp	r6, #0
 800f74a:	f340 80a1 	ble.w	800f890 <xmp3fixpt_DecodeHuffman+0x250>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f74e:	9b07      	ldr	r3, [sp, #28]
	cachedBits = (8 - bitOffset) & 0x07;
 800f750:	4252      	negs	r2, r2
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f752:	9904      	ldr	r1, [sp, #16]
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f754:	6818      	ldr	r0, [r3, #0]
	if (cachedBits)
 800f756:	f012 0207 	ands.w	r2, r2, #7
	tabType = huffTabLookup[tabIdx].tabType;
 800f75a:	4bac      	ldr	r3, [pc, #688]	; (800fa0c <xmp3fixpt_DecodeHuffman+0x3cc>)
 800f75c:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800f760:	791b      	ldrb	r3, [r3, #4]
 800f762:	9300      	str	r3, [sp, #0]
	if (cachedBits)
 800f764:	f000 822a 	beq.w	800fbbc <xmp3fixpt_DecodeHuffman+0x57c>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f768:	f811 5b01 	ldrb.w	r5, [r1], #1
 800f76c:	f1c2 0320 	rsb	r3, r2, #32
 800f770:	fa05 f303 	lsl.w	r3, r5, r3
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f774:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800f776:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	if (tabType == noBits) {
 800f77a:	9d00      	ldr	r5, [sp, #0]
 800f77c:	2d00      	cmp	r5, #0
 800f77e:	f000 8225 	beq.w	800fbcc <xmp3fixpt_DecodeHuffman+0x58c>
	bitsLeft -= cachedBits;
 800f782:	9d06      	ldr	r5, [sp, #24]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f784:	4ca2      	ldr	r4, [pc, #648]	; (800fa10 <xmp3fixpt_DecodeHuffman+0x3d0>)
	bitsLeft -= cachedBits;
 800f786:	1aaf      	subs	r7, r5, r2
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f788:	4da2      	ldr	r5, [pc, #648]	; (800fa14 <xmp3fixpt_DecodeHuffman+0x3d4>)
 800f78a:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
 800f78e:	eb05 0b44 	add.w	fp, r5, r4, lsl #1
	} else if (tabType == oneShot) {
 800f792:	9d00      	ldr	r5, [sp, #0]
 800f794:	2d01      	cmp	r5, #1
 800f796:	f000 81b8 	beq.w	800fb0a <xmp3fixpt_DecodeHuffman+0x4ca>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 800f79a:	1eac      	subs	r4, r5, #2
 800f79c:	2c01      	cmp	r4, #1
 800f79e:	f200 8208 	bhi.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
	linBits = huffTabLookup[tabIdx].linBits;
 800f7a2:	4c9a      	ldr	r4, [pc, #616]	; (800fa0c <xmp3fixpt_DecodeHuffman+0x3cc>)
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f7a4:	465d      	mov	r5, fp
	linBits = huffTabLookup[tabIdx].linBits;
 800f7a6:	f854 a030 	ldr.w	sl, [r4, r0, lsl #3]
		padBits = 0;
 800f7aa:	2000      	movs	r0, #0
 800f7ac:	9001      	str	r0, [sp, #4]
					minBits = linBits + 1;
 800f7ae:	f10a 0001 	add.w	r0, sl, #1
 800f7b2:	9002      	str	r0, [sp, #8]
					y += (int)(cache >> (32 - linBits));
 800f7b4:	f1ca 0020 	rsb	r0, sl, #32
 800f7b8:	9003      	str	r0, [sp, #12]
			if (bitsLeft >= 16) {
 800f7ba:	2f0f      	cmp	r7, #15
 800f7bc:	f340 821f 	ble.w	800fbfe <xmp3fixpt_DecodeHuffman+0x5be>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f7c0:	7848      	ldrb	r0, [r1, #1]
 800f7c2:	f1c2 0410 	rsb	r4, r2, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f7c6:	f1c2 0e18 	rsb	lr, r2, #24
				cachedBits += 16;
 800f7ca:	3210      	adds	r2, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f7cc:	fa00 f404 	lsl.w	r4, r0, r4
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f7d0:	f811 0b02 	ldrb.w	r0, [r1], #2
			while (nVals > 0 && cachedBits >= 11 ) {
 800f7d4:	2a0a      	cmp	r2, #10
				bitsLeft -= 16;
 800f7d6:	f1a7 0710 	sub.w	r7, r7, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f7da:	fa00 f00e 	lsl.w	r0, r0, lr
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f7de:	ea40 0004 	orr.w	r0, r0, r4
 800f7e2:	ea43 0300 	orr.w	r3, r3, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 800f7e6:	dde8      	ble.n	800f7ba <xmp3fixpt_DecodeHuffman+0x17a>
				maxBits = GetMaxbits(tCurr[0]);
 800f7e8:	882c      	ldrh	r4, [r5, #0]
 800f7ea:	f004 040f 	and.w	r4, r4, #15
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 800f7ee:	f1c4 0020 	rsb	r0, r4, #32
 800f7f2:	fa23 f000 	lsr.w	r0, r3, r0
 800f7f6:	3001      	adds	r0, #1
 800f7f8:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
				if (!len) {
 800f7fc:	ea5f 3e10 	movs.w	lr, r0, lsr #12
 800f800:	f000 817e 	beq.w	800fb00 <xmp3fixpt_DecodeHuffman+0x4c0>
				if (x == 15 && tabType == loopLinbits) {
 800f804:	9c00      	ldr	r4, [sp, #0]
				x = GetCWX(cw);
 800f806:	f3c0 1503 	ubfx	r5, r0, #4, #4
				cachedBits -= len;
 800f80a:	eba2 020e 	sub.w	r2, r2, lr
				cache <<= len;
 800f80e:	fa03 f30e 	lsl.w	r3, r3, lr
				if (x == 15 && tabType == loopLinbits) {
 800f812:	f1a4 0903 	sub.w	r9, r4, #3
 800f816:	2d0f      	cmp	r5, #15
				y = GetCWY(cw);
 800f818:	f3c0 2003 	ubfx	r0, r0, #8, #4
				if (x == 15 && tabType == loopLinbits) {
 800f81c:	fab9 f989 	clz	r9, r9
 800f820:	ea4f 1959 	mov.w	r9, r9, lsr #5
 800f824:	d103      	bne.n	800f82e <xmp3fixpt_DecodeHuffman+0x1ee>
 800f826:	f1b9 0f00 	cmp.w	r9, #0
 800f82a:	f040 80fb 	bne.w	800fa24 <xmp3fixpt_DecodeHuffman+0x3e4>
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f82e:	b125      	cbz	r5, 800f83a <xmp3fixpt_DecodeHuffman+0x1fa>
 800f830:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 800f834:	3a01      	subs	r2, #1
 800f836:	005b      	lsls	r3, r3, #1
 800f838:	4325      	orrs	r5, r4
				if (y == 15 && tabType == loopLinbits) {
 800f83a:	280f      	cmp	r0, #15
 800f83c:	d103      	bne.n	800f846 <xmp3fixpt_DecodeHuffman+0x206>
 800f83e:	f1b9 0f00 	cmp.w	r9, #0
 800f842:	f040 8128 	bne.w	800fa96 <xmp3fixpt_DecodeHuffman+0x456>
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800f846:	b120      	cbz	r0, 800f852 <xmp3fixpt_DecodeHuffman+0x212>
 800f848:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 800f84c:	3a01      	subs	r2, #1
 800f84e:	005b      	lsls	r3, r3, #1
 800f850:	4320      	orrs	r0, r4
				if (cachedBits < padBits)
 800f852:	9c01      	ldr	r4, [sp, #4]
 800f854:	42a2      	cmp	r2, r4
 800f856:	f2c0 81ac 	blt.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
				*xy++ = x;
 800f85a:	4664      	mov	r4, ip
				nVals -= 2;
 800f85c:	3e02      	subs	r6, #2
				*xy++ = x;
 800f85e:	f844 5b08 	str.w	r5, [r4], #8
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f862:	465d      	mov	r5, fp
				*xy++ = y;
 800f864:	f8cc 0004 	str.w	r0, [ip, #4]
 800f868:	46a4      	mov	ip, r4
			while (nVals > 0 && cachedBits >= 11 ) {
 800f86a:	2e00      	cmp	r6, #0
 800f86c:	dd03      	ble.n	800f876 <xmp3fixpt_DecodeHuffman+0x236>
 800f86e:	2a0a      	cmp	r2, #10
 800f870:	dcba      	bgt.n	800f7e8 <xmp3fixpt_DecodeHuffman+0x1a8>
		while (nVals > 0) {
 800f872:	2e00      	cmp	r6, #0
 800f874:	dca1      	bgt.n	800f7ba <xmp3fixpt_DecodeHuffman+0x17a>
		bitsLeft += (cachedBits - padBits);
 800f876:	9b01      	ldr	r3, [sp, #4]
 800f878:	1ad2      	subs	r2, r2, r3
		return (startBits - bitsLeft);
 800f87a:	9b06      	ldr	r3, [sp, #24]
		bitsLeft += (cachedBits - padBits);
 800f87c:	443a      	add	r2, r7
		return (startBits - bitsLeft);
 800f87e:	1a9b      	subs	r3, r3, r2
		if (bitsUsed < 0 || bitsUsed > bitsLeft) {
 800f880:	9906      	ldr	r1, [sp, #24]
 800f882:	428b      	cmp	r3, r1
 800f884:	f200 8195 	bhi.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
			i = 1;
			return -1;
		}

		/* update bitstream position */
		buf += (bitsUsed + *bitOffset) >> 3;
 800f888:	9206      	str	r2, [sp, #24]
 800f88a:	9a08      	ldr	r2, [sp, #32]
 800f88c:	6812      	ldr	r2, [r2, #0]
 800f88e:	441a      	add	r2, r3
 800f890:	9b04      	ldr	r3, [sp, #16]
	for (i = 0; i < 3; i++) {
 800f892:	a915      	add	r1, sp, #84	; 0x54
		buf += (bitsUsed + *bitOffset) >> 3;
 800f894:	eb03 03e2 	add.w	r3, r3, r2, asr #3
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800f898:	f002 0207 	and.w	r2, r2, #7
		buf += (bitsUsed + *bitOffset) >> 3;
 800f89c:	9304      	str	r3, [sp, #16]
	for (i = 0; i < 3; i++) {
 800f89e:	9b07      	ldr	r3, [sp, #28]
 800f8a0:	3304      	adds	r3, #4
 800f8a2:	9307      	str	r3, [sp, #28]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800f8a4:	9b08      	ldr	r3, [sp, #32]
 800f8a6:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
 800f8a8:	9b05      	ldr	r3, [sp, #20]
 800f8aa:	4299      	cmp	r1, r3
 800f8ac:	f47f af46 	bne.w	800f73c <xmp3fixpt_DecodeHuffman+0xfc>
	if (bitsLeft <= 0)
 800f8b0:	9b06      	ldr	r3, [sp, #24]
 800f8b2:	2b00      	cmp	r3, #0
 800f8b4:	f000 822f 	beq.w	800fd16 <xmp3fixpt_DecodeHuffman+0x6d6>
		bitsLeft -= bitsUsed;
	}

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f8b8:	9b20      	ldr	r3, [sp, #128]	; 0x80
	cachedBits = (8 - bitOffset) & 0x07;
 800f8ba:	4252      	negs	r2, r2
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f8bc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f8be:	9821      	ldr	r0, [sp, #132]	; 0x84
	if (cachedBits)
 800f8c0:	f012 0207 	ands.w	r2, r2, #7
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f8c4:	4419      	add	r1, r3
 800f8c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f8c8:	ea4f 1101 	mov.w	r1, r1, lsl #4
 800f8cc:	4403      	add	r3, r0
 800f8ce:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800f8d2:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f8d4:	4419      	add	r1, r3
 800f8d6:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 800f8d8:	494f      	ldr	r1, [pc, #316]	; (800fa18 <xmp3fixpt_DecodeHuffman+0x3d8>)
 800f8da:	f851 a023 	ldr.w	sl, [r1, r3, lsl #2]
	maxBits = quadTabMaxBits[tabIdx];
 800f8de:	494f      	ldr	r1, [pc, #316]	; (800fa1c <xmp3fixpt_DecodeHuffman+0x3dc>)
 800f8e0:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f8e4:	9b04      	ldr	r3, [sp, #16]
	if (cachedBits)
 800f8e6:	f040 81c2 	bne.w	800fc6e <xmp3fixpt_DecodeHuffman+0x62e>
	cache = 0;
 800f8ea:	4611      	mov	r1, r2
		buf += (bitsUsed + *bitOffset) >> 3;
 800f8ec:	9300      	str	r3, [sp, #0]
	while (i < (nVals - 3)) {
 800f8ee:	f240 2e3d 	movw	lr, #573	; 0x23d
 800f8f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
	bitsLeft -= cachedBits;
 800f8f4:	9c06      	ldr	r4, [sp, #24]
	while (i < (nVals - 3)) {
 800f8f6:	ebae 0e03 	sub.w	lr, lr, r3
	bitsLeft -= cachedBits;
 800f8fa:	eba4 0b02 	sub.w	fp, r4, r2
	while (i < (nVals - 3)) {
 800f8fe:	f1be 0f00 	cmp.w	lr, #0
 800f902:	f340 8243 	ble.w	800fd8c <xmp3fixpt_DecodeHuffman+0x74c>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f906:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	i = padBits = 0;
 800f908:	f04f 0c00 	mov.w	ip, #0
			cw = tBase[cache >> (32 - maxBits)];
 800f90c:	f1c0 0820 	rsb	r8, r0, #32
 800f910:	f8df 910c 	ldr.w	r9, [pc, #268]	; 800fa20 <xmp3fixpt_DecodeHuffman+0x3e0>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f914:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	i = padBits = 0;
 800f918:	4667      	mov	r7, ip
		if (bitsLeft >= 16) {
 800f91a:	f1bb 0f0f 	cmp.w	fp, #15
 800f91e:	f340 81ae 	ble.w	800fc7e <xmp3fixpt_DecodeHuffman+0x63e>
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f922:	9800      	ldr	r0, [sp, #0]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f924:	f1c2 0418 	rsb	r4, r2, #24
			bitsLeft -= 16;
 800f928:	f1ab 0b10 	sub.w	fp, fp, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f92c:	7845      	ldrb	r5, [r0, #1]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f92e:	f810 6b02 	ldrb.w	r6, [r0], #2
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f932:	9000      	str	r0, [sp, #0]
 800f934:	f1c2 0010 	rsb	r0, r2, #16
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f938:	fa06 f404 	lsl.w	r4, r6, r4
			cachedBits += 16;
 800f93c:	3210      	adds	r2, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f93e:	fa05 f000 	lsl.w	r0, r5, r0
 800f942:	4320      	orrs	r0, r4
 800f944:	4301      	orrs	r1, r0
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f946:	f103 0010 	add.w	r0, r3, #16
 800f94a:	e003      	b.n	800f954 <xmp3fixpt_DecodeHuffman+0x314>
 800f94c:	2a09      	cmp	r2, #9
 800f94e:	f100 0010 	add.w	r0, r0, #16
 800f952:	dde2      	ble.n	800f91a <xmp3fixpt_DecodeHuffman+0x2da>
			cw = tBase[cache >> (32 - maxBits)];
 800f954:	fa21 f308 	lsr.w	r3, r1, r8
 800f958:	4453      	add	r3, sl
 800f95a:	f819 3003 	ldrb.w	r3, [r9, r3]
			len = GetHLenQ(cw);
 800f95e:	091c      	lsrs	r4, r3, #4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800f960:	f013 0608 	ands.w	r6, r3, #8
			cachedBits -= len;
 800f964:	eba2 1213 	sub.w	r2, r2, r3, lsr #4
			cache <<= len;
 800f968:	fa01 f104 	lsl.w	r1, r1, r4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800f96c:	d005      	beq.n	800f97a <xmp3fixpt_DecodeHuffman+0x33a>
 800f96e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800f972:	3a01      	subs	r2, #1
 800f974:	0049      	lsls	r1, r1, #1
 800f976:	f046 0601 	orr.w	r6, r6, #1
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 800f97a:	f013 0504 	ands.w	r5, r3, #4
 800f97e:	d005      	beq.n	800f98c <xmp3fixpt_DecodeHuffman+0x34c>
 800f980:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800f984:	3a01      	subs	r2, #1
 800f986:	0049      	lsls	r1, r1, #1
 800f988:	f045 0501 	orr.w	r5, r5, #1
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f98c:	f013 0402 	ands.w	r4, r3, #2
 800f990:	d005      	beq.n	800f99e <xmp3fixpt_DecodeHuffman+0x35e>
 800f992:	f001 4400 	and.w	r4, r1, #2147483648	; 0x80000000
 800f996:	3a01      	subs	r2, #1
 800f998:	0049      	lsls	r1, r1, #1
 800f99a:	f044 0401 	orr.w	r4, r4, #1
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800f99e:	f013 0301 	ands.w	r3, r3, #1
 800f9a2:	d005      	beq.n	800f9b0 <xmp3fixpt_DecodeHuffman+0x370>
 800f9a4:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
 800f9a8:	3a01      	subs	r2, #1
 800f9aa:	0049      	lsls	r1, r1, #1
 800f9ac:	f043 0301 	orr.w	r3, r3, #1
			if (cachedBits < padBits)
 800f9b0:	4562      	cmp	r2, ip
 800f9b2:	db07      	blt.n	800f9c4 <xmp3fixpt_DecodeHuffman+0x384>
			i += 4;
 800f9b4:	3704      	adds	r7, #4
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f9b6:	4577      	cmp	r7, lr
			*vwxy++ = y;
 800f9b8:	e940 4302 	strd	r4, r3, [r0, #-8]
			*vwxy++ = w;
 800f9bc:	e940 6504 	strd	r6, r5, [r0, #-16]
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f9c0:	4603      	mov	r3, r0
 800f9c2:	dbc3      	blt.n	800f94c <xmp3fixpt_DecodeHuffman+0x30c>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f9c4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800f9c6:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800f9ca:	443b      	add	r3, r7

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800f9cc:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f9d0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800f9d4:	da0a      	bge.n	800f9ec <xmp3fixpt_DecodeHuffman+0x3ac>
		hi->huffDecBuf[ch][i] = 0;
 800f9d6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800f9d8:	2100      	movs	r1, #0
 800f9da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f9dc:	4418      	add	r0, r3
 800f9de:	f5c3 7310 	rsb	r3, r3, #576	; 0x240
 800f9e2:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 800f9e6:	009a      	lsls	r2, r3, #2
 800f9e8:	f010 fb78 	bl	80200dc <memset>
	
	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
	 *  to be stuffing bits (throw away, but need to return correct bitstream position) 
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
 800f9ec:	9908      	ldr	r1, [sp, #32]
 800f9ee:	9a06      	ldr	r2, [sp, #24]
 800f9f0:	680b      	ldr	r3, [r1, #0]
 800f9f2:	9804      	ldr	r0, [sp, #16]
 800f9f4:	441a      	add	r2, r3
 800f9f6:	4613      	mov	r3, r2
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800f9f8:	f002 0207 	and.w	r2, r2, #7
	buf += (bitsLeft + *bitOffset) >> 3;
 800f9fc:	eb00 00e3 	add.w	r0, r0, r3, asr #3
	
	return (buf - startBuf);
 800fa00:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800fa02:	600a      	str	r2, [r1, #0]
	return (buf - startBuf);
 800fa04:	1ac0      	subs	r0, r0, r3
}
 800fa06:	b017      	add	sp, #92	; 0x5c
 800fa08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fa0c:	08022de4 	.word	0x08022de4
 800fa10:	08022ee4 	.word	0x08022ee4
 800fa14:	08022f64 	.word	0x08022f64
 800fa18:	08025090 	.word	0x08025090
 800fa1c:	08025088 	.word	0x08025088
 800fa20:	08025098 	.word	0x08025098
					minBits = linBits + 1 + (y ? 1 : 0);
 800fa24:	9c02      	ldr	r4, [sp, #8]
					if (cachedBits + bitsLeft < minBits)
 800fa26:	18bd      	adds	r5, r7, r2
					minBits = linBits + 1 + (y ? 1 : 0);
 800fa28:	2800      	cmp	r0, #0
 800fa2a:	bf18      	it	ne
 800fa2c:	3401      	addne	r4, #1
					if (cachedBits + bitsLeft < minBits)
 800fa2e:	42ac      	cmp	r4, r5
 800fa30:	f300 80bf 	bgt.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
					while (cachedBits < minBits) {
 800fa34:	42a2      	cmp	r2, r4
 800fa36:	f280 814a 	bge.w	800fcce <xmp3fixpt_DecodeHuffman+0x68e>
 800fa3a:	ea6f 0802 	mvn.w	r8, r2
 800fa3e:	f1c2 0518 	rsb	r5, r2, #24
 800fa42:	44a0      	add	r8, r4
 800fa44:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 800fa48:	f108 0e01 	add.w	lr, r8, #1
 800fa4c:	448e      	add	lr, r1
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fa4e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800fa52:	40ac      	lsls	r4, r5
					while (cachedBits < minBits) {
 800fa54:	4571      	cmp	r1, lr
 800fa56:	f1a5 0508 	sub.w	r5, r5, #8
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fa5a:	ea43 0304 	orr.w	r3, r3, r4
					while (cachedBits < minBits) {
 800fa5e:	d1f6      	bne.n	800fa4e <xmp3fixpt_DecodeHuffman+0x40e>
					if (bitsLeft < 0) {
 800fa60:	3208      	adds	r2, #8
 800fa62:	3f08      	subs	r7, #8
						cachedBits += 8;
 800fa64:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
						bitsLeft -= 8;
 800fa68:	ebc8 7848 	rsb	r8, r8, r8, lsl #29
					if (bitsLeft < 0) {
 800fa6c:	eb17 07c8 	adds.w	r7, r7, r8, lsl #3
 800fa70:	d507      	bpl.n	800fa82 <xmp3fixpt_DecodeHuffman+0x442>
						cachedBits += bitsLeft;
 800fa72:	443a      	add	r2, r7
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fa74:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
						bitsLeft = 0;
 800fa78:	2700      	movs	r7, #0
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fa7a:	1e51      	subs	r1, r2, #1
 800fa7c:	fa44 f101 	asr.w	r1, r4, r1
 800fa80:	400b      	ands	r3, r1
					x += (int)(cache >> (32 - linBits));
 800fa82:	9c03      	ldr	r4, [sp, #12]
					cachedBits -= linBits;
 800fa84:	eba2 020a 	sub.w	r2, r2, sl
					cache <<= linBits;
 800fa88:	4671      	mov	r1, lr
					x += (int)(cache >> (32 - linBits));
 800fa8a:	fa23 f504 	lsr.w	r5, r3, r4
					cache <<= linBits;
 800fa8e:	fa03 f30a 	lsl.w	r3, r3, sl
					x += (int)(cache >> (32 - linBits));
 800fa92:	350f      	adds	r5, #15
					cache <<= linBits;
 800fa94:	e6cb      	b.n	800f82e <xmp3fixpt_DecodeHuffman+0x1ee>
					if (cachedBits + bitsLeft < minBits)
 800fa96:	18b8      	adds	r0, r7, r2
 800fa98:	9c02      	ldr	r4, [sp, #8]
 800fa9a:	4284      	cmp	r4, r0
 800fa9c:	f300 8089 	bgt.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
					while (cachedBits < minBits) {
 800faa0:	4294      	cmp	r4, r2
 800faa2:	f340 8116 	ble.w	800fcd2 <xmp3fixpt_DecodeHuffman+0x692>
 800faa6:	ebaa 0802 	sub.w	r8, sl, r2
 800faaa:	f1c2 0418 	rsb	r4, r2, #24
 800faae:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 800fab2:	f108 0e01 	add.w	lr, r8, #1
 800fab6:	448e      	add	lr, r1
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fab8:	f811 0b01 	ldrb.w	r0, [r1], #1
 800fabc:	40a0      	lsls	r0, r4
					while (cachedBits < minBits) {
 800fabe:	4571      	cmp	r1, lr
 800fac0:	f1a4 0408 	sub.w	r4, r4, #8
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fac4:	ea43 0300 	orr.w	r3, r3, r0
					while (cachedBits < minBits) {
 800fac8:	d1f6      	bne.n	800fab8 <xmp3fixpt_DecodeHuffman+0x478>
					if (bitsLeft < 0) {
 800faca:	3208      	adds	r2, #8
 800facc:	3f08      	subs	r7, #8
						cachedBits += 8;
 800face:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
						bitsLeft -= 8;
 800fad2:	ebc8 7848 	rsb	r8, r8, r8, lsl #29
					if (bitsLeft < 0) {
 800fad6:	eb17 07c8 	adds.w	r7, r7, r8, lsl #3
 800fada:	d507      	bpl.n	800faec <xmp3fixpt_DecodeHuffman+0x4ac>
						cachedBits += bitsLeft;
 800fadc:	443a      	add	r2, r7
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fade:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
						bitsLeft = 0;
 800fae2:	2700      	movs	r7, #0
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fae4:	1e51      	subs	r1, r2, #1
 800fae6:	fa40 f101 	asr.w	r1, r0, r1
 800faea:	400b      	ands	r3, r1
					y += (int)(cache >> (32 - linBits));
 800faec:	9803      	ldr	r0, [sp, #12]
					cachedBits -= linBits;
 800faee:	eba2 020a 	sub.w	r2, r2, sl
					cache <<= linBits;
 800faf2:	4671      	mov	r1, lr
					y += (int)(cache >> (32 - linBits));
 800faf4:	fa23 f000 	lsr.w	r0, r3, r0
					cache <<= linBits;
 800faf8:	fa03 f30a 	lsl.w	r3, r3, sl
					y += (int)(cache >> (32 - linBits));
 800fafc:	300f      	adds	r0, #15
					cache <<= linBits;
 800fafe:	e6a2      	b.n	800f846 <xmp3fixpt_DecodeHuffman+0x206>
					tCurr += cw;
 800fb00:	eb05 0540 	add.w	r5, r5, r0, lsl #1
					cachedBits -= maxBits;
 800fb04:	1b12      	subs	r2, r2, r4
					cache <<= maxBits;
 800fb06:	40a3      	lsls	r3, r4
					continue;
 800fb08:	e6af      	b.n	800f86a <xmp3fixpt_DecodeHuffman+0x22a>
		maxBits = GetMaxbits(tBase[0]);
 800fb0a:	48a1      	ldr	r0, [pc, #644]	; (800fd90 <xmp3fixpt_DecodeHuffman+0x750>)
		padBits = 0;
 800fb0c:	f04f 0900 	mov.w	r9, #0
		maxBits = GetMaxbits(tBase[0]);
 800fb10:	f830 8014 	ldrh.w	r8, [r0, r4, lsl #1]
 800fb14:	f008 080f 	and.w	r8, r8, #15
				cw = tBase[cache >> (32 - maxBits)];
 800fb18:	f1c8 0820 	rsb	r8, r8, #32
			if (bitsLeft >= 16) {
 800fb1c:	2f0f      	cmp	r7, #15
 800fb1e:	f340 80da 	ble.w	800fcd6 <xmp3fixpt_DecodeHuffman+0x696>
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fb22:	f1c2 0518 	rsb	r5, r2, #24
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fb26:	784c      	ldrb	r4, [r1, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fb28:	f811 0b02 	ldrb.w	r0, [r1], #2
				bitsLeft -= 16;
 800fb2c:	3f10      	subs	r7, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fb2e:	40a8      	lsls	r0, r5
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fb30:	f1c2 0510 	rsb	r5, r2, #16
				cachedBits += 16;
 800fb34:	3210      	adds	r2, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fb36:	40ac      	lsls	r4, r5
 800fb38:	4320      	orrs	r0, r4
 800fb3a:	4303      	orrs	r3, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 800fb3c:	2e00      	cmp	r6, #0
 800fb3e:	f340 80fe 	ble.w	800fd3e <xmp3fixpt_DecodeHuffman+0x6fe>
 800fb42:	f10c 0408 	add.w	r4, ip, #8
 800fb46:	468e      	mov	lr, r1
 800fb48:	e00b      	b.n	800fb62 <xmp3fixpt_DecodeHuffman+0x522>
				*xy++ = x;
 800fb4a:	f844 1c08 	str.w	r1, [r4, #-8]
			while (nVals > 0 && cachedBits >= 11 ) {
 800fb4e:	2e00      	cmp	r6, #0
 800fb50:	f104 0408 	add.w	r4, r4, #8
				*xy++ = y;
 800fb54:	f844 0c0c 	str.w	r0, [r4, #-12]
			while (nVals > 0 && cachedBits >= 11 ) {
 800fb58:	f340 80f1 	ble.w	800fd3e <xmp3fixpt_DecodeHuffman+0x6fe>
 800fb5c:	2a0a      	cmp	r2, #10
 800fb5e:	f340 80ea 	ble.w	800fd36 <xmp3fixpt_DecodeHuffman+0x6f6>
				cw = tBase[cache >> (32 - maxBits)];
 800fb62:	fa23 f008 	lsr.w	r0, r3, r8
 800fb66:	3001      	adds	r0, #1
 800fb68:	f83b 0010 	ldrh.w	r0, [fp, r0, lsl #1]
				len = GetHLen(cw);
 800fb6c:	ea4f 3c10 	mov.w	ip, r0, lsr #12
				cachedBits -= len;
 800fb70:	f3c0 1503 	ubfx	r5, r0, #4, #4
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800fb74:	f010 0ff0 	tst.w	r0, #240	; 0xf0
				cachedBits -= len;
 800fb78:	eba2 3210 	sub.w	r2, r2, r0, lsr #12
				cache <<= len;
 800fb7c:	fa03 f30c 	lsl.w	r3, r3, ip
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800fb80:	4629      	mov	r1, r5
 800fb82:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800fb86:	d003      	beq.n	800fb90 <xmp3fixpt_DecodeHuffman+0x550>
 800fb88:	005b      	lsls	r3, r3, #1
 800fb8a:	3a01      	subs	r2, #1
 800fb8c:	ea4c 0105 	orr.w	r1, ip, r5
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800fb90:	f3c0 2503 	ubfx	r5, r0, #8, #4
 800fb94:	f410 6f70 	tst.w	r0, #3840	; 0xf00
 800fb98:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800fb9c:	4628      	mov	r0, r5
 800fb9e:	d003      	beq.n	800fba8 <xmp3fixpt_DecodeHuffman+0x568>
 800fba0:	ea4c 0005 	orr.w	r0, ip, r5
 800fba4:	005b      	lsls	r3, r3, #1
 800fba6:	3a01      	subs	r2, #1
				if (cachedBits < padBits)
 800fba8:	454a      	cmp	r2, r9
				nVals -= 2;
 800fbaa:	f1a6 0602 	sub.w	r6, r6, #2
 800fbae:	46a4      	mov	ip, r4
				if (cachedBits < padBits)
 800fbb0:	dacb      	bge.n	800fb4a <xmp3fixpt_DecodeHuffman+0x50a>
		return -1;
 800fbb2:	f04f 30ff 	mov.w	r0, #4294967295
}
 800fbb6:	b017      	add	sp, #92	; 0x5c
 800fbb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800fbbc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	cache = 0;
 800fbbe:	4613      	mov	r3, r2
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800fbc0:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	if (tabType == noBits) {
 800fbc4:	9d00      	ldr	r5, [sp, #0]
 800fbc6:	2d00      	cmp	r5, #0
 800fbc8:	f47f addb 	bne.w	800f782 <xmp3fixpt_DecodeHuffman+0x142>
 800fbcc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800fbce:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800fbd0:	18e3      	adds	r3, r4, r3
 800fbd2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800fbd6:	1e72      	subs	r2, r6, #1
 800fbd8:	0759      	lsls	r1, r3, #29
 800fbda:	f040 809e 	bne.w	800fd1a <xmp3fixpt_DecodeHuffman+0x6da>
 800fbde:	2a13      	cmp	r2, #19
 800fbe0:	f240 809b 	bls.w	800fd1a <xmp3fixpt_DecodeHuffman+0x6da>
 800fbe4:	0851      	lsrs	r1, r2, #1
			xy[i+0] = 0;
 800fbe6:	2400      	movs	r4, #0
	if (tabType == noBits) {
 800fbe8:	462a      	mov	r2, r5
			xy[i+0] = 0;
 800fbea:	2500      	movs	r5, #0
 800fbec:	3101      	adds	r1, #1
			xy[i+1] = 0;
 800fbee:	3201      	adds	r2, #1
 800fbf0:	428a      	cmp	r2, r1
			xy[i+0] = 0;
 800fbf2:	e8e3 4502 	strd	r4, r5, [r3], #8
		for (i = 0; i < nVals; i+=2) {
 800fbf6:	d3fa      	bcc.n	800fbee <xmp3fixpt_DecodeHuffman+0x5ae>
		buf += (bitsUsed + *bitOffset) >> 3;
 800fbf8:	9b08      	ldr	r3, [sp, #32]
 800fbfa:	681a      	ldr	r2, [r3, #0]
 800fbfc:	e648      	b.n	800f890 <xmp3fixpt_DecodeHuffman+0x250>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800fbfe:	18b8      	adds	r0, r7, r2
 800fc00:	2800      	cmp	r0, #0
 800fc02:	ddd6      	ble.n	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fc04:	2f00      	cmp	r7, #0
 800fc06:	dd06      	ble.n	800fc16 <xmp3fixpt_DecodeHuffman+0x5d6>
 800fc08:	f1c2 0e18 	rsb	lr, r2, #24
 800fc0c:	f811 4b01 	ldrb.w	r4, [r1], #1
 800fc10:	fa04 f40e 	lsl.w	r4, r4, lr
 800fc14:	4323      	orrs	r3, r4
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fc16:	2f08      	cmp	r7, #8
 800fc18:	dd05      	ble.n	800fc26 <xmp3fixpt_DecodeHuffman+0x5e6>
 800fc1a:	f1c2 0410 	rsb	r4, r2, #16
 800fc1e:	f811 2b01 	ldrb.w	r2, [r1], #1
 800fc22:	40a2      	lsls	r2, r4
 800fc24:	4313      	orrs	r3, r2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fc26:	1e44      	subs	r4, r0, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800fc28:	f100 020b 	add.w	r2, r0, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fc2c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
				bitsLeft = 0;
 800fc30:	2700      	movs	r7, #0
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fc32:	4120      	asrs	r0, r4
 800fc34:	4003      	ands	r3, r0
				padBits = 11;
 800fc36:	200b      	movs	r0, #11
 800fc38:	9001      	str	r0, [sp, #4]
 800fc3a:	e5d5      	b.n	800f7e8 <xmp3fixpt_DecodeHuffman+0x1a8>
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800fc3c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800fc3e:	2b02      	cmp	r3, #2
 800fc40:	f47f ad31 	bne.w	800f6a6 <xmp3fixpt_DecodeHuffman+0x66>
		if (sis->mixedBlock == 0) {
 800fc44:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800fc46:	2b00      	cmp	r3, #0
 800fc48:	d17f      	bne.n	800fd4a <xmp3fixpt_DecodeHuffman+0x70a>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800fc4a:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800fc4c:	f1a3 33aa 	sub.w	r3, r3, #2863311530	; 0xaaaaaaaa
 800fc50:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800fc52:	3201      	adds	r2, #1
 800fc54:	fb83 0302 	smull	r0, r3, r3, r2
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800fc58:	f44f 7010 	mov.w	r0, #576	; 0x240
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800fc5c:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 800fc60:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800fc64:	f9b3 102e 	ldrsh.w	r1, [r3, #46]	; 0x2e
 800fc68:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800fc6c:	e530      	b.n	800f6d0 <xmp3fixpt_DecodeHuffman+0x90>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800fc6e:	f813 4b01 	ldrb.w	r4, [r3], #1
 800fc72:	f1c2 0120 	rsb	r1, r2, #32
 800fc76:	9300      	str	r3, [sp, #0]
 800fc78:	fa04 f101 	lsl.w	r1, r4, r1
 800fc7c:	e637      	b.n	800f8ee <xmp3fixpt_DecodeHuffman+0x2ae>
			if (cachedBits + bitsLeft <= 0) return i;
 800fc7e:	eb02 000b 	add.w	r0, r2, fp
 800fc82:	2800      	cmp	r0, #0
 800fc84:	f77f ae9e 	ble.w	800f9c4 <xmp3fixpt_DecodeHuffman+0x384>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fc88:	f1bb 0f00 	cmp.w	fp, #0
 800fc8c:	dd08      	ble.n	800fca0 <xmp3fixpt_DecodeHuffman+0x660>
 800fc8e:	9c00      	ldr	r4, [sp, #0]
 800fc90:	f1c2 0518 	rsb	r5, r2, #24
 800fc94:	f814 6b01 	ldrb.w	r6, [r4], #1
 800fc98:	fa06 f505 	lsl.w	r5, r6, r5
 800fc9c:	9400      	str	r4, [sp, #0]
 800fc9e:	4329      	orrs	r1, r5
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fca0:	f1bb 0f08 	cmp.w	fp, #8
 800fca4:	dd07      	ble.n	800fcb6 <xmp3fixpt_DecodeHuffman+0x676>
 800fca6:	9c00      	ldr	r4, [sp, #0]
 800fca8:	f1c2 0510 	rsb	r5, r2, #16
 800fcac:	f814 2b01 	ldrb.w	r2, [r4], #1
 800fcb0:	40aa      	lsls	r2, r5
 800fcb2:	9400      	str	r4, [sp, #0]
 800fcb4:	4311      	orrs	r1, r2
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fcb6:	1e44      	subs	r4, r0, #1
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800fcb8:	f100 020a 	add.w	r2, r0, #10
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fcbc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
			padBits = 10;
 800fcc0:	f04f 0c0a 	mov.w	ip, #10
			bitsLeft = 0;
 800fcc4:	f04f 0b00 	mov.w	fp, #0
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fcc8:	4120      	asrs	r0, r4
 800fcca:	4001      	ands	r1, r0
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800fccc:	e63b      	b.n	800f946 <xmp3fixpt_DecodeHuffman+0x306>
					while (cachedBits < minBits) {
 800fcce:	468e      	mov	lr, r1
 800fcd0:	e6d7      	b.n	800fa82 <xmp3fixpt_DecodeHuffman+0x442>
					while (cachedBits < minBits) {
 800fcd2:	468e      	mov	lr, r1
 800fcd4:	e70a      	b.n	800faec <xmp3fixpt_DecodeHuffman+0x4ac>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800fcd6:	18bc      	adds	r4, r7, r2
 800fcd8:	2c00      	cmp	r4, #0
 800fcda:	f77f af6a 	ble.w	800fbb2 <xmp3fixpt_DecodeHuffman+0x572>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800fcde:	2f00      	cmp	r7, #0
 800fce0:	dd05      	ble.n	800fcee <xmp3fixpt_DecodeHuffman+0x6ae>
 800fce2:	f1c2 0518 	rsb	r5, r2, #24
 800fce6:	f811 0b01 	ldrb.w	r0, [r1], #1
 800fcea:	40a8      	lsls	r0, r5
 800fcec:	4303      	orrs	r3, r0
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800fcee:	2f08      	cmp	r7, #8
 800fcf0:	dd05      	ble.n	800fcfe <xmp3fixpt_DecodeHuffman+0x6be>
 800fcf2:	f1c2 0010 	rsb	r0, r2, #16
 800fcf6:	f811 2b01 	ldrb.w	r2, [r1], #1
 800fcfa:	4082      	lsls	r2, r0
 800fcfc:	4313      	orrs	r3, r2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fcfe:	1e60      	subs	r0, r4, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800fd00:	f104 020b 	add.w	r2, r4, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fd04:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
				padBits = 11;
 800fd08:	f04f 090b 	mov.w	r9, #11
				bitsLeft = 0;
 800fd0c:	2700      	movs	r7, #0
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800fd0e:	fa44 f000 	asr.w	r0, r4, r0
 800fd12:	4003      	ands	r3, r0
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800fd14:	e712      	b.n	800fb3c <xmp3fixpt_DecodeHuffman+0x4fc>
 800fd16:	461f      	mov	r7, r3
 800fd18:	e654      	b.n	800f9c4 <xmp3fixpt_DecodeHuffman+0x384>
		for (i = 0; i < nVals; i+=2) {
 800fd1a:	2300      	movs	r3, #0
 800fd1c:	f10c 0204 	add.w	r2, ip, #4
			xy[i+0] = 0;
 800fd20:	2100      	movs	r1, #0
 800fd22:	f84c 1023 	str.w	r1, [ip, r3, lsl #2]
			xy[i+1] = 0;
 800fd26:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (i = 0; i < nVals; i+=2) {
 800fd2a:	3302      	adds	r3, #2
 800fd2c:	429e      	cmp	r6, r3
 800fd2e:	dcf7      	bgt.n	800fd20 <xmp3fixpt_DecodeHuffman+0x6e0>
		buf += (bitsUsed + *bitOffset) >> 3;
 800fd30:	9b08      	ldr	r3, [sp, #32]
 800fd32:	681a      	ldr	r2, [r3, #0]
 800fd34:	e5ac      	b.n	800f890 <xmp3fixpt_DecodeHuffman+0x250>
		while (nVals > 0) {
 800fd36:	2e00      	cmp	r6, #0
 800fd38:	4671      	mov	r1, lr
 800fd3a:	f73f aeef 	bgt.w	800fb1c <xmp3fixpt_DecodeHuffman+0x4dc>
		bitsLeft += (cachedBits - padBits);
 800fd3e:	eba2 0209 	sub.w	r2, r2, r9
		return (startBits - bitsLeft);
 800fd42:	9b06      	ldr	r3, [sp, #24]
		bitsLeft += (cachedBits - padBits);
 800fd44:	443a      	add	r2, r7
		return (startBits - bitsLeft);
 800fd46:	1a9b      	subs	r3, r3, r2
 800fd48:	e59a      	b.n	800f880 <xmp3fixpt_DecodeHuffman+0x240>
			if (fh->ver == MPEG1) {
 800fd4a:	780b      	ldrb	r3, [r1, #0]
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800fd4c:	6b4a      	ldr	r2, [r1, #52]	; 0x34
			if (fh->ver == MPEG1) {
 800fd4e:	b98b      	cbnz	r3, 800fd74 <xmp3fixpt_DecodeHuffman+0x734>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800fd50:	9920      	ldr	r1, [sp, #128]	; 0x80
 800fd52:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fd54:	9821      	ldr	r0, [sp, #132]	; 0x84
 800fd56:	440b      	add	r3, r1
 800fd58:	990c      	ldr	r1, [sp, #48]	; 0x30
 800fd5a:	011b      	lsls	r3, r3, #4
 800fd5c:	4401      	add	r1, r0
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800fd5e:	f44f 7010 	mov.w	r0, #576	; 0x240
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800fd62:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800fd66:	9909      	ldr	r1, [sp, #36]	; 0x24
 800fd68:	440b      	add	r3, r1
 800fd6a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800fd6c:	3301      	adds	r3, #1
 800fd6e:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800fd72:	e4ad      	b.n	800f6d0 <xmp3fixpt_DecodeHuffman+0x90>
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800fd74:	f9b2 1034 	ldrsh.w	r1, [r2, #52]	; 0x34
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800fd78:	f44f 7010 	mov.w	r0, #576	; 0x240
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800fd7c:	f9b2 3036 	ldrsh.w	r3, [r2, #54]	; 0x36
 800fd80:	1a5b      	subs	r3, r3, r1
				r1Start = fh->sfBand->l[6] + 2*w;
 800fd82:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
 800fd86:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800fd8a:	e4a1      	b.n	800f6d0 <xmp3fixpt_DecodeHuffman+0x90>
		return 0;
 800fd8c:	2700      	movs	r7, #0
 800fd8e:	e619      	b.n	800f9c4 <xmp3fixpt_DecodeHuffman+0x384>
 800fd90:	08022f64 	.word	0x08022f64

0800fd94 <WinPrevious.part.0>:
	xp = xPrev;
	/* mapping (see IMDCT12x3): xPrev[0-2] = sum[6-8], xPrev[3-8] = sum[12-17] */
	if (btPrev == 2) {
		/* this could be reordered for minimum loads/stores */
		wpLo = imdctWin[btPrev];
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800fd94:	4b37      	ldr	r3, [pc, #220]	; (800fe74 <WinPrevious.part.0+0xe0>)
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800fd96:	6882      	ldr	r2, [r0, #8]
static void WinPrevious(int *xPrev, int *xPrevWin, int btPrev)
 800fd98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800fd9c:	f8d3 7138 	ldr.w	r7, [r3, #312]	; 0x138
 800fda0:	fb87 4202 	smull	r4, r2, r7, r2
 800fda4:	6984      	ldr	r4, [r0, #24]
 800fda6:	f8d3 5120 	ldr.w	r5, [r3, #288]	; 0x120
 800fdaa:	fb85 6404 	smull	r6, r4, r5, r4
 800fdae:	4422      	add	r2, r4
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800fdb0:	f8d3 613c 	ldr.w	r6, [r3, #316]	; 0x13c
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800fdb4:	600a      	str	r2, [r1, #0]
 800fdb6:	6842      	ldr	r2, [r0, #4]
 800fdb8:	fb86 4202 	smull	r4, r2, r6, r2
 800fdbc:	69c4      	ldr	r4, [r0, #28]
 800fdbe:	f8d3 5124 	ldr.w	r5, [r3, #292]	; 0x124
 800fdc2:	fb85 c404 	smull	ip, r4, r5, r4
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800fdc6:	4422      	add	r2, r4
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800fdc8:	f8d3 5140 	ldr.w	r5, [r3, #320]	; 0x140
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800fdcc:	604a      	str	r2, [r1, #4]
 800fdce:	6802      	ldr	r2, [r0, #0]
 800fdd0:	fb85 4202 	smull	r4, r2, r5, r2
 800fdd4:	6a04      	ldr	r4, [r0, #32]
 800fdd6:	46a4      	mov	ip, r4
 800fdd8:	f8d3 4128 	ldr.w	r4, [r3, #296]	; 0x128
 800fddc:	fb84 ec0c 	smull	lr, ip, r4, ip
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800fde0:	4462      	add	r2, ip
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800fde2:	f8d3 a144 	ldr.w	sl, [r3, #324]	; 0x144
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800fde6:	608a      	str	r2, [r1, #8]
 800fde8:	6802      	ldr	r2, [r0, #0]
 800fdea:	4694      	mov	ip, r2
 800fdec:	fb8a 2c0c 	smull	r2, ip, sl, ip
 800fdf0:	6a02      	ldr	r2, [r0, #32]
 800fdf2:	f8d3 412c 	ldr.w	r4, [r3, #300]	; 0x12c
 800fdf6:	fb84 e202 	smull	lr, r2, r4, r2
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800fdfa:	4462      	add	r2, ip
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800fdfc:	f8d3 c148 	ldr.w	ip, [r3, #328]	; 0x148
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800fe00:	60ca      	str	r2, [r1, #12]
 800fe02:	6842      	ldr	r2, [r0, #4]
 800fe04:	fb8c e202 	smull	lr, r2, ip, r2
 800fe08:	f8d0 e01c 	ldr.w	lr, [r0, #28]
 800fe0c:	f8d3 4130 	ldr.w	r4, [r3, #304]	; 0x130
 800fe10:	fb84 8e0e 	smull	r8, lr, r4, lr
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800fe14:	4472      	add	r2, lr
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 800fe16:	f8d3 e14c 	ldr.w	lr, [r3, #332]	; 0x14c
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800fe1a:	610a      	str	r2, [r1, #16]
 800fe1c:	6882      	ldr	r2, [r0, #8]
 800fe1e:	fb8e 8202 	smull	r8, r2, lr, r2
 800fe22:	f8d3 8134 	ldr.w	r8, [r3, #308]	; 0x134
 800fe26:	6983      	ldr	r3, [r0, #24]
 800fe28:	fb88 9303 	smull	r9, r3, r8, r3
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 800fe2c:	441a      	add	r2, r3
 800fe2e:	614a      	str	r2, [r1, #20]
 800fe30:	6943      	ldr	r3, [r0, #20]
 800fe32:	fb87 2303 	smull	r2, r3, r7, r3
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 800fe36:	618b      	str	r3, [r1, #24]
 800fe38:	6903      	ldr	r3, [r0, #16]
 800fe3a:	fb86 2303 	smull	r2, r3, r6, r3
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 800fe3e:	61cb      	str	r3, [r1, #28]
 800fe40:	68c3      	ldr	r3, [r0, #12]
 800fe42:	fb85 2303 	smull	r2, r3, r5, r3
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 800fe46:	620b      	str	r3, [r1, #32]
 800fe48:	68c3      	ldr	r3, [r0, #12]
 800fe4a:	fb8a 2303 	smull	r2, r3, sl, r3
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 800fe4e:	624b      	str	r3, [r1, #36]	; 0x24
 800fe50:	6903      	ldr	r3, [r0, #16]
 800fe52:	fb8c 2303 	smull	r2, r3, ip, r3
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 800fe56:	628b      	str	r3, [r1, #40]	; 0x28
 800fe58:	6942      	ldr	r2, [r0, #20]
 800fe5a:	fb8e 3202 	smull	r3, r2, lr, r2
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800fe5e:	2300      	movs	r3, #0
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 800fe60:	62ca      	str	r2, [r1, #44]	; 0x2c
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800fe62:	e9c1 3310 	strd	r3, r3, [r1, #64]	; 0x40
 800fe66:	e9c1 330e 	strd	r3, r3, [r1, #56]	; 0x38
 800fe6a:	e9c1 330c 	strd	r3, r3, [r1, #48]	; 0x30
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
			*xpwLo++ = MULSHIFT32(wLo, x);
			*xpwHi-- = MULSHIFT32(wHi, x);
		}
	}
}
 800fe6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fe72:	bf00      	nop
 800fe74:	080252fc 	.word	0x080252fc

0800fe78 <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 800fe78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fe7c:	b08b      	sub	sp, #44	; 0x2c
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
 800fe7e:	bba3      	cbnz	r3, 800feea <FreqInvertRescale+0x72>
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 800fe80:	f012 0e01 	ands.w	lr, r2, #1
 800fe84:	d02d      	beq.n	800fee2 <FreqInvertRescale+0x6a>
			y += NBANDS;
			y0 = *y;	y += 2*NBANDS;
			y1 = *y;	y += 2*NBANDS;
			y2 = *y;	y += 2*NBANDS;
 800fe86:	f8d0 1280 	ldr.w	r1, [r0, #640]	; 0x280
			*y = -y5;	y += 2*NBANDS;
			*y = -y6;	y += 2*NBANDS;
			*y = -y7;	y += 2*NBANDS;
			*y = -y8;	y += 2*NBANDS;
		}
		return 0;
 800fe8a:	469e      	mov	lr, r3
			y3 = *y;	y += 2*NBANDS;
 800fe8c:	f8d0 2380 	ldr.w	r2, [r0, #896]	; 0x380
			*y = -y2;	y += 2*NBANDS;
 800fe90:	4249      	negs	r1, r1
			y6 = *y;	y += 2*NBANDS;
 800fe92:	f8d0 3680 	ldr.w	r3, [r0, #1664]	; 0x680
			*y = -y3;	y += 2*NBANDS;
 800fe96:	4252      	negs	r2, r2
			y1 = *y;	y += 2*NBANDS;
 800fe98:	f8d0 4180 	ldr.w	r4, [r0, #384]	; 0x180
			*y = -y2;	y += 2*NBANDS;
 800fe9c:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
			*y = -y6;	y += 2*NBANDS;
 800fea0:	425b      	negs	r3, r3
			y4 = *y;	y += 2*NBANDS;
 800fea2:	f8d0 1480 	ldr.w	r1, [r0, #1152]	; 0x480
			*y = -y1;	y += 2*NBANDS;
 800fea6:	4264      	negs	r4, r4
			*y = -y3;	y += 2*NBANDS;
 800fea8:	f8c0 2380 	str.w	r2, [r0, #896]	; 0x380
			y5 = *y;	y += 2*NBANDS;
 800feac:	f8d0 2580 	ldr.w	r2, [r0, #1408]	; 0x580
			*y = -y4;	y += 2*NBANDS;
 800feb0:	4249      	negs	r1, r1
			*y = -y6;	y += 2*NBANDS;
 800feb2:	f8c0 3680 	str.w	r3, [r0, #1664]	; 0x680
			*y = -y5;	y += 2*NBANDS;
 800feb6:	4252      	negs	r2, r2
			y8 = *y;	y += 2*NBANDS;
 800feb8:	f8d0 3880 	ldr.w	r3, [r0, #2176]	; 0x880
			*y = -y4;	y += 2*NBANDS;
 800febc:	f8c0 1480 	str.w	r1, [r0, #1152]	; 0x480
			*y = -y5;	y += 2*NBANDS;
 800fec0:	f8c0 2580 	str.w	r2, [r0, #1408]	; 0x580
			*y = -y8;	y += 2*NBANDS;
 800fec4:	425b      	negs	r3, r3
			y7 = *y;	y += 2*NBANDS;
 800fec6:	f8d0 1780 	ldr.w	r1, [r0, #1920]	; 0x780
			*y = -y0;	y += 2*NBANDS;
 800feca:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
			*y = -y7;	y += 2*NBANDS;
 800fece:	4249      	negs	r1, r1
			*y = -y1;	y += 2*NBANDS;
 800fed0:	f8c0 4180 	str.w	r4, [r0, #384]	; 0x180
			*y = -y0;	y += 2*NBANDS;
 800fed4:	4252      	negs	r2, r2
			*y = -y8;	y += 2*NBANDS;
 800fed6:	f8c0 3880 	str.w	r3, [r0, #2176]	; 0x880
			*y = -y7;	y += 2*NBANDS;
 800feda:	f8c0 1780 	str.w	r1, [r0, #1920]	; 0x780
			*y = -y0;	y += 2*NBANDS;
 800fede:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		}
		return mOut;
	}
}
 800fee2:	4670      	mov	r0, lr
 800fee4:	b00b      	add	sp, #44	; 0x2c
 800fee6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (blockIdx & 0x01) {
 800feea:	07d2      	lsls	r2, r2, #31
 800feec:	d54b      	bpl.n	800ff86 <FreqInvertRescale+0x10e>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800feee:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
		mOut = 0;
 800fef2:	f04f 0e00 	mov.w	lr, #0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fef6:	f1c3 061f 	rsb	r6, r3, #31
 800fefa:	f100 0580 	add.w	r5, r0, #128	; 0x80
 800fefe:	40df      	lsrs	r7, r3
 800ff00:	f500 6810 	add.w	r8, r0, #2304	; 0x900
	__asm__ volatile (
 800ff04:	46f4      	mov	ip, lr
 800ff06:	3f01      	subs	r7, #1
 800ff08:	f855 2c80 	ldr.w	r2, [r5, #-128]
 800ff0c:	4664      	mov	r4, ip
 800ff0e:	fa42 f906 	asr.w	r9, r2, r6
 800ff12:	ea4f 7ae2 	mov.w	sl, r2, asr #31
 800ff16:	ebb9 7fe2 	cmp.w	r9, r2, asr #31
 800ff1a:	bf18      	it	ne
 800ff1c:	ea8a 0207 	eorne.w	r2, sl, r7
 800ff20:	409a      	lsls	r2, r3
 800ff22:	f845 2c80 	str.w	r2, [r5, #-128]
 800ff26:	ea82 74e2 	eor.w	r4, r2, r2, asr #31
 800ff2a:	eba4 74e2 	sub.w	r4, r4, r2, asr #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ff2e:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 800ff32:	46e1      	mov	r9, ip
 800ff34:	4252      	negs	r2, r2
 800ff36:	fa42 fa06 	asr.w	sl, r2, r6
 800ff3a:	ea4f 7be2 	mov.w	fp, r2, asr #31
 800ff3e:	ebba 7fe2 	cmp.w	sl, r2, asr #31
 800ff42:	bf18      	it	ne
 800ff44:	ea87 020b 	eorne.w	r2, r7, fp
 800ff48:	409a      	lsls	r2, r3
 800ff4a:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 800ff4e:	ea82 79e2 	eor.w	r9, r2, r2, asr #31
 800ff52:	eba9 79e2 	sub.w	r9, r9, r2, asr #31
 800ff56:	ea44 0409 	orr.w	r4, r4, r9
 800ff5a:	f500 7080 	add.w	r0, r0, #256	; 0x100
 800ff5e:	ea4e 0e04 	orr.w	lr, lr, r4
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ff62:	680c      	ldr	r4, [r1, #0]
 800ff64:	17e2      	asrs	r2, r4, #31
 800ff66:	fa44 f906 	asr.w	r9, r4, r6
 800ff6a:	407a      	eors	r2, r7
 800ff6c:	ebb9 7fe4 	cmp.w	r9, r4, asr #31
 800ff70:	fa02 f203 	lsl.w	r2, r2, r3
 800ff74:	f000 81f6 	beq.w	8010364 <FreqInvertRescale+0x4ec>
			for (i = 0; i < 18; i+=2) {
 800ff78:	4540      	cmp	r0, r8
 800ff7a:	f505 7580 	add.w	r5, r5, #256	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ff7e:	f841 2b04 	str.w	r2, [r1], #4
			for (i = 0; i < 18; i+=2) {
 800ff82:	d1c1      	bne.n	800ff08 <FreqInvertRescale+0x90>
 800ff84:	e7ad      	b.n	800fee2 <FreqInvertRescale+0x6a>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ff86:	6804      	ldr	r4, [r0, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ff88:	f1c3 021f 	rsb	r2, r3, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ff8c:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800ff90:	fa44 f502 	asr.w	r5, r4, r2
 800ff94:	17e6      	asrs	r6, r4, #31
 800ff96:	fa2c fc03 	lsr.w	ip, ip, r3
 800ff9a:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 800ff9e:	f10c 3cff 	add.w	ip, ip, #4294967295
 800ffa2:	bf18      	it	ne
 800ffa4:	ea8c 0406 	eorne.w	r4, ip, r6
 800ffa8:	2600      	movs	r6, #0
 800ffaa:	409c      	lsls	r4, r3
 800ffac:	6004      	str	r4, [r0, #0]
 800ffae:	ea84 76e4 	eor.w	r6, r4, r4, asr #31
 800ffb2:	eba6 76e4 	sub.w	r6, r6, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ffb6:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 800ffba:	fa45 f402 	asr.w	r4, r5, r2
 800ffbe:	17ef      	asrs	r7, r5, #31
 800ffc0:	ebb4 7fe5 	cmp.w	r4, r5, asr #31
 800ffc4:	f04f 0400 	mov.w	r4, #0
 800ffc8:	bf18      	it	ne
 800ffca:	ea8c 0507 	eorne.w	r5, ip, r7
 800ffce:	409d      	lsls	r5, r3
 800ffd0:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
 800ffd4:	ea85 74e5 	eor.w	r4, r5, r5, asr #31
 800ffd8:	eba4 74e5 	sub.w	r4, r4, r5, asr #31
 800ffdc:	4334      	orrs	r4, r6
 800ffde:	9400      	str	r4, [sp, #0]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ffe0:	680c      	ldr	r4, [r1, #0]
 800ffe2:	fa44 f502 	asr.w	r5, r4, r2
 800ffe6:	17e6      	asrs	r6, r4, #31
 800ffe8:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 800ffec:	bf18      	it	ne
 800ffee:	ea86 040c 	eorne.w	r4, r6, ip
 800fff2:	409c      	lsls	r4, r3
 800fff4:	600c      	str	r4, [r1, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fff6:	f8d0 4100 	ldr.w	r4, [r0, #256]	; 0x100
 800fffa:	fa44 f502 	asr.w	r5, r4, r2
 800fffe:	17e6      	asrs	r6, r4, #31
 8010000:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010004:	f04f 0500 	mov.w	r5, #0
 8010008:	bf18      	it	ne
 801000a:	ea8c 0406 	eorne.w	r4, ip, r6
 801000e:	409c      	lsls	r4, r3
 8010010:	f8c0 4100 	str.w	r4, [r0, #256]	; 0x100
 8010014:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 8010018:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801001c:	f8d0 4180 	ldr.w	r4, [r0, #384]	; 0x180
 8010020:	9501      	str	r5, [sp, #4]
 8010022:	fa44 f502 	asr.w	r5, r4, r2
 8010026:	17e6      	asrs	r6, r4, #31
 8010028:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 801002c:	f04f 0500 	mov.w	r5, #0
 8010030:	bf18      	it	ne
 8010032:	ea8c 0406 	eorne.w	r4, ip, r6
 8010036:	409c      	lsls	r4, r3
 8010038:	f8c0 4180 	str.w	r4, [r0, #384]	; 0x180
 801003c:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 8010040:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8010044:	684c      	ldr	r4, [r1, #4]
 8010046:	9502      	str	r5, [sp, #8]
 8010048:	fa44 f502 	asr.w	r5, r4, r2
 801004c:	17e6      	asrs	r6, r4, #31
 801004e:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010052:	bf18      	it	ne
 8010054:	ea8c 0406 	eorne.w	r4, ip, r6
 8010058:	409c      	lsls	r4, r3
 801005a:	604c      	str	r4, [r1, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801005c:	f8d0 4200 	ldr.w	r4, [r0, #512]	; 0x200
 8010060:	fa44 f502 	asr.w	r5, r4, r2
 8010064:	17e6      	asrs	r6, r4, #31
 8010066:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 801006a:	f04f 0500 	mov.w	r5, #0
 801006e:	bf18      	it	ne
 8010070:	ea8c 0406 	eorne.w	r4, ip, r6
 8010074:	409c      	lsls	r4, r3
 8010076:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 801007a:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 801007e:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010082:	f8d0 4280 	ldr.w	r4, [r0, #640]	; 0x280
 8010086:	9503      	str	r5, [sp, #12]
 8010088:	fa44 f502 	asr.w	r5, r4, r2
 801008c:	17e6      	asrs	r6, r4, #31
 801008e:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010092:	f04f 0500 	mov.w	r5, #0
 8010096:	bf18      	it	ne
 8010098:	ea8c 0406 	eorne.w	r4, ip, r6
 801009c:	409c      	lsls	r4, r3
 801009e:	f8c0 4280 	str.w	r4, [r0, #640]	; 0x280
 80100a2:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 80100a6:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 80100aa:	688c      	ldr	r4, [r1, #8]
 80100ac:	9504      	str	r5, [sp, #16]
 80100ae:	fa44 f502 	asr.w	r5, r4, r2
 80100b2:	17e6      	asrs	r6, r4, #31
 80100b4:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80100b8:	bf18      	it	ne
 80100ba:	ea8c 0406 	eorne.w	r4, ip, r6
 80100be:	409c      	lsls	r4, r3
 80100c0:	608c      	str	r4, [r1, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80100c2:	f8d0 4300 	ldr.w	r4, [r0, #768]	; 0x300
 80100c6:	fa44 f502 	asr.w	r5, r4, r2
 80100ca:	17e6      	asrs	r6, r4, #31
 80100cc:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80100d0:	f04f 0500 	mov.w	r5, #0
 80100d4:	bf18      	it	ne
 80100d6:	ea8c 0406 	eorne.w	r4, ip, r6
 80100da:	409c      	lsls	r4, r3
 80100dc:	f8c0 4300 	str.w	r4, [r0, #768]	; 0x300
 80100e0:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 80100e4:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80100e8:	f8d0 4380 	ldr.w	r4, [r0, #896]	; 0x380
 80100ec:	9505      	str	r5, [sp, #20]
 80100ee:	fa44 f502 	asr.w	r5, r4, r2
 80100f2:	17e6      	asrs	r6, r4, #31
 80100f4:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80100f8:	f04f 0500 	mov.w	r5, #0
 80100fc:	bf18      	it	ne
 80100fe:	ea8c 0406 	eorne.w	r4, ip, r6
 8010102:	409c      	lsls	r4, r3
 8010104:	f8c0 4380 	str.w	r4, [r0, #896]	; 0x380
 8010108:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 801010c:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8010110:	68cc      	ldr	r4, [r1, #12]
 8010112:	9506      	str	r5, [sp, #24]
 8010114:	fa44 f502 	asr.w	r5, r4, r2
 8010118:	17e6      	asrs	r6, r4, #31
 801011a:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 801011e:	bf18      	it	ne
 8010120:	ea8c 0406 	eorne.w	r4, ip, r6
 8010124:	409c      	lsls	r4, r3
 8010126:	60cc      	str	r4, [r1, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010128:	f8d0 4400 	ldr.w	r4, [r0, #1024]	; 0x400
 801012c:	fa44 f502 	asr.w	r5, r4, r2
 8010130:	17e6      	asrs	r6, r4, #31
 8010132:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010136:	f04f 0500 	mov.w	r5, #0
 801013a:	bf18      	it	ne
 801013c:	ea8c 0406 	eorne.w	r4, ip, r6
 8010140:	409c      	lsls	r4, r3
 8010142:	f8c0 4400 	str.w	r4, [r0, #1024]	; 0x400
 8010146:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 801014a:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801014e:	f8d0 4480 	ldr.w	r4, [r0, #1152]	; 0x480
 8010152:	9507      	str	r5, [sp, #28]
 8010154:	fa44 f502 	asr.w	r5, r4, r2
 8010158:	17e6      	asrs	r6, r4, #31
 801015a:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 801015e:	f04f 0500 	mov.w	r5, #0
 8010162:	bf18      	it	ne
 8010164:	ea8c 0406 	eorne.w	r4, ip, r6
 8010168:	409c      	lsls	r4, r3
 801016a:	f8c0 4480 	str.w	r4, [r0, #1152]	; 0x480
 801016e:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 8010172:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8010176:	690c      	ldr	r4, [r1, #16]
 8010178:	f04f 0900 	mov.w	r9, #0
 801017c:	9508      	str	r5, [sp, #32]
 801017e:	fa44 f502 	asr.w	r5, r4, r2
 8010182:	17e6      	asrs	r6, r4, #31
 8010184:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010188:	bf18      	it	ne
 801018a:	ea8c 0406 	eorne.w	r4, ip, r6
 801018e:	409c      	lsls	r4, r3
 8010190:	610c      	str	r4, [r1, #16]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010192:	f8d0 4500 	ldr.w	r4, [r0, #1280]	; 0x500
 8010196:	fa44 f502 	asr.w	r5, r4, r2
 801019a:	17e6      	asrs	r6, r4, #31
 801019c:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80101a0:	bf18      	it	ne
 80101a2:	ea8c 0406 	eorne.w	r4, ip, r6
 80101a6:	409c      	lsls	r4, r3
 80101a8:	f8c0 4500 	str.w	r4, [r0, #1280]	; 0x500
 80101ac:	ea84 79e4 	eor.w	r9, r4, r4, asr #31
 80101b0:	eba9 79e4 	sub.w	r9, r9, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80101b4:	f8d0 4580 	ldr.w	r4, [r0, #1408]	; 0x580
 80101b8:	fa44 f502 	asr.w	r5, r4, r2
 80101bc:	17e6      	asrs	r6, r4, #31
 80101be:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80101c2:	f04f 0500 	mov.w	r5, #0
 80101c6:	bf18      	it	ne
 80101c8:	ea8c 0406 	eorne.w	r4, ip, r6
 80101cc:	46ab      	mov	fp, r5
 80101ce:	409c      	lsls	r4, r3
 80101d0:	f8c0 4580 	str.w	r4, [r0, #1408]	; 0x580
 80101d4:	ea84 7be4 	eor.w	fp, r4, r4, asr #31
 80101d8:	ebab 7be4 	sub.w	fp, fp, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 80101dc:	694c      	ldr	r4, [r1, #20]
 80101de:	f04f 0800 	mov.w	r8, #0
 80101e2:	fa44 f502 	asr.w	r5, r4, r2
 80101e6:	17e6      	asrs	r6, r4, #31
 80101e8:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 80101ec:	bf18      	it	ne
 80101ee:	ea8c 0406 	eorne.w	r4, ip, r6
 80101f2:	409c      	lsls	r4, r3
 80101f4:	614c      	str	r4, [r1, #20]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80101f6:	f8d0 4600 	ldr.w	r4, [r0, #1536]	; 0x600
 80101fa:	fa44 f502 	asr.w	r5, r4, r2
 80101fe:	17e6      	asrs	r6, r4, #31
 8010200:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010204:	bf18      	it	ne
 8010206:	ea8c 0406 	eorne.w	r4, ip, r6
 801020a:	409c      	lsls	r4, r3
 801020c:	f8c0 4600 	str.w	r4, [r0, #1536]	; 0x600
 8010210:	ea84 78e4 	eor.w	r8, r4, r4, asr #31
 8010214:	eba8 78e4 	sub.w	r8, r8, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010218:	f8d0 4680 	ldr.w	r4, [r0, #1664]	; 0x680
 801021c:	2700      	movs	r7, #0
 801021e:	fa44 f502 	asr.w	r5, r4, r2
 8010222:	17e6      	asrs	r6, r4, #31
 8010224:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010228:	bf18      	it	ne
 801022a:	ea8c 0406 	eorne.w	r4, ip, r6
 801022e:	409c      	lsls	r4, r3
 8010230:	f8c0 4680 	str.w	r4, [r0, #1664]	; 0x680
 8010234:	ea84 77e4 	eor.w	r7, r4, r4, asr #31
 8010238:	eba7 77e4 	sub.w	r7, r7, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801023c:	698c      	ldr	r4, [r1, #24]
 801023e:	fa44 f502 	asr.w	r5, r4, r2
 8010242:	17e6      	asrs	r6, r4, #31
 8010244:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010248:	bf18      	it	ne
 801024a:	ea8c 0406 	eorne.w	r4, ip, r6
 801024e:	409c      	lsls	r4, r3
 8010250:	618c      	str	r4, [r1, #24]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010252:	f8d0 4700 	ldr.w	r4, [r0, #1792]	; 0x700
 8010256:	fa44 f502 	asr.w	r5, r4, r2
 801025a:	17e6      	asrs	r6, r4, #31
 801025c:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010260:	bf18      	it	ne
 8010262:	ea8c 0406 	eorne.w	r4, ip, r6
 8010266:	2600      	movs	r6, #0
 8010268:	409c      	lsls	r4, r3
 801026a:	f8c0 4700 	str.w	r4, [r0, #1792]	; 0x700
 801026e:	ea84 76e4 	eor.w	r6, r4, r4, asr #31
 8010272:	eba6 76e4 	sub.w	r6, r6, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8010276:	f8d0 4780 	ldr.w	r4, [r0, #1920]	; 0x780
 801027a:	fa44 f502 	asr.w	r5, r4, r2
 801027e:	ea4f 7ee4 	mov.w	lr, r4, asr #31
 8010282:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 8010286:	f04f 0500 	mov.w	r5, #0
 801028a:	bf18      	it	ne
 801028c:	ea8c 040e 	eorne.w	r4, ip, lr
 8010290:	409c      	lsls	r4, r3
 8010292:	f8c0 4780 	str.w	r4, [r0, #1920]	; 0x780
 8010296:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 801029a:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801029e:	69cc      	ldr	r4, [r1, #28]
 80102a0:	9509      	str	r5, [sp, #36]	; 0x24
 80102a2:	fa44 fe02 	asr.w	lr, r4, r2
 80102a6:	ea4f 7ae4 	mov.w	sl, r4, asr #31
 80102aa:	ebbe 7fe4 	cmp.w	lr, r4, asr #31
 80102ae:	bf18      	it	ne
 80102b0:	ea8c 040a 	eorne.w	r4, ip, sl
 80102b4:	409c      	lsls	r4, r3
 80102b6:	61cc      	str	r4, [r1, #28]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80102b8:	f8d0 4800 	ldr.w	r4, [r0, #2048]	; 0x800
 80102bc:	fa44 fe02 	asr.w	lr, r4, r2
 80102c0:	ea4f 7ae4 	mov.w	sl, r4, asr #31
 80102c4:	ebbe 7fe4 	cmp.w	lr, r4, asr #31
 80102c8:	f04f 0e00 	mov.w	lr, #0
 80102cc:	bf18      	it	ne
 80102ce:	ea8a 040c 	eorne.w	r4, sl, ip
 80102d2:	409c      	lsls	r4, r3
 80102d4:	f8c0 4800 	str.w	r4, [r0, #2048]	; 0x800
 80102d8:	ea84 7ee4 	eor.w	lr, r4, r4, asr #31
 80102dc:	ebae 7ee4 	sub.w	lr, lr, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80102e0:	f8d0 4880 	ldr.w	r4, [r0, #2176]	; 0x880
 80102e4:	fa44 fa02 	asr.w	sl, r4, r2
 80102e8:	17e5      	asrs	r5, r4, #31
 80102ea:	ebba 7fe4 	cmp.w	sl, r4, asr #31
 80102ee:	bf18      	it	ne
 80102f0:	ea8c 0405 	eorne.w	r4, ip, r5
 80102f4:	409c      	lsls	r4, r3
 80102f6:	f8c0 4880 	str.w	r4, [r0, #2176]	; 0x880
 80102fa:	2000      	movs	r0, #0
 80102fc:	ea84 70e4 	eor.w	r0, r4, r4, asr #31
 8010300:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
 8010304:	e9dd 4500 	ldrd	r4, r5, [sp]
 8010308:	432c      	orrs	r4, r5
 801030a:	9d02      	ldr	r5, [sp, #8]
 801030c:	432c      	orrs	r4, r5
 801030e:	9d03      	ldr	r5, [sp, #12]
 8010310:	432c      	orrs	r4, r5
 8010312:	9d04      	ldr	r5, [sp, #16]
 8010314:	432c      	orrs	r4, r5
 8010316:	9d05      	ldr	r5, [sp, #20]
 8010318:	432c      	orrs	r4, r5
 801031a:	9d06      	ldr	r5, [sp, #24]
 801031c:	432c      	orrs	r4, r5
 801031e:	9d07      	ldr	r5, [sp, #28]
 8010320:	432c      	orrs	r4, r5
 8010322:	9d08      	ldr	r5, [sp, #32]
 8010324:	432c      	orrs	r4, r5
 8010326:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8010328:	ea44 0909 	orr.w	r9, r4, r9
 801032c:	ea49 090b 	orr.w	r9, r9, fp
 8010330:	ea49 0808 	orr.w	r8, r9, r8
 8010334:	ea48 0707 	orr.w	r7, r8, r7
 8010338:	433e      	orrs	r6, r7
 801033a:	4335      	orrs	r5, r6
 801033c:	ea45 0e0e 	orr.w	lr, r5, lr
 8010340:	ea4e 0e00 	orr.w	lr, lr, r0
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8010344:	6a08      	ldr	r0, [r1, #32]
 8010346:	fa40 f202 	asr.w	r2, r0, r2
 801034a:	17c4      	asrs	r4, r0, #31
 801034c:	ebb2 7fe0 	cmp.w	r2, r0, asr #31
 8010350:	bf18      	it	ne
 8010352:	ea8c 0004 	eorne.w	r0, ip, r4
 8010356:	fa00 f303 	lsl.w	r3, r0, r3
}
 801035a:	4670      	mov	r0, lr
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801035c:	620b      	str	r3, [r1, #32]
}
 801035e:	b00b      	add	sp, #44	; 0x2c
 8010360:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 8010364:	409c      	lsls	r4, r3
			for (i = 0; i < 18; i+=2) {
 8010366:	4540      	cmp	r0, r8
 8010368:	f505 7580 	add.w	r5, r5, #256	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801036c:	f841 4b04 	str.w	r4, [r1], #4
			for (i = 0; i < 18; i+=2) {
 8010370:	f47f adca 	bne.w	800ff08 <FreqInvertRescale+0x90>
 8010374:	e5b5      	b.n	800fee2 <FreqInvertRescale+0x6a>
 8010376:	bf00      	nop

08010378 <xmp3fixpt_IMDCT>:
 *              updated hi->nonZeroBound index for this channel
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 8010378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801037c:	b0df      	sub	sp, #380	; 0x17c
 801037e:	9136      	str	r1, [sp, #216]	; 0xd8
 8010380:	9233      	str	r2, [sp, #204]	; 0xcc
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 8010382:	2800      	cmp	r0, #0
 8010384:	f002 8040 	beq.w	8012408 <xmp3fixpt_IMDCT+0x2090>
 8010388:	6803      	ldr	r3, [r0, #0]
 801038a:	2b00      	cmp	r3, #0
 801038c:	f002 803c 	beq.w	8012408 <xmp3fixpt_IMDCT+0x2090>
 8010390:	6844      	ldr	r4, [r0, #4]
 8010392:	9435      	str	r4, [sp, #212]	; 0xd4
 8010394:	2c00      	cmp	r4, #0
 8010396:	f002 8037 	beq.w	8012408 <xmp3fixpt_IMDCT+0x2090>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 801039a:	68c5      	ldr	r5, [r0, #12]
 801039c:	950c      	str	r5, [sp, #48]	; 0x30
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 801039e:	2d00      	cmp	r5, #0
 80103a0:	f002 8032 	beq.w	8012408 <xmp3fixpt_IMDCT+0x2090>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 80103a4:	6940      	ldr	r0, [r0, #20]
 80103a6:	900d      	str	r0, [sp, #52]	; 0x34
 80103a8:	2800      	cmp	r0, #0
 80103aa:	f002 802d 	beq.w	8012408 <xmp3fixpt_IMDCT+0x2090>
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103ae:	4616      	mov	r6, r2
 80103b0:	781a      	ldrb	r2, [r3, #0]
 80103b2:	460f      	mov	r7, r1
 80103b4:	48c6      	ldr	r0, [pc, #792]	; (80106d0 <xmp3fixpt_IMDCT+0x358>)
 80103b6:	2a00      	cmp	r2, #0
 80103b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	if (si->sis[gr][ch].blockType != 2) {
 80103ba:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103be:	bf0c      	ite	eq
 80103c0:	2108      	moveq	r1, #8
 80103c2:	2106      	movne	r1, #6
	if (si->sis[gr][ch].blockType != 2) {
 80103c4:	011b      	lsls	r3, r3, #4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103c6:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
	if (si->sis[gr][ch].blockType != 2) {
 80103ca:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
 80103ce:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80103d2:	4423      	add	r3, r4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103d4:	17cc      	asrs	r4, r1, #31
 80103d6:	fb80 c101 	smull	ip, r1, r0, r1
 80103da:	ebc4 01a1 	rsb	r1, r4, r1, asr #2
	if (si->sis[gr][ch].blockType != 2) {
 80103de:	00f4      	lsls	r4, r6, #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103e0:	b209      	sxth	r1, r1
	if (si->sis[gr][ch].blockType != 2) {
 80103e2:	9434      	str	r4, [sp, #208]	; 0xd0
 80103e4:	00fc      	lsls	r4, r7, #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80103e6:	9125      	str	r1, [sp, #148]	; 0x94
	if (si->sis[gr][ch].blockType != 2) {
 80103e8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80103ea:	9437      	str	r4, [sp, #220]	; 0xdc
 80103ec:	2902      	cmp	r1, #2
 80103ee:	f001 87dd 	beq.w	80123ac <xmp3fixpt_IMDCT+0x2034>
		/* all long transforms */
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 80103f2:	f506 6390 	add.w	r3, r6, #1152	; 0x480
 80103f6:	f240 2126 	movw	r1, #550	; 0x226
 80103fa:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80103fe:	428b      	cmp	r3, r1
 8010400:	f340 8323 	ble.w	8010a4a <xmp3fixpt_IMDCT+0x6d2>
		/* all short transforms */
		bc.nBlocksLong = 0;
		nBfly = 0;
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010404:	0213      	lsls	r3, r2, #8
 8010406:	930f      	str	r3, [sp, #60]	; 0x3c
 8010408:	eb05 2302 	add.w	r3, r5, r2, lsl #8
 801040c:	f240 2236 	movw	r2, #566	; 0x236
 8010410:	9309      	str	r3, [sp, #36]	; 0x24
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8010412:	2320      	movs	r3, #32
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010414:	920e      	str	r2, [sp, #56]	; 0x38
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8010416:	932c      	str	r3, [sp, #176]	; 0xb0
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010418:	231f      	movs	r3, #31
 801041a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801041c:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 8010420:	4aac      	ldr	r2, [pc, #688]	; (80106d4 <xmp3fixpt_IMDCT+0x35c>)
 8010422:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8010426:	9308      	str	r3, [sp, #32]
 8010428:	460b      	mov	r3, r1
 801042a:	6811      	ldr	r1, [r2, #0]
 801042c:	9100      	str	r1, [sp, #0]
 801042e:	6851      	ldr	r1, [r2, #4]
 8010430:	9101      	str	r1, [sp, #4]
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 8010432:	6891      	ldr	r1, [r2, #8]
 8010434:	9102      	str	r1, [sp, #8]
 8010436:	68d1      	ldr	r1, [r2, #12]
 8010438:	9103      	str	r1, [sp, #12]
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 801043a:	6911      	ldr	r1, [r2, #16]
 801043c:	9104      	str	r1, [sp, #16]
 801043e:	6951      	ldr	r1, [r2, #20]
 8010440:	9105      	str	r1, [sp, #20]
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 8010442:	6991      	ldr	r1, [r2, #24]
 8010444:	9106      	str	r1, [sp, #24]
 8010446:	69d1      	ldr	r1, [r2, #28]
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8010448:	e9d2 c708 	ldrd	ip, r7, [r2, #32]
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 801044c:	9107      	str	r1, [sp, #28]
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 801044e:	e9d2 650a 	ldrd	r6, r5, [r2, #40]	; 0x28
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 8010452:	e9d2 010e 	ldrd	r0, r1, [r2, #56]	; 0x38
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 8010456:	e9d2 4b0c 	ldrd	r4, fp, [r2, #48]	; 0x30
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801045a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 801045e:	e9d3 8211 	ldrd	r8, r2, [r3, #68]	; 0x44
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010462:	9900      	ldr	r1, [sp, #0]
 8010464:	46c1      	mov	r9, r8
 8010466:	fb81 e909 	smull	lr, r9, r1, r9
 801046a:	4696      	mov	lr, r2
 801046c:	9801      	ldr	r0, [sp, #4]
 801046e:	fb80 ae0e 	smull	sl, lr, r0, lr
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010472:	eba9 0e0e 	sub.w	lr, r9, lr
 8010476:	9900      	ldr	r1, [sp, #0]
 8010478:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 801047c:	f8c3 e044 	str.w	lr, [r3, #68]	; 0x44
 8010480:	fb81 e202 	smull	lr, r2, r1, r2
 8010484:	fb80 e808 	smull	lr, r8, r0, r8
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010488:	4442      	add	r2, r8
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801048a:	f8d3 8040 	ldr.w	r8, [r3, #64]	; 0x40
 801048e:	9902      	ldr	r1, [sp, #8]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010490:	0052      	lsls	r2, r2, #1
 8010492:	46c1      	mov	r9, r8
 8010494:	649a      	str	r2, [r3, #72]	; 0x48
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 8010496:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010498:	fb81 e909 	smull	lr, r9, r1, r9
 801049c:	4696      	mov	lr, r2
 801049e:	9803      	ldr	r0, [sp, #12]
 80104a0:	fb80 ae0e 	smull	sl, lr, r0, lr
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80104a4:	eba9 0e0e 	sub.w	lr, r9, lr
 80104a8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80104ac:	f8c3 e040 	str.w	lr, [r3, #64]	; 0x40
 80104b0:	fb81 e202 	smull	lr, r2, r1, r2
 80104b4:	fb80 e808 	smull	lr, r8, r0, r8
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80104b8:	4442      	add	r2, r8
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 80104ba:	f8d3 803c 	ldr.w	r8, [r3, #60]	; 0x3c
 80104be:	9904      	ldr	r1, [sp, #16]
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80104c0:	0052      	lsls	r2, r2, #1
 80104c2:	46c1      	mov	r9, r8
 80104c4:	64da      	str	r2, [r3, #76]	; 0x4c
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 80104c6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80104c8:	fb81 e909 	smull	lr, r9, r1, r9
 80104cc:	4696      	mov	lr, r2
 80104ce:	9805      	ldr	r0, [sp, #20]
 80104d0:	fb80 ae0e 	smull	sl, lr, r0, lr
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80104d4:	eba9 0e0e 	sub.w	lr, r9, lr
 80104d8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80104dc:	f8c3 e03c 	str.w	lr, [r3, #60]	; 0x3c
 80104e0:	fb81 e202 	smull	lr, r2, r1, r2
 80104e4:	fb80 e808 	smull	lr, r8, r0, r8
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80104e8:	4442      	add	r2, r8
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 80104ea:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
 80104ee:	9906      	ldr	r1, [sp, #24]
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80104f0:	0052      	lsls	r2, r2, #1
 80104f2:	46c1      	mov	r9, r8
 80104f4:	651a      	str	r2, [r3, #80]	; 0x50
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 80104f6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80104f8:	fb81 e909 	smull	lr, r9, r1, r9
 80104fc:	4696      	mov	lr, r2
 80104fe:	9807      	ldr	r0, [sp, #28]
 8010500:	fb80 ae0e 	smull	sl, lr, r0, lr
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010504:	eba9 0e0e 	sub.w	lr, r9, lr
 8010508:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 801050c:	f8c3 e038 	str.w	lr, [r3, #56]	; 0x38
 8010510:	fb81 e202 	smull	lr, r2, r1, r2
 8010514:	fb80 e808 	smull	lr, r8, r0, r8
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010518:	4442      	add	r2, r8
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 801051a:	f8d3 8034 	ldr.w	r8, [r3, #52]	; 0x34
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801051e:	0052      	lsls	r2, r2, #1
 8010520:	46c1      	mov	r9, r8
 8010522:	655a      	str	r2, [r3, #84]	; 0x54
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8010524:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8010526:	fb8c e909 	smull	lr, r9, ip, r9
 801052a:	4696      	mov	lr, r2
 801052c:	fb87 ae0e 	smull	sl, lr, r7, lr
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010530:	eba9 0e0e 	sub.w	lr, r9, lr
 8010534:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8010538:	f8c3 e034 	str.w	lr, [r3, #52]	; 0x34
 801053c:	fb8c e202 	smull	lr, r2, ip, r2
 8010540:	fb87 e808 	smull	lr, r8, r7, r8
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010544:	4442      	add	r2, r8
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 8010546:	f8d3 8030 	ldr.w	r8, [r3, #48]	; 0x30
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801054a:	0052      	lsls	r2, r2, #1
 801054c:	46c1      	mov	r9, r8
 801054e:	659a      	str	r2, [r3, #88]	; 0x58
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 8010550:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8010552:	fb86 e909 	smull	lr, r9, r6, r9
 8010556:	4696      	mov	lr, r2
 8010558:	fb85 ae0e 	smull	sl, lr, r5, lr
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801055c:	eba9 0e0e 	sub.w	lr, r9, lr
 8010560:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8010564:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
 8010568:	fb86 e202 	smull	lr, r2, r6, r2
 801056c:	fb85 e808 	smull	lr, r8, r5, r8
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010570:	4442      	add	r2, r8
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 8010572:	f8d3 802c 	ldr.w	r8, [r3, #44]	; 0x2c
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010576:	0052      	lsls	r2, r2, #1
 8010578:	46c1      	mov	r9, r8
 801057a:	65da      	str	r2, [r3, #92]	; 0x5c
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801057c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 801057e:	fb84 e909 	smull	lr, r9, r4, r9
 8010582:	4696      	mov	lr, r2
 8010584:	fb8b ae0e 	smull	sl, lr, fp, lr
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010588:	eba9 0e0e 	sub.w	lr, r9, lr
 801058c:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8010590:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
 8010594:	fb84 e202 	smull	lr, r2, r4, r2
 8010598:	fb8b e808 	smull	lr, r8, fp, r8
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801059c:	4442      	add	r2, r8
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801059e:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 80105a2:	980a      	ldr	r0, [sp, #40]	; 0x28
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80105a4:	0052      	lsls	r2, r2, #1
 80105a6:	46c1      	mov	r9, r8
 80105a8:	661a      	str	r2, [r3, #96]	; 0x60
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 80105aa:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80105ac:	fb80 e909 	smull	lr, r9, r0, r9
 80105b0:	4696      	mov	lr, r2
 80105b2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80105b4:	fb81 ae0e 	smull	sl, lr, r1, lr
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80105b8:	eba9 0e0e 	sub.w	lr, r9, lr
 80105bc:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80105c0:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
 80105c4:	fb80 e202 	smull	lr, r2, r0, r2
 80105c8:	fb81 e808 	smull	lr, r8, r1, r8
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80105cc:	4442      	add	r2, r8
	for (k = nBfly; k > 0; k--) {
 80105ce:	3348      	adds	r3, #72	; 0x48
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80105d0:	0052      	lsls	r2, r2, #1
 80105d2:	61da      	str	r2, [r3, #28]
	for (k = nBfly; k > 0; k--) {
 80105d4:	9a08      	ldr	r2, [sp, #32]
 80105d6:	4293      	cmp	r3, r2
 80105d8:	f47f af41 	bne.w	801045e <xmp3fixpt_IMDCT+0xe6>
	/* for readability, use a struct instead of passing a million parameters to HybridTransform() */
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
	bc.prevType = mi->prevType[ch];
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80105dc:	e9dd 2336 	ldrd	r2, r3, [sp, #216]	; 0xd8
 80105e0:	4413      	add	r3, r2
 80105e2:	e9dd 1233 	ldrd	r1, r2, [sp, #204]	; 0xcc
 80105e6:	011b      	lsls	r3, r3, #4
 80105e8:	440a      	add	r2, r1
 80105ea:	460e      	mov	r6, r1
 80105ec:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80105f0:	9a35      	ldr	r2, [sp, #212]	; 0xd4
 80105f2:	4413      	add	r3, r2
 80105f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80105f6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	bc.gbIn = hi->gb[ch];

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 80105f8:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 80105fa:	eb02 0186 	add.w	r1, r2, r6, lsl #2
 80105fe:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8010600:	eb07 0286 	add.w	r2, r7, r6, lsl #2
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 8010604:	4832      	ldr	r0, [pc, #200]	; (80106d0 <xmp3fixpt_IMDCT+0x358>)
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8010606:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801060a:	443d      	add	r5, r7
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801060c:	f502 5480 	add.w	r4, r2, #4096	; 0x1000
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8010610:	9532      	str	r5, [sp, #200]	; 0xc8
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8010612:	f8d1 2200 	ldr.w	r2, [r1, #512]	; 0x200
 8010616:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 8010618:	9438      	str	r4, [sp, #224]	; 0xe0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801061a:	4295      	cmp	r5, r2
 801061c:	bfb8      	it	lt
 801061e:	4615      	movlt	r5, r2
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 8010620:	2b00      	cmp	r3, #0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8010622:	462a      	mov	r2, r5
 8010624:	f8c1 5200 	str.w	r5, [r1, #512]	; 0x200
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 8010628:	9d25      	ldr	r5, [sp, #148]	; 0x94
 801062a:	bf08      	it	eq
 801062c:	2500      	moveq	r5, #0
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 801062e:	3211      	adds	r2, #17
	bc.gbIn = hi->gb[ch];
 8010630:	f8d1 1208 	ldr.w	r1, [r1, #520]	; 0x208
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 8010634:	9525      	str	r5, [sp, #148]	; 0x94
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 8010636:	fb80 5002 	smull	r5, r0, r0, r2
 801063a:	17d2      	asrs	r2, r2, #31
	bc.gbIn = hi->gb[ch];
 801063c:	910a      	str	r1, [sp, #40]	; 0x28
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 801063e:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 8010642:	9202      	str	r2, [sp, #8]
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8010644:	9a34      	ldr	r2, [sp, #208]	; 0xd0
 8010646:	1991      	adds	r1, r2, r6
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010648:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801064a:	eb07 12c1 	add.w	r2, r7, r1, lsl #7
	for(i = 0; i < bc->nBlocksLong; i++) {
 801064e:	2e00      	cmp	r6, #0
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8010650:	f502 5590 	add.w	r5, r2, #4608	; 0x1200
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 8010654:	f8d4 2b00 	ldr.w	r2, [r4, #2816]	; 0xb00
 8010658:	9224      	str	r2, [sp, #144]	; 0x90
	bc.prevType = mi->prevType[ch];
 801065a:	f8d4 2b08 	ldr.w	r2, [r4, #2824]	; 0xb08
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801065e:	952b      	str	r5, [sp, #172]	; 0xac
	bc.prevType = mi->prevType[ch];
 8010660:	9213      	str	r2, [sp, #76]	; 0x4c
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 8010662:	f8d4 2b10 	ldr.w	r2, [r4, #2832]	; 0xb10
 8010666:	9226      	str	r2, [sp, #152]	; 0x98
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010668:	f341 86c6 	ble.w	80123f8 <xmp3fixpt_IMDCT+0x2080>
 801066c:	980a      	ldr	r0, [sp, #40]	; 0x28
		currWinIdx = sis->blockType;
 801066e:	e9dd 4236 	ldrd	r4, r2, [sp, #216]	; 0xd8
 8010672:	2806      	cmp	r0, #6
 8010674:	4422      	add	r2, r4
 8010676:	ea4f 1202 	mov.w	r2, r2, lsl #4
 801067a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801067e:	9935      	ldr	r1, [sp, #212]	; 0xd4
 8010680:	440a      	add	r2, r1
	mOut = 0;
 8010682:	f04f 0100 	mov.w	r1, #0
		currWinIdx = sis->blockType;
 8010686:	921a      	str	r2, [sp, #104]	; 0x68
		es = 7 - gb;
 8010688:	f1c0 0207 	rsb	r2, r0, #7
 801068c:	9809      	ldr	r0, [sp, #36]	; 0x24
 801068e:	921c      	str	r2, [sp, #112]	; 0x70
 8010690:	bfc8      	it	gt
 8010692:	460a      	movgt	r2, r1
 8010694:	f100 0448 	add.w	r4, r0, #72	; 0x48
	mOut = 0;
 8010698:	9100      	str	r1, [sp, #0]
 801069a:	ee07 2a90 	vmov	s15, r2
 801069e:	f105 0224 	add.w	r2, r5, #36	; 0x24
 80106a2:	9d32      	ldr	r5, [sp, #200]	; 0xc8
 80106a4:	46a3      	mov	fp, r4
 80106a6:	9205      	str	r2, [sp, #20]
 80106a8:	eb05 0286 	add.w	r2, r5, r6, lsl #2
 80106ac:	9504      	str	r5, [sp, #16]
	for(i = 0; i < bc->nBlocksLong; i++) {
 80106ae:	9106      	str	r1, [sp, #24]
 80106b0:	921d      	str	r2, [sp, #116]	; 0x74
 80106b2:	9a05      	ldr	r2, [sp, #20]
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 80106b4:	9925      	ldr	r1, [sp, #148]	; 0x94
 80106b6:	3a24      	subs	r2, #36	; 0x24
 80106b8:	9806      	ldr	r0, [sp, #24]
 80106ba:	920c      	str	r2, [sp, #48]	; 0x30
 80106bc:	4281      	cmp	r1, r0
		currWinIdx = sis->blockType;
 80106be:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80106c0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 80106c2:	920b      	str	r2, [sp, #44]	; 0x2c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 80106c4:	dd08      	ble.n	80106d8 <xmp3fixpt_IMDCT+0x360>
			currWinIdx = 0;
 80106c6:	2b00      	cmp	r3, #0
 80106c8:	bf18      	it	ne
 80106ca:	2200      	movne	r2, #0
 80106cc:	920b      	str	r2, [sp, #44]	; 0x2c
 80106ce:	e003      	b.n	80106d8 <xmp3fixpt_IMDCT+0x360>
 80106d0:	38e38e39 	.word	0x38e38e39
 80106d4:	080252bc 	.word	0x080252bc
		if (i < bc->prevWinSwitch)
 80106d8:	9b26      	ldr	r3, [sp, #152]	; 0x98
 80106da:	9a06      	ldr	r2, [sp, #24]
 80106dc:	4293      	cmp	r3, r2
 80106de:	f300 827f 	bgt.w	8010be0 <xmp3fixpt_IMDCT+0x868>
 80106e2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80106e4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	bc.prevType = mi->prevType[ch];
 80106e6:	931b      	str	r3, [sp, #108]	; 0x6c
 80106e8:	431a      	orrs	r2, r3
 80106ea:	9201      	str	r2, [sp, #4]
	if (gb < 7) {
 80106ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80106ee:	2b06      	cmp	r3, #6
 80106f0:	f340 81dc 	ble.w	8010aac <xmp3fixpt_IMDCT+0x734>
			acc1 = (*xCurr--) - acc1;
 80106f4:	f85b 3c04 	ldr.w	r3, [fp, #-4]
			acc1 = (*xCurr--) - acc1;
 80106f8:	f85b 6c08 	ldr.w	r6, [fp, #-8]
			acc1 = (*xCurr--) - acc1;
 80106fc:	f85b 2c0c 	ldr.w	r2, [fp, #-12]
			acc1 = (*xCurr--) - acc1;
 8010700:	eba6 0803 	sub.w	r8, r6, r3
 8010704:	f85b 7c10 	ldr.w	r7, [fp, #-16]
			acc1 = (*xCurr--) - acc1;
 8010708:	9315      	str	r3, [sp, #84]	; 0x54
 801070a:	eba2 0208 	sub.w	r2, r2, r8
			acc1 = (*xCurr--) - acc1;
 801070e:	f85b 5c20 	ldr.w	r5, [fp, #-32]
 8010712:	f85b 6c28 	ldr.w	r6, [fp, #-40]
			acc2 = acc1 - acc2;
 8010716:	1ad1      	subs	r1, r2, r3
			acc1 = (*xCurr--) - acc1;
 8010718:	1ab8      	subs	r0, r7, r2
			acc1 = (*xCurr--) - acc1;
 801071a:	f85b 3c14 	ldr.w	r3, [fp, #-20]
			acc1 = (*xCurr--) - acc1;
 801071e:	f85b 2c18 	ldr.w	r2, [fp, #-24]
 8010722:	4686      	mov	lr, r0
			acc1 = (*xCurr--) - acc1;
 8010724:	1a1b      	subs	r3, r3, r0
			acc1 = (*xCurr--) - acc1;
 8010726:	f85b 4c30 	ldr.w	r4, [fp, #-48]
			acc2 = acc1 - acc2;
 801072a:	9107      	str	r1, [sp, #28]
			acc1 = (*xCurr--) - acc1;
 801072c:	eba2 0a03 	sub.w	sl, r2, r3
			acc2 = acc1 - acc2;
 8010730:	1a5a      	subs	r2, r3, r1
			acc1 = (*xCurr--) - acc1;
 8010732:	f85b 3c1c 	ldr.w	r3, [fp, #-28]
			acc2 = acc1 - acc2;
 8010736:	920f      	str	r2, [sp, #60]	; 0x3c
			acc1 = (*xCurr--) - acc1;
 8010738:	eba3 030a 	sub.w	r3, r3, sl
			acc1 = (*xCurr--) - acc1;
 801073c:	eba5 0903 	sub.w	r9, r5, r3
			acc2 = acc1 - acc2;
 8010740:	1a9a      	subs	r2, r3, r2
			acc1 = (*xCurr--) - acc1;
 8010742:	f85b 3c24 	ldr.w	r3, [fp, #-36]
			acc2 = acc1 - acc2;
 8010746:	9208      	str	r2, [sp, #32]
			acc1 = (*xCurr--) - acc1;
 8010748:	eba3 0309 	sub.w	r3, r3, r9
			acc1 = (*xCurr--) - acc1;
 801074c:	f85b 5c40 	ldr.w	r5, [fp, #-64]
			acc2 = acc1 - acc2;
 8010750:	1a9a      	subs	r2, r3, r2
			acc1 = (*xCurr--) - acc1;
 8010752:	1af6      	subs	r6, r6, r3
			acc1 = (*xCurr--) - acc1;
 8010754:	f85b 3c2c 	ldr.w	r3, [fp, #-44]
			acc2 = acc1 - acc2;
 8010758:	9216      	str	r2, [sp, #88]	; 0x58
			acc1 = (*xCurr--) - acc1;
 801075a:	1b9b      	subs	r3, r3, r6
			acc2 = acc1 - acc2;
 801075c:	1a99      	subs	r1, r3, r2
			acc1 = (*xCurr--) - acc1;
 801075e:	1ae4      	subs	r4, r4, r3
			acc1 = (*xCurr--) - acc1;
 8010760:	f85b 3c34 	ldr.w	r3, [fp, #-52]
			acc2 = acc1 - acc2;
 8010764:	9112      	str	r1, [sp, #72]	; 0x48
			acc1 = (*xCurr--) - acc1;
 8010766:	1b1a      	subs	r2, r3, r4
			acc1 = (*xCurr--) - acc1;
 8010768:	f85b 3c38 	ldr.w	r3, [fp, #-56]
			acc2 = acc1 - acc2;
 801076c:	1a51      	subs	r1, r2, r1
			acc1 = (*xCurr--) - acc1;
 801076e:	1a9b      	subs	r3, r3, r2
			acc1 = (*xCurr--) - acc1;
 8010770:	f85b 2c3c 	ldr.w	r2, [fp, #-60]
			acc2 = acc1 - acc2;
 8010774:	9110      	str	r1, [sp, #64]	; 0x40
			acc1 = (*xCurr--) - acc1;
 8010776:	1ad2      	subs	r2, r2, r3
			acc1 = (*xCurr--) - acc1;
 8010778:	1aa8      	subs	r0, r5, r2
 801077a:	9003      	str	r0, [sp, #12]
			acc2 = acc1 - acc2;
 801077c:	1a50      	subs	r0, r2, r1
			acc1 = (*xCurr--) - acc1;
 801077e:	9903      	ldr	r1, [sp, #12]
 8010780:	f85b 2c44 	ldr.w	r2, [fp, #-68]
			acc2 = acc1 - acc2;
 8010784:	900e      	str	r0, [sp, #56]	; 0x38
			acc1 = (*xCurr--) - acc1;
 8010786:	1a52      	subs	r2, r2, r1
			acc1 = (*xCurr--) - acc1;
 8010788:	f85b 1c48 	ldr.w	r1, [fp, #-72]
 801078c:	eba1 0c02 	sub.w	ip, r1, r2
			acc2 = acc1 - acc2;
 8010790:	1a12      	subs	r2, r2, r0
	xBuf[9] >>= 1;
 8010792:	1052      	asrs	r2, r2, #1
 8010794:	4625      	mov	r5, r4
	xBuf[0] >>= 1;
 8010796:	ea4f 016c 	mov.w	r1, ip, asr #1
	a5 = x2 + x4;
 801079a:	18f0      	adds	r0, r6, r3
	xBuf[9] >>= 1;
 801079c:	920d      	str	r2, [sp, #52]	; 0x34
	a4 = x2 - x4;
 801079e:	1b9a      	subs	r2, r3, r6
	xBuf[0] >>= 1;
 80107a0:	9111      	str	r1, [sp, #68]	; 0x44
	a1 = x0 - x6;
 80107a2:	ebca 0c6c 	rsb	ip, sl, ip, asr #1
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 80107a6:	eba2 0708 	sub.w	r7, r2, r8
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 80107aa:	4674      	mov	r4, lr
 80107ac:	eba9 010e 	sub.w	r1, r9, lr
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 80107b0:	9714      	str	r7, [sp, #80]	; 0x50
 80107b2:	4fb8      	ldr	r7, [pc, #736]	; (8010a94 <xmp3fixpt_IMDCT+0x71c>)
 80107b4:	fb87 2505 	smull	r2, r5, r7, r5
	a2 = x1 - x5;
 80107b8:	9a03      	ldr	r2, [sp, #12]
 80107ba:	9517      	str	r5, [sp, #92]	; 0x5c
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80107bc:	4625      	mov	r5, r4
	a2 = x1 - x5;
 80107be:	eba2 0e09 	sub.w	lr, r2, r9
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80107c2:	ebae 0e04 	sub.w	lr, lr, r4
 80107c6:	fb87 2e0e 	smull	r2, lr, r7, lr
 80107ca:	4fb3      	ldr	r7, [pc, #716]	; (8010a98 <xmp3fixpt_IMDCT+0x720>)
 80107cc:	4604      	mov	r4, r0
 80107ce:	fb87 2404 	smull	r2, r4, r7, r4
 80107d2:	9418      	str	r4, [sp, #96]	; 0x60
	a6 = x2 + x8;
 80107d4:	4443      	add	r3, r8
 80107d6:	4cb1      	ldr	r4, [pc, #708]	; (8010a9c <xmp3fixpt_IMDCT+0x724>)
 80107d8:	fb84 2303 	smull	r2, r3, r4, r3
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 80107dc:	eba8 0606 	sub.w	r6, r8, r6
 80107e0:	9319      	str	r3, [sp, #100]	; 0x64
 80107e2:	fb87 2606 	smull	r2, r6, r7, r6
 80107e6:	fb84 2000 	smull	r2, r0, r4, r0
 80107ea:	f104 5470 	add.w	r4, r4, #1006632960	; 0x3c000000
 80107ee:	4688      	mov	r8, r1
 80107f0:	f504 244c 	add.w	r4, r4, #835584	; 0xcc000
 80107f4:	f204 24cb 	addw	r4, r4, #715	; 0x2cb
 80107f8:	fb84 2808 	smull	r2, r8, r4, r8
	a7 = x1 + x7;
 80107fc:	9b03      	ldr	r3, [sp, #12]
 80107fe:	462a      	mov	r2, r5
 8010800:	441a      	add	r2, r3
 8010802:	4ba7      	ldr	r3, [pc, #668]	; (8010aa0 <xmp3fixpt_IMDCT+0x728>)
 8010804:	fb83 7202 	smull	r7, r2, r3, r2
	a3 = x1 + x5;
 8010808:	9d03      	ldr	r5, [sp, #12]
 801080a:	444d      	add	r5, r9
 801080c:	fb84 7505 	smull	r7, r5, r4, r5
 8010810:	fb83 7101 	smull	r7, r1, r3, r1
	a12 = x[0] +  (x[6] >> 1);
 8010814:	9b11      	ldr	r3, [sp, #68]	; 0x44
	a20 = (m11 << 1) - (m12 << 1);
 8010816:	0049      	lsls	r1, r1, #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010818:	9c18      	ldr	r4, [sp, #96]	; 0x60
	a19 = ( m9 << 1) + (m10 << 1);
 801081a:	0052      	lsls	r2, r2, #1
	a12 = x[0] +  (x[6] >> 1);
 801081c:	eb03 076a 	add.w	r7, r3, sl, asr #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010820:	9b19      	ldr	r3, [sp, #100]	; 0x64
	a20 = (m11 << 1) - (m12 << 1);
 8010822:	ebc1 0545 	rsb	r5, r1, r5, lsl #1
	a13 = a12  +  (  m1 << 1);
 8010826:	9917      	ldr	r1, [sp, #92]	; 0x5c
	a16 = ( m5 << 1) + (m6 << 1);
 8010828:	005b      	lsls	r3, r3, #1
 801082a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
	a19 = ( m9 << 1) + (m10 << 1);
 801082e:	eb02 0848 	add.w	r8, r2, r8, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010832:	eb03 0344 	add.w	r3, r3, r4, lsl #1
	a13 = a12  +  (  m1 << 1);
 8010836:	eb07 0241 	add.w	r2, r7, r1, lsl #1
	a14 = a12  -  (  m1 << 1);
 801083a:	eba7 0441 	sub.w	r4, r7, r1, lsl #1
	a15 = a1   +  ( a11 >> 1);
 801083e:	9f14      	ldr	r7, [sp, #80]	; 0x50
	a17 = ( m7 << 1) - (m8 << 1);
 8010840:	0040      	lsls	r0, r0, #1
 8010842:	ebc0 0646 	rsb	r6, r0, r6, lsl #1
	a15 = a1   +  ( a11 >> 1);
 8010846:	eb0c 0067 	add.w	r0, ip, r7, asr #1
	x4 = a1 - a11;			x[4] = x4;
 801084a:	ebac 0707 	sub.w	r7, ip, r7
	a18 = a16 + a17;
 801084e:	1999      	adds	r1, r3, r6
	a21 = a20 - a19;
 8010850:	eba5 0c08 	sub.w	ip, r5, r8
	x4 = a1 - a11;			x[4] = x4;
 8010854:	973e      	str	r7, [sp, #248]	; 0xf8
	a22 = a13 + a16;
 8010856:	18d7      	adds	r7, r2, r3
	a23 = a14 + a16;
 8010858:	4423      	add	r3, r4
	x0 = a22 + a19;			x[0] = x0;
 801085a:	4447      	add	r7, r8
	x8 = a23 - a19;			x[8] = x8;
 801085c:	eba3 0308 	sub.w	r3, r3, r8
	x0 = a22 + a19;			x[0] = x0;
 8010860:	973a      	str	r7, [sp, #232]	; 0xe8
	x8 = a23 - a19;			x[8] = x8;
 8010862:	9342      	str	r3, [sp, #264]	; 0x108
	a24 = a14 + a17;
 8010864:	19a3      	adds	r3, r4, r6
	a26 = a14 - a18;
 8010866:	1a64      	subs	r4, r4, r1
	a25 = a13 + a17;
 8010868:	4416      	add	r6, r2
	x2 = a24 + a20;			x[2] = x2;
 801086a:	442b      	add	r3, r5
	a27 = a13 - a18;
 801086c:	1a51      	subs	r1, r2, r1
	x6 = a25 - a20;			x[6] = x6;
 801086e:	1b76      	subs	r6, r6, r5
	x3 = a26 - a21;			x[3] = x3;
 8010870:	eba4 040c 	sub.w	r4, r4, ip
	x2 = a24 + a20;			x[2] = x2;
 8010874:	933c      	str	r3, [sp, #240]	; 0xf0
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8010876:	eb00 034e 	add.w	r3, r0, lr, lsl #1
	x5 = a27 + a21;			x[5] = x5;
 801087a:	4461      	add	r1, ip
	a1 = x0 - x6;
 801087c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801087e:	933b      	str	r3, [sp, #236]	; 0xec
	x7 = a15 - (m3 << 1);	x[7] = x7;
 8010880:	eba0 004e 	sub.w	r0, r0, lr, lsl #1
	a1 = x0 - x6;
 8010884:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	x3 = a26 - a21;			x[3] = x3;
 8010886:	943d      	str	r4, [sp, #244]	; 0xf4
	a1 = x0 - x6;
 8010888:	eba3 0c05 	sub.w	ip, r3, r5
	a4 = x2 - x4;
 801088c:	9c16      	ldr	r4, [sp, #88]	; 0x58
	x5 = a27 + a21;			x[5] = x5;
 801088e:	913f      	str	r1, [sp, #252]	; 0xfc
	a4 = x2 - x4;
 8010890:	9910      	ldr	r1, [sp, #64]	; 0x40
	x6 = a25 - a20;			x[6] = x6;
 8010892:	9640      	str	r6, [sp, #256]	; 0x100
	a4 = x2 - x4;
 8010894:	eba1 0904 	sub.w	r9, r1, r4
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8010898:	9e15      	ldr	r6, [sp, #84]	; 0x54
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801089a:	9041      	str	r0, [sp, #260]	; 0x104
	a5 = x2 + x4;
 801089c:	1908      	adds	r0, r1, r4
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 801089e:	eba9 0906 	sub.w	r9, r9, r6
 80108a2:	4a7c      	ldr	r2, [pc, #496]	; (8010a94 <xmp3fixpt_IMDCT+0x71c>)
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 80108a4:	e9dd 3507 	ldrd	r3, r5, [sp, #28]
 80108a8:	1aeb      	subs	r3, r5, r3
 80108aa:	9303      	str	r3, [sp, #12]
 80108ac:	fb82 3a0a 	smull	r3, sl, r2, sl
	a2 = x1 - x5;
 80108b0:	9f0e      	ldr	r7, [sp, #56]	; 0x38
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80108b2:	9b07      	ldr	r3, [sp, #28]
	a2 = x1 - x5;
 80108b4:	1b7f      	subs	r7, r7, r5
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80108b6:	1aff      	subs	r7, r7, r3
 80108b8:	fb82 3707 	smull	r3, r7, r2, r7
 80108bc:	4d76      	ldr	r5, [pc, #472]	; (8010a98 <xmp3fixpt_IMDCT+0x720>)
 80108be:	4680      	mov	r8, r0
 80108c0:	fb85 3808 	smull	r3, r8, r5, r8
	a6 = x2 + x8;
 80108c4:	460a      	mov	r2, r1
 80108c6:	4631      	mov	r1, r6
 80108c8:	1993      	adds	r3, r2, r6
 80108ca:	4e74      	ldr	r6, [pc, #464]	; (8010a9c <xmp3fixpt_IMDCT+0x724>)
 80108cc:	fb86 2303 	smull	r2, r3, r6, r3
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 80108d0:	1b0c      	subs	r4, r1, r4
 80108d2:	9310      	str	r3, [sp, #64]	; 0x40
 80108d4:	fb85 2404 	smull	r2, r4, r5, r4
 80108d8:	fb86 2000 	smull	r2, r0, r6, r0
 80108dc:	f106 5670 	add.w	r6, r6, #1006632960	; 0x3c000000
 80108e0:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80108e4:	f506 264c 	add.w	r6, r6, #835584	; 0xcc000
 80108e8:	f206 26cb 	addw	r6, r6, #715	; 0x2cb
 80108ec:	fb86 2e0e 	smull	r2, lr, r6, lr
	a7 = x1 + x7;
 80108f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80108f2:	9a07      	ldr	r2, [sp, #28]
 80108f4:	496a      	ldr	r1, [pc, #424]	; (8010aa0 <xmp3fixpt_IMDCT+0x728>)
 80108f6:	189a      	adds	r2, r3, r2
 80108f8:	fb81 5202 	smull	r5, r2, r1, r2
	a3 = x1 + x5;
 80108fc:	9d08      	ldr	r5, [sp, #32]
 80108fe:	4631      	mov	r1, r6
 8010900:	195d      	adds	r5, r3, r5
 8010902:	fb81 6505 	smull	r6, r5, r1, r5
 8010906:	4b66      	ldr	r3, [pc, #408]	; (8010aa0 <xmp3fixpt_IMDCT+0x728>)
 8010908:	9903      	ldr	r1, [sp, #12]
 801090a:	fb83 6101 	smull	r6, r1, r3, r1
	a12 = x[0] +  (x[6] >> 1);
 801090e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	a19 = ( m9 << 1) + (m10 << 1);
 8010910:	0052      	lsls	r2, r2, #1
	a12 = x[0] +  (x[6] >> 1);
 8010912:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
	a17 = ( m7 << 1) - (m8 << 1);
 8010914:	0040      	lsls	r0, r0, #1
	a19 = ( m9 << 1) + (m10 << 1);
 8010916:	eb02 0e4e 	add.w	lr, r2, lr, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 801091a:	eb03 0666 	add.w	r6, r3, r6, asr #1
	a16 = ( m5 << 1) + (m6 << 1);
 801091e:	9b10      	ldr	r3, [sp, #64]	; 0x40
	a17 = ( m7 << 1) - (m8 << 1);
 8010920:	ebc0 0044 	rsb	r0, r0, r4, lsl #1
	x4 = a1 - a11;			x[4] = x4;
 8010924:	ebac 0409 	sub.w	r4, ip, r9
	a16 = ( m5 << 1) + (m6 << 1);
 8010928:	005b      	lsls	r3, r3, #1
	a13 = a12  +  (  m1 << 1);
 801092a:	eb06 024a 	add.w	r2, r6, sl, lsl #1
	x4 = a1 - a11;			x[4] = x4;
 801092e:	9447      	str	r4, [sp, #284]	; 0x11c
	a14 = a12  -  (  m1 << 1);
 8010930:	eba6 064a 	sub.w	r6, r6, sl, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010934:	eb03 0348 	add.w	r3, r3, r8, lsl #1
	a20 = (m11 << 1) - (m12 << 1);
 8010938:	0049      	lsls	r1, r1, #1
	a22 = a13 + a16;
 801093a:	18d4      	adds	r4, r2, r3
	a15 = a1   +  ( a11 >> 1);
 801093c:	eb0c 0a69 	add.w	sl, ip, r9, asr #1
	a20 = (m11 << 1) - (m12 << 1);
 8010940:	ebc1 0545 	rsb	r5, r1, r5, lsl #1
	a18 = a16 + a17;
 8010944:	1819      	adds	r1, r3, r0
	a23 = a14 + a16;
 8010946:	4433      	add	r3, r6
	x0 = a22 + a19;			x[0] = x0;
 8010948:	4474      	add	r4, lr
	a21 = a20 - a19;
 801094a:	eba5 0c0e 	sub.w	ip, r5, lr
	x8 = a23 - a19;			x[8] = x8;
 801094e:	eba3 030e 	sub.w	r3, r3, lr
	x0 = a22 + a19;			x[0] = x0;
 8010952:	9443      	str	r4, [sp, #268]	; 0x10c
	x8 = a23 - a19;			x[8] = x8;
 8010954:	934b      	str	r3, [sp, #300]	; 0x12c
	a24 = a14 + a17;
 8010956:	1833      	adds	r3, r6, r0
	a26 = a14 - a18;
 8010958:	1a76      	subs	r6, r6, r1
	a25 = a13 + a17;
 801095a:	4410      	add	r0, r2
	x2 = a24 + a20;			x[2] = x2;
 801095c:	442b      	add	r3, r5
	a27 = a13 - a18;
 801095e:	1a51      	subs	r1, r2, r1
	x6 = a25 - a20;			x[6] = x6;
 8010960:	1b40      	subs	r0, r0, r5
	x3 = a26 - a21;			x[3] = x3;
 8010962:	eba6 060c 	sub.w	r6, r6, ip
	x2 = a24 + a20;			x[2] = x2;
 8010966:	9345      	str	r3, [sp, #276]	; 0x114
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8010968:	eb0a 0347 	add.w	r3, sl, r7, lsl #1
	x5 = a27 + a21;			x[5] = x5;
 801096c:	4461      	add	r1, ip
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801096e:	ebaa 0747 	sub.w	r7, sl, r7, lsl #1
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8010972:	9344      	str	r3, [sp, #272]	; 0x110
	if (btPrev == 0 && btCurr == 0) {
 8010974:	9b01      	ldr	r3, [sp, #4]
	x6 = a25 - a20;			x[6] = x6;
 8010976:	9049      	str	r0, [sp, #292]	; 0x124
	x3 = a26 - a21;			x[3] = x3;
 8010978:	9646      	str	r6, [sp, #280]	; 0x118
	x5 = a27 + a21;			x[5] = x5;
 801097a:	9148      	str	r1, [sp, #288]	; 0x120
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801097c:	974a      	str	r7, [sp, #296]	; 0x128
	if (btPrev == 0 && btCurr == 0) {
 801097e:	2b00      	cmp	r3, #0
 8010980:	f040 8133 	bne.w	8010bea <xmp3fixpt_IMDCT+0x872>
 8010984:	f8dd a010 	ldr.w	sl, [sp, #16]
 8010988:	4699      	mov	r9, r3
 801098a:	4c46      	ldr	r4, [pc, #280]	; (8010aa4 <xmp3fixpt_IMDCT+0x72c>)
	xp = xBuf + 8;
 801098c:	ad42      	add	r5, sp, #264	; 0x108
	if (btPrev == 0 && btCurr == 0) {
 801098e:	4657      	mov	r7, sl
 8010990:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	cp = c18 + 8;
 8010992:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8010aa8 <xmp3fixpt_IMDCT+0x730>
	__asm__ volatile (
 8010996:	469e      	mov	lr, r3
 8010998:	469c      	mov	ip, r3
 801099a:	f8cd b00c 	str.w	fp, [sp, #12]
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 801099e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80109a0:	f858 1904 	ldr.w	r1, [r8], #-4
 80109a4:	f855 2904 	ldr.w	r2, [r5], #-4
 80109a8:	fb81 0303 	smull	r0, r3, r1, r3
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 80109ac:	eb03 01a2 	add.w	r1, r3, r2, asr #2
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 80109b0:	6830      	ldr	r0, [r6, #0]
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 80109b2:	eba3 02a2 	sub.w	r2, r3, r2, asr #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 80109b6:	f846 1b04 	str.w	r1, [r6], #4
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 80109ba:	4241      	negs	r1, r0
 80109bc:	f854 3c08 	ldr.w	r3, [r4, #-8]
			t = s - d;
 80109c0:	1a89      	subs	r1, r1, r2
 80109c2:	fb81 b303 	smull	fp, r3, r1, r3
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 80109c6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80109ca:	f854 2c04 	ldr.w	r2, [r4, #-4]
 80109ce:	fb81 b202 	smull	fp, r2, r1, r2
    return y;
 80109d2:	ebc0 0282 	rsb	r2, r0, r2, lsl #2
			y[(i)*NBANDS]    = 	yLo;
 80109d6:	f84a 302c 	str.w	r3, [sl, ip, lsl #2]
	__asm__ volatile (
 80109da:	4671      	mov	r1, lr
			y[(17-i)*NBANDS] =  yHi;
 80109dc:	f8c7 2880 	str.w	r2, [r7, #2176]	; 0x880
 80109e0:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80109e4:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 80109e8:	4673      	mov	r3, lr
 80109ea:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 80109ee:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
		for (i = 0; i < 9; i++) {
 80109f2:	f10c 0c20 	add.w	ip, ip, #32
			mOut |= FASTABS(yHi);
 80109f6:	4319      	orrs	r1, r3
		for (i = 0; i < 9; i++) {
 80109f8:	3408      	adds	r4, #8
 80109fa:	3f80      	subs	r7, #128	; 0x80
 80109fc:	f5bc 7f90 	cmp.w	ip, #288	; 0x120
			mOut |= FASTABS(yHi);
 8010a00:	ea49 0901 	orr.w	r9, r9, r1
		for (i = 0; i < 9; i++) {
 8010a04:	d1cb      	bne.n	801099e <xmp3fixpt_IMDCT+0x626>
 8010a06:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8010a0a:	f8cd 9004 	str.w	r9, [sp, #4]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a0e:	9b05      	ldr	r3, [sp, #20]
 8010a10:	f10b 0b48 	add.w	fp, fp, #72	; 0x48
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010a14:	9c04      	ldr	r4, [sp, #16]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a16:	3324      	adds	r3, #36	; 0x24
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010a18:	990c      	ldr	r1, [sp, #48]	; 0x30
 8010a1a:	4620      	mov	r0, r4
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a1c:	3404      	adds	r4, #4
 8010a1e:	9305      	str	r3, [sp, #20]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010a20:	9b06      	ldr	r3, [sp, #24]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a22:	9404      	str	r4, [sp, #16]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010a24:	461a      	mov	r2, r3
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a26:	3301      	adds	r3, #1
 8010a28:	9306      	str	r3, [sp, #24]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010a2a:	ee17 3a90 	vmov	r3, s15
 8010a2e:	f7ff fa23 	bl	800fe78 <FreqInvertRescale>
 8010a32:	9b01      	ldr	r3, [sp, #4]
 8010a34:	4318      	orrs	r0, r3
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 8010a36:	9b00      	ldr	r3, [sp, #0]
 8010a38:	4303      	orrs	r3, r0
 8010a3a:	9300      	str	r3, [sp, #0]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010a3c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010a3e:	429c      	cmp	r4, r3
 8010a40:	f000 81a4 	beq.w	8010d8c <xmp3fixpt_IMDCT+0xa14>
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 8010a44:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8010a46:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010a48:	e633      	b.n	80106b2 <xmp3fixpt_IMDCT+0x33a>
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8010a4a:	3307      	adds	r3, #7
 8010a4c:	4631      	mov	r1, r6
 8010a4e:	fb80 2003 	smull	r2, r0, r0, r3
 8010a52:	17db      	asrs	r3, r3, #31
 8010a54:	ebc3 03a0 	rsb	r3, r3, r0, asr #2
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8010a58:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 8010a5c:	0052      	lsls	r2, r2, #1
 8010a5e:	3208      	adds	r2, #8
 8010a60:	920e      	str	r2, [sp, #56]	; 0x38
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8010a62:	1c5a      	adds	r2, r3, #1
 8010a64:	922c      	str	r2, [sp, #176]	; 0xb0
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010a66:	9a34      	ldr	r2, [sp, #208]	; 0xd0
	for (k = nBfly; k > 0; k--) {
 8010a68:	2b00      	cmp	r3, #0
 8010a6a:	440a      	add	r2, r1
 8010a6c:	ea4f 2102 	mov.w	r1, r2, lsl #8
 8010a70:	910f      	str	r1, [sp, #60]	; 0x3c
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010a72:	990c      	ldr	r1, [sp, #48]	; 0x30
 8010a74:	eb01 2102 	add.w	r1, r1, r2, lsl #8
 8010a78:	9109      	str	r1, [sp, #36]	; 0x24
	for (k = nBfly; k > 0; k--) {
 8010a7a:	f73f acce 	bgt.w	801041a <xmp3fixpt_IMDCT+0xa2>
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 8010a7e:	e9dd 1336 	ldrd	r1, r3, [sp, #216]	; 0xd8
 8010a82:	9e33      	ldr	r6, [sp, #204]	; 0xcc
 8010a84:	440b      	add	r3, r1
 8010a86:	011b      	lsls	r3, r3, #4
 8010a88:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8010a8c:	9a35      	ldr	r2, [sp, #212]	; 0xd4
 8010a8e:	4413      	add	r3, r2
 8010a90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010a92:	e5b0      	b.n	80105f6 <xmp3fixpt_IMDCT+0x27e>
 8010a94:	6ed9eba1 	.word	0x6ed9eba1
 8010a98:	620dbe8b 	.word	0x620dbe8b
 8010a9c:	163a1a7e 	.word	0x163a1a7e
 8010aa0:	7e0e2e32 	.word	0x7e0e2e32
 8010aa4:	08025114 	.word	0x08025114
 8010aa8:	08025108 	.word	0x08025108
			xPrev[i] >>= es;
 8010aac:	9d05      	ldr	r5, [sp, #20]
 8010aae:	981c      	ldr	r0, [sp, #112]	; 0x70
 8010ab0:	f855 3c04 	ldr.w	r3, [r5, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ab4:	f85b 4c04 	ldr.w	r4, [fp, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ab8:	f85b 6c08 	ldr.w	r6, [fp, #-8]
			xPrev[i] >>= es;
 8010abc:	4103      	asrs	r3, r0
 8010abe:	f855 1c08 	ldr.w	r1, [r5, #-8]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ac2:	4104      	asrs	r4, r0
			xPrev[i] >>= es;
 8010ac4:	f845 3c04 	str.w	r3, [r5, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ac8:	4106      	asrs	r6, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010aca:	f85b 3c0c 	ldr.w	r3, [fp, #-12]
			xPrev[i] >>= es;
 8010ace:	4101      	asrs	r1, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ad0:	f85b 7c10 	ldr.w	r7, [fp, #-16]
 8010ad4:	eba6 0804 	sub.w	r8, r6, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ad8:	fa43 f200 	asr.w	r2, r3, r0
			xPrev[i] >>= es;
 8010adc:	f845 1c08 	str.w	r1, [r5, #-8]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ae0:	4107      	asrs	r7, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ae2:	f85b 3c14 	ldr.w	r3, [fp, #-20]
 8010ae6:	eba2 0208 	sub.w	r2, r2, r8
 8010aea:	9415      	str	r4, [sp, #84]	; 0x54
 8010aec:	4103      	asrs	r3, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010aee:	1ab9      	subs	r1, r7, r2
			acc2 = acc1 - acc2;
 8010af0:	1b14      	subs	r4, r2, r4
			xPrev[i] >>= es;
 8010af2:	f855 2c0c 	ldr.w	r2, [r5, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010af6:	1a5e      	subs	r6, r3, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010af8:	f85b 3c18 	ldr.w	r3, [fp, #-24]
			xPrev[i] >>= es;
 8010afc:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010afe:	468e      	mov	lr, r1
 8010b00:	4103      	asrs	r3, r0
			xPrev[i] >>= es;
 8010b02:	4629      	mov	r1, r5
 8010b04:	f845 2c0c 	str.w	r2, [r5, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b08:	eba3 0a06 	sub.w	sl, r3, r6
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b0c:	f85b 3c1c 	ldr.w	r3, [fp, #-28]
			xPrev[i] >>= es;
 8010b10:	f851 2c10 	ldr.w	r2, [r1, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b14:	4103      	asrs	r3, r0
			acc2 = acc1 - acc2;
 8010b16:	9407      	str	r4, [sp, #28]
			xPrev[i] >>= es;
 8010b18:	4102      	asrs	r2, r0
			acc2 = acc1 - acc2;
 8010b1a:	1b34      	subs	r4, r6, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b1c:	eba3 050a 	sub.w	r5, r3, sl
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b20:	f85b 3c20 	ldr.w	r3, [fp, #-32]
			xPrev[i] >>= es;
 8010b24:	f841 2c10 	str.w	r2, [r1, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b28:	4103      	asrs	r3, r0
			xPrev[i] >>= es;
 8010b2a:	f851 2c14 	ldr.w	r2, [r1, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b2e:	f85b 6c28 	ldr.w	r6, [fp, #-40]
 8010b32:	eba3 0905 	sub.w	r9, r3, r5
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b36:	f85b 3c24 	ldr.w	r3, [fp, #-36]
			xPrev[i] >>= es;
 8010b3a:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b3c:	4106      	asrs	r6, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b3e:	4103      	asrs	r3, r0
			acc2 = acc1 - acc2;
 8010b40:	940f      	str	r4, [sp, #60]	; 0x3c
 8010b42:	1b2c      	subs	r4, r5, r4
			xPrev[i] >>= es;
 8010b44:	f841 2c14 	str.w	r2, [r1, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b48:	eba3 0309 	sub.w	r3, r3, r9
			xPrev[i] >>= es;
 8010b4c:	460d      	mov	r5, r1
			acc2 = acc1 - acc2;
 8010b4e:	9408      	str	r4, [sp, #32]
 8010b50:	1b19      	subs	r1, r3, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b52:	1af6      	subs	r6, r6, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b54:	f85b 3c2c 	ldr.w	r3, [fp, #-44]
			xPrev[i] >>= es;
 8010b58:	f855 2c18 	ldr.w	r2, [r5, #-24]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b5c:	4103      	asrs	r3, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b5e:	f85b 4c30 	ldr.w	r4, [fp, #-48]
			xPrev[i] >>= es;
 8010b62:	4102      	asrs	r2, r0
			acc2 = acc1 - acc2;
 8010b64:	9116      	str	r1, [sp, #88]	; 0x58
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b66:	1b9b      	subs	r3, r3, r6
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b68:	4104      	asrs	r4, r0
			xPrev[i] >>= es;
 8010b6a:	f845 2c18 	str.w	r2, [r5, #-24]
			acc2 = acc1 - acc2;
 8010b6e:	1a5f      	subs	r7, r3, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b70:	1ae4      	subs	r4, r4, r3
			acc2 = acc1 - acc2;
 8010b72:	9712      	str	r7, [sp, #72]	; 0x48
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b74:	f85b 3c34 	ldr.w	r3, [fp, #-52]
			xPrev[i] >>= es;
 8010b78:	f855 2c1c 	ldr.w	r2, [r5, #-28]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b7c:	4103      	asrs	r3, r0
			xPrev[i] >>= es;
 8010b7e:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b80:	1b19      	subs	r1, r3, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b82:	f85b 3c38 	ldr.w	r3, [fp, #-56]
			xPrev[i] >>= es;
 8010b86:	f845 2c1c 	str.w	r2, [r5, #-28]
			acc2 = acc1 - acc2;
 8010b8a:	1bca      	subs	r2, r1, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b8c:	4103      	asrs	r3, r0
			xPrev[i] >>= es;
 8010b8e:	462f      	mov	r7, r5
			acc2 = acc1 - acc2;
 8010b90:	9210      	str	r2, [sp, #64]	; 0x40
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b92:	1a5b      	subs	r3, r3, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b94:	f85b 2c3c 	ldr.w	r2, [fp, #-60]
			xPrev[i] >>= es;
 8010b98:	f855 1c20 	ldr.w	r1, [r5, #-32]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b9c:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010b9e:	f85b 5c40 	ldr.w	r5, [fp, #-64]
			xPrev[i] >>= es;
 8010ba2:	4101      	asrs	r1, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ba4:	1ad2      	subs	r2, r2, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 8010ba6:	4105      	asrs	r5, r0
			xPrev[i] >>= es;
 8010ba8:	f847 1c20 	str.w	r1, [r7, #-32]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010bac:	4601      	mov	r1, r0
 8010bae:	1aa8      	subs	r0, r5, r2
			acc1 = ((*xCurr--) >> es) - acc1;
 8010bb0:	460d      	mov	r5, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010bb2:	9003      	str	r0, [sp, #12]
			acc2 = acc1 - acc2;
 8010bb4:	9810      	ldr	r0, [sp, #64]	; 0x40
 8010bb6:	1a12      	subs	r2, r2, r0
 8010bb8:	4617      	mov	r7, r2
 8010bba:	920e      	str	r2, [sp, #56]	; 0x38
			acc1 = ((*xCurr--) >> es) - acc1;
 8010bbc:	f85b 2c44 	ldr.w	r2, [fp, #-68]
 8010bc0:	410a      	asrs	r2, r1
 8010bc2:	9903      	ldr	r1, [sp, #12]
 8010bc4:	1a52      	subs	r2, r2, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010bc6:	f85b 1c48 	ldr.w	r1, [fp, #-72]
 8010bca:	4129      	asrs	r1, r5
 8010bcc:	eba1 0c02 	sub.w	ip, r1, r2
			acc2 = acc1 - acc2;
 8010bd0:	1bd2      	subs	r2, r2, r7
			xPrev[i] >>= es;
 8010bd2:	9f05      	ldr	r7, [sp, #20]
 8010bd4:	f857 0c24 	ldr.w	r0, [r7, #-36]
 8010bd8:	4128      	asrs	r0, r5
 8010bda:	f847 0c24 	str.w	r0, [r7, #-36]
		for (i = 8; i >= 0; i--) {	
 8010bde:	e5d8      	b.n	8010792 <xmp3fixpt_IMDCT+0x41a>
 8010be0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010be2:	9301      	str	r3, [sp, #4]
			 prevWinIdx = 0;
 8010be4:	2300      	movs	r3, #0
 8010be6:	931b      	str	r3, [sp, #108]	; 0x6c
 8010be8:	e580      	b.n	80106ec <xmp3fixpt_IMDCT+0x374>
	if (btPrev == 2) {
 8010bea:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010bec:	2b02      	cmp	r3, #2
 8010bee:	f000 80c1 	beq.w	8010d74 <xmp3fixpt_IMDCT+0x9fc>
		wpLo = imdctWin[btPrev] + 18;
 8010bf2:	4c64      	ldr	r4, [pc, #400]	; (8010d84 <xmp3fixpt_IMDCT+0xa0c>)
 8010bf4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010bf8:	9f05      	ldr	r7, [sp, #20]
		wpLo = imdctWin[btPrev] + 18;
 8010bfa:	eb04 1303 	add.w	r3, r4, r3, lsl #4
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010bfe:	f857 0c24 	ldr.w	r0, [r7, #-36]
 8010c02:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010c06:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8010c08:	4605      	mov	r5, r0
 8010c0a:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c0e:	954c      	str	r5, [sp, #304]	; 0x130
 8010c10:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c14:	905d      	str	r0, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c16:	f857 0c20 	ldr.w	r0, [r7, #-32]
 8010c1a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8010c1e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8010c20:	4605      	mov	r5, r0
 8010c22:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c26:	954d      	str	r5, [sp, #308]	; 0x134
 8010c28:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c2c:	905c      	str	r0, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c2e:	f857 0c1c 	ldr.w	r0, [r7, #-28]
 8010c32:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8010c36:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8010c38:	4605      	mov	r5, r0
 8010c3a:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c3e:	954e      	str	r5, [sp, #312]	; 0x138
 8010c40:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c44:	905b      	str	r0, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c46:	f857 0c18 	ldr.w	r0, [r7, #-24]
 8010c4a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8010c4e:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8010c50:	4605      	mov	r5, r0
 8010c52:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c56:	954f      	str	r5, [sp, #316]	; 0x13c
 8010c58:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c5c:	905a      	str	r0, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c5e:	f857 0c14 	ldr.w	r0, [r7, #-20]
 8010c62:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8010c64:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8010c66:	4605      	mov	r5, r0
 8010c68:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c6c:	9550      	str	r5, [sp, #320]	; 0x140
 8010c6e:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c72:	9059      	str	r0, [sp, #356]	; 0x164
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c74:	f857 0c10 	ldr.w	r0, [r7, #-16]
 8010c78:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8010c7a:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8010c7c:	4605      	mov	r5, r0
 8010c7e:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c82:	9551      	str	r5, [sp, #324]	; 0x144
 8010c84:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c88:	9058      	str	r0, [sp, #352]	; 0x160
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010c8a:	f857 0c0c 	ldr.w	r0, [r7, #-12]
 8010c8e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8010c90:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8010c92:	4605      	mov	r5, r0
 8010c94:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010c98:	9552      	str	r5, [sp, #328]	; 0x148
 8010c9a:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010c9e:	9057      	str	r0, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010ca0:	f857 0c08 	ldr.w	r0, [r7, #-8]
 8010ca4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8010ca6:	6e59      	ldr	r1, [r3, #100]	; 0x64
 8010ca8:	4605      	mov	r5, r0
 8010caa:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010cae:	9553      	str	r5, [sp, #332]	; 0x14c
 8010cb0:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010cb4:	9056      	str	r0, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010cb6:	f857 2c04 	ldr.w	r2, [r7, #-4]
 8010cba:	e9d3 011a 	ldrd	r0, r1, [r3, #104]	; 0x68
 8010cbe:	4613      	mov	r3, r2
 8010cc0:	fb80 5303 	smull	r5, r3, r0, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010cc4:	9354      	str	r3, [sp, #336]	; 0x150
 8010cc6:	fb81 3202 	smull	r3, r2, r1, r2
    return y;
 8010cca:	f50d 7898 	add.w	r8, sp, #304	; 0x130
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010cce:	9255      	str	r2, [sp, #340]	; 0x154
		wp = imdctWin[btCurr];
 8010cd0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010cd2:	f50d 79bc 	add.w	r9, sp, #376	; 0x178
	cp = c18 + 8;
 8010cd6:	492c      	ldr	r1, [pc, #176]	; (8010d88 <xmp3fixpt_IMDCT+0xa10>)
	xp = xBuf + 8;
 8010cd8:	ad42      	add	r5, sp, #264	; 0x108
		wp = imdctWin[btCurr];
 8010cda:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8010cde:	9e04      	ldr	r6, [sp, #16]
 8010ce0:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8010ce4:	eb04 1403 	add.w	r4, r4, r3, lsl #4
	mOut = 0;
 8010ce8:	2300      	movs	r3, #0
	__asm__ volatile (
 8010cea:	9103      	str	r1, [sp, #12]
 8010cec:	f1a4 0e04 	sub.w	lr, r4, #4
 8010cf0:	461f      	mov	r7, r3
 8010cf2:	3448      	adds	r4, #72	; 0x48
		for (i = 0; i < 9; i++) {
 8010cf4:	4618      	mov	r0, r3
	mOut = 0;
 8010cf6:	9301      	str	r3, [sp, #4]
 8010cf8:	f8cd b01c 	str.w	fp, [sp, #28]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010cfc:	9903      	ldr	r1, [sp, #12]
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 8010cfe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8010d00:	f851 a904 	ldr.w	sl, [r1], #-4
 8010d04:	f855 2904 	ldr.w	r2, [r5], #-4
 8010d08:	9103      	str	r1, [sp, #12]
 8010d0a:	fb8a b303 	smull	fp, r3, sl, r3
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8010d0e:	eb03 0ba2 	add.w	fp, r3, r2, asr #2
			d = xe - xo;
 8010d12:	ebc3 0aa2 	rsb	sl, r3, r2, asr #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8010d16:	f84c bb04 	str.w	fp, [ip], #4
 8010d1a:	f85e 2f04 	ldr.w	r2, [lr, #4]!
 8010d1e:	fb8a 3202 	smull	r3, r2, sl, r2
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 8010d22:	f858 3020 	ldr.w	r3, [r8, r0, lsl #2]
 8010d26:	441a      	add	r2, r3
 8010d28:	f854 3d04 	ldr.w	r3, [r4, #-4]!
 8010d2c:	0092      	lsls	r2, r2, #2
 8010d2e:	fb8a b303 	smull	fp, r3, sl, r3
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 8010d32:	f859 ad04 	ldr.w	sl, [r9, #-4]!
			y[(i)*NBANDS]    = yLo;
 8010d36:	9904      	ldr	r1, [sp, #16]
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 8010d38:	4453      	add	r3, sl
			y[(i)*NBANDS]    = yLo;
 8010d3a:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 8010d3e:	009b      	lsls	r3, r3, #2
			y[(i)*NBANDS]    = yLo;
 8010d40:	f841 200a 	str.w	r2, [r1, sl]
	__asm__ volatile (
 8010d44:	46ba      	mov	sl, r7
			y[(17-i)*NBANDS] = yHi;
 8010d46:	f8c6 3880 	str.w	r3, [r6, #2176]	; 0x880
 8010d4a:	ea82 7ae2 	eor.w	sl, r2, r2, asr #31
 8010d4e:	ebaa 7ae2 	sub.w	sl, sl, r2, asr #31
 8010d52:	463a      	mov	r2, r7
 8010d54:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8010d58:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
			mOut |= FASTABS(yHi);
 8010d5c:	9b01      	ldr	r3, [sp, #4]
 8010d5e:	ea4a 0202 	orr.w	r2, sl, r2
		for (i = 0; i < 9; i++) {
 8010d62:	3001      	adds	r0, #1
 8010d64:	3e80      	subs	r6, #128	; 0x80
			mOut |= FASTABS(yHi);
 8010d66:	4313      	orrs	r3, r2
		for (i = 0; i < 9; i++) {
 8010d68:	2809      	cmp	r0, #9
			mOut |= FASTABS(yHi);
 8010d6a:	9301      	str	r3, [sp, #4]
		for (i = 0; i < 9; i++) {
 8010d6c:	d1c6      	bne.n	8010cfc <xmp3fixpt_IMDCT+0x984>
 8010d6e:	f8dd b01c 	ldr.w	fp, [sp, #28]
 8010d72:	e64c      	b.n	8010a0e <xmp3fixpt_IMDCT+0x696>
 8010d74:	f50d 7898 	add.w	r8, sp, #304	; 0x130
 8010d78:	980c      	ldr	r0, [sp, #48]	; 0x30
 8010d7a:	4c02      	ldr	r4, [pc, #8]	; (8010d84 <xmp3fixpt_IMDCT+0xa0c>)
 8010d7c:	4641      	mov	r1, r8
 8010d7e:	f7ff f809 	bl	800fd94 <WinPrevious.part.0>
 8010d82:	e7a5      	b.n	8010cd0 <xmp3fixpt_IMDCT+0x958>
 8010d84:	080252fc 	.word	0x080252fc
 8010d88:	08025108 	.word	0x08025108
		xCurr += 18;
 8010d8c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8010d8e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010d90:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8010d94:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8010d98:	9209      	str	r2, [sp, #36]	; 0x24
		xPrev += 9;
 8010d9a:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8010d9c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8010da0:	932b      	str	r3, [sp, #172]	; 0xac
	for (   ; i < bc->nBlocksTotal; i++) {
 8010da2:	9a02      	ldr	r2, [sp, #8]
 8010da4:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8010da6:	429a      	cmp	r2, r3
 8010da8:	f341 831c 	ble.w	80123e4 <xmp3fixpt_IMDCT+0x206c>
 8010dac:	990a      	ldr	r1, [sp, #40]	; 0x28
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010dae:	f8df 8524 	ldr.w	r8, [pc, #1316]	; 80112d4 <xmp3fixpt_IMDCT+0xf5c>
 8010db2:	2906      	cmp	r1, #6
		es = 7 - gb;
 8010db4:	f1c1 0107 	rsb	r1, r1, #7
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010db8:	f8d8 0120 	ldr.w	r0, [r8, #288]	; 0x120
		es = 7 - gb;
 8010dbc:	9127      	str	r1, [sp, #156]	; 0x9c
 8010dbe:	bfc8      	it	gt
 8010dc0:	2100      	movgt	r1, #0
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010dc2:	901b      	str	r0, [sp, #108]	; 0x6c
 8010dc4:	ee07 1a10 	vmov	s14, r1
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010dc8:	f8d8 1138 	ldr.w	r1, [r8, #312]	; 0x138
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010dcc:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010dd0:	911d      	str	r1, [sp, #116]	; 0x74
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010dd2:	f8d8 1144 	ldr.w	r1, [r8, #324]	; 0x144
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010dd6:	901c      	str	r0, [sp, #112]	; 0x70
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010dd8:	9114      	str	r1, [sp, #80]	; 0x50
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010dda:	f8d8 1124 	ldr.w	r1, [r8, #292]	; 0x124
 8010dde:	9115      	str	r1, [sp, #84]	; 0x54
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010de0:	f8d8 1130 	ldr.w	r1, [r8, #304]	; 0x130
 8010de4:	9104      	str	r1, [sp, #16]
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010de6:	f8d8 113c 	ldr.w	r1, [r8, #316]	; 0x13c
 8010dea:	911a      	str	r1, [sp, #104]	; 0x68
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010dec:	f8d8 1148 	ldr.w	r1, [r8, #328]	; 0x148
 8010df0:	9116      	str	r1, [sp, #88]	; 0x58
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010df2:	f8d8 1128 	ldr.w	r1, [r8, #296]	; 0x128
 8010df6:	9117      	str	r1, [sp, #92]	; 0x5c
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010df8:	f8d8 1134 	ldr.w	r1, [r8, #308]	; 0x134
 8010dfc:	9105      	str	r1, [sp, #20]
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010dfe:	f8d8 1140 	ldr.w	r1, [r8, #320]	; 0x140
 8010e02:	9118      	str	r1, [sp, #96]	; 0x60
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010e04:	f8d8 114c 	ldr.w	r1, [r8, #332]	; 0x14c
 8010e08:	9119      	str	r1, [sp, #100]	; 0x64
 8010e0a:	9926      	ldr	r1, [sp, #152]	; 0x98
 8010e0c:	4299      	cmp	r1, r3
 8010e0e:	f341 82c8 	ble.w	80123a2 <xmp3fixpt_IMDCT+0x202a>
 8010e12:	428a      	cmp	r2, r1
 8010e14:	9809      	ldr	r0, [sp, #36]	; 0x24
 8010e16:	9301      	str	r3, [sp, #4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010e18:	46c1      	mov	r9, r8
 8010e1a:	bfa8      	it	ge
 8010e1c:	460a      	movge	r2, r1
 8010e1e:	f100 0a48 	add.w	sl, r0, #72	; 0x48
 8010e22:	9229      	str	r2, [sp, #164]	; 0xa4
 8010e24:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8010e26:	f102 0c24 	add.w	ip, r2, #36	; 0x24
 8010e2a:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 8010e2c:	eb02 0283 	add.w	r2, r2, r3, lsl #2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010e30:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
 8010e34:	46e6      	mov	lr, ip
 8010e36:	9328      	str	r3, [sp, #160]	; 0xa0
 8010e38:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
 8010e3c:	4690      	mov	r8, r2
 8010e3e:	932a      	str	r3, [sp, #168]	; 0xa8
 8010e40:	f1ae 0324 	sub.w	r3, lr, #36	; 0x24
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8010e44:	ee07 8a90 	vmov	s15, r8
 8010e48:	ee06 3a90 	vmov	s13, r3
	if (gb < 7) {
 8010e4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010e4e:	2b06      	cmp	r3, #6
 8010e50:	f300 8088 	bgt.w	8010f64 <xmp3fixpt_IMDCT+0xbec>
			xCurr[i+0] >>= es;
 8010e54:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8010e56:	f85a 3c48 	ldr.w	r3, [sl, #-72]
 8010e5a:	4113      	asrs	r3, r2
 8010e5c:	f84a 3c48 	str.w	r3, [sl, #-72]
			xCurr[i+1] >>= es;
 8010e60:	f85a 3c44 	ldr.w	r3, [sl, #-68]
 8010e64:	4113      	asrs	r3, r2
 8010e66:	f84a 3c44 	str.w	r3, [sl, #-68]
			*xPrev++ >>= es;
 8010e6a:	f85e 3c24 	ldr.w	r3, [lr, #-36]
 8010e6e:	4113      	asrs	r3, r2
 8010e70:	f84e 3c24 	str.w	r3, [lr, #-36]
			xCurr[i+0] >>= es;
 8010e74:	f85a 3c40 	ldr.w	r3, [sl, #-64]
 8010e78:	4113      	asrs	r3, r2
 8010e7a:	f84a 3c40 	str.w	r3, [sl, #-64]
			xCurr[i+1] >>= es;
 8010e7e:	f85a 3c3c 	ldr.w	r3, [sl, #-60]
 8010e82:	4113      	asrs	r3, r2
 8010e84:	f84a 3c3c 	str.w	r3, [sl, #-60]
			*xPrev++ >>= es;
 8010e88:	f85e 3c20 	ldr.w	r3, [lr, #-32]
 8010e8c:	4113      	asrs	r3, r2
 8010e8e:	f84e 3c20 	str.w	r3, [lr, #-32]
			xCurr[i+0] >>= es;
 8010e92:	f85a 3c38 	ldr.w	r3, [sl, #-56]
 8010e96:	4113      	asrs	r3, r2
 8010e98:	f84a 3c38 	str.w	r3, [sl, #-56]
			xCurr[i+1] >>= es;
 8010e9c:	f85a 3c34 	ldr.w	r3, [sl, #-52]
 8010ea0:	4113      	asrs	r3, r2
 8010ea2:	f84a 3c34 	str.w	r3, [sl, #-52]
			*xPrev++ >>= es;
 8010ea6:	f85e 3c1c 	ldr.w	r3, [lr, #-28]
 8010eaa:	4113      	asrs	r3, r2
 8010eac:	f84e 3c1c 	str.w	r3, [lr, #-28]
			xCurr[i+0] >>= es;
 8010eb0:	f85a 3c30 	ldr.w	r3, [sl, #-48]
 8010eb4:	4113      	asrs	r3, r2
 8010eb6:	f84a 3c30 	str.w	r3, [sl, #-48]
			xCurr[i+1] >>= es;
 8010eba:	f85a 3c2c 	ldr.w	r3, [sl, #-44]
 8010ebe:	4113      	asrs	r3, r2
 8010ec0:	f84a 3c2c 	str.w	r3, [sl, #-44]
			*xPrev++ >>= es;
 8010ec4:	f85e 3c18 	ldr.w	r3, [lr, #-24]
 8010ec8:	4113      	asrs	r3, r2
 8010eca:	f84e 3c18 	str.w	r3, [lr, #-24]
			xCurr[i+0] >>= es;
 8010ece:	f85a 3c28 	ldr.w	r3, [sl, #-40]
 8010ed2:	4113      	asrs	r3, r2
 8010ed4:	f84a 3c28 	str.w	r3, [sl, #-40]
			xCurr[i+1] >>= es;
 8010ed8:	f85a 3c24 	ldr.w	r3, [sl, #-36]
 8010edc:	4113      	asrs	r3, r2
 8010ede:	f84a 3c24 	str.w	r3, [sl, #-36]
			*xPrev++ >>= es;
 8010ee2:	f85e 3c14 	ldr.w	r3, [lr, #-20]
 8010ee6:	4113      	asrs	r3, r2
 8010ee8:	f84e 3c14 	str.w	r3, [lr, #-20]
			xCurr[i+0] >>= es;
 8010eec:	f85a 3c20 	ldr.w	r3, [sl, #-32]
 8010ef0:	4113      	asrs	r3, r2
 8010ef2:	f84a 3c20 	str.w	r3, [sl, #-32]
			xCurr[i+1] >>= es;
 8010ef6:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
 8010efa:	4113      	asrs	r3, r2
 8010efc:	f84a 3c1c 	str.w	r3, [sl, #-28]
			*xPrev++ >>= es;
 8010f00:	f85e 3c10 	ldr.w	r3, [lr, #-16]
 8010f04:	4113      	asrs	r3, r2
 8010f06:	f84e 3c10 	str.w	r3, [lr, #-16]
			xCurr[i+0] >>= es;
 8010f0a:	f85a 3c18 	ldr.w	r3, [sl, #-24]
 8010f0e:	4113      	asrs	r3, r2
 8010f10:	f84a 3c18 	str.w	r3, [sl, #-24]
			xCurr[i+1] >>= es;
 8010f14:	f85a 3c14 	ldr.w	r3, [sl, #-20]
 8010f18:	4113      	asrs	r3, r2
 8010f1a:	f84a 3c14 	str.w	r3, [sl, #-20]
			*xPrev++ >>= es;
 8010f1e:	f85e 3c0c 	ldr.w	r3, [lr, #-12]
 8010f22:	4113      	asrs	r3, r2
 8010f24:	f84e 3c0c 	str.w	r3, [lr, #-12]
			xCurr[i+0] >>= es;
 8010f28:	f85a 3c10 	ldr.w	r3, [sl, #-16]
 8010f2c:	4113      	asrs	r3, r2
 8010f2e:	f84a 3c10 	str.w	r3, [sl, #-16]
			xCurr[i+1] >>= es;
 8010f32:	f85a 3c0c 	ldr.w	r3, [sl, #-12]
 8010f36:	4113      	asrs	r3, r2
 8010f38:	f84a 3c0c 	str.w	r3, [sl, #-12]
			*xPrev++ >>= es;
 8010f3c:	f85e 3c08 	ldr.w	r3, [lr, #-8]
 8010f40:	4113      	asrs	r3, r2
 8010f42:	f84e 3c08 	str.w	r3, [lr, #-8]
			xCurr[i+0] >>= es;
 8010f46:	f85a 3c08 	ldr.w	r3, [sl, #-8]
 8010f4a:	4113      	asrs	r3, r2
 8010f4c:	f84a 3c08 	str.w	r3, [sl, #-8]
			xCurr[i+1] >>= es;
 8010f50:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 8010f54:	4113      	asrs	r3, r2
 8010f56:	f84a 3c04 	str.w	r3, [sl, #-4]
			*xPrev++ >>= es;
 8010f5a:	f85e 3c04 	ldr.w	r3, [lr, #-4]
 8010f5e:	4113      	asrs	r3, r2
 8010f60:	f84e 3c04 	str.w	r3, [lr, #-4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010f64:	f85a 0c0c 	ldr.w	r0, [sl, #-12]
 8010f68:	f85a 6c18 	ldr.w	r6, [sl, #-24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010f6c:	f85a 3c24 	ldr.w	r3, [sl, #-36]
	x4 -= x5;
 8010f70:	1a35      	subs	r5, r6, r0
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010f72:	f85a 2c30 	ldr.w	r2, [sl, #-48]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010f76:	f85a 4c48 	ldr.w	r4, [sl, #-72]
	x3 -= x4;
 8010f7a:	1b5b      	subs	r3, r3, r5
 8010f7c:	4fd1      	ldr	r7, [pc, #836]	; (80112c4 <xmp3fixpt_IMDCT+0xf4c>)
	x2 -= x3;
 8010f7e:	eba2 0c03 	sub.w	ip, r2, r3
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010f82:	f85a 2c3c 	ldr.w	r2, [sl, #-60]
	x3 -= x5;
 8010f86:	1a1b      	subs	r3, r3, r0
	x1 -= x2;
 8010f88:	eba2 020c 	sub.w	r2, r2, ip
	x0 -= x1;
 8010f8c:	1aa6      	subs	r6, r4, r2
	x1 -= x3;
 8010f8e:	1ad2      	subs	r2, r2, r3
	x0 >>= 1;
 8010f90:	1076      	asrs	r6, r6, #1
	x1 >>= 1;
 8010f92:	1052      	asrs	r2, r2, #1
 8010f94:	fb87 4c0c 	smull	r4, ip, r7, ip
	a1 = x0 + (x4 >> 1);
 8010f98:	eb06 0765 	add.w	r7, r6, r5, asr #1
	a2 = x0 - x4;
 8010f9c:	1b76      	subs	r6, r6, r5
	x0 = a1 + a0;
 8010f9e:	eb07 014c 	add.w	r1, r7, ip, lsl #1
	a2 = x0 - x4;
 8010fa2:	9603      	str	r6, [sp, #12]
	x4 = a1 - a0;
 8010fa4:	eba7 0c4c 	sub.w	ip, r7, ip, lsl #1
 8010fa8:	4fc6      	ldr	r7, [pc, #792]	; (80112c4 <xmp3fixpt_IMDCT+0xf4c>)
	x0 = a1 + a0;
 8010faa:	9106      	str	r1, [sp, #24]
 8010fac:	fb87 4303 	smull	r4, r3, r7, r3
	a1 = x1 + (x5 >> 1);
 8010fb0:	eb02 0560 	add.w	r5, r2, r0, asr #1
 8010fb4:	49c4      	ldr	r1, [pc, #784]	; (80112c8 <xmp3fixpt_IMDCT+0xf50>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8010fb6:	005c      	lsls	r4, r3, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010fb8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8010fbc:	fb81 7303 	smull	r7, r3, r1, r3
 8010fc0:	49c2      	ldr	r1, [pc, #776]	; (80112cc <xmp3fixpt_IMDCT+0xf54>)
	a2 = x1 - x5;
 8010fc2:	1a10      	subs	r0, r2, r0
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010fc4:	009b      	lsls	r3, r3, #2
 8010fc6:	fb81 2000 	smull	r2, r0, r1, r0
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010fca:	0082      	lsls	r2, r0, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010fcc:	1b2d      	subs	r5, r5, r4
 8010fce:	48c0      	ldr	r0, [pc, #768]	; (80112d0 <xmp3fixpt_IMDCT+0xf58>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010fd0:	9207      	str	r2, [sp, #28]
 8010fd2:	fb80 2505 	smull	r2, r5, r0, r5
	*out = x0 + x1;	out++;
 8010fd6:	9e06      	ldr	r6, [sp, #24]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010fd8:	f85a 1c08 	ldr.w	r1, [sl, #-8]
	*out = x0 + x1;	out++;
 8010fdc:	441e      	add	r6, r3
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010fde:	f85a 2c14 	ldr.w	r2, [sl, #-20]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010fe2:	f85a 4c2c 	ldr.w	r4, [sl, #-44]
	*out = x0 + x1;	out++;
 8010fe6:	960e      	str	r6, [sp, #56]	; 0x38
	x4 -= x5;
 8010fe8:	1a50      	subs	r0, r2, r1
	*out = x0 - x1;
 8010fea:	9e06      	ldr	r6, [sp, #24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010fec:	f85a 2c20 	ldr.w	r2, [sl, #-32]
	*out = x0 - x1;
 8010ff0:	1af3      	subs	r3, r6, r3
	*out = x2 + x3;	out++;
 8010ff2:	9e03      	ldr	r6, [sp, #12]
	x3 -= x4;
 8010ff4:	1a12      	subs	r2, r2, r0
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010ff6:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	*out = x0 - x1;
 8010ffa:	9312      	str	r3, [sp, #72]	; 0x48
	*out = x2 + x3;	out++;
 8010ffc:	9b07      	ldr	r3, [sp, #28]
	x2 -= x3;
 8010ffe:	1aa7      	subs	r7, r4, r2
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011000:	f85a 4c38 	ldr.w	r4, [sl, #-56]
	x3 -= x5;
 8011004:	1a52      	subs	r2, r2, r1
	*out = x2 + x3;	out++;
 8011006:	441e      	add	r6, r3
	x1 -= x2;
 8011008:	eba4 0b07 	sub.w	fp, r4, r7
 801100c:	463c      	mov	r4, r7
	*out = x2 + x3;	out++;
 801100e:	960f      	str	r6, [sp, #60]	; 0x3c
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011010:	f85a 7c44 	ldr.w	r7, [sl, #-68]
	*out = x2 - x3;	out++;
 8011014:	9e03      	ldr	r6, [sp, #12]
	x0 -= x1;
 8011016:	eba7 070b 	sub.w	r7, r7, fp
	x1 -= x3;
 801101a:	ebab 0b02 	sub.w	fp, fp, r2
	*out = x2 - x3;	out++;
 801101e:	1af6      	subs	r6, r6, r3
	*out = x4 + x5;	out++;
 8011020:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
	*out = x4 - x5;	out++;
 8011024:	ebac 0c85 	sub.w	ip, ip, r5, lsl #2
 8011028:	4da6      	ldr	r5, [pc, #664]	; (80112c4 <xmp3fixpt_IMDCT+0xf4c>)
	x0 >>= 1;
 801102a:	107f      	asrs	r7, r7, #1
	*out = x4 + x5;	out++;
 801102c:	9310      	str	r3, [sp, #64]	; 0x40
	x1 >>= 1;
 801102e:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	*out = x4 - x5;	out++;
 8011032:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
 8011036:	fb85 3404 	smull	r3, r4, r5, r4
	a1 = x0 + (x4 >> 1);
 801103a:	eb07 0360 	add.w	r3, r7, r0, asr #1
	a2 = x0 - x4;
 801103e:	1a38      	subs	r0, r7, r0
	x0 = a1 + a0;
 8011040:	eb03 0c44 	add.w	ip, r3, r4, lsl #1
	a2 = x0 - x4;
 8011044:	9003      	str	r0, [sp, #12]
	x0 = a1 + a0;
 8011046:	f8cd c018 	str.w	ip, [sp, #24]
	x4 = a1 - a0;
 801104a:	eba3 0c44 	sub.w	ip, r3, r4, lsl #1
 801104e:	f8cd c01c 	str.w	ip, [sp, #28]
 8011052:	fb85 3202 	smull	r3, r2, r5, r2
	a1 = x1 + (x5 >> 1);
 8011056:	eb0b 0461 	add.w	r4, fp, r1, asr #1
 801105a:	4d9b      	ldr	r5, [pc, #620]	; (80112c8 <xmp3fixpt_IMDCT+0xf50>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 801105c:	0053      	lsls	r3, r2, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801105e:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 8011062:	fb85 0202 	smull	r0, r2, r5, r2
 8011066:	0092      	lsls	r2, r2, #2
	a2 = x1 - x5;
 8011068:	ebab 0b01 	sub.w	fp, fp, r1
 801106c:	4897      	ldr	r0, [pc, #604]	; (80112cc <xmp3fixpt_IMDCT+0xf54>)
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801106e:	9208      	str	r2, [sp, #32]
 8011070:	fb80 2b0b 	smull	r2, fp, r0, fp
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011074:	ea4f 0c8b 	mov.w	ip, fp, lsl #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011078:	1ae4      	subs	r4, r4, r3
 801107a:	4a95      	ldr	r2, [pc, #596]	; (80112d0 <xmp3fixpt_IMDCT+0xf58>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801107c:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
 8011080:	fb82 3404 	smull	r3, r4, r2, r4
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8011084:	f85a 5c04 	ldr.w	r5, [sl, #-4]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011088:	00a1      	lsls	r1, r4, #2
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 801108a:	f85a 3c10 	ldr.w	r3, [sl, #-16]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801108e:	f85a 2c28 	ldr.w	r2, [sl, #-40]
	x4 -= x5;
 8011092:	1b5f      	subs	r7, r3, r5
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8011094:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011098:	9123      	str	r1, [sp, #140]	; 0x8c
	x3 -= x4;
 801109a:	1bdb      	subs	r3, r3, r7
	*out = x4 - x5;	out++;
 801109c:	9907      	ldr	r1, [sp, #28]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801109e:	f85a cc40 	ldr.w	ip, [sl, #-64]
	x2 -= x3;
 80110a2:	1ad2      	subs	r2, r2, r3
	x3 -= x5;
 80110a4:	1b58      	subs	r0, r3, r5
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 80110a6:	f85a 3c34 	ldr.w	r3, [sl, #-52]
	*out = x4 - x5;	out++;
 80110aa:	eba1 0a84 	sub.w	sl, r1, r4, lsl #2
	*out = x2 - x3;	out++;
 80110ae:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80110b0:	9c03      	ldr	r4, [sp, #12]
	x1 -= x2;
 80110b2:	1a9b      	subs	r3, r3, r2
	*out = x2 - x3;	out++;
 80110b4:	1a64      	subs	r4, r4, r1
	*out = x0 - x1;
 80110b6:	9908      	ldr	r1, [sp, #32]
	x0 -= x1;
 80110b8:	ebac 0c03 	sub.w	ip, ip, r3
	x1 -= x3;
 80110bc:	1a1b      	subs	r3, r3, r0
	*out = x2 - x3;	out++;
 80110be:	940c      	str	r4, [sp, #48]	; 0x30
	*out = x0 - x1;
 80110c0:	9c06      	ldr	r4, [sp, #24]
	x0 >>= 1;
 80110c2:	ea4f 0c6c 	mov.w	ip, ip, asr #1
	x1 >>= 1;
 80110c6:	105b      	asrs	r3, r3, #1
	*out = x0 - x1;
 80110c8:	1a64      	subs	r4, r4, r1
 80110ca:	497e      	ldr	r1, [pc, #504]	; (80112c4 <xmp3fixpt_IMDCT+0xf4c>)
 80110cc:	940d      	str	r4, [sp, #52]	; 0x34
 80110ce:	fb81 4202 	smull	r4, r2, r1, r2
	a1 = x0 + (x4 >> 1);
 80110d2:	eb0c 0467 	add.w	r4, ip, r7, asr #1
	a2 = x0 - x4;
 80110d6:	ebac 0c07 	sub.w	ip, ip, r7
 80110da:	f8cd c078 	str.w	ip, [sp, #120]	; 0x78
	x0 = a1 + a0;
 80110de:	eb04 0c42 	add.w	ip, r4, r2, lsl #1
	x4 = a1 - a0;
 80110e2:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
 80110e6:	921f      	str	r2, [sp, #124]	; 0x7c
 80110e8:	fb81 2000 	smull	r2, r0, r1, r0
	a1 = x1 + (x5 >> 1);
 80110ec:	eb03 0265 	add.w	r2, r3, r5, asr #1
 80110f0:	4975      	ldr	r1, [pc, #468]	; (80112c8 <xmp3fixpt_IMDCT+0xf50>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 80110f2:	0044      	lsls	r4, r0, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80110f4:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80110f8:	fb81 7000 	smull	r7, r0, r1, r0
	a2 = x1 - x5;
 80110fc:	1b5b      	subs	r3, r3, r5
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80110fe:	0085      	lsls	r5, r0, #2
 8011100:	4972      	ldr	r1, [pc, #456]	; (80112cc <xmp3fixpt_IMDCT+0xf54>)
 8011102:	9520      	str	r5, [sp, #128]	; 0x80
 8011104:	fb81 0303 	smull	r0, r3, r1, r3
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011108:	0098      	lsls	r0, r3, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 801110a:	1b12      	subs	r2, r2, r4
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801110c:	9021      	str	r0, [sp, #132]	; 0x84
 801110e:	4870      	ldr	r0, [pc, #448]	; (80112d0 <xmp3fixpt_IMDCT+0xf58>)
 8011110:	fb80 3202 	smull	r3, r2, r0, r2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011114:	0090      	lsls	r0, r2, #2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011116:	f85e 2c24 	ldr.w	r2, [lr, #-36]
 801111a:	46f3      	mov	fp, lr
 801111c:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
 801111e:	4613      	mov	r3, r2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011120:	9022      	str	r0, [sp, #136]	; 0x88
 8011122:	fb87 0303 	smull	r0, r3, r7, r3
 8011126:	9f28      	ldr	r7, [sp, #160]	; 0xa0
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011128:	934c      	str	r3, [sp, #304]	; 0x130
 801112a:	fb87 0202 	smull	r0, r2, r7, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 801112e:	925d      	str	r2, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011130:	f85e 4c20 	ldr.w	r4, [lr, #-32]
 8011134:	f8d9 2088 	ldr.w	r2, [r9, #136]	; 0x88
 8011138:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 801113c:	4625      	mov	r5, r4
 801113e:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011142:	954d      	str	r5, [sp, #308]	; 0x134
 8011144:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011148:	945c      	str	r4, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801114a:	f85e 4c1c 	ldr.w	r4, [lr, #-28]
 801114e:	f8d9 2084 	ldr.w	r2, [r9, #132]	; 0x84
 8011152:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
 8011156:	4625      	mov	r5, r4
 8011158:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801115c:	954e      	str	r5, [sp, #312]	; 0x138
 801115e:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011162:	945b      	str	r4, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011164:	f85e 4c18 	ldr.w	r4, [lr, #-24]
 8011168:	f8d9 2080 	ldr.w	r2, [r9, #128]	; 0x80
 801116c:	f8d9 0054 	ldr.w	r0, [r9, #84]	; 0x54
 8011170:	4625      	mov	r5, r4
 8011172:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011176:	954f      	str	r5, [sp, #316]	; 0x13c
 8011178:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801117c:	945a      	str	r4, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801117e:	f85e 4c14 	ldr.w	r4, [lr, #-20]
 8011182:	f8d9 207c 	ldr.w	r2, [r9, #124]	; 0x7c
 8011186:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 801118a:	4625      	mov	r5, r4
 801118c:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011190:	9550      	str	r5, [sp, #320]	; 0x140
 8011192:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011196:	9459      	str	r4, [sp, #356]	; 0x164
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011198:	f85e 4c10 	ldr.w	r4, [lr, #-16]
 801119c:	f8d9 2078 	ldr.w	r2, [r9, #120]	; 0x78
 80111a0:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 80111a4:	4625      	mov	r5, r4
 80111a6:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111aa:	9551      	str	r5, [sp, #324]	; 0x144
 80111ac:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111b0:	9458      	str	r4, [sp, #352]	; 0x160
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111b2:	f85e 4c0c 	ldr.w	r4, [lr, #-12]
 80111b6:	f8d9 2074 	ldr.w	r2, [r9, #116]	; 0x74
 80111ba:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 80111be:	4625      	mov	r5, r4
 80111c0:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111c4:	9552      	str	r5, [sp, #328]	; 0x148
 80111c6:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111ca:	9457      	str	r4, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111cc:	f85e 4c08 	ldr.w	r4, [lr, #-8]
 80111d0:	f8d9 2070 	ldr.w	r2, [r9, #112]	; 0x70
 80111d4:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 80111d8:	4625      	mov	r5, r4
 80111da:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111de:	9553      	str	r5, [sp, #332]	; 0x14c
 80111e0:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111e4:	9456      	str	r4, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111e6:	f85e 4c04 	ldr.w	r4, [lr, #-4]
 80111ea:	e9d9 021a 	ldrd	r0, r2, [r9, #104]	; 0x68
 80111ee:	4625      	mov	r5, r4
 80111f0:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111f4:	9554      	str	r5, [sp, #336]	; 0x150
 80111f6:	fb82 0404 	smull	r0, r4, r2, r4
	__asm__ volatile (
 80111fa:	2200      	movs	r2, #0
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111fc:	9455      	str	r4, [sp, #340]	; 0x154
		yLo = (xPrevWin[ 0+i] << 2);
 80111fe:	009b      	lsls	r3, r3, #2
 8011200:	4614      	mov	r4, r2
 8011202:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011206:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 801120a:	f848 3b04 	str.w	r3, [r8], #4
 801120e:	4610      	mov	r0, r2
		yLo = (xPrevWin[ 3+i] << 2);
 8011210:	9b4f      	ldr	r3, [sp, #316]	; 0x13c
 8011212:	009b      	lsls	r3, r3, #2
 8011214:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8011218:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 801121c:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801121e:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8011220:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8011222:	f8c8 317c 	str.w	r3, [r8, #380]	; 0x17c
 8011226:	fb87 3404 	smull	r3, r4, r7, r4
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801122a:	9b52      	ldr	r3, [sp, #328]	; 0x148
 801122c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 8011230:	4614      	mov	r4, r2
 8011232:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011236:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 801123a:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801123c:	991c      	ldr	r1, [sp, #112]	; 0x70
 801123e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8011240:	f8c8 32fc 	str.w	r3, [r8, #764]	; 0x2fc
 8011244:	fb81 3404 	smull	r3, r4, r1, r4
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8011248:	9b55      	ldr	r3, [sp, #340]	; 0x154
 801124a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 801124e:	4614      	mov	r4, r2
 8011250:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011254:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8011258:	f8c8 347c 	str.w	r3, [r8, #1148]	; 0x47c
 801125c:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801125e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011260:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 8011262:	fb85 4303 	smull	r4, r3, r5, r3
 8011266:	4654      	mov	r4, sl
 8011268:	fb87 5404 	smull	r5, r4, r7, r4
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 801126c:	441c      	add	r4, r3
 801126e:	9b58      	ldr	r3, [sp, #352]	; 0x160
 8011270:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 8011274:	4614      	mov	r4, r2
 8011276:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 801127a:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 801127e:	f8c8 35fc 	str.w	r3, [r8, #1532]	; 0x5fc
 8011282:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011284:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011286:	9f14      	ldr	r7, [sp, #80]	; 0x50
 8011288:	fb87 4303 	smull	r4, r3, r7, r3
 801128c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 801128e:	fb81 5404 	smull	r5, r4, r1, r4
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011292:	441c      	add	r4, r3
 8011294:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
 8011296:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 801129a:	4614      	mov	r4, r2
 801129c:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 80112a0:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 80112a4:	f8c8 377c 	str.w	r3, [r8, #1916]	; 0x77c
 80112a8:	4320      	orrs	r0, r4
		yLo = (xPrevWin[ 0+i] << 2);
 80112aa:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 80112ac:	4614      	mov	r4, r2
 80112ae:	009b      	lsls	r3, r3, #2
 80112b0:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 80112b4:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 80112b8:	f8c8 307c 	str.w	r3, [r8, #124]	; 0x7c
 80112bc:	4320      	orrs	r0, r4
		yLo = (xPrevWin[ 3+i] << 2);
 80112be:	9b50      	ldr	r3, [sp, #320]	; 0x140
 80112c0:	4614      	mov	r4, r2
 80112c2:	e009      	b.n	80112d8 <xmp3fixpt_IMDCT+0xf60>
 80112c4:	6ed9eba1 	.word	0x6ed9eba1
 80112c8:	7ba3751d 	.word	0x7ba3751d
 80112cc:	5a82799a 	.word	0x5a82799a
 80112d0:	2120fb83 	.word	0x2120fb83
 80112d4:	080252fc 	.word	0x080252fc
 80112d8:	009b      	lsls	r3, r3, #2
 80112da:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 80112de:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 80112e2:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80112e4:	9f15      	ldr	r7, [sp, #84]	; 0x54
 80112e6:	4634      	mov	r4, r6
 80112e8:	f8c8 31fc 	str.w	r3, [r8, #508]	; 0x1fc
 80112ec:	fb87 3404 	smull	r3, r4, r7, r4
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80112f0:	9b53      	ldr	r3, [sp, #332]	; 0x14c
 80112f2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 80112f6:	4614      	mov	r4, r2
 80112f8:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 80112fc:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8011300:	4304      	orrs	r4, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011302:	9904      	ldr	r1, [sp, #16]
 8011304:	f8c8 337c 	str.w	r3, [r8, #892]	; 0x37c
 8011308:	fb81 3606 	smull	r3, r6, r1, r6
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 801130c:	9b56      	ldr	r3, [sp, #344]	; 0x158
	__asm__ volatile (
 801130e:	4610      	mov	r0, r2
 8011310:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8011314:	ea86 70e6 	eor.w	r0, r6, r6, asr #31
 8011318:	eba0 70e6 	sub.w	r0, r0, r6, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 801131c:	f8c8 64fc 	str.w	r6, [r8, #1276]	; 0x4fc
 8011320:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011322:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011324:	9e1a      	ldr	r6, [sp, #104]	; 0x68
 8011326:	fb86 4303 	smull	r4, r3, r6, r3
 801132a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801132c:	fb87 5404 	smull	r5, r4, r7, r4
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8011330:	441c      	add	r4, r3
 8011332:	9b59      	ldr	r3, [sp, #356]	; 0x164
 8011334:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	__asm__ volatile (
 8011338:	4614      	mov	r4, r2
 801133a:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 801133e:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8011342:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011344:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8011346:	9e16      	ldr	r6, [sp, #88]	; 0x58
 8011348:	f8c8 367c 	str.w	r3, [r8, #1660]	; 0x67c
 801134c:	fb86 3505 	smull	r3, r5, r6, r5
 8011350:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8011352:	fb81 3404 	smull	r3, r4, r1, r4
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011356:	192b      	adds	r3, r5, r4
 8011358:	9c5c      	ldr	r4, [sp, #368]	; 0x170
 801135a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	__asm__ volatile (
 801135e:	4614      	mov	r4, r2
 8011360:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011364:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011368:	f8c8 37fc 	str.w	r3, [r8, #2044]	; 0x7fc
 801136c:	4320      	orrs	r0, r4
		yLo = (xPrevWin[ 0+i] << 2);
 801136e:	9b4e      	ldr	r3, [sp, #312]	; 0x138
 8011370:	4614      	mov	r4, r2
 8011372:	009b      	lsls	r3, r3, #2
 8011374:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011378:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 801137c:	f8c8 30fc 	str.w	r3, [r8, #252]	; 0xfc
 8011380:	4320      	orrs	r0, r4
		yLo = (xPrevWin[ 3+i] << 2);
 8011382:	9b51      	ldr	r3, [sp, #324]	; 0x144
 8011384:	4614      	mov	r4, r2
 8011386:	009b      	lsls	r3, r3, #2
 8011388:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 801138c:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8011390:	f8c8 327c 	str.w	r3, [r8, #636]	; 0x27c
 8011394:	4304      	orrs	r4, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011396:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8011398:	9e17      	ldr	r6, [sp, #92]	; 0x5c
 801139a:	fb86 0303 	smull	r0, r3, r6, r3
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801139e:	9854      	ldr	r0, [sp, #336]	; 0x150
 80113a0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
	__asm__ volatile (
 80113a4:	4613      	mov	r3, r2
 80113a6:	ea80 73e0 	eor.w	r3, r0, r0, asr #31
 80113aa:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80113ae:	431c      	orrs	r4, r3
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113b0:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80113b2:	9f05      	ldr	r7, [sp, #20]
 80113b4:	f8c8 03fc 	str.w	r0, [r8, #1020]	; 0x3fc
 80113b8:	fb87 3505 	smull	r3, r5, r7, r5
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 80113bc:	9b57      	ldr	r3, [sp, #348]	; 0x15c
	__asm__ volatile (
 80113be:	4610      	mov	r0, r2
 80113c0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80113c4:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 80113c8:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 80113cc:	f8c8 357c 	str.w	r3, [r8, #1404]	; 0x57c
 80113d0:	4304      	orrs	r4, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80113d4:	9918      	ldr	r1, [sp, #96]	; 0x60
 80113d6:	fb81 0303 	smull	r0, r3, r1, r3
 80113da:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80113dc:	fb86 0505 	smull	r0, r5, r6, r5
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80113e0:	985a      	ldr	r0, [sp, #360]	; 0x168
 80113e2:	442b      	add	r3, r5
 80113e4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
	__asm__ volatile (
 80113e8:	4610      	mov	r0, r2
 80113ea:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 80113ee:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 80113f2:	f8c8 36fc 	str.w	r3, [r8, #1788]	; 0x6fc
 80113f6:	4320      	orrs	r0, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113f8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80113fa:	9e19      	ldr	r6, [sp, #100]	; 0x64
 80113fc:	fb86 4303 	smull	r4, r3, r6, r3
 8011400:	4654      	mov	r4, sl
 8011402:	fb87 5404 	smull	r5, r4, r7, r4
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011406:	441c      	add	r4, r3
 8011408:	9b5d      	ldr	r3, [sp, #372]	; 0x174
 801140a:	eb04 0483 	add.w	r4, r4, r3, lsl #2
	__asm__ volatile (
 801140e:	ea84 72e4 	eor.w	r2, r4, r4, asr #31
 8011412:	eba2 72e4 	sub.w	r2, r2, r4, asr #31
	*out = x0 + x1;	out++;
 8011416:	9906      	ldr	r1, [sp, #24]
	*out = x2 + x3;	out++;
 8011418:	9b03      	ldr	r3, [sp, #12]
	*out = x0 + x1;	out++;
 801141a:	9d08      	ldr	r5, [sp, #32]
	*out = x2 + x3;	out++;
 801141c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
	*out = x0 + x1;	out++;
 801141e:	194d      	adds	r5, r1, r5
	*out = x4 + x5;	out++;
 8011420:	9923      	ldr	r1, [sp, #140]	; 0x8c
	*out = x2 + x3;	out++;
 8011422:	199f      	adds	r7, r3, r6
	*out = x4 + x5;	out++;
 8011424:	9b07      	ldr	r3, [sp, #28]
		*xPrev++ = xBuf[i] >> 2;
 8011426:	10ad      	asrs	r5, r5, #2
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011428:	f8c8 487c 	str.w	r4, [r8, #2172]	; 0x87c
	*out = x4 + x5;	out++;
 801142c:	440b      	add	r3, r1
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801142e:	ea40 0402 	orr.w	r4, r0, r2
		*xPrev++ = xBuf[i] >> 2;
 8011432:	f84e 5c24 	str.w	r5, [lr, #-36]
 8011436:	10bf      	asrs	r7, r7, #2
	*out = x0 + x1;	out++;
 8011438:	9d20      	ldr	r5, [sp, #128]	; 0x80
		*xPrev++ = xBuf[i] >> 2;
 801143a:	109b      	asrs	r3, r3, #2
 801143c:	f84e 7c20 	str.w	r7, [lr, #-32]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011440:	ee16 1a90 	vmov	r1, s13
		*xPrev++ = xBuf[i] >> 2;
 8011444:	f84e 3c1c 	str.w	r3, [lr, #-28]
	*out = x0 + x1;	out++;
 8011448:	eb0c 0305 	add.w	r3, ip, r5
	*out = x0 - x1;
 801144c:	ebac 0c05 	sub.w	ip, ip, r5
	*out = x2 + x3;	out++;
 8011450:	9d21      	ldr	r5, [sp, #132]	; 0x84
		*xPrev++ = xBuf[i] >> 2;
 8011452:	109b      	asrs	r3, r3, #2
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011454:	ee17 0a90 	vmov	r0, s15
		*xPrev++ = xBuf[i] >> 2;
 8011458:	f84e 3c18 	str.w	r3, [lr, #-24]
 801145c:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8011460:	f84e 3c04 	str.w	r3, [lr, #-4]
	*out = x2 + x3;	out++;
 8011464:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8011466:	195a      	adds	r2, r3, r5
	*out = x2 - x3;	out++;
 8011468:	1b5b      	subs	r3, r3, r5
	*out = x4 + x5;	out++;
 801146a:	9d22      	ldr	r5, [sp, #136]	; 0x88
		*xPrev++ = xBuf[i] >> 2;
 801146c:	1092      	asrs	r2, r2, #2
 801146e:	109b      	asrs	r3, r3, #2
 8011470:	f84e 2c14 	str.w	r2, [lr, #-20]
	*out = x4 + x5;	out++;
 8011474:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
		*xPrev++ = xBuf[i] >> 2;
 8011476:	f84e 3c08 	str.w	r3, [lr, #-8]
	*out = x4 + x5;	out++;
 801147a:	1953      	adds	r3, r2, r5
	*out = x4 - x5;	out++;
 801147c:	1b52      	subs	r2, r2, r5
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801147e:	9d01      	ldr	r5, [sp, #4]
		*xPrev++ = xBuf[i] >> 2;
 8011480:	1092      	asrs	r2, r2, #2
 8011482:	109b      	asrs	r3, r3, #2
 8011484:	f84e 2c0c 	str.w	r2, [lr, #-12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011488:	462a      	mov	r2, r5
	for (   ; i < bc->nBlocksTotal; i++) {
 801148a:	3501      	adds	r5, #1
		*xPrev++ = xBuf[i] >> 2;
 801148c:	f84e 3c10 	str.w	r3, [lr, #-16]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011490:	ee17 3a10 	vmov	r3, s14
	for (   ; i < bc->nBlocksTotal; i++) {
 8011494:	9501      	str	r5, [sp, #4]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011496:	f7fe fcef 	bl	800fe78 <FreqInvertRescale>
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 801149a:	9b00      	ldr	r3, [sp, #0]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801149c:	4320      	orrs	r0, r4
	for (   ; i < bc->nBlocksTotal; i++) {
 801149e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80114a0:	f10b 0e24 	add.w	lr, fp, #36	; 0x24
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80114a4:	4303      	orrs	r3, r0
	for (   ; i < bc->nBlocksTotal; i++) {
 80114a6:	f107 0a48 	add.w	sl, r7, #72	; 0x48
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80114aa:	9300      	str	r3, [sp, #0]
	for (   ; i < bc->nBlocksTotal; i++) {
 80114ac:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 80114ae:	429d      	cmp	r5, r3
 80114b0:	f6ff acc6 	blt.w	8010e40 <xmp3fixpt_IMDCT+0xac8>
 80114b4:	46c8      	mov	r8, r9
 80114b6:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
 80114ba:	4293      	cmp	r3, r2
 80114bc:	f340 835a 	ble.w	8011b74 <xmp3fixpt_IMDCT+0x17fc>
 80114c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80114c2:	f10b 0a24 	add.w	sl, fp, #36	; 0x24
 80114c6:	9a01      	ldr	r2, [sp, #4]
 80114c8:	f103 0948 	add.w	r9, r3, #72	; 0x48
		wpLo = imdctWin[btPrev] + 18;
 80114cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80114ce:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 80114d2:	eb08 1b03 	add.w	fp, r8, r3, lsl #4
 80114d6:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 80114d8:	f04f 0800 	mov.w	r8, #0
 80114dc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80114e0:	f8cd b088 	str.w	fp, [sp, #136]	; 0x88
 80114e4:	9303      	str	r3, [sp, #12]
 80114e6:	e1b1      	b.n	801184c <xmp3fixpt_IMDCT+0x14d4>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80114e8:	9822      	ldr	r0, [sp, #136]	; 0x88
 80114ea:	f85a 4c24 	ldr.w	r4, [sl, #-36]
 80114ee:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80114f2:	6c81      	ldr	r1, [r0, #72]	; 0x48
 80114f4:	4623      	mov	r3, r4
 80114f6:	fb81 5303 	smull	r5, r3, r1, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 80114fa:	934c      	str	r3, [sp, #304]	; 0x130
 80114fc:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011500:	945d      	str	r4, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011502:	f85a 4c20 	ldr.w	r4, [sl, #-32]
 8011506:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 801150a:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 801150c:	4625      	mov	r5, r4
 801150e:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011512:	954d      	str	r5, [sp, #308]	; 0x134
 8011514:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011518:	945c      	str	r4, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801151a:	f85a 4c1c 	ldr.w	r4, [sl, #-28]
 801151e:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8011522:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8011524:	4625      	mov	r5, r4
 8011526:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801152a:	954e      	str	r5, [sp, #312]	; 0x138
 801152c:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011530:	945b      	str	r4, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011532:	f85a 4c18 	ldr.w	r4, [sl, #-24]
 8011536:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 801153a:	6d41      	ldr	r1, [r0, #84]	; 0x54
 801153c:	4625      	mov	r5, r4
 801153e:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011542:	954f      	str	r5, [sp, #316]	; 0x13c
 8011544:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011548:	945a      	str	r4, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801154a:	f85a 4c14 	ldr.w	r4, [sl, #-20]
 801154e:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 8011550:	6d81      	ldr	r1, [r0, #88]	; 0x58
 8011552:	4625      	mov	r5, r4
 8011554:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011558:	9550      	str	r5, [sp, #320]	; 0x140
 801155a:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801155e:	9459      	str	r4, [sp, #356]	; 0x164
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011560:	f85a 4c10 	ldr.w	r4, [sl, #-16]
 8011564:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8011566:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8011568:	4625      	mov	r5, r4
 801156a:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801156e:	9551      	str	r5, [sp, #324]	; 0x144
 8011570:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011574:	9458      	str	r4, [sp, #352]	; 0x160
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011576:	f85a 4c0c 	ldr.w	r4, [sl, #-12]
 801157a:	6f42      	ldr	r2, [r0, #116]	; 0x74
 801157c:	6e01      	ldr	r1, [r0, #96]	; 0x60
 801157e:	4625      	mov	r5, r4
 8011580:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011584:	9552      	str	r5, [sp, #328]	; 0x148
 8011586:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801158a:	9457      	str	r4, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801158c:	f85a 4c08 	ldr.w	r4, [sl, #-8]
 8011590:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8011592:	6e41      	ldr	r1, [r0, #100]	; 0x64
 8011594:	4625      	mov	r5, r4
 8011596:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801159a:	9553      	str	r5, [sp, #332]	; 0x14c
 801159c:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80115a0:	9456      	str	r4, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80115a2:	f85a 4c04 	ldr.w	r4, [sl, #-4]
 80115a6:	e9d0 121a 	ldrd	r1, r2, [r0, #104]	; 0x68
 80115aa:	4625      	mov	r5, r4
 80115ac:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80115b0:	9554      	str	r5, [sp, #336]	; 0x150
 80115b2:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80115b6:	9455      	str	r4, [sp, #340]	; 0x154
		yLo = (xPrevWin[ 0+i] << 2);
 80115b8:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 80115ba:	4642      	mov	r2, r8
 80115bc:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80115c0:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 80115c4:	9e03      	ldr	r6, [sp, #12]
 80115c6:	4641      	mov	r1, r8
 80115c8:	f846 3b04 	str.w	r3, [r6], #4
		yLo = (xPrevWin[ 3+i] << 2);
 80115cc:	9b4f      	ldr	r3, [sp, #316]	; 0x13c
 80115ce:	009b      	lsls	r3, r3, #2
 80115d0:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80115d4:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 80115d8:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80115da:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80115dc:	9908      	ldr	r1, [sp, #32]
 80115de:	f8c6 317c 	str.w	r3, [r6, #380]	; 0x17c
 80115e2:	fb80 3101 	smull	r3, r1, r0, r1
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80115e6:	9b52      	ldr	r3, [sp, #328]	; 0x148
 80115e8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	__asm__ volatile (
 80115ec:	4641      	mov	r1, r8
 80115ee:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80115f2:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80115f6:	f8dd e048 	ldr.w	lr, [sp, #72]	; 0x48
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80115fa:	430a      	orrs	r2, r1
 80115fc:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80115fe:	4671      	mov	r1, lr
 8011600:	f8c6 32fc 	str.w	r3, [r6, #764]	; 0x2fc
 8011604:	fb85 3101 	smull	r3, r1, r5, r1
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8011608:	9b55      	ldr	r3, [sp, #340]	; 0x154
 801160a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	__asm__ volatile (
 801160e:	4641      	mov	r1, r8
 8011610:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011614:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8011618:	f8c6 347c 	str.w	r3, [r6, #1148]	; 0x47c
 801161c:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801161e:	9b07      	ldr	r3, [sp, #28]
 8011620:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 8011622:	fb84 1303 	smull	r1, r3, r4, r3
 8011626:	4639      	mov	r1, r7
 8011628:	fb80 4101 	smull	r4, r1, r0, r1
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 801162c:	440b      	add	r3, r1
 801162e:	9958      	ldr	r1, [sp, #352]	; 0x160
 8011630:	eb03 0181 	add.w	r1, r3, r1, lsl #2
	__asm__ volatile (
 8011634:	4643      	mov	r3, r8
 8011636:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 801163a:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 801163e:	431a      	orrs	r2, r3
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011640:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011642:	9b06      	ldr	r3, [sp, #24]
 8011644:	f8c6 15fc 	str.w	r1, [r6, #1532]	; 0x5fc
 8011648:	fb80 1303 	smull	r1, r3, r0, r3
 801164c:	9909      	ldr	r1, [sp, #36]	; 0x24
 801164e:	fb85 4101 	smull	r4, r1, r5, r1
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011652:	4419      	add	r1, r3
 8011654:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
 8011656:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	__asm__ volatile (
 801165a:	4641      	mov	r1, r8
 801165c:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011660:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011664:	f8c6 377c 	str.w	r3, [r6, #1916]	; 0x77c
 8011668:	430a      	orrs	r2, r1
		yLo = (xPrevWin[ 0+i] << 2);
 801166a:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 801166c:	4641      	mov	r1, r8
 801166e:	009b      	lsls	r3, r3, #2
 8011670:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011674:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8011678:	67f3      	str	r3, [r6, #124]	; 0x7c
 801167a:	430a      	orrs	r2, r1
		yLo = (xPrevWin[ 3+i] << 2);
 801167c:	9b50      	ldr	r3, [sp, #320]	; 0x140
 801167e:	4641      	mov	r1, r8
 8011680:	009b      	lsls	r3, r3, #2
 8011682:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011686:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801168a:	9c11      	ldr	r4, [sp, #68]	; 0x44
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 801168c:	4311      	orrs	r1, r2
 801168e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011690:	4622      	mov	r2, r4
 8011692:	f8c6 31fc 	str.w	r3, [r6, #508]	; 0x1fc
 8011696:	fb80 3202 	smull	r3, r2, r0, r2
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801169a:	9b53      	ldr	r3, [sp, #332]	; 0x14c
 801169c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	__asm__ volatile (
 80116a0:	4642      	mov	r2, r8
 80116a2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80116a6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80116aa:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80116ac:	9d04      	ldr	r5, [sp, #16]
 80116ae:	f8c6 337c 	str.w	r3, [r6, #892]	; 0x37c
 80116b2:	fb85 3404 	smull	r3, r4, r5, r4
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 80116b6:	9b56      	ldr	r3, [sp, #344]	; 0x158
	__asm__ volatile (
 80116b8:	4641      	mov	r1, r8
 80116ba:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 80116be:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
 80116c2:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80116c6:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 80116ca:	4635      	mov	r5, r6
 80116cc:	f8c6 44fc 	str.w	r4, [r6, #1276]	; 0x4fc
 80116d0:	4311      	orrs	r1, r2
 80116d2:	4663      	mov	r3, ip
 80116d4:	9e1a      	ldr	r6, [sp, #104]	; 0x68
 80116d6:	fb86 2303 	smull	r2, r3, r6, r3
 80116da:	9e21      	ldr	r6, [sp, #132]	; 0x84
 80116dc:	4632      	mov	r2, r6
 80116de:	fb80 4202 	smull	r4, r2, r0, r2
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80116e2:	4413      	add	r3, r2
 80116e4:	9a59      	ldr	r2, [sp, #356]	; 0x164
 80116e6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
	__asm__ volatile (
 80116ea:	4643      	mov	r3, r8
 80116ec:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 80116f0:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 80116f4:	f8c5 267c 	str.w	r2, [r5, #1660]	; 0x67c
 80116f8:	4319      	orrs	r1, r3
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80116fa:	4662      	mov	r2, ip
 80116fc:	9816      	ldr	r0, [sp, #88]	; 0x58
 80116fe:	fb80 3202 	smull	r3, r2, r0, r2
 8011702:	9804      	ldr	r0, [sp, #16]
 8011704:	fb80 3606 	smull	r3, r6, r0, r6
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011708:	4416      	add	r6, r2
 801170a:	9b5c      	ldr	r3, [sp, #368]	; 0x170
	__asm__ volatile (
 801170c:	4642      	mov	r2, r8
 801170e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8011712:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8011716:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801171a:	f8c5 37fc 	str.w	r3, [r5, #2044]	; 0x7fc
 801171e:	4311      	orrs	r1, r2
		yLo = (xPrevWin[ 0+i] << 2);
 8011720:	9b4e      	ldr	r3, [sp, #312]	; 0x138
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011722:	462c      	mov	r4, r5
 8011724:	4642      	mov	r2, r8
		yLo = (xPrevWin[ 0+i] << 2);
 8011726:	009b      	lsls	r3, r3, #2
 8011728:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801172c:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8011730:	f8c5 30fc 	str.w	r3, [r5, #252]	; 0xfc
 8011734:	430a      	orrs	r2, r1
		yLo = (xPrevWin[ 3+i] << 2);
 8011736:	9b51      	ldr	r3, [sp, #324]	; 0x144
 8011738:	4641      	mov	r1, r8
 801173a:	009b      	lsls	r3, r3, #2
 801173c:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011740:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8011744:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011746:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011748:	f8c5 327c 	str.w	r3, [r5, #636]	; 0x27c
 801174c:	fb80 3e0e 	smull	r3, lr, r0, lr
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8011750:	9b54      	ldr	r3, [sp, #336]	; 0x150
	__asm__ volatile (
 8011752:	4641      	mov	r1, r8
 8011754:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
 8011758:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 801175c:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8011760:	f8c5 33fc 	str.w	r3, [r5, #1020]	; 0x3fc
 8011764:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011766:	9d08      	ldr	r5, [sp, #32]
 8011768:	9e05      	ldr	r6, [sp, #20]
 801176a:	fb86 3505 	smull	r3, r5, r6, r5
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 801176e:	9b57      	ldr	r3, [sp, #348]	; 0x15c
	__asm__ volatile (
 8011770:	4646      	mov	r6, r8
 8011772:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8011776:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 801177a:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 801177e:	f8c4 557c 	str.w	r5, [r4, #1404]	; 0x57c
 8011782:	4332      	orrs	r2, r6
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011784:	9b06      	ldr	r3, [sp, #24]
 8011786:	9d18      	ldr	r5, [sp, #96]	; 0x60
 8011788:	9403      	str	r4, [sp, #12]
 801178a:	fb85 1303 	smull	r1, r3, r5, r3
 801178e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8011790:	fb80 1404 	smull	r1, r4, r0, r4
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8011794:	441c      	add	r4, r3
 8011796:	9b5a      	ldr	r3, [sp, #360]	; 0x168
	__asm__ volatile (
 8011798:	4646      	mov	r6, r8
 801179a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801179e:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 80117a2:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 80117a6:	9c03      	ldr	r4, [sp, #12]
 80117a8:	4332      	orrs	r2, r6
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80117aa:	9819      	ldr	r0, [sp, #100]	; 0x64
 80117ac:	f8c4 36fc 	str.w	r3, [r4, #1788]	; 0x6fc
 80117b0:	9b07      	ldr	r3, [sp, #28]
 80117b2:	fb80 1303 	smull	r1, r3, r0, r3
 80117b6:	9e05      	ldr	r6, [sp, #20]
 80117b8:	fb86 1707 	smull	r1, r7, r6, r7
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 80117bc:	441f      	add	r7, r3
 80117be:	995d      	ldr	r1, [sp, #372]	; 0x174
	__asm__ volatile (
 80117c0:	4646      	mov	r6, r8
 80117c2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 80117c6:	ea81 76e1 	eor.w	r6, r1, r1, asr #31
 80117ca:	eba6 76e1 	sub.w	r6, r6, r1, asr #31
		*xPrev++ = xBuf[i] >> 2;
 80117ce:	9b1e      	ldr	r3, [sp, #120]	; 0x78
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 80117d0:	4316      	orrs	r6, r2
 80117d2:	f8c4 187c 	str.w	r1, [r4, #2172]	; 0x87c
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80117d6:	ee16 0a90 	vmov	r0, s13
		*xPrev++ = xBuf[i] >> 2;
 80117da:	109b      	asrs	r3, r3, #2
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80117dc:	9c01      	ldr	r4, [sp, #4]
	for (   ; i < bc->nBlocksTotal; i++) {
 80117de:	f109 0948 	add.w	r9, r9, #72	; 0x48
 80117e2:	f10a 0a24 	add.w	sl, sl, #36	; 0x24
		*xPrev++ = xBuf[i] >> 2;
 80117e6:	f84a 3c48 	str.w	r3, [sl, #-72]
 80117ea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80117ec:	109b      	asrs	r3, r3, #2
 80117ee:	f84a 3c44 	str.w	r3, [sl, #-68]
 80117f2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80117f4:	109b      	asrs	r3, r3, #2
 80117f6:	f84a 3c40 	str.w	r3, [sl, #-64]
		*xPrev++ = xBuf[i] >> 2;
 80117fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80117fc:	109b      	asrs	r3, r3, #2
 80117fe:	f84a 3c3c 	str.w	r3, [sl, #-60]
 8011802:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011804:	109b      	asrs	r3, r3, #2
 8011806:	f84a 3c38 	str.w	r3, [sl, #-56]
 801180a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801180c:	109b      	asrs	r3, r3, #2
 801180e:	f84a 3c34 	str.w	r3, [sl, #-52]
 8011812:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011814:	1099      	asrs	r1, r3, #2
 8011816:	ea4f 03ab 	mov.w	r3, fp, asr #2
 801181a:	f84a 1c30 	str.w	r1, [sl, #-48]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801181e:	ee17 1a90 	vmov	r1, s15
		*xPrev++ = xBuf[i] >> 2;
 8011822:	f84a 3c2c 	str.w	r3, [sl, #-44]
 8011826:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011828:	109a      	asrs	r2, r3, #2
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801182a:	ee17 3a10 	vmov	r3, s14
		*xPrev++ = xBuf[i] >> 2;
 801182e:	f84a 2c28 	str.w	r2, [sl, #-40]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011832:	4622      	mov	r2, r4
	for (   ; i < bc->nBlocksTotal; i++) {
 8011834:	3401      	adds	r4, #1
 8011836:	9401      	str	r4, [sp, #4]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011838:	f7fe fb1e 	bl	800fe78 <FreqInvertRescale>
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 801183c:	9b00      	ldr	r3, [sp, #0]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801183e:	4330      	orrs	r0, r6
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8011840:	4303      	orrs	r3, r0
 8011842:	9300      	str	r3, [sp, #0]
	for (   ; i < bc->nBlocksTotal; i++) {
 8011844:	9b02      	ldr	r3, [sp, #8]
 8011846:	42a3      	cmp	r3, r4
 8011848:	f340 8194 	ble.w	8011b74 <xmp3fixpt_IMDCT+0x17fc>
 801184c:	f1aa 0324 	sub.w	r3, sl, #36	; 0x24
 8011850:	ee07 3a90 	vmov	s15, r3
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8011854:	9b03      	ldr	r3, [sp, #12]
 8011856:	ee06 3a90 	vmov	s13, r3
	if (gb < 7) {
 801185a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801185c:	2b06      	cmp	r3, #6
 801185e:	f300 8088 	bgt.w	8011972 <xmp3fixpt_IMDCT+0x15fa>
			xCurr[i+0] >>= es;
 8011862:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8011864:	f859 3c48 	ldr.w	r3, [r9, #-72]
 8011868:	4113      	asrs	r3, r2
 801186a:	f849 3c48 	str.w	r3, [r9, #-72]
			xCurr[i+1] >>= es;
 801186e:	f859 3c44 	ldr.w	r3, [r9, #-68]
 8011872:	4113      	asrs	r3, r2
 8011874:	f849 3c44 	str.w	r3, [r9, #-68]
			*xPrev++ >>= es;
 8011878:	f85a 3c24 	ldr.w	r3, [sl, #-36]
 801187c:	4113      	asrs	r3, r2
 801187e:	f84a 3c24 	str.w	r3, [sl, #-36]
			xCurr[i+0] >>= es;
 8011882:	f859 3c40 	ldr.w	r3, [r9, #-64]
 8011886:	4113      	asrs	r3, r2
 8011888:	f849 3c40 	str.w	r3, [r9, #-64]
			xCurr[i+1] >>= es;
 801188c:	f859 3c3c 	ldr.w	r3, [r9, #-60]
 8011890:	4113      	asrs	r3, r2
 8011892:	f849 3c3c 	str.w	r3, [r9, #-60]
			*xPrev++ >>= es;
 8011896:	f85a 3c20 	ldr.w	r3, [sl, #-32]
 801189a:	4113      	asrs	r3, r2
 801189c:	f84a 3c20 	str.w	r3, [sl, #-32]
			xCurr[i+0] >>= es;
 80118a0:	f859 3c38 	ldr.w	r3, [r9, #-56]
 80118a4:	4113      	asrs	r3, r2
 80118a6:	f849 3c38 	str.w	r3, [r9, #-56]
			xCurr[i+1] >>= es;
 80118aa:	f859 3c34 	ldr.w	r3, [r9, #-52]
 80118ae:	4113      	asrs	r3, r2
 80118b0:	f849 3c34 	str.w	r3, [r9, #-52]
			*xPrev++ >>= es;
 80118b4:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
 80118b8:	4113      	asrs	r3, r2
 80118ba:	f84a 3c1c 	str.w	r3, [sl, #-28]
			xCurr[i+0] >>= es;
 80118be:	f859 3c30 	ldr.w	r3, [r9, #-48]
 80118c2:	4113      	asrs	r3, r2
 80118c4:	f849 3c30 	str.w	r3, [r9, #-48]
			xCurr[i+1] >>= es;
 80118c8:	f859 3c2c 	ldr.w	r3, [r9, #-44]
 80118cc:	4113      	asrs	r3, r2
 80118ce:	f849 3c2c 	str.w	r3, [r9, #-44]
			*xPrev++ >>= es;
 80118d2:	f85a 3c18 	ldr.w	r3, [sl, #-24]
 80118d6:	4113      	asrs	r3, r2
 80118d8:	f84a 3c18 	str.w	r3, [sl, #-24]
			xCurr[i+0] >>= es;
 80118dc:	f859 3c28 	ldr.w	r3, [r9, #-40]
 80118e0:	4113      	asrs	r3, r2
 80118e2:	f849 3c28 	str.w	r3, [r9, #-40]
			xCurr[i+1] >>= es;
 80118e6:	f859 3c24 	ldr.w	r3, [r9, #-36]
 80118ea:	4113      	asrs	r3, r2
 80118ec:	f849 3c24 	str.w	r3, [r9, #-36]
			*xPrev++ >>= es;
 80118f0:	f85a 3c14 	ldr.w	r3, [sl, #-20]
 80118f4:	4113      	asrs	r3, r2
 80118f6:	f84a 3c14 	str.w	r3, [sl, #-20]
			xCurr[i+0] >>= es;
 80118fa:	f859 3c20 	ldr.w	r3, [r9, #-32]
 80118fe:	4113      	asrs	r3, r2
 8011900:	f849 3c20 	str.w	r3, [r9, #-32]
			xCurr[i+1] >>= es;
 8011904:	f859 3c1c 	ldr.w	r3, [r9, #-28]
 8011908:	4113      	asrs	r3, r2
 801190a:	f849 3c1c 	str.w	r3, [r9, #-28]
			*xPrev++ >>= es;
 801190e:	f85a 3c10 	ldr.w	r3, [sl, #-16]
 8011912:	4113      	asrs	r3, r2
 8011914:	f84a 3c10 	str.w	r3, [sl, #-16]
			xCurr[i+0] >>= es;
 8011918:	f859 3c18 	ldr.w	r3, [r9, #-24]
 801191c:	4113      	asrs	r3, r2
 801191e:	f849 3c18 	str.w	r3, [r9, #-24]
			xCurr[i+1] >>= es;
 8011922:	f859 3c14 	ldr.w	r3, [r9, #-20]
 8011926:	4113      	asrs	r3, r2
 8011928:	f849 3c14 	str.w	r3, [r9, #-20]
			*xPrev++ >>= es;
 801192c:	f85a 3c0c 	ldr.w	r3, [sl, #-12]
 8011930:	4113      	asrs	r3, r2
 8011932:	f84a 3c0c 	str.w	r3, [sl, #-12]
			xCurr[i+0] >>= es;
 8011936:	f859 3c10 	ldr.w	r3, [r9, #-16]
 801193a:	4113      	asrs	r3, r2
 801193c:	f849 3c10 	str.w	r3, [r9, #-16]
			xCurr[i+1] >>= es;
 8011940:	f859 3c0c 	ldr.w	r3, [r9, #-12]
 8011944:	4113      	asrs	r3, r2
 8011946:	f849 3c0c 	str.w	r3, [r9, #-12]
			*xPrev++ >>= es;
 801194a:	f85a 3c08 	ldr.w	r3, [sl, #-8]
 801194e:	4113      	asrs	r3, r2
 8011950:	f84a 3c08 	str.w	r3, [sl, #-8]
			xCurr[i+0] >>= es;
 8011954:	f859 3c08 	ldr.w	r3, [r9, #-8]
 8011958:	4113      	asrs	r3, r2
 801195a:	f849 3c08 	str.w	r3, [r9, #-8]
			xCurr[i+1] >>= es;
 801195e:	f859 3c04 	ldr.w	r3, [r9, #-4]
 8011962:	4113      	asrs	r3, r2
 8011964:	f849 3c04 	str.w	r3, [r9, #-4]
			*xPrev++ >>= es;
 8011968:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801196c:	4113      	asrs	r3, r2
 801196e:	f84a 3c04 	str.w	r3, [sl, #-4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8011972:	f859 1c0c 	ldr.w	r1, [r9, #-12]
 8011976:	f859 7c18 	ldr.w	r7, [r9, #-24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801197a:	f859 2c24 	ldr.w	r2, [r9, #-36]
	x4 -= x5;
 801197e:	1a7e      	subs	r6, r7, r1
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8011980:	f859 4c30 	ldr.w	r4, [r9, #-48]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011984:	f859 3c3c 	ldr.w	r3, [r9, #-60]
	x3 -= x4;
 8011988:	1b92      	subs	r2, r2, r6
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801198a:	f859 5c48 	ldr.w	r5, [r9, #-72]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801198e:	4875      	ldr	r0, [pc, #468]	; (8011b64 <xmp3fixpt_IMDCT+0x17ec>)
	x2 -= x3;
 8011990:	1aa4      	subs	r4, r4, r2
	x3 -= x5;
 8011992:	1a52      	subs	r2, r2, r1
	x1 -= x2;
 8011994:	1b1b      	subs	r3, r3, r4
	x0 -= x1;
 8011996:	1aef      	subs	r7, r5, r3
	x1 -= x3;
 8011998:	1a9b      	subs	r3, r3, r2
	x0 >>= 1;
 801199a:	107f      	asrs	r7, r7, #1
	x1 >>= 1;
 801199c:	105b      	asrs	r3, r3, #1
 801199e:	fb80 5404 	smull	r5, r4, r0, r4
	a1 = x0 + (x4 >> 1);
 80119a2:	eb07 0c66 	add.w	ip, r7, r6, asr #1
	a2 = x0 - x4;
 80119a6:	1bbf      	subs	r7, r7, r6
	x4 = a1 - a0;
 80119a8:	ebac 0544 	sub.w	r5, ip, r4, lsl #1
	x0 = a1 + a0;
 80119ac:	eb0c 0e44 	add.w	lr, ip, r4, lsl #1
	x4 = a1 - a0;
 80119b0:	9507      	str	r5, [sp, #28]
 80119b2:	fb80 4202 	smull	r4, r2, r0, r2
	a1 = x1 + (x5 >> 1);
 80119b6:	eb03 0561 	add.w	r5, r3, r1, asr #1
 80119ba:	486b      	ldr	r0, [pc, #428]	; (8011b68 <xmp3fixpt_IMDCT+0x17f0>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 80119bc:	0056      	lsls	r6, r2, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80119be:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 80119c2:	fb80 4202 	smull	r4, r2, r0, r2
 80119c6:	4c69      	ldr	r4, [pc, #420]	; (8011b6c <xmp3fixpt_IMDCT+0x17f4>)
	a2 = x1 - x5;
 80119c8:	1a5b      	subs	r3, r3, r1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80119ca:	0092      	lsls	r2, r2, #2
 80119cc:	fb84 1303 	smull	r1, r3, r4, r3
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 80119d0:	1bad      	subs	r5, r5, r6
	x3 = MULSHIFT32(c6[1], a2) << 2;
 80119d2:	009c      	lsls	r4, r3, #2
 80119d4:	4e66      	ldr	r6, [pc, #408]	; (8011b70 <xmp3fixpt_IMDCT+0x17f8>)
 80119d6:	fb86 3505 	smull	r3, r5, r6, r5
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 80119da:	f859 3c14 	ldr.w	r3, [r9, #-20]
	x4 -= x5;
 80119de:	f859 1c08 	ldr.w	r1, [r9, #-8]
 80119e2:	eba3 0c01 	sub.w	ip, r3, r1
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 80119e6:	f859 3c20 	ldr.w	r3, [r9, #-32]
 80119ea:	f859 1c2c 	ldr.w	r1, [r9, #-44]
	x3 -= x4;
 80119ee:	eba3 030c 	sub.w	r3, r3, ip
	x2 -= x3;
 80119f2:	1ace      	subs	r6, r1, r3
	x3 -= x5;
 80119f4:	f859 1c08 	ldr.w	r1, [r9, #-8]
 80119f8:	1a5b      	subs	r3, r3, r1
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 80119fa:	f859 1c38 	ldr.w	r1, [r9, #-56]
	x1 -= x2;
 80119fe:	eba1 0b06 	sub.w	fp, r1, r6
 8011a02:	4631      	mov	r1, r6
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011a04:	f859 6c44 	ldr.w	r6, [r9, #-68]
	x1 -= x3;
 8011a08:	9309      	str	r3, [sp, #36]	; 0x24
	x0 -= x1;
 8011a0a:	eba6 060b 	sub.w	r6, r6, fp
	x1 -= x3;
 8011a0e:	ebab 0b03 	sub.w	fp, fp, r3
	*out = x0 + x1;	out++;
 8011a12:	eb02 030e 	add.w	r3, r2, lr
	x0 >>= 1;
 8011a16:	1076      	asrs	r6, r6, #1
	*out = x0 + x1;	out++;
 8011a18:	9306      	str	r3, [sp, #24]
	*out = x0 - x1;
 8011a1a:	ebae 0302 	sub.w	r3, lr, r2
	x1 >>= 1;
 8011a1e:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	*out = x0 - x1;
 8011a22:	9312      	str	r3, [sp, #72]	; 0x48
	*out = x2 + x3;	out++;
 8011a24:	193b      	adds	r3, r7, r4
 8011a26:	9310      	str	r3, [sp, #64]	; 0x40
	*out = x2 - x3;	out++;
 8011a28:	1b3b      	subs	r3, r7, r4
	*out = x4 + x5;	out++;
 8011a2a:	9f07      	ldr	r7, [sp, #28]
	*out = x2 - x3;	out++;
 8011a2c:	9311      	str	r3, [sp, #68]	; 0x44
	*out = x4 + x5;	out++;
 8011a2e:	eb07 0385 	add.w	r3, r7, r5, lsl #2
 8011a32:	4c4c      	ldr	r4, [pc, #304]	; (8011b64 <xmp3fixpt_IMDCT+0x17ec>)
 8011a34:	9307      	str	r3, [sp, #28]
	*out = x4 - x5;	out++;
 8011a36:	eba7 0385 	sub.w	r3, r7, r5, lsl #2
 8011a3a:	9308      	str	r3, [sp, #32]
 8011a3c:	fb84 2101 	smull	r2, r1, r4, r1
	a1 = x0 + (x4 >> 1);
 8011a40:	eb06 026c 	add.w	r2, r6, ip, asr #1
 8011a44:	9b09      	ldr	r3, [sp, #36]	; 0x24
	a2 = x0 - x4;
 8011a46:	eba6 060c 	sub.w	r6, r6, ip
	x4 = a1 - a0;
 8011a4a:	eba2 0541 	sub.w	r5, r2, r1, lsl #1
	x0 = a1 + a0;
 8011a4e:	eb02 0e41 	add.w	lr, r2, r1, lsl #1
	x4 = a1 - a0;
 8011a52:	950c      	str	r5, [sp, #48]	; 0x30
 8011a54:	fb84 2303 	smull	r2, r3, r4, r3
	a1 = x1 + (x5 >> 1);
 8011a58:	f859 7c08 	ldr.w	r7, [r9, #-8]
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8011a5c:	005a      	lsls	r2, r3, #1
	a1 = x1 + (x5 >> 1);
 8011a5e:	eb0b 0767 	add.w	r7, fp, r7, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011a62:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 8011a66:	fb80 1303 	smull	r1, r3, r0, r3
	a2 = x1 - x5;
 8011a6a:	f859 1c08 	ldr.w	r1, [r9, #-8]
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011a6e:	009c      	lsls	r4, r3, #2
	a2 = x1 - x5;
 8011a70:	ebab 0b01 	sub.w	fp, fp, r1
 8011a74:	493d      	ldr	r1, [pc, #244]	; (8011b6c <xmp3fixpt_IMDCT+0x17f4>)
 8011a76:	fb81 3b0b 	smull	r3, fp, r1, fp
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011a7a:	1abf      	subs	r7, r7, r2
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011a7c:	ea4f 058b 	mov.w	r5, fp, lsl #2
 8011a80:	4a3b      	ldr	r2, [pc, #236]	; (8011b70 <xmp3fixpt_IMDCT+0x17f8>)
 8011a82:	fb82 3707 	smull	r3, r7, r2, r7
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8011a86:	f859 3c10 	ldr.w	r3, [r9, #-16]
	x4 -= x5;
 8011a8a:	f859 2c04 	ldr.w	r2, [r9, #-4]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8011a8e:	f859 1c28 	ldr.w	r1, [r9, #-40]
	x4 -= x5;
 8011a92:	eba3 0c02 	sub.w	ip, r3, r2
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8011a96:	f859 2c1c 	ldr.w	r2, [r9, #-28]
	x3 -= x4;
 8011a9a:	eba2 020c 	sub.w	r2, r2, ip
	x2 -= x3;
 8011a9e:	1a8b      	subs	r3, r1, r2
	x3 -= x5;
 8011aa0:	f859 1c04 	ldr.w	r1, [r9, #-4]
 8011aa4:	1a52      	subs	r2, r2, r1
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011aa6:	f859 1c34 	ldr.w	r1, [r9, #-52]
	x1 -= x2;
 8011aaa:	eba1 0b03 	sub.w	fp, r1, r3
 8011aae:	4619      	mov	r1, r3
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011ab0:	f859 3c40 	ldr.w	r3, [r9, #-64]
	x0 -= x1;
 8011ab4:	eba3 030b 	sub.w	r3, r3, fp
	x1 -= x3;
 8011ab8:	ebab 0b02 	sub.w	fp, fp, r2
	x0 >>= 1;
 8011abc:	105b      	asrs	r3, r3, #1
	x1 >>= 1;
 8011abe:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	x0 >>= 1;
 8011ac2:	930b      	str	r3, [sp, #44]	; 0x2c
	*out = x0 + x1;	out++;
 8011ac4:	eb0e 0304 	add.w	r3, lr, r4
 8011ac8:	931e      	str	r3, [sp, #120]	; 0x78
	*out = x0 - x1;
 8011aca:	ebae 0304 	sub.w	r3, lr, r4
 8011ace:	9309      	str	r3, [sp, #36]	; 0x24
	*out = x2 + x3;	out++;
 8011ad0:	1973      	adds	r3, r6, r5
 8011ad2:	931f      	str	r3, [sp, #124]	; 0x7c
	*out = x2 - x3;	out++;
 8011ad4:	1b73      	subs	r3, r6, r5
	*out = x4 + x5;	out++;
 8011ad6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
	*out = x2 - x3;	out++;
 8011ad8:	9321      	str	r3, [sp, #132]	; 0x84
	*out = x4 + x5;	out++;
 8011ada:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 8011ade:	4e21      	ldr	r6, [pc, #132]	; (8011b64 <xmp3fixpt_IMDCT+0x17ec>)
	*out = x4 - x5;	out++;
 8011ae0:	eba5 0787 	sub.w	r7, r5, r7, lsl #2
	*out = x4 + x5;	out++;
 8011ae4:	9320      	str	r3, [sp, #128]	; 0x80
 8011ae6:	fb86 4101 	smull	r4, r1, r6, r1
	a1 = x0 + (x4 >> 1);
 8011aea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011aec:	eb03 046c 	add.w	r4, r3, ip, asr #1
	a2 = x0 - x4;
 8011af0:	eba3 030c 	sub.w	r3, r3, ip
	x0 = a1 + a0;
 8011af4:	eb04 0541 	add.w	r5, r4, r1, lsl #1
	x4 = a1 - a0;
 8011af8:	eba4 0141 	sub.w	r1, r4, r1, lsl #1
 8011afc:	fb86 4202 	smull	r4, r2, r6, r2
	a1 = x1 + (x5 >> 1);
 8011b00:	f859 4c04 	ldr.w	r4, [r9, #-4]
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8011b04:	0056      	lsls	r6, r2, #1
	a1 = x1 + (x5 >> 1);
 8011b06:	eb0b 0464 	add.w	r4, fp, r4, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011b0a:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 8011b0e:	fb80 c202 	smull	ip, r2, r0, r2
	a2 = x1 - x5;
 8011b12:	f859 0c04 	ldr.w	r0, [r9, #-4]
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011b16:	0092      	lsls	r2, r2, #2
	a2 = x1 - x5;
 8011b18:	ebab 0b00 	sub.w	fp, fp, r0
 8011b1c:	4813      	ldr	r0, [pc, #76]	; (8011b6c <xmp3fixpt_IMDCT+0x17f4>)
 8011b1e:	fb80 cb0b 	smull	ip, fp, r0, fp
 8011b22:	4813      	ldr	r0, [pc, #76]	; (8011b70 <xmp3fixpt_IMDCT+0x17f8>)
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011b24:	1ba4      	subs	r4, r4, r6
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011b26:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8011b2a:	fb80 6404 	smull	r6, r4, r0, r4
	*out = x0 + x1;	out++;
 8011b2e:	1950      	adds	r0, r2, r5
	*out = x0 - x1;
 8011b30:	1aaa      	subs	r2, r5, r2
 8011b32:	920f      	str	r2, [sp, #60]	; 0x3c
	*out = x2 + x3;	out++;
 8011b34:	eb0b 0203 	add.w	r2, fp, r3
	*out = x2 - x3;	out++;
 8011b38:	eba3 0b0b 	sub.w	fp, r3, fp
	*out = x4 + x5;	out++;
 8011b3c:	eb01 0384 	add.w	r3, r1, r4, lsl #2
	*out = x0 + x1;	out++;
 8011b40:	900b      	str	r0, [sp, #44]	; 0x2c
	*out = x4 + x5;	out++;
 8011b42:	930d      	str	r3, [sp, #52]	; 0x34
	*out = x4 - x5;	out++;
 8011b44:	eba1 0384 	sub.w	r3, r1, r4, lsl #2
	*out = x2 + x3;	out++;
 8011b48:	920c      	str	r2, [sp, #48]	; 0x30
	*out = x4 - x5;	out++;
 8011b4a:	930e      	str	r3, [sp, #56]	; 0x38
	if (btPrev == 2) {
 8011b4c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011b4e:	2b02      	cmp	r3, #2
 8011b50:	f47f acca 	bne.w	80114e8 <xmp3fixpt_IMDCT+0x1170>
 8011b54:	a94c      	add	r1, sp, #304	; 0x130
 8011b56:	ee17 0a90 	vmov	r0, s15
 8011b5a:	f7fe f91b 	bl	800fd94 <WinPrevious.part.0>
		yLo = (xPrevWin[ 0+i] << 2);
 8011b5e:	9b4c      	ldr	r3, [sp, #304]	; 0x130
 8011b60:	e52a      	b.n	80115b8 <xmp3fixpt_IMDCT+0x1240>
 8011b62:	bf00      	nop
 8011b64:	6ed9eba1 	.word	0x6ed9eba1
 8011b68:	7ba3751d 	.word	0x7ba3751d
 8011b6c:	5a82799a 	.word	0x5a82799a
 8011b70:	2120fb83 	.word	0x2120fb83
		xPrev += 9;
 8011b74:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8011b76:	9b02      	ldr	r3, [sp, #8]
	for (   ; i < bc->nBlocksPrev; i++) {
 8011b78:	9902      	ldr	r1, [sp, #8]
		xPrev += 9;
 8011b7a:	1a9b      	subs	r3, r3, r2
 8011b7c:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8011b7e:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8011b82:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	for (   ; i < bc->nBlocksPrev; i++) {
 8011b86:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8011b88:	428a      	cmp	r2, r1
		xPrev += 9;
 8011b8a:	932b      	str	r3, [sp, #172]	; 0xac
	for (   ; i < bc->nBlocksPrev; i++) {
 8011b8c:	f340 8430 	ble.w	80123f0 <xmp3fixpt_IMDCT+0x2078>
 8011b90:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8011b92:	428b      	cmp	r3, r1
 8011b94:	f340 8401 	ble.w	801239a <xmp3fixpt_IMDCT+0x2022>
 8011b98:	4293      	cmp	r3, r2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011b9a:	f8df 8874 	ldr.w	r8, [pc, #2164]	; 8012410 <xmp3fixpt_IMDCT+0x2098>
	__asm__ volatile (
 8011b9e:	f04f 0500 	mov.w	r5, #0
 8011ba2:	bfa8      	it	ge
 8011ba4:	4613      	movge	r3, r2
 8011ba6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8011ba8:	9331      	str	r3, [sp, #196]	; 0xc4
 8011baa:	3224      	adds	r2, #36	; 0x24
 8011bac:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8011bae:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8011bb2:	f1a3 0e04 	sub.w	lr, r3, #4
 8011bb6:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
 8011bba:	931d      	str	r3, [sp, #116]	; 0x74
 8011bbc:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
 8011bc0:	931e      	str	r3, [sp, #120]	; 0x78
 8011bc2:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 8011bc6:	931f      	str	r3, [sp, #124]	; 0x7c
 8011bc8:	f8d8 3088 	ldr.w	r3, [r8, #136]	; 0x88
 8011bcc:	9320      	str	r3, [sp, #128]	; 0x80
 8011bce:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 8011bd2:	9321      	str	r3, [sp, #132]	; 0x84
 8011bd4:	f8d8 3084 	ldr.w	r3, [r8, #132]	; 0x84
 8011bd8:	9322      	str	r3, [sp, #136]	; 0x88
 8011bda:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8011bde:	9323      	str	r3, [sp, #140]	; 0x8c
 8011be0:	f8d8 3080 	ldr.w	r3, [r8, #128]	; 0x80
 8011be4:	9326      	str	r3, [sp, #152]	; 0x98
 8011be6:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 8011bea:	9327      	str	r3, [sp, #156]	; 0x9c
 8011bec:	f8d8 307c 	ldr.w	r3, [r8, #124]	; 0x7c
 8011bf0:	9328      	str	r3, [sp, #160]	; 0xa0
 8011bf2:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 8011bf6:	9329      	str	r3, [sp, #164]	; 0xa4
 8011bf8:	f8d8 3078 	ldr.w	r3, [r8, #120]	; 0x78
 8011bfc:	932a      	str	r3, [sp, #168]	; 0xa8
 8011bfe:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
 8011c02:	932b      	str	r3, [sp, #172]	; 0xac
 8011c04:	f8d8 3074 	ldr.w	r3, [r8, #116]	; 0x74
 8011c08:	932c      	str	r3, [sp, #176]	; 0xb0
 8011c0a:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 8011c0e:	932d      	str	r3, [sp, #180]	; 0xb4
 8011c10:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
 8011c14:	9101      	str	r1, [sp, #4]
 8011c16:	932e      	str	r3, [sp, #184]	; 0xb8
 8011c18:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 8011c1c:	f8cd 80e4 	str.w	r8, [sp, #228]	; 0xe4
 8011c20:	932f      	str	r3, [sp, #188]	; 0xbc
 8011c22:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 8011c26:	9330      	str	r3, [sp, #192]	; 0xc0
 8011c28:	f852 3c24 	ldr.w	r3, [r2, #-36]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011c2c:	4611      	mov	r1, r2
 8011c2e:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 8011c30:	4618      	mov	r0, r3
 8011c32:	fb84 2000 	smull	r2, r0, r4, r0
 8011c36:	9c1e      	ldr	r4, [sp, #120]	; 0x78
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011c38:	904c      	str	r0, [sp, #304]	; 0x130
 8011c3a:	fb84 2303 	smull	r2, r3, r4, r3
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011c3e:	935d      	str	r3, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011c40:	f851 2c20 	ldr.w	r2, [r1, #-32]
 8011c44:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 8011c46:	4613      	mov	r3, r2
 8011c48:	fb84 6303 	smull	r6, r3, r4, r3
 8011c4c:	9c20      	ldr	r4, [sp, #128]	; 0x80
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011c4e:	934d      	str	r3, [sp, #308]	; 0x134
 8011c50:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011c54:	925c      	str	r2, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011c56:	f851 2c1c 	ldr.w	r2, [r1, #-28]
 8011c5a:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8011c5c:	4616      	mov	r6, r2
 8011c5e:	fb84 7606 	smull	r7, r6, r4, r6
 8011c62:	9c22      	ldr	r4, [sp, #136]	; 0x88
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011c64:	964e      	str	r6, [sp, #312]	; 0x138
 8011c66:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011c6a:	925b      	str	r2, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011c6c:	f851 2c18 	ldr.w	r2, [r1, #-24]
 8011c70:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 8011c72:	4616      	mov	r6, r2
 8011c74:	fb84 7606 	smull	r7, r6, r4, r6
 8011c78:	9c26      	ldr	r4, [sp, #152]	; 0x98
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011c7a:	964f      	str	r6, [sp, #316]	; 0x13c
 8011c7c:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011c80:	925a      	str	r2, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011c82:	f851 2c14 	ldr.w	r2, [r1, #-20]
 8011c86:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 8011c88:	4616      	mov	r6, r2
 8011c8a:	fb84 7606 	smull	r7, r6, r4, r6
 8011c8e:	9c28      	ldr	r4, [sp, #160]	; 0xa0
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011c90:	9650      	str	r6, [sp, #320]	; 0x140
 8011c92:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011c96:	9259      	str	r2, [sp, #356]	; 0x164
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011c98:	f851 2c10 	ldr.w	r2, [r1, #-16]
 8011c9c:	9c29      	ldr	r4, [sp, #164]	; 0xa4
 8011c9e:	4616      	mov	r6, r2
 8011ca0:	fb84 7606 	smull	r7, r6, r4, r6
 8011ca4:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011ca6:	9651      	str	r6, [sp, #324]	; 0x144
 8011ca8:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011cac:	9258      	str	r2, [sp, #352]	; 0x160
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011cae:	f851 2c0c 	ldr.w	r2, [r1, #-12]
 8011cb2:	9c2b      	ldr	r4, [sp, #172]	; 0xac
 8011cb4:	4616      	mov	r6, r2
 8011cb6:	fb84 7606 	smull	r7, r6, r4, r6
 8011cba:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011cbc:	9652      	str	r6, [sp, #328]	; 0x148
 8011cbe:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011cc2:	9257      	str	r2, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011cc4:	f851 2c08 	ldr.w	r2, [r1, #-8]
 8011cc8:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
 8011cca:	4616      	mov	r6, r2
 8011ccc:	fb84 7606 	smull	r7, r6, r4, r6
 8011cd0:	9c2e      	ldr	r4, [sp, #184]	; 0xb8
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011cd2:	9653      	str	r6, [sp, #332]	; 0x14c
 8011cd4:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011cd8:	9256      	str	r2, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011cda:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8011cde:	9c2f      	ldr	r4, [sp, #188]	; 0xbc
 8011ce0:	4616      	mov	r6, r2
 8011ce2:	fb84 7606 	smull	r7, r6, r4, r6
 8011ce6:	9c30      	ldr	r4, [sp, #192]	; 0xc0
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011ce8:	9654      	str	r6, [sp, #336]	; 0x150
 8011cea:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011cee:	9255      	str	r2, [sp, #340]	; 0x154
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011cf0:	0082      	lsls	r2, r0, #2
	__asm__ volatile (
 8011cf2:	4628      	mov	r0, r5
			y[2*j+0][i] = xp;
 8011cf4:	f84e 2f04 	str.w	r2, [lr, #4]!
 8011cf8:	9203      	str	r2, [sp, #12]
 8011cfa:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
 8011cfe:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
 8011d02:	9010      	str	r0, [sp, #64]	; 0x40
 8011d04:	462c      	mov	r4, r5
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d06:	9802      	ldr	r0, [sp, #8]
 8011d08:	f340 0200 	sbfx	r2, r0, #0, #1
 8011d0c:	f000 0001 	and.w	r0, r0, #1
 8011d10:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011d14:	4403      	add	r3, r0
			y[2*j+1][i] = xp;
 8011d16:	f8ce 3080 	str.w	r3, [lr, #128]	; 0x80
 8011d1a:	9304      	str	r3, [sp, #16]
 8011d1c:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8011d20:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
			xPrev[j] = 0;
 8011d24:	f841 5c24 	str.w	r5, [r1, #-36]
 8011d28:	46ac      	mov	ip, r5
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d2a:	9b4e      	ldr	r3, [sp, #312]	; 0x138
 8011d2c:	462e      	mov	r6, r5
 8011d2e:	9411      	str	r4, [sp, #68]	; 0x44
 8011d30:	009f      	lsls	r7, r3, #2
			y[2*j+0][i] = xp;
 8011d32:	f8ce 7100 	str.w	r7, [lr, #256]	; 0x100
 8011d36:	9705      	str	r7, [sp, #20]
 8011d38:	ea87 76e7 	eor.w	r6, r7, r7, asr #31
 8011d3c:	eba6 76e7 	sub.w	r6, r6, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011d40:	9b4f      	ldr	r3, [sp, #316]	; 0x13c
 8011d42:	462f      	mov	r7, r5
 8011d44:	9612      	str	r6, [sp, #72]	; 0x48
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d46:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011d4a:	18c6      	adds	r6, r0, r3
			y[2*j+1][i] = xp;
 8011d4c:	f8ce 6180 	str.w	r6, [lr, #384]	; 0x180
 8011d50:	9606      	str	r6, [sp, #24]
 8011d52:	ea86 77e6 	eor.w	r7, r6, r6, asr #31
 8011d56:	eba7 77e6 	sub.w	r7, r7, r6, asr #31
			xPrev[j] = 0;
 8011d5a:	f841 5c20 	str.w	r5, [r1, #-32]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d5e:	9b50      	ldr	r3, [sp, #320]	; 0x140
 8011d60:	9714      	str	r7, [sp, #80]	; 0x50
 8011d62:	009f      	lsls	r7, r3, #2
 8011d64:	462b      	mov	r3, r5
			y[2*j+0][i] = xp;
 8011d66:	f8ce 7200 	str.w	r7, [lr, #512]	; 0x200
 8011d6a:	9707      	str	r7, [sp, #28]
 8011d6c:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011d70:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 8011d74:	9315      	str	r3, [sp, #84]	; 0x54
			xp = xPrevWin[2*j+1] << 2;
 8011d76:	9b51      	ldr	r3, [sp, #324]	; 0x144
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d78:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011d7c:	18c4      	adds	r4, r0, r3
 8011d7e:	462b      	mov	r3, r5
			y[2*j+1][i] = xp;
 8011d80:	f8ce 4280 	str.w	r4, [lr, #640]	; 0x280
 8011d84:	9408      	str	r4, [sp, #32]
 8011d86:	ea84 73e4 	eor.w	r3, r4, r4, asr #31
 8011d8a:	eba3 73e4 	sub.w	r3, r3, r4, asr #31
			xPrev[j] = 0;
 8011d8e:	f841 5c1c 	str.w	r5, [r1, #-28]
 8011d92:	462e      	mov	r6, r5
 8011d94:	9316      	str	r3, [sp, #88]	; 0x58
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d96:	9b52      	ldr	r3, [sp, #328]	; 0x148
 8011d98:	009b      	lsls	r3, r3, #2
			y[2*j+0][i] = xp;
 8011d9a:	f8ce 3300 	str.w	r3, [lr, #768]	; 0x300
 8011d9e:	9309      	str	r3, [sp, #36]	; 0x24
 8011da0:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 8011da4:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011da8:	9b53      	ldr	r3, [sp, #332]	; 0x14c
 8011daa:	9617      	str	r6, [sp, #92]	; 0x5c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011dac:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011db0:	18c7      	adds	r7, r0, r3
 8011db2:	462b      	mov	r3, r5
			y[2*j+1][i] = xp;
 8011db4:	f8ce 7380 	str.w	r7, [lr, #896]	; 0x380
 8011db8:	970a      	str	r7, [sp, #40]	; 0x28
 8011dba:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011dbe:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
			xPrev[j] = 0;
 8011dc2:	f841 5c18 	str.w	r5, [r1, #-24]
 8011dc6:	462e      	mov	r6, r5
 8011dc8:	9318      	str	r3, [sp, #96]	; 0x60
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011dca:	9b54      	ldr	r3, [sp, #336]	; 0x150
 8011dcc:	009b      	lsls	r3, r3, #2
			y[2*j+0][i] = xp;
 8011dce:	f8ce 3400 	str.w	r3, [lr, #1024]	; 0x400
 8011dd2:	930b      	str	r3, [sp, #44]	; 0x2c
 8011dd4:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 8011dd8:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011ddc:	9b55      	ldr	r3, [sp, #340]	; 0x154
 8011dde:	462f      	mov	r7, r5
 8011de0:	9619      	str	r6, [sp, #100]	; 0x64
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011de2:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011de6:	18c6      	adds	r6, r0, r3
			y[2*j+1][i] = xp;
 8011de8:	f8ce 6480 	str.w	r6, [lr, #1152]	; 0x480
 8011dec:	960c      	str	r6, [sp, #48]	; 0x30
 8011dee:	ea86 77e6 	eor.w	r7, r6, r6, asr #31
 8011df2:	eba7 77e6 	sub.w	r7, r7, r6, asr #31
			xPrev[j] = 0;
 8011df6:	f841 5c14 	str.w	r5, [r1, #-20]
 8011dfa:	462c      	mov	r4, r5
 8011dfc:	971a      	str	r7, [sp, #104]	; 0x68
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011dfe:	9f56      	ldr	r7, [sp, #344]	; 0x158
 8011e00:	00bf      	lsls	r7, r7, #2
			y[2*j+0][i] = xp;
 8011e02:	f8ce 7500 	str.w	r7, [lr, #1280]	; 0x500
 8011e06:	ea87 74e7 	eor.w	r4, r7, r7, asr #31
 8011e0a:	eba4 74e7 	sub.w	r4, r4, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011e0e:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 8011e10:	462e      	mov	r6, r5
 8011e12:	941b      	str	r4, [sp, #108]	; 0x6c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011e14:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011e18:	18c3      	adds	r3, r0, r3
			y[2*j+1][i] = xp;
 8011e1a:	f8ce 3580 	str.w	r3, [lr, #1408]	; 0x580
 8011e1e:	930d      	str	r3, [sp, #52]	; 0x34
 8011e20:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 8011e24:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
			xPrev[j] = 0;
 8011e28:	f841 5c10 	str.w	r5, [r1, #-16]
 8011e2c:	46aa      	mov	sl, r5
 8011e2e:	961c      	str	r6, [sp, #112]	; 0x70
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011e30:	9e58      	ldr	r6, [sp, #352]	; 0x160
 8011e32:	00b4      	lsls	r4, r6, #2
			y[2*j+0][i] = xp;
 8011e34:	f8ce 4600 	str.w	r4, [lr, #1536]	; 0x600
 8011e38:	940e      	str	r4, [sp, #56]	; 0x38
 8011e3a:	ea84 7ae4 	eor.w	sl, r4, r4, asr #31
 8011e3e:	ebaa 7ae4 	sub.w	sl, sl, r4, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011e42:	9b59      	ldr	r3, [sp, #356]	; 0x164
 8011e44:	46a9      	mov	r9, r5
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011e46:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011e4a:	18c6      	adds	r6, r0, r3
			y[2*j+1][i] = xp;
 8011e4c:	f8ce 6680 	str.w	r6, [lr, #1664]	; 0x680
 8011e50:	960f      	str	r6, [sp, #60]	; 0x3c
 8011e52:	ea86 79e6 	eor.w	r9, r6, r6, asr #31
 8011e56:	eba9 79e6 	sub.w	r9, r9, r6, asr #31
			xPrev[j] = 0;
 8011e5a:	f841 5c0c 	str.w	r5, [r1, #-12]
 8011e5e:	46a8      	mov	r8, r5
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011e60:	9e5a      	ldr	r6, [sp, #360]	; 0x168
 8011e62:	00b6      	lsls	r6, r6, #2
			y[2*j+0][i] = xp;
 8011e64:	f8ce 6700 	str.w	r6, [lr, #1792]	; 0x700
 8011e68:	ea86 78e6 	eor.w	r8, r6, r6, asr #31
 8011e6c:	eba8 78e6 	sub.w	r8, r8, r6, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011e70:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011e72:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011e76:	eb00 0b03 	add.w	fp, r0, r3
			y[2*j+1][i] = xp;
 8011e7a:	f8ce b780 	str.w	fp, [lr, #1920]	; 0x780
 8011e7e:	ea8b 7ceb 	eor.w	ip, fp, fp, asr #31
 8011e82:	ebac 7ceb 	sub.w	ip, ip, fp, asr #31
			nonZero |= xp;
 8011e86:	9c07      	ldr	r4, [sp, #28]
 8011e88:	9b05      	ldr	r3, [sp, #20]
			xPrev[j] = 0;
 8011e8a:	f841 5c08 	str.w	r5, [r1, #-8]
			nonZero |= xp;
 8011e8e:	4323      	orrs	r3, r4
 8011e90:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8011e92:	4323      	orrs	r3, r4
 8011e94:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8011e96:	4323      	orrs	r3, r4
 8011e98:	9c08      	ldr	r4, [sp, #32]
 8011e9a:	433b      	orrs	r3, r7
 8011e9c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8011e9e:	433b      	orrs	r3, r7
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011ea0:	9f5c      	ldr	r7, [sp, #368]	; 0x170
			nonZero |= xp;
 8011ea2:	4333      	orrs	r3, r6
 8011ea4:	9e03      	ldr	r6, [sp, #12]
 8011ea6:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011eaa:	00bf      	lsls	r7, r7, #2
			nonZero |= xp;
 8011eac:	4333      	orrs	r3, r6
 8011eae:	9e04      	ldr	r6, [sp, #16]
			y[2*j+0][i] = xp;
 8011eb0:	f8ce 7800 	str.w	r7, [lr, #2048]	; 0x800
			nonZero |= xp;
 8011eb4:	4333      	orrs	r3, r6
 8011eb6:	9e06      	ldr	r6, [sp, #24]
 8011eb8:	4333      	orrs	r3, r6
 8011eba:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8011ebc:	4323      	orrs	r3, r4
 8011ebe:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8011ec0:	4323      	orrs	r3, r4
 8011ec2:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8011ec4:	4333      	orrs	r3, r6
 8011ec6:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8011ec8:	4323      	orrs	r3, r4
 8011eca:	4333      	orrs	r3, r6
 8011ecc:	462e      	mov	r6, r5
 8011ece:	ea43 0b0b 	orr.w	fp, r3, fp
 8011ed2:	ea87 76e7 	eor.w	r6, r7, r7, asr #31
 8011ed6:	eba6 76e7 	sub.w	r6, r6, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011eda:	9b5d      	ldr	r3, [sp, #372]	; 0x174
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011edc:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
 8011ee0:	4418      	add	r0, r3
 8011ee2:	462b      	mov	r3, r5
			y[2*j+1][i] = xp;
 8011ee4:	f8ce 0880 	str.w	r0, [lr, #2176]	; 0x880
 8011ee8:	ea80 73e0 	eor.w	r3, r0, r0, asr #31
 8011eec:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
		if (nonZero)
 8011ef0:	ea5b 0200 	orrs.w	r2, fp, r0
			mOut |= FASTABS(xp);
 8011ef4:	9f14      	ldr	r7, [sp, #80]	; 0x50
			xPrev[j] = 0;
 8011ef6:	f841 5c04 	str.w	r5, [r1, #-4]
			mOut |= FASTABS(xp);
 8011efa:	e9dd 0410 	ldrd	r0, r4, [sp, #64]	; 0x40
 8011efe:	ea40 0204 	orr.w	r2, r0, r4
 8011f02:	9812      	ldr	r0, [sp, #72]	; 0x48
 8011f04:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 8011f06:	ea42 0200 	orr.w	r2, r2, r0
 8011f0a:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011f0c:	ea42 0207 	orr.w	r2, r2, r7
 8011f10:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8011f12:	ea42 0200 	orr.w	r2, r2, r0
 8011f16:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011f18:	ea42 0200 	orr.w	r2, r2, r0
 8011f1c:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011f1e:	ea42 0200 	orr.w	r2, r2, r0
 8011f22:	9818      	ldr	r0, [sp, #96]	; 0x60
 8011f24:	ea42 0200 	orr.w	r2, r2, r0
 8011f28:	9819      	ldr	r0, [sp, #100]	; 0x64
 8011f2a:	ea42 0200 	orr.w	r2, r2, r0
 8011f2e:	981c      	ldr	r0, [sp, #112]	; 0x70
 8011f30:	ea42 0207 	orr.w	r2, r2, r7
 8011f34:	ea42 0204 	orr.w	r2, r2, r4
 8011f38:	ea42 0200 	orr.w	r2, r2, r0
 8011f3c:	ea42 020a 	orr.w	r2, r2, sl
 8011f40:	ea42 0209 	orr.w	r2, r2, r9
 8011f44:	ea42 0208 	orr.w	r2, r2, r8
 8011f48:	ea42 020c 	orr.w	r2, r2, ip
 8011f4c:	ea42 0206 	orr.w	r2, r2, r6
 8011f50:	ea42 0203 	orr.w	r2, r2, r3
 8011f54:	9b00      	ldr	r3, [sp, #0]
 8011f56:	ea43 0302 	orr.w	r3, r3, r2
	for (   ; i < bc->nBlocksPrev; i++) {
 8011f5a:	f101 0224 	add.w	r2, r1, #36	; 0x24
			mOut |= FASTABS(xp);
 8011f5e:	9300      	str	r3, [sp, #0]
		if (nonZero)
 8011f60:	e9dd 3001 	ldrd	r3, r0, [sp, #4]
 8011f64:	bf18      	it	ne
 8011f66:	4603      	movne	r3, r0
	for (   ; i < bc->nBlocksPrev; i++) {
 8011f68:	3001      	adds	r0, #1
		if (nonZero)
 8011f6a:	9301      	str	r3, [sp, #4]
	for (   ; i < bc->nBlocksPrev; i++) {
 8011f6c:	9b31      	ldr	r3, [sp, #196]	; 0xc4
 8011f6e:	9002      	str	r0, [sp, #8]
 8011f70:	4298      	cmp	r0, r3
 8011f72:	f6ff ae59 	blt.w	8011c28 <xmp3fixpt_IMDCT+0x18b0>
 8011f76:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8011f78:	f8dd 80e4 	ldr.w	r8, [sp, #228]	; 0xe4
 8011f7c:	4283      	cmp	r3, r0
 8011f7e:	912b      	str	r1, [sp, #172]	; 0xac
 8011f80:	f340 81d3 	ble.w	801232a <xmp3fixpt_IMDCT+0x1fb2>
 8011f84:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8011f86:	f04f 0900 	mov.w	r9, #0
 8011f8a:	9a02      	ldr	r2, [sp, #8]
 8011f8c:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 8011f8e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8011f92:	3624      	adds	r6, #36	; 0x24
 8011f94:	f1a3 0a04 	sub.w	sl, r3, #4
		wpLo = imdctWin[btPrev] + 18;
 8011f98:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011f9a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8011f9e:	eb08 1b03 	add.w	fp, r8, r3, lsl #4
 8011fa2:	e147      	b.n	8012234 <xmp3fixpt_IMDCT+0x1ebc>
 8011fa4:	a94c      	add	r1, sp, #304	; 0x130
 8011fa6:	f7fd fef5 	bl	800fd94 <WinPrevious.part.0>
			xp = xPrevWin[2*j+1] << 2;
 8011faa:	e9dd 324c 	ldrd	r3, r2, [sp, #304]	; 0x130
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011fae:	009b      	lsls	r3, r3, #2
 8011fb0:	46c8      	mov	r8, r9
			y[2*j+0][i] = xp;
 8011fb2:	f84a 3f04 	str.w	r3, [sl, #4]!
 8011fb6:	930f      	str	r3, [sp, #60]	; 0x3c
 8011fb8:	ea83 78e3 	eor.w	r8, r3, r3, asr #31
 8011fbc:	eba8 78e3 	sub.w	r8, r8, r3, asr #31
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011fc0:	9802      	ldr	r0, [sp, #8]
 8011fc2:	464c      	mov	r4, r9
 8011fc4:	f340 0300 	sbfx	r3, r0, #0, #1
 8011fc8:	ea83 0182 	eor.w	r1, r3, r2, lsl #2
 8011fcc:	f000 0201 	and.w	r2, r0, #1
 8011fd0:	1851      	adds	r1, r2, r1
			y[2*j+1][i] = xp;
 8011fd2:	f8ca 1080 	str.w	r1, [sl, #128]	; 0x80
 8011fd6:	910e      	str	r1, [sp, #56]	; 0x38
 8011fd8:	ea81 74e1 	eor.w	r4, r1, r1, asr #31
 8011fdc:	eba4 74e1 	sub.w	r4, r4, r1, asr #31
			xPrev[j] = 0;
 8011fe0:	f846 9c24 	str.w	r9, [r6, #-36]
 8011fe4:	464d      	mov	r5, r9
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011fe6:	994e      	ldr	r1, [sp, #312]	; 0x138
 8011fe8:	9410      	str	r4, [sp, #64]	; 0x40
 8011fea:	008c      	lsls	r4, r1, #2
			y[2*j+0][i] = xp;
 8011fec:	f8ca 4100 	str.w	r4, [sl, #256]	; 0x100
 8011ff0:	940d      	str	r4, [sp, #52]	; 0x34
 8011ff2:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 8011ff6:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011ffa:	994f      	ldr	r1, [sp, #316]	; 0x13c
 8011ffc:	46cc      	mov	ip, r9
 8011ffe:	9511      	str	r5, [sp, #68]	; 0x44
 8012000:	464f      	mov	r7, r9
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8012002:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8012006:	188d      	adds	r5, r1, r2
			y[2*j+1][i] = xp;
 8012008:	f8ca 5180 	str.w	r5, [sl, #384]	; 0x180
 801200c:	950c      	str	r5, [sp, #48]	; 0x30
 801200e:	ea85 77e5 	eor.w	r7, r5, r5, asr #31
 8012012:	eba7 77e5 	sub.w	r7, r7, r5, asr #31
			xPrev[j] = 0;
 8012016:	f846 9c20 	str.w	r9, [r6, #-32]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801201a:	9950      	ldr	r1, [sp, #320]	; 0x140
 801201c:	9712      	str	r7, [sp, #72]	; 0x48
 801201e:	008f      	lsls	r7, r1, #2
 8012020:	4649      	mov	r1, r9
			y[2*j+0][i] = xp;
 8012022:	f8ca 7200 	str.w	r7, [sl, #512]	; 0x200
 8012026:	970b      	str	r7, [sp, #44]	; 0x2c
 8012028:	ea87 71e7 	eor.w	r1, r7, r7, asr #31
 801202c:	eba1 71e7 	sub.w	r1, r1, r7, asr #31
 8012030:	9114      	str	r1, [sp, #80]	; 0x50
 8012032:	4648      	mov	r0, r9
			xp = xPrevWin[2*j+1] << 2;
 8012034:	9951      	ldr	r1, [sp, #324]	; 0x144
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8012036:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 801203a:	188c      	adds	r4, r1, r2
			y[2*j+1][i] = xp;
 801203c:	f8ca 4280 	str.w	r4, [sl, #640]	; 0x280
 8012040:	940a      	str	r4, [sp, #40]	; 0x28
 8012042:	ea84 70e4 	eor.w	r0, r4, r4, asr #31
 8012046:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
			xPrev[j] = 0;
 801204a:	f846 9c1c 	str.w	r9, [r6, #-28]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801204e:	9952      	ldr	r1, [sp, #328]	; 0x148
 8012050:	9015      	str	r0, [sp, #84]	; 0x54
 8012052:	4648      	mov	r0, r9
 8012054:	0089      	lsls	r1, r1, #2
			y[2*j+0][i] = xp;
 8012056:	f8ca 1300 	str.w	r1, [sl, #768]	; 0x300
 801205a:	9109      	str	r1, [sp, #36]	; 0x24
 801205c:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 8012060:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8012064:	9953      	ldr	r1, [sp, #332]	; 0x14c
 8012066:	464d      	mov	r5, r9
 8012068:	9016      	str	r0, [sp, #88]	; 0x58
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 801206a:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 801206e:	1888      	adds	r0, r1, r2
			y[2*j+1][i] = xp;
 8012070:	f8ca 0380 	str.w	r0, [sl, #896]	; 0x380
 8012074:	9008      	str	r0, [sp, #32]
 8012076:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
 801207a:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
			xPrev[j] = 0;
 801207e:	f846 9c18 	str.w	r9, [r6, #-24]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8012082:	9954      	ldr	r1, [sp, #336]	; 0x150
 8012084:	9517      	str	r5, [sp, #92]	; 0x5c
 8012086:	008d      	lsls	r5, r1, #2
 8012088:	4649      	mov	r1, r9
			y[2*j+0][i] = xp;
 801208a:	f8ca 5400 	str.w	r5, [sl, #1024]	; 0x400
 801208e:	9507      	str	r5, [sp, #28]
 8012090:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
 8012094:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
 8012098:	9118      	str	r1, [sp, #96]	; 0x60
 801209a:	4648      	mov	r0, r9
			xp = xPrevWin[2*j+1] << 2;
 801209c:	9955      	ldr	r1, [sp, #340]	; 0x154
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 801209e:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 80120a2:	4411      	add	r1, r2
			y[2*j+1][i] = xp;
 80120a4:	f8ca 1480 	str.w	r1, [sl, #1152]	; 0x480
 80120a8:	9106      	str	r1, [sp, #24]
 80120aa:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 80120ae:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
			xPrev[j] = 0;
 80120b2:	f846 9c14 	str.w	r9, [r6, #-20]
 80120b6:	464d      	mov	r5, r9
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 80120b8:	9956      	ldr	r1, [sp, #344]	; 0x158
 80120ba:	9019      	str	r0, [sp, #100]	; 0x64
 80120bc:	0088      	lsls	r0, r1, #2
			y[2*j+0][i] = xp;
 80120be:	f8ca 0500 	str.w	r0, [sl, #1280]	; 0x500
 80120c2:	9005      	str	r0, [sp, #20]
 80120c4:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
 80120c8:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
			xp = xPrevWin[2*j+1] << 2;
 80120cc:	9957      	ldr	r1, [sp, #348]	; 0x15c
 80120ce:	464c      	mov	r4, r9
 80120d0:	951a      	str	r5, [sp, #104]	; 0x68
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 80120d2:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 80120d6:	188d      	adds	r5, r1, r2
			y[2*j+1][i] = xp;
 80120d8:	f8ca 5580 	str.w	r5, [sl, #1408]	; 0x580
 80120dc:	9504      	str	r5, [sp, #16]
 80120de:	ea85 74e5 	eor.w	r4, r5, r5, asr #31
 80120e2:	eba4 74e5 	sub.w	r4, r4, r5, asr #31
			xPrev[j] = 0;
 80120e6:	f846 9c10 	str.w	r9, [r6, #-16]
 80120ea:	4649      	mov	r1, r9
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 80120ec:	9d58      	ldr	r5, [sp, #352]	; 0x160
 80120ee:	941b      	str	r4, [sp, #108]	; 0x6c
 80120f0:	00ad      	lsls	r5, r5, #2
			y[2*j+0][i] = xp;
 80120f2:	f8ca 5600 	str.w	r5, [sl, #1536]	; 0x600
 80120f6:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
 80120fa:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
			xp = xPrevWin[2*j+1] << 2;
 80120fe:	9859      	ldr	r0, [sp, #356]	; 0x164
 8012100:	911c      	str	r1, [sp, #112]	; 0x70
 8012102:	4649      	mov	r1, r9
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8012104:	ea83 0080 	eor.w	r0, r3, r0, lsl #2
 8012108:	4410      	add	r0, r2
			y[2*j+1][i] = xp;
 801210a:	f8ca 0680 	str.w	r0, [sl, #1664]	; 0x680
 801210e:	ea80 71e0 	eor.w	r1, r0, r0, asr #31
 8012112:	eba1 71e0 	sub.w	r1, r1, r0, asr #31
			xPrev[j] = 0;
 8012116:	f846 9c0c 	str.w	r9, [r6, #-12]
 801211a:	911d      	str	r1, [sp, #116]	; 0x74
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801211c:	995a      	ldr	r1, [sp, #360]	; 0x168
 801211e:	008f      	lsls	r7, r1, #2
 8012120:	4649      	mov	r1, r9
			y[2*j+0][i] = xp;
 8012122:	f8ca 7700 	str.w	r7, [sl, #1792]	; 0x700
 8012126:	9703      	str	r7, [sp, #12]
 8012128:	ea87 71e7 	eor.w	r1, r7, r7, asr #31
 801212c:	eba1 71e7 	sub.w	r1, r1, r7, asr #31
 8012130:	911e      	str	r1, [sp, #120]	; 0x78
 8012132:	46ce      	mov	lr, r9
			xp = xPrevWin[2*j+1] << 2;
 8012134:	995b      	ldr	r1, [sp, #364]	; 0x16c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8012136:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 801213a:	4411      	add	r1, r2
			y[2*j+1][i] = xp;
 801213c:	f8ca 1780 	str.w	r1, [sl, #1920]	; 0x780
 8012140:	ea81 7ee1 	eor.w	lr, r1, r1, asr #31
 8012144:	ebae 7ee1 	sub.w	lr, lr, r1, asr #31
			xPrev[j] = 0;
 8012148:	f846 9c08 	str.w	r9, [r6, #-8]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801214c:	9c5c      	ldr	r4, [sp, #368]	; 0x170
 801214e:	00a4      	lsls	r4, r4, #2
			y[2*j+0][i] = xp;
 8012150:	f8ca 4800 	str.w	r4, [sl, #2048]	; 0x800
 8012154:	ea84 7ce4 	eor.w	ip, r4, r4, asr #31
 8012158:	ebac 7ce4 	sub.w	ip, ip, r4, asr #31
			xp = xPrevWin[2*j+1] << 2;
 801215c:	9f5d      	ldr	r7, [sp, #372]	; 0x174
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 801215e:	ea83 0387 	eor.w	r3, r3, r7, lsl #2
 8012162:	441a      	add	r2, r3
 8012164:	464b      	mov	r3, r9
			y[2*j+1][i] = xp;
 8012166:	f8ca 2880 	str.w	r2, [sl, #2176]	; 0x880
 801216a:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 801216e:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
			nonZero |= xp;
 8012172:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
	for (   ; i < bc->nBlocksPrev; i++) {
 8012174:	3624      	adds	r6, #36	; 0x24
 8012176:	931f      	str	r3, [sp, #124]	; 0x7c
			nonZero |= xp;
 8012178:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801217a:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 801217c:	9f10      	ldr	r7, [sp, #64]	; 0x40
 801217e:	ea47 0808 	orr.w	r8, r7, r8
			nonZero |= xp;
 8012182:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8012184:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8012186:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8012188:	ea48 0807 	orr.w	r8, r8, r7
			nonZero |= xp;
 801218c:	9f07      	ldr	r7, [sp, #28]
 801218e:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8012190:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8012192:	ea48 0807 	orr.w	r8, r8, r7
			nonZero |= xp;
 8012196:	9f05      	ldr	r7, [sp, #20]
 8012198:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 801219a:	9f14      	ldr	r7, [sp, #80]	; 0x50
 801219c:	ea48 0807 	orr.w	r8, r8, r7
 80121a0:	9f15      	ldr	r7, [sp, #84]	; 0x54
			nonZero |= xp;
 80121a2:	432b      	orrs	r3, r5
 80121a4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
			mOut |= FASTABS(xp);
 80121a6:	ea48 0807 	orr.w	r8, r8, r7
			nonZero |= xp;
 80121aa:	9f03      	ldr	r7, [sp, #12]
 80121ac:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 80121ae:	9f16      	ldr	r7, [sp, #88]	; 0x58
			nonZero |= xp;
 80121b0:	4323      	orrs	r3, r4
			mOut |= FASTABS(xp);
 80121b2:	ea48 0807 	orr.w	r8, r8, r7
 80121b6:	9f17      	ldr	r7, [sp, #92]	; 0x5c
			nonZero |= xp;
 80121b8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80121ba:	432b      	orrs	r3, r5
			mOut |= FASTABS(xp);
 80121bc:	ea48 0807 	orr.w	r8, r8, r7
 80121c0:	9f18      	ldr	r7, [sp, #96]	; 0x60
			nonZero |= xp;
 80121c2:	4323      	orrs	r3, r4
 80121c4:	9c08      	ldr	r4, [sp, #32]
			mOut |= FASTABS(xp);
 80121c6:	ea48 0807 	orr.w	r8, r8, r7
 80121ca:	9f19      	ldr	r7, [sp, #100]	; 0x64
			nonZero |= xp;
 80121cc:	4323      	orrs	r3, r4
 80121ce:	9c06      	ldr	r4, [sp, #24]
			mOut |= FASTABS(xp);
 80121d0:	ea48 0807 	orr.w	r8, r8, r7
 80121d4:	9f1a      	ldr	r7, [sp, #104]	; 0x68
			nonZero |= xp;
 80121d6:	4323      	orrs	r3, r4
 80121d8:	9d04      	ldr	r5, [sp, #16]
			mOut |= FASTABS(xp);
 80121da:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 80121dc:	ea48 0807 	orr.w	r8, r8, r7
			nonZero |= xp;
 80121e0:	432b      	orrs	r3, r5
			mOut |= FASTABS(xp);
 80121e2:	ea48 0804 	orr.w	r8, r8, r4
 80121e6:	9c1c      	ldr	r4, [sp, #112]	; 0x70
			nonZero |= xp;
 80121e8:	4303      	orrs	r3, r0
			mOut |= FASTABS(xp);
 80121ea:	ea48 0804 	orr.w	r8, r8, r4
 80121ee:	9c1d      	ldr	r4, [sp, #116]	; 0x74
			nonZero |= xp;
 80121f0:	430b      	orrs	r3, r1
		if (nonZero)
 80121f2:	990e      	ldr	r1, [sp, #56]	; 0x38
			mOut |= FASTABS(xp);
 80121f4:	ea48 0804 	orr.w	r8, r8, r4
 80121f8:	9c1e      	ldr	r4, [sp, #120]	; 0x78
			nonZero |= xp;
 80121fa:	4313      	orrs	r3, r2
 80121fc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
			mOut |= FASTABS(xp);
 80121fe:	ea48 0804 	orr.w	r8, r8, r4
			nonZero |= xp;
 8012202:	4313      	orrs	r3, r2
			mOut |= FASTABS(xp);
 8012204:	ea48 080e 	orr.w	r8, r8, lr
		if (nonZero)
 8012208:	430b      	orrs	r3, r1
			mOut |= FASTABS(xp);
 801220a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801220c:	ea48 080c 	orr.w	r8, r8, ip
 8012210:	ea48 0703 	orr.w	r7, r8, r3
 8012214:	9b00      	ldr	r3, [sp, #0]
 8012216:	ea43 0307 	orr.w	r3, r3, r7
 801221a:	9300      	str	r3, [sp, #0]
		if (nonZero)
 801221c:	e9dd 3001 	ldrd	r3, r0, [sp, #4]
	for (   ; i < bc->nBlocksPrev; i++) {
 8012220:	9a24      	ldr	r2, [sp, #144]	; 0x90
		if (nonZero)
 8012222:	bf18      	it	ne
 8012224:	4603      	movne	r3, r0
			xPrev[j] = 0;
 8012226:	f846 9c28 	str.w	r9, [r6, #-40]
		if (nonZero)
 801222a:	9301      	str	r3, [sp, #4]
	for (   ; i < bc->nBlocksPrev; i++) {
 801222c:	1c43      	adds	r3, r0, #1
 801222e:	429a      	cmp	r2, r3
 8012230:	9302      	str	r3, [sp, #8]
 8012232:	dd79      	ble.n	8012328 <xmp3fixpt_IMDCT+0x1fb0>
	if (btPrev == 2) {
 8012234:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012236:	f1a6 0024 	sub.w	r0, r6, #36	; 0x24
 801223a:	2b02      	cmp	r3, #2
 801223c:	f43f aeb2 	beq.w	8011fa4 <xmp3fixpt_IMDCT+0x1c2c>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8012240:	f856 1c24 	ldr.w	r1, [r6, #-36]
 8012244:	f8db 208c 	ldr.w	r2, [fp, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012248:	f8db 0048 	ldr.w	r0, [fp, #72]	; 0x48
 801224c:	460b      	mov	r3, r1
 801224e:	fb80 4303 	smull	r4, r3, r0, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 8012252:	934c      	str	r3, [sp, #304]	; 0x130
 8012254:	fb82 0101 	smull	r0, r1, r2, r1
			*xpwHi-- = MULSHIFT32(wHi, x);
 8012258:	915d      	str	r1, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801225a:	f856 4c20 	ldr.w	r4, [r6, #-32]
 801225e:	f8db 1088 	ldr.w	r1, [fp, #136]	; 0x88
 8012262:	f8db 004c 	ldr.w	r0, [fp, #76]	; 0x4c
 8012266:	4622      	mov	r2, r4
 8012268:	fb80 5202 	smull	r5, r2, r0, r2
			*xpwLo++ = MULSHIFT32(wLo, x);
 801226c:	924d      	str	r2, [sp, #308]	; 0x134
 801226e:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8012272:	945c      	str	r4, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8012274:	f856 4c1c 	ldr.w	r4, [r6, #-28]
 8012278:	f8db 1084 	ldr.w	r1, [fp, #132]	; 0x84
 801227c:	f8db 0050 	ldr.w	r0, [fp, #80]	; 0x50
 8012280:	4625      	mov	r5, r4
 8012282:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8012286:	954e      	str	r5, [sp, #312]	; 0x138
 8012288:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801228c:	945b      	str	r4, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801228e:	f856 4c18 	ldr.w	r4, [r6, #-24]
 8012292:	f8db 1080 	ldr.w	r1, [fp, #128]	; 0x80
 8012296:	f8db 0054 	ldr.w	r0, [fp, #84]	; 0x54
 801229a:	4625      	mov	r5, r4
 801229c:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80122a0:	954f      	str	r5, [sp, #316]	; 0x13c
 80122a2:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80122a6:	945a      	str	r4, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80122a8:	f856 4c14 	ldr.w	r4, [r6, #-20]
 80122ac:	f8db 107c 	ldr.w	r1, [fp, #124]	; 0x7c
 80122b0:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
 80122b4:	4625      	mov	r5, r4
 80122b6:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80122ba:	9550      	str	r5, [sp, #320]	; 0x140
 80122bc:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80122c0:	9459      	str	r4, [sp, #356]	; 0x164
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80122c2:	f856 4c10 	ldr.w	r4, [r6, #-16]
 80122c6:	f8db 1078 	ldr.w	r1, [fp, #120]	; 0x78
 80122ca:	f8db 005c 	ldr.w	r0, [fp, #92]	; 0x5c
 80122ce:	4625      	mov	r5, r4
 80122d0:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80122d4:	9551      	str	r5, [sp, #324]	; 0x144
 80122d6:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80122da:	9458      	str	r4, [sp, #352]	; 0x160
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80122dc:	f856 4c0c 	ldr.w	r4, [r6, #-12]
 80122e0:	f8db 1074 	ldr.w	r1, [fp, #116]	; 0x74
 80122e4:	f8db 0060 	ldr.w	r0, [fp, #96]	; 0x60
 80122e8:	4625      	mov	r5, r4
 80122ea:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80122ee:	9552      	str	r5, [sp, #328]	; 0x148
 80122f0:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80122f4:	9457      	str	r4, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80122f6:	f856 4c08 	ldr.w	r4, [r6, #-8]
 80122fa:	f8db 1070 	ldr.w	r1, [fp, #112]	; 0x70
 80122fe:	f8db 0064 	ldr.w	r0, [fp, #100]	; 0x64
 8012302:	4625      	mov	r5, r4
 8012304:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8012308:	9553      	str	r5, [sp, #332]	; 0x14c
 801230a:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801230e:	9456      	str	r4, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8012310:	f856 4c04 	ldr.w	r4, [r6, #-4]
 8012314:	e9db 011a 	ldrd	r0, r1, [fp, #104]	; 0x68
 8012318:	4625      	mov	r5, r4
 801231a:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801231e:	9554      	str	r5, [sp, #336]	; 0x150
 8012320:	fb81 0404 	smull	r0, r4, r1, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8012324:	9455      	str	r4, [sp, #340]	; 0x154
		for (i = 9; i > 0; i--) {
 8012326:	e642      	b.n	8011fae <xmp3fixpt_IMDCT+0x1c36>
 8012328:	4613      	mov	r3, r2
	for (   ; i < 32; i++) {
 801232a:	2b1f      	cmp	r3, #31
 801232c:	dc0f      	bgt.n	801234e <xmp3fixpt_IMDCT+0x1fd6>
 801232e:	4618      	mov	r0, r3
 8012330:	9b32      	ldr	r3, [sp, #200]	; 0xc8
			y[j][i] = 0;
 8012332:	2100      	movs	r1, #0
 8012334:	eb03 0280 	add.w	r2, r3, r0, lsl #2
	for (   ; i < bc->nBlocksPrev; i++) {
 8012338:	2300      	movs	r3, #0
			y[j][i] = 0;
 801233a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (j = 0; j < 18; j++) 
 801233e:	3320      	adds	r3, #32
 8012340:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8012344:	d1f9      	bne.n	801233a <xmp3fixpt_IMDCT+0x1fc2>
	for (   ; i < 32; i++) {
 8012346:	3001      	adds	r0, #1
 8012348:	3204      	adds	r2, #4
 801234a:	2820      	cmp	r0, #32
 801234c:	d1f4      	bne.n	8012338 <xmp3fixpt_IMDCT+0x1fc0>
	if (!x)
 801234e:	9b00      	ldr	r3, [sp, #0]
 8012350:	2b00      	cmp	r3, #0
 8012352:	d03a      	beq.n	80123ca <xmp3fixpt_IMDCT+0x2052>
	while (!(x & 0x80000000)) {
 8012354:	db55      	blt.n	8012402 <xmp3fixpt_IMDCT+0x208a>
 8012356:	4619      	mov	r1, r3
	numZeros = 0;
 8012358:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 801235a:	0049      	lsls	r1, r1, #1
 801235c:	461a      	mov	r2, r3
		numZeros++;
 801235e:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 8012362:	d5fa      	bpl.n	801235a <xmp3fixpt_IMDCT+0x1fe2>
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8012364:	9c38      	ldr	r4, [sp, #224]	; 0xe0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8012366:	e9dd 1336 	ldrd	r1, r3, [sp, #216]	; 0xd8
 801236a:	440b      	add	r3, r1
 801236c:	e9dd 0133 	ldrd	r0, r1, [sp, #204]	; 0xcc
 8012370:	011b      	lsls	r3, r3, #4
 8012372:	4401      	add	r1, r0
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8012374:	9801      	ldr	r0, [sp, #4]
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8012376:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 801237a:	9935      	ldr	r1, [sp, #212]	; 0xd4
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801237c:	f8c4 0b00 	str.w	r0, [r4, #2816]	; 0xb00
	mi->gb[ch] = bc.gbOut;

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 8012380:	2000      	movs	r0, #0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8012382:	4419      	add	r1, r3
 8012384:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 8012386:	9925      	ldr	r1, [sp, #148]	; 0x94
	mi->gb[ch] = bc.gbOut;
 8012388:	f8c4 2b18 	str.w	r2, [r4, #2840]	; 0xb18
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 801238c:	f8c4 1b10 	str.w	r1, [r4, #2832]	; 0xb10
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8012390:	f8c4 3b08 	str.w	r3, [r4, #2824]	; 0xb08
}
 8012394:	b05f      	add	sp, #380	; 0x17c
 8012396:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801239a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8012410 <xmp3fixpt_IMDCT+0x2098>
	for (   ; i < bc->nBlocksPrev; i++) {
 801239e:	9101      	str	r1, [sp, #4]
 80123a0:	e5f0      	b.n	8011f84 <xmp3fixpt_IMDCT+0x1c0c>
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 80123a2:	f8dd b0ac 	ldr.w	fp, [sp, #172]	; 0xac
 80123a6:	9301      	str	r3, [sp, #4]
 80123a8:	f7ff b88a 	b.w	80114c0 <xmp3fixpt_IMDCT+0x1148>
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 80123ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80123ae:	932c      	str	r3, [sp, #176]	; 0xb0
 80123b0:	b16b      	cbz	r3, 80123ce <xmp3fixpt_IMDCT+0x2056>
		nBfly = bc.nBlocksLong - 1;
 80123b2:	9825      	ldr	r0, [sp, #148]	; 0x94
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80123b4:	2112      	movs	r1, #18
 80123b6:	2208      	movs	r2, #8
 80123b8:	1e43      	subs	r3, r0, #1
		bc.nBlocksLong = blockCutoff;	
 80123ba:	902c      	str	r0, [sp, #176]	; 0xb0
 80123bc:	b21b      	sxth	r3, r3
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80123be:	fb13 2201 	smlabb	r2, r3, r1, r2
 80123c2:	4631      	mov	r1, r6
 80123c4:	920e      	str	r2, [sp, #56]	; 0x38
		nBfly = bc.nBlocksLong - 1;
 80123c6:	f7fe bb4e 	b.w	8010a66 <xmp3fixpt_IMDCT+0x6ee>
 80123ca:	221f      	movs	r2, #31
 80123cc:	e7ca      	b.n	8012364 <xmp3fixpt_IMDCT+0x1fec>
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 80123ce:	0213      	lsls	r3, r2, #8
 80123d0:	930f      	str	r3, [sp, #60]	; 0x3c
 80123d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80123d4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80123d8:	2208      	movs	r2, #8
 80123da:	9309      	str	r3, [sp, #36]	; 0x24
 80123dc:	920e      	str	r2, [sp, #56]	; 0x38
 80123de:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 80123e0:	f7fe b909 	b.w	80105f6 <xmp3fixpt_IMDCT+0x27e>
	for (   ; i < bc->nBlocksTotal; i++) {
 80123e4:	9302      	str	r3, [sp, #8]
	for (   ; i < bc->nBlocksPrev; i++) {
 80123e6:	9a24      	ldr	r2, [sp, #144]	; 0x90
 80123e8:	9902      	ldr	r1, [sp, #8]
 80123ea:	428a      	cmp	r2, r1
 80123ec:	f73f abd0 	bgt.w	8011b90 <xmp3fixpt_IMDCT+0x1818>
 80123f0:	460b      	mov	r3, r1
 80123f2:	9124      	str	r1, [sp, #144]	; 0x90
 80123f4:	9101      	str	r1, [sp, #4]
 80123f6:	e798      	b.n	801232a <xmp3fixpt_IMDCT+0x1fb2>
	mOut = 0;
 80123f8:	2300      	movs	r3, #0
 80123fa:	932c      	str	r3, [sp, #176]	; 0xb0
	for(i = 0; i < bc->nBlocksLong; i++) {
 80123fc:	9300      	str	r3, [sp, #0]
 80123fe:	f7fe bcd0 	b.w	8010da2 <xmp3fixpt_IMDCT+0xa2a>
 8012402:	f04f 32ff 	mov.w	r2, #4294967295
 8012406:	e7ad      	b.n	8012364 <xmp3fixpt_IMDCT+0x1fec>
		return -1;
 8012408:	f04f 30ff 	mov.w	r0, #4294967295
 801240c:	e7c2      	b.n	8012394 <xmp3fixpt_IMDCT+0x201c>
 801240e:	bf00      	nop
 8012410:	080252fc 	.word	0x080252fc

08012414 <xmp3fixpt_PolyphaseMono>:
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 *                (note max filter gain - see polyCoef[] comments)
 **************************************************************************************/
void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
{	
 8012414:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	MC0M(1)
	MC0M(2)
	MC0M(3)
	MC0M(4)
	MC0M(5)
	MC0M(6)
 8012418:	6b53      	ldr	r3, [r2, #52]	; 0x34
{	
 801241a:	b087      	sub	sp, #28
	MC0M(7)
 801241c:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
	MC0M(6)
 801241e:	f1c3 0b00 	rsb	fp, r3, #0
}

//mw
static __inline Word64 MADD64(Word64 sum, int x, int y)
{
   return (sum + ((int64_t)x * y));
 8012422:	680b      	ldr	r3, [r1, #0]
	MC0M(7)
 8012424:	4267      	negs	r7, r4
 8012426:	6814      	ldr	r4, [r2, #0]
 8012428:	684d      	ldr	r5, [r1, #4]
 801242a:	fb83 8904 	smull	r8, r9, r3, r4
	MC0M(5)
 801242e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8012430:	6894      	ldr	r4, [r2, #8]
 8012432:	f1c3 0a00 	rsb	sl, r3, #0
	MC0M(4)
 8012436:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8012438:	fbc5 8904 	smlal	r8, r9, r5, r4
 801243c:	f118 7800 	adds.w	r8, r8, #33554432	; 0x2000000
 8012440:	f1c3 0e00 	rsb	lr, r3, #0
	MC0M(3)
 8012444:	69d3      	ldr	r3, [r2, #28]
 8012446:	6916      	ldr	r6, [r2, #16]
 8012448:	f149 0900 	adc.w	r9, r9, #0
 801244c:	f1c3 0c00 	rsb	ip, r3, #0
	MC0M(2)
 8012450:	6953      	ldr	r3, [r2, #20]
	MC0M(0)
 8012452:	6855      	ldr	r5, [r2, #4]
	MC0M(2)
 8012454:	425b      	negs	r3, r3
	MC0M(1)
 8012456:	68d4      	ldr	r4, [r2, #12]
	MC0M(0)
 8012458:	426d      	negs	r5, r5
	MC0M(2)
 801245a:	9300      	str	r3, [sp, #0]
	MC0M(1)
 801245c:	4264      	negs	r4, r4
 801245e:	688b      	ldr	r3, [r1, #8]
 8012460:	fbc3 8906 	smlal	r8, r9, r3, r6
 8012464:	6996      	ldr	r6, [r2, #24]
 8012466:	68cb      	ldr	r3, [r1, #12]
 8012468:	fbc3 8906 	smlal	r8, r9, r3, r6
 801246c:	6a16      	ldr	r6, [r2, #32]
 801246e:	690b      	ldr	r3, [r1, #16]
 8012470:	fbc3 8906 	smlal	r8, r9, r3, r6
 8012474:	6a96      	ldr	r6, [r2, #40]	; 0x28
 8012476:	694b      	ldr	r3, [r1, #20]
 8012478:	fbc3 8906 	smlal	r8, r9, r3, r6
 801247c:	6b16      	ldr	r6, [r2, #48]	; 0x30
 801247e:	698b      	ldr	r3, [r1, #24]
 8012480:	fbc3 8906 	smlal	r8, r9, r3, r6
 8012484:	69ce      	ldr	r6, [r1, #28]
 8012486:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8012488:	fbc3 8906 	smlal	r8, r9, r3, r6
 801248c:	6dce      	ldr	r6, [r1, #92]	; 0x5c
 801248e:	9b00      	ldr	r3, [sp, #0]
 8012490:	fbc6 8905 	smlal	r8, r9, r6, r5
 8012494:	6d8d      	ldr	r5, [r1, #88]	; 0x58
 8012496:	fbc5 8904 	smlal	r8, r9, r5, r4
 801249a:	6d4c      	ldr	r4, [r1, #84]	; 0x54
 801249c:	464e      	mov	r6, r9
 801249e:	fbc4 8603 	smlal	r8, r6, r4, r3
 80124a2:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 80124a4:	6ccc      	ldr	r4, [r1, #76]	; 0x4c
 80124a6:	fbc3 860c 	smlal	r8, r6, r3, ip
 80124aa:	4643      	mov	r3, r8
 80124ac:	fbc4 360e 	smlal	r3, r6, r4, lr
 80124b0:	6c8c      	ldr	r4, [r1, #72]	; 0x48
 80124b2:	6c4d      	ldr	r5, [r1, #68]	; 0x44
 80124b4:	fbc4 360a 	smlal	r3, r6, r4, sl
 80124b8:	4634      	mov	r4, r6
 80124ba:	fbc5 340b 	smlal	r3, r4, r5, fp
 80124be:	6c0d      	ldr	r5, [r1, #64]	; 0x40
 80124c0:	fbc7 3405 	smlal	r3, r4, r7, r5
  return x << n;
}

static __inline Word64 SAR64(Word64 x, int n)
{
  return x >> n;
 80124c4:	0d1b      	lsrs	r3, r3, #20
 80124c6:	ea43 3304 	orr.w	r3, r3, r4, lsl #12
	if (sign != (x >> 15))
 80124ca:	155c      	asrs	r4, r3, #21
 80124cc:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 80124d0:	f000 8129 	beq.w	8012726 <xmp3fixpt_PolyphaseMono+0x312>
		x = sign ^ ((1 << 15) - 1);
 80124d4:	17dd      	asrs	r5, r3, #31
 80124d6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80124da:	406b      	eors	r3, r5
	MC1M(2)
	MC1M(3)
	MC1M(4)
	MC1M(5)
	MC1M(6)
	MC1M(7)
 80124dc:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	return (short)x;
 80124e0:	8003      	strh	r3, [r0, #0]
   return (sum + ((int64_t)x * y));
 80124e2:	f8d2 3404 	ldr.w	r3, [r2, #1028]	; 0x404
 80124e6:	6866      	ldr	r6, [r4, #4]
 80124e8:	f8d2 5400 	ldr.w	r5, [r2, #1024]	; 0x400
 80124ec:	fb83 3706 	smull	r3, r7, r3, r6
 80124f0:	6826      	ldr	r6, [r4, #0]
 80124f2:	fbc5 3706 	smlal	r3, r7, r5, r6
 80124f6:	f113 7300 	adds.w	r3, r3, #33554432	; 0x2000000
 80124fa:	68a5      	ldr	r5, [r4, #8]
 80124fc:	f147 0700 	adc.w	r7, r7, #0
 8012500:	f8d2 6408 	ldr.w	r6, [r2, #1032]	; 0x408
 8012504:	fbc6 3705 	smlal	r3, r7, r6, r5
 8012508:	68e5      	ldr	r5, [r4, #12]
 801250a:	f8d2 640c 	ldr.w	r6, [r2, #1036]	; 0x40c
 801250e:	fbc6 3705 	smlal	r3, r7, r6, r5
 8012512:	6925      	ldr	r5, [r4, #16]
 8012514:	f8d2 6410 	ldr.w	r6, [r2, #1040]	; 0x410
 8012518:	fbc6 3705 	smlal	r3, r7, r6, r5
 801251c:	6965      	ldr	r5, [r4, #20]
 801251e:	f8d2 6414 	ldr.w	r6, [r2, #1044]	; 0x414
 8012522:	fbc6 3705 	smlal	r3, r7, r6, r5
 8012526:	69a5      	ldr	r5, [r4, #24]
 8012528:	f8d2 6418 	ldr.w	r6, [r2, #1048]	; 0x418
 801252c:	fbc6 3705 	smlal	r3, r7, r6, r5
 8012530:	69e6      	ldr	r6, [r4, #28]
 8012532:	f8d2 541c 	ldr.w	r5, [r2, #1052]	; 0x41c
 8012536:	463c      	mov	r4, r7
 8012538:	fbc5 3406 	smlal	r3, r4, r5, r6
  return x >> n;
 801253c:	0d1b      	lsrs	r3, r3, #20
 801253e:	ea43 3304 	orr.w	r3, r3, r4, lsl #12
	if (sign != (x >> 15))
 8012542:	155c      	asrs	r4, r3, #21
	sign = x >> 31;
 8012544:	17dd      	asrs	r5, r3, #31
	if (sign != (x >> 15))
 8012546:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 801254a:	f000 80ee 	beq.w	801272a <xmp3fixpt_PolyphaseMono+0x316>
		x = sign ^ ((1 << 15) - 1);
 801254e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8012552:	406b      	eors	r3, r5
	return (short)x;
 8012554:	f102 0c80 	add.w	ip, r2, #128	; 0x80
 8012558:	f100 0640 	add.w	r6, r0, #64	; 0x40
 801255c:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 8012560:	460f      	mov	r7, r1
		x = sign ^ ((1 << 15) - 1);
 8012562:	4686      	mov	lr, r0
	return (short)x;
 8012564:	8403      	strh	r3, [r0, #32]
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm++;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8012566:	9205      	str	r2, [sp, #20]
		x = sign ^ ((1 << 15) - 1);
 8012568:	9600      	str	r6, [sp, #0]
		MC2M(2)
		MC2M(3)
		MC2M(4)
		MC2M(5)
		MC2M(6)
		MC2M(7)
 801256a:	f85c 1c04 	ldr.w	r1, [ip, #-4]
	for (i = 15; i > 0; i--) {
 801256e:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
		MC2M(0)
 8012572:	f85c 2c7c 	ldr.w	r2, [ip, #-124]
	for (i = 15; i > 0; i--) {
 8012576:	f507 7780 	add.w	r7, r7, #256	; 0x100
		MC2M(7)
 801257a:	4249      	negs	r1, r1
		MC2M(0)
 801257c:	683b      	ldr	r3, [r7, #0]
 801257e:	f85c bc80 	ldr.w	fp, [ip, #-128]
 8012582:	f1c2 0a00 	rsb	sl, r2, #0
		MC2M(7)
 8012586:	9101      	str	r1, [sp, #4]
		MC2M(4)
 8012588:	f85c 1c5c 	ldr.w	r1, [ip, #-92]
   return (sum + ((int64_t)x * y));
 801258c:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 801258e:	4249      	negs	r1, r1
 8012590:	687c      	ldr	r4, [r7, #4]
		MC2M(6)
 8012592:	f85c 5c4c 	ldr.w	r5, [ip, #-76]
		MC2M(4)
 8012596:	9102      	str	r1, [sp, #8]
		MC2M(3)
 8012598:	f85c 1c64 	ldr.w	r1, [ip, #-100]
		MC2M(6)
 801259c:	4268      	negs	r0, r5
		MC2M(5)
 801259e:	f85c 5c54 	ldr.w	r5, [ip, #-84]
		MC2M(3)
 80125a2:	4249      	negs	r1, r1
		MC2M(5)
 80125a4:	426d      	negs	r5, r5
		MC2M(3)
 80125a6:	9103      	str	r1, [sp, #12]
		MC2M(2)
 80125a8:	f85c 1c6c 	ldr.w	r1, [ip, #-108]
 80125ac:	f1c1 0800 	rsb	r8, r1, #0
		MC2M(1)
 80125b0:	f85c 1c74 	ldr.w	r1, [ip, #-116]
 80125b4:	f1c1 0900 	rsb	r9, r1, #0
 80125b8:	fb82 2103 	smull	r2, r1, r2, r3
 80125bc:	fbc6 210b 	smlal	r2, r1, r6, fp
 80125c0:	f85c 6c78 	ldr.w	r6, [ip, #-120]
 80125c4:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80125c8:	fb8b 3b03 	smull	r3, fp, fp, r3
 80125cc:	f141 0100 	adc.w	r1, r1, #0
 80125d0:	fbc6 3b04 	smlal	r3, fp, r6, r4
 80125d4:	f85c 4c74 	ldr.w	r4, [ip, #-116]
 80125d8:	f113 7300 	adds.w	r3, r3, #33554432	; 0x2000000
 80125dc:	687e      	ldr	r6, [r7, #4]
 80125de:	f14b 0b00 	adc.w	fp, fp, #0
 80125e2:	fbc4 2106 	smlal	r2, r1, r4, r6
 80125e6:	f85c 6c78 	ldr.w	r6, [ip, #-120]
 80125ea:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 80125ec:	fbc4 2106 	smlal	r2, r1, r4, r6
 80125f0:	f85c 4c6c 	ldr.w	r4, [ip, #-108]
 80125f4:	68be      	ldr	r6, [r7, #8]
 80125f6:	fbc4 2106 	smlal	r2, r1, r4, r6
 80125fa:	f85c 6c70 	ldr.w	r6, [ip, #-112]
 80125fe:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 8012600:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012604:	f85c 4c64 	ldr.w	r4, [ip, #-100]
 8012608:	68fe      	ldr	r6, [r7, #12]
 801260a:	fbc4 2106 	smlal	r2, r1, r4, r6
 801260e:	f85c 4c70 	ldr.w	r4, [ip, #-112]
 8012612:	68be      	ldr	r6, [r7, #8]
 8012614:	fbc4 3b06 	smlal	r3, fp, r4, r6
 8012618:	f85c 4c68 	ldr.w	r4, [ip, #-104]
 801261c:	68fe      	ldr	r6, [r7, #12]
 801261e:	fbc4 3b06 	smlal	r3, fp, r4, r6
 8012622:	f85c 6c68 	ldr.w	r6, [ip, #-104]
 8012626:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8012628:	fbc4 2106 	smlal	r2, r1, r4, r6
 801262c:	f85c 4c5c 	ldr.w	r4, [ip, #-92]
 8012630:	693e      	ldr	r6, [r7, #16]
 8012632:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012636:	f85c 4c60 	ldr.w	r4, [ip, #-96]
 801263a:	fbc4 3b06 	smlal	r3, fp, r4, r6
 801263e:	f85c 6c60 	ldr.w	r6, [ip, #-96]
 8012642:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 8012644:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012648:	f85c 4c54 	ldr.w	r4, [ip, #-84]
 801264c:	697e      	ldr	r6, [r7, #20]
 801264e:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012652:	f85c 4c58 	ldr.w	r4, [ip, #-88]
 8012656:	fbc4 3b06 	smlal	r3, fp, r4, r6
 801265a:	f85c 6c58 	ldr.w	r6, [ip, #-88]
 801265e:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 8012660:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012664:	f85c 4c4c 	ldr.w	r4, [ip, #-76]
 8012668:	69be      	ldr	r6, [r7, #24]
 801266a:	fbc4 2106 	smlal	r2, r1, r4, r6
 801266e:	f85c 4c50 	ldr.w	r4, [ip, #-80]
 8012672:	fbc4 3b06 	smlal	r3, fp, r4, r6
 8012676:	f85c 6c50 	ldr.w	r6, [ip, #-80]
 801267a:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 801267c:	fbc4 2106 	smlal	r2, r1, r4, r6
 8012680:	f85c 4c44 	ldr.w	r4, [ip, #-68]
 8012684:	69fe      	ldr	r6, [r7, #28]
 8012686:	fbc4 2106 	smlal	r2, r1, r4, r6
 801268a:	f85c 4c48 	ldr.w	r4, [ip, #-72]
 801268e:	9204      	str	r2, [sp, #16]
 8012690:	fbc4 3b06 	smlal	r3, fp, r4, r6
 8012694:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 8012696:	9a03      	ldr	r2, [sp, #12]
 8012698:	fbca 3b04 	smlal	r3, fp, sl, r4
 801269c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 801269e:	fbc9 3b04 	smlal	r3, fp, r9, r4
 80126a2:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 80126a4:	fbc8 3b04 	smlal	r3, fp, r8, r4
 80126a8:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 80126aa:	fbc2 3b04 	smlal	r3, fp, r2, r4
 80126ae:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 80126b0:	9a02      	ldr	r2, [sp, #8]
 80126b2:	fbc2 3b04 	smlal	r3, fp, r2, r4
 80126b6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80126b8:	f85c 4c48 	ldr.w	r4, [ip, #-72]
 80126bc:	fbc5 3b02 	smlal	r3, fp, r5, r2
 80126c0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80126c2:	fbc0 3b02 	smlal	r3, fp, r0, r2
 80126c6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80126c8:	9804      	ldr	r0, [sp, #16]
 80126ca:	fbc2 0104 	smlal	r0, r1, r2, r4
 80126ce:	4602      	mov	r2, r0
 80126d0:	9801      	ldr	r0, [sp, #4]
 80126d2:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  return x >> n;
 80126d4:	0d12      	lsrs	r2, r2, #20
   return (sum + ((int64_t)x * y));
 80126d6:	fbc0 3b04 	smlal	r3, fp, r0, r4
  return x >> n;
 80126da:	0d1b      	lsrs	r3, r3, #20
 80126dc:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
 80126e0:	ea43 330b 	orr.w	r3, r3, fp, lsl #12
	if (sign != (x >> 15))
 80126e4:	1551      	asrs	r1, r2, #21
 80126e6:	155d      	asrs	r5, r3, #21
	sign = x >> 31;
 80126e8:	17d8      	asrs	r0, r3, #31
	if (sign != (x >> 15))
 80126ea:	ebb5 7fe3 	cmp.w	r5, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 80126ee:	f480 40ff 	eor.w	r0, r0, #32640	; 0x7f80
 80126f2:	f080 007f 	eor.w	r0, r0, #127	; 0x7f
	x >>= fracBits;
 80126f6:	bf08      	it	eq
 80126f8:	1198      	asreq	r0, r3, #6
	sign = x >> 31;
 80126fa:	17d3      	asrs	r3, r2, #31
	if (sign != (x >> 15))
 80126fc:	ebb1 7fe2 	cmp.w	r1, r2, asr #31
	return (short)x;
 8012700:	f82e 0f02 	strh.w	r0, [lr, #2]!
		x = sign ^ ((1 << 15) - 1);
 8012704:	f483 43ff 	eor.w	r3, r3, #32640	; 0x7f80
 8012708:	f083 037f 	eor.w	r3, r3, #127	; 0x7f
	x >>= fracBits;
 801270c:	bf08      	it	eq
 801270e:	1193      	asreq	r3, r2, #6
	return (short)x;
 8012710:	9a00      	ldr	r2, [sp, #0]
 8012712:	f822 3d02 	strh.w	r3, [r2, #-2]!
	for (i = 15; i > 0; i--) {
 8012716:	9b05      	ldr	r3, [sp, #20]
	return (short)x;
 8012718:	9200      	str	r2, [sp, #0]
	for (i = 15; i > 0; i--) {
 801271a:	4563      	cmp	r3, ip
 801271c:	f47f af25 	bne.w	801256a <xmp3fixpt_PolyphaseMono+0x156>
		vb1 += 64;
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		pcm++;
	}
}
 8012720:	b007      	add	sp, #28
 8012722:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	x >>= fracBits;
 8012726:	119b      	asrs	r3, r3, #6
 8012728:	e6d8      	b.n	80124dc <xmp3fixpt_PolyphaseMono+0xc8>
 801272a:	119b      	asrs	r3, r3, #6
 801272c:	e712      	b.n	8012554 <xmp3fixpt_PolyphaseMono+0x140>
 801272e:	bf00      	nop

08012730 <xmp3fixpt_PolyphaseStereo>:
 * Notes:       interleaves PCM samples LRLRLR...
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 **************************************************************************************/
void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
{
 8012730:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012734:	4615      	mov	r5, r2
 8012736:	460c      	mov	r4, r1
 8012738:	b08b      	sub	sp, #44	; 0x2c
 801273a:	4683      	mov	fp, r0
	MC0S(0)
	MC0S(1)
	MC0S(2)
	MC0S(3)
	MC0S(4)
	MC0S(5)
 801273c:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   return (sum + ((int64_t)x * y));
 801273e:	692b      	ldr	r3, [r5, #16]
 8012740:	4249      	negs	r1, r1
	MC0S(6)
	MC0S(7)
 8012742:	6bef      	ldr	r7, [r5, #60]	; 0x3c
	MC0S(0)
 8012744:	e9d2 8200 	ldrd	r8, r2, [r2]
	MC0S(5)
 8012748:	9103      	str	r1, [sp, #12]
	MC0S(7)
 801274a:	427f      	negs	r7, r7
 801274c:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
	MC0S(0)
 8012750:	4252      	negs	r2, r2
 8012752:	fb88 ce01 	smull	ip, lr, r8, r1
 8012756:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 801275a:	9201      	str	r2, [sp, #4]
	MC0S(1)
 801275c:	e9d5 0202 	ldrd	r0, r2, [r5, #8]
 8012760:	fbc1 ce00 	smlal	ip, lr, r1, r0
 8012764:	f11c 7c00 	adds.w	ip, ip, #33554432	; 0x2000000
 8012768:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
 801276c:	f1c2 0900 	rsb	r9, r2, #0
 8012770:	f14e 0e00 	adc.w	lr, lr, #0
	MC0S(2)
 8012774:	696a      	ldr	r2, [r5, #20]
 8012776:	fbc1 ce03 	smlal	ip, lr, r1, r3
 801277a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 801277e:	69a9      	ldr	r1, [r5, #24]
 8012780:	f1c2 0a00 	rsb	sl, r2, #0
	MC0S(3)
 8012784:	69ea      	ldr	r2, [r5, #28]
 8012786:	fbc3 ce01 	smlal	ip, lr, r3, r1
 801278a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 801278e:	6a29      	ldr	r1, [r5, #32]
 8012790:	4256      	negs	r6, r2
	MC0S(4)
 8012792:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8012794:	fbc3 ce01 	smlal	ip, lr, r3, r1
 8012798:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 801279c:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 801279e:	4252      	negs	r2, r2
	MC0S(3)
 80127a0:	9602      	str	r6, [sp, #8]
 80127a2:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127a6:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80127aa:	6b29      	ldr	r1, [r5, #48]	; 0x30
	MC0S(6)
 80127ac:	6b6e      	ldr	r6, [r5, #52]	; 0x34
 80127ae:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127b2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80127b4:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
 80127b8:	4276      	negs	r6, r6
 80127ba:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127be:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 80127c2:	9901      	ldr	r1, [sp, #4]
 80127c4:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127c8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 80127cc:	fbc3 ce09 	smlal	ip, lr, r3, r9
 80127d0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80127d4:	fbc3 ce0a 	smlal	ip, lr, r3, sl
 80127d8:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80127dc:	9902      	ldr	r1, [sp, #8]
 80127de:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127e2:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80127e6:	9903      	ldr	r1, [sp, #12]
 80127e8:	fbc3 ce02 	smlal	ip, lr, r3, r2
 80127ec:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 80127f0:	fbc3 ce01 	smlal	ip, lr, r3, r1
 80127f4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80127f8:	6861      	ldr	r1, [r4, #4]
 80127fa:	fbc3 ce06 	smlal	ip, lr, r3, r6
 80127fe:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8012802:	fbc7 ce03 	smlal	ip, lr, r7, r3
 8012806:	6823      	ldr	r3, [r4, #0]
 8012808:	f8cd c010 	str.w	ip, [sp, #16]
 801280c:	fb88 8303 	smull	r8, r3, r8, r3
 8012810:	fbc1 8300 	smlal	r8, r3, r1, r0
 8012814:	f118 7000 	adds.w	r0, r8, #33554432	; 0x2000000
 8012818:	6929      	ldr	r1, [r5, #16]
 801281a:	f143 0c00 	adc.w	ip, r3, #0
 801281e:	68a3      	ldr	r3, [r4, #8]
 8012820:	fbc3 0c01 	smlal	r0, ip, r3, r1
 8012824:	68e3      	ldr	r3, [r4, #12]
 8012826:	69a9      	ldr	r1, [r5, #24]
 8012828:	fbc3 0c01 	smlal	r0, ip, r3, r1
 801282c:	6923      	ldr	r3, [r4, #16]
 801282e:	6a29      	ldr	r1, [r5, #32]
 8012830:	fbc3 0c01 	smlal	r0, ip, r3, r1
 8012834:	6963      	ldr	r3, [r4, #20]
 8012836:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8012838:	fbc3 0c01 	smlal	r0, ip, r3, r1
 801283c:	69a3      	ldr	r3, [r4, #24]
 801283e:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8012840:	fbc3 0c01 	smlal	r0, ip, r3, r1
 8012844:	69e3      	ldr	r3, [r4, #28]
 8012846:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8012848:	fbc1 0c03 	smlal	r0, ip, r1, r3
 801284c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 801284e:	9901      	ldr	r1, [sp, #4]
 8012850:	fbc3 0c01 	smlal	r0, ip, r3, r1
 8012854:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8012856:	9902      	ldr	r1, [sp, #8]
 8012858:	fbc3 0c09 	smlal	r0, ip, r3, r9
 801285c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 801285e:	fbc3 0c0a 	smlal	r0, ip, r3, sl
 8012862:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8012864:	fbc3 0c01 	smlal	r0, ip, r3, r1
 8012868:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 801286a:	fbc3 0c02 	smlal	r0, ip, r3, r2
 801286e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8012870:	9a03      	ldr	r2, [sp, #12]
 8012872:	fbc3 0c02 	smlal	r0, ip, r3, r2
 8012876:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8012878:	4603      	mov	r3, r0
 801287a:	4660      	mov	r0, ip
 801287c:	fbc2 3006 	smlal	r3, r0, r2, r6
 8012880:	6c26      	ldr	r6, [r4, #64]	; 0x40
 8012882:	fbc7 3006 	smlal	r3, r0, r7, r6
  return x >> n;
 8012886:	0d1b      	lsrs	r3, r3, #20
 8012888:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
	if (sign != (x >> 15))
 801288c:	1558      	asrs	r0, r3, #21
 801288e:	ebb0 7fe3 	cmp.w	r0, r3, asr #31
 8012892:	f000 826a 	beq.w	8012d6a <xmp3fixpt_PolyphaseStereo+0x63a>
		x = sign ^ ((1 << 15) - 1);
 8012896:	17de      	asrs	r6, r3, #31
 8012898:	f647 73ff 	movw	r3, #32767	; 0x7fff
 801289c:	4073      	eors	r3, r6
	return (short)x;
 801289e:	f8ab 3000 	strh.w	r3, [fp]
 80128a2:	9b04      	ldr	r3, [sp, #16]
 80128a4:	0d1a      	lsrs	r2, r3, #20
 80128a6:	ea42 320e 	orr.w	r2, r2, lr, lsl #12
	if (sign != (x >> 15))
 80128aa:	1553      	asrs	r3, r2, #21
	sign = x >> 31;
 80128ac:	17d1      	asrs	r1, r2, #31
	if (sign != (x >> 15))
 80128ae:	ebb3 7fe2 	cmp.w	r3, r2, asr #31
 80128b2:	f000 8261 	beq.w	8012d78 <xmp3fixpt_PolyphaseStereo+0x648>
		x = sign ^ ((1 << 15) - 1);
 80128b6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80128ba:	404b      	eors	r3, r1
	MC1S(2)
	MC1S(3)
	MC1S(4)
	MC1S(5)
	MC1S(6)
	MC1S(7)
 80128bc:	f504 5080 	add.w	r0, r4, #4096	; 0x1000
	MC1S(1)
 80128c0:	f8d5 2404 	ldr.w	r2, [r5, #1028]	; 0x404
	MC1S(0)
 80128c4:	f8d5 1400 	ldr.w	r1, [r5, #1024]	; 0x400
	return (short)x;
 80128c8:	f8ab 3002 	strh.w	r3, [fp, #2]
	MC1S(3)
 80128cc:	f8d5 340c 	ldr.w	r3, [r5, #1036]	; 0x40c
   return (sum + ((int64_t)x * y));
 80128d0:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 80128d4:	9302      	str	r3, [sp, #8]
 80128d6:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80128da:	6807      	ldr	r7, [r0, #0]
 80128dc:	fb82 e303 	smull	lr, r3, r2, r3
	MC1S(2)
 80128e0:	f8d5 c408 	ldr.w	ip, [r5, #1032]	; 0x408
	MC1S(7)
 80128e4:	f8d5 841c 	ldr.w	r8, [r5, #1052]	; 0x41c
 80128e8:	fbc1 e306 	smlal	lr, r3, r1, r6
 80128ec:	6846      	ldr	r6, [r0, #4]
 80128ee:	fb82 9a06 	smull	r9, sl, r2, r6
 80128f2:	f11e 7200 	adds.w	r2, lr, #33554432	; 0x2000000
 80128f6:	6886      	ldr	r6, [r0, #8]
 80128f8:	fbc1 9a07 	smlal	r9, sl, r1, r7
 80128fc:	f143 0300 	adc.w	r3, r3, #0
 8012900:	f119 7900 	adds.w	r9, r9, #33554432	; 0x2000000
 8012904:	9902      	ldr	r1, [sp, #8]
	MC1S(4)
 8012906:	f8d5 7410 	ldr.w	r7, [r5, #1040]	; 0x410
 801290a:	f14a 0a00 	adc.w	sl, sl, #0
	MC1S(5)
 801290e:	f8d5 e414 	ldr.w	lr, [r5, #1044]	; 0x414
 8012912:	9303      	str	r3, [sp, #12]
 8012914:	fbcc 9a06 	smlal	r9, sl, ip, r6
 8012918:	68c6      	ldr	r6, [r0, #12]
	MC1S(6)
 801291a:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
 801291e:	fbc1 9a06 	smlal	r9, sl, r1, r6
 8012922:	6906      	ldr	r6, [r0, #16]
 8012924:	9301      	str	r3, [sp, #4]
 8012926:	fbc7 9a06 	smlal	r9, sl, r7, r6
 801292a:	6946      	ldr	r6, [r0, #20]
 801292c:	fbce 9a06 	smlal	r9, sl, lr, r6
 8012930:	6986      	ldr	r6, [r0, #24]
 8012932:	fbc3 9a06 	smlal	r9, sl, r3, r6
 8012936:	69c6      	ldr	r6, [r0, #28]
 8012938:	9b03      	ldr	r3, [sp, #12]
 801293a:	fbc8 9a06 	smlal	r9, sl, r8, r6
 801293e:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
  return x >> n;
 8012942:	ea4f 5919 	mov.w	r9, r9, lsr #20
   return (sum + ((int64_t)x * y));
 8012946:	fbcc 2306 	smlal	r2, r3, ip, r6
 801294a:	f8d0 608c 	ldr.w	r6, [r0, #140]	; 0x8c
  return x >> n;
 801294e:	ea49 390a 	orr.w	r9, r9, sl, lsl #12
   return (sum + ((int64_t)x * y));
 8012952:	fbc1 2306 	smlal	r2, r3, r1, r6
 8012956:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
 801295a:	4694      	mov	ip, r2
 801295c:	9901      	ldr	r1, [sp, #4]
 801295e:	fbc7 c306 	smlal	ip, r3, r7, r6
 8012962:	f8d0 6094 	ldr.w	r6, [r0, #148]	; 0x94
 8012966:	461a      	mov	r2, r3
 8012968:	4663      	mov	r3, ip
 801296a:	fbce 3206 	smlal	r3, r2, lr, r6
 801296e:	f8d0 6098 	ldr.w	r6, [r0, #152]	; 0x98
 8012972:	fbc1 3206 	smlal	r3, r2, r1, r6
 8012976:	f8d0 109c 	ldr.w	r1, [r0, #156]	; 0x9c
	sign = x >> 31;
 801297a:	ea4f 70e9 	mov.w	r0, r9, asr #31
 801297e:	fbc8 3201 	smlal	r3, r2, r8, r1
	if (sign != (x >> 15))
 8012982:	ea4f 5169 	mov.w	r1, r9, asr #21
 8012986:	ebb1 7fe9 	cmp.w	r1, r9, asr #31
 801298a:	f000 81f2 	beq.w	8012d72 <xmp3fixpt_PolyphaseStereo+0x642>
		x = sign ^ ((1 << 15) - 1);
 801298e:	f647 79ff 	movw	r9, #32767	; 0x7fff
 8012992:	ea80 0909 	eor.w	r9, r0, r9
  return x >> n;
 8012996:	0d1b      	lsrs	r3, r3, #20
	return (short)x;
 8012998:	f8ab 9040 	strh.w	r9, [fp, #64]	; 0x40
 801299c:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
	if (sign != (x >> 15))
 80129a0:	155a      	asrs	r2, r3, #21
	sign = x >> 31;
 80129a2:	17d9      	asrs	r1, r3, #31
	if (sign != (x >> 15))
 80129a4:	ebb2 7fe3 	cmp.w	r2, r3, asr #31
 80129a8:	f000 81e1 	beq.w	8012d6e <xmp3fixpt_PolyphaseStereo+0x63e>
		x = sign ^ ((1 << 15) - 1);
 80129ac:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80129b0:	404b      	eors	r3, r1
	return (short)x;
 80129b2:	f8ab 3042 	strh.w	r3, [fp, #66]	; 0x42
 80129b6:	f505 6388 	add.w	r3, r5, #1088	; 0x440
 80129ba:	f10b 0808 	add.w	r8, fp, #8
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm += 2;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 80129be:	46a6      	mov	lr, r4
 80129c0:	f105 0080 	add.w	r0, r5, #128	; 0x80
 80129c4:	9309      	str	r3, [sp, #36]	; 0x24
		x = sign ^ ((1 << 15) - 1);
 80129c6:	f8cd b004 	str.w	fp, [sp, #4]
 80129ca:	e03e      	b.n	8012a4a <xmp3fixpt_PolyphaseStereo+0x31a>
 80129cc:	f647 71ff 	movw	r1, #32767	; 0x7fff
 80129d0:	ea8c 0101 	eor.w	r1, ip, r1
 80129d4:	0d12      	lsrs	r2, r2, #20
	return (short)x;
 80129d6:	f828 1c04 	strh.w	r1, [r8, #-4]
 80129da:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
	if (sign != (x >> 15))
 80129de:	1556      	asrs	r6, r2, #21
	sign = x >> 31;
 80129e0:	17d1      	asrs	r1, r2, #31
	if (sign != (x >> 15))
 80129e2:	ebb6 7fe2 	cmp.w	r6, r2, asr #31
 80129e6:	f000 81bb 	beq.w	8012d60 <xmp3fixpt_PolyphaseStereo+0x630>
		x = sign ^ ((1 << 15) - 1);
 80129ea:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80129ee:	404a      	eors	r2, r1
 80129f0:	9907      	ldr	r1, [sp, #28]
	return (short)x;
 80129f2:	f828 2c02 	strh.w	r2, [r8, #-2]
 80129f6:	0d0e      	lsrs	r6, r1, #20
 80129f8:	9a08      	ldr	r2, [sp, #32]
 80129fa:	ea46 3602 	orr.w	r6, r6, r2, lsl #12
	if (sign != (x >> 15))
 80129fe:	1571      	asrs	r1, r6, #21
	sign = x >> 31;
 8012a00:	17f2      	asrs	r2, r6, #31
	if (sign != (x >> 15))
 8012a02:	ebb1 7fe6 	cmp.w	r1, r6, asr #31
 8012a06:	f000 81a9 	beq.w	8012d5c <xmp3fixpt_PolyphaseStereo+0x62c>
		x = sign ^ ((1 << 15) - 1);
 8012a0a:	f647 76ff 	movw	r6, #32767	; 0x7fff
 8012a0e:	4056      	eors	r6, r2
 8012a10:	0d1b      	lsrs	r3, r3, #20
	return (short)x;
 8012a12:	9a01      	ldr	r2, [sp, #4]
 8012a14:	ea43 3304 	orr.w	r3, r3, r4, lsl #12
 8012a18:	f8a2 607c 	strh.w	r6, [r2, #124]	; 0x7c
	if (sign != (x >> 15))
 8012a1c:	1559      	asrs	r1, r3, #21
	sign = x >> 31;
 8012a1e:	17da      	asrs	r2, r3, #31
	if (sign != (x >> 15))
 8012a20:	ebb1 7fe3 	cmp.w	r1, r3, asr #31
 8012a24:	f000 8198 	beq.w	8012d58 <xmp3fixpt_PolyphaseStereo+0x628>
		x = sign ^ ((1 << 15) - 1);
 8012a28:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8012a2c:	4053      	eors	r3, r2
	return (short)x;
 8012a2e:	9a01      	ldr	r2, [sp, #4]
	for (i = 15; i > 0; i--) {
 8012a30:	3040      	adds	r0, #64	; 0x40
 8012a32:	f108 0804 	add.w	r8, r8, #4
 8012a36:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
	return (short)x;
 8012a3a:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
	for (i = 15; i > 0; i--) {
 8012a3e:	1f13      	subs	r3, r2, #4
 8012a40:	9301      	str	r3, [sp, #4]
 8012a42:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012a44:	4283      	cmp	r3, r0
 8012a46:	f000 818d 	beq.w	8012d64 <xmp3fixpt_PolyphaseStereo+0x634>
		sum1L = sum2L = rndVal;
		sum1R = sum2R = rndVal;

		MC2S(0)
		MC2S(1)
 8012a4a:	f850 6c34 	ldr.w	r6, [r0, #-52]
		MC2S(0)
 8012a4e:	f850 4c3c 	ldr.w	r4, [r0, #-60]
		MC2S(1)
 8012a52:	f1c6 0a00 	rsb	sl, r6, #0
		MC2S(2)
 8012a56:	f850 6c2c 	ldr.w	r6, [r0, #-44]
		MC2S(0)
 8012a5a:	4263      	negs	r3, r4
 8012a5c:	f8de b100 	ldr.w	fp, [lr, #256]	; 0x100
		MC2S(2)
 8012a60:	f1c6 0900 	rsb	r9, r6, #0
		MC2S(3)
 8012a64:	f850 6c24 	ldr.w	r6, [r0, #-36]
		MC2S(0)
 8012a68:	9306      	str	r3, [sp, #24]
		MC2S(3)
 8012a6a:	f1c6 0c00 	rsb	ip, r6, #0
		MC2S(4)
		MC2S(5)
 8012a6e:	f850 3c14 	ldr.w	r3, [r0, #-20]
		MC2S(4)
 8012a72:	f850 6c1c 	ldr.w	r6, [r0, #-28]
		MC2S(5)
 8012a76:	425b      	negs	r3, r3
		MC2S(0)
 8012a78:	f850 1c40 	ldr.w	r1, [r0, #-64]
		MC2S(4)
 8012a7c:	4276      	negs	r6, r6
   return (sum + ((int64_t)x * y));
 8012a7e:	f8de 7104 	ldr.w	r7, [lr, #260]	; 0x104
		MC2S(5)
 8012a82:	9304      	str	r3, [sp, #16]
		MC2S(4)
 8012a84:	9605      	str	r6, [sp, #20]
		MC2S(6)
		MC2S(7)
 8012a86:	f850 3c04 	ldr.w	r3, [r0, #-4]
		MC2S(6)
 8012a8a:	f850 6c0c 	ldr.w	r6, [r0, #-12]
		MC2S(7)
 8012a8e:	425b      	negs	r3, r3
		MC2S(0)
 8012a90:	f8de 2180 	ldr.w	r2, [lr, #384]	; 0x180
		MC2S(6)
 8012a94:	4276      	negs	r6, r6
		MC2S(7)
 8012a96:	9302      	str	r3, [sp, #8]
		MC2S(6)
 8012a98:	9603      	str	r6, [sp, #12]
 8012a9a:	f8de 315c 	ldr.w	r3, [lr, #348]	; 0x15c
 8012a9e:	fb84 650b 	smull	r6, r5, r4, fp
 8012aa2:	fbc3 6501 	smlal	r6, r5, r3, r1
 8012aa6:	f116 7600 	adds.w	r6, r6, #33554432	; 0x2000000
 8012aaa:	f850 3c34 	ldr.w	r3, [r0, #-52]
 8012aae:	f145 0500 	adc.w	r5, r5, #0
 8012ab2:	fbc3 6507 	smlal	r6, r5, r3, r7
 8012ab6:	f8de 7158 	ldr.w	r7, [lr, #344]	; 0x158
 8012aba:	f850 3c38 	ldr.w	r3, [r0, #-56]
 8012abe:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012ac2:	f850 7c2c 	ldr.w	r7, [r0, #-44]
 8012ac6:	f8de 3108 	ldr.w	r3, [lr, #264]	; 0x108
 8012aca:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012ace:	f8de 7154 	ldr.w	r7, [lr, #340]	; 0x154
 8012ad2:	f850 3c30 	ldr.w	r3, [r0, #-48]
 8012ad6:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012ada:	f850 7c24 	ldr.w	r7, [r0, #-36]
 8012ade:	f8de 310c 	ldr.w	r3, [lr, #268]	; 0x10c
 8012ae2:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012ae6:	f8de 7150 	ldr.w	r7, [lr, #336]	; 0x150
 8012aea:	f850 3c28 	ldr.w	r3, [r0, #-40]
 8012aee:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012af2:	f850 7c1c 	ldr.w	r7, [r0, #-28]
 8012af6:	f8de 3110 	ldr.w	r3, [lr, #272]	; 0x110
 8012afa:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012afe:	f8de 714c 	ldr.w	r7, [lr, #332]	; 0x14c
 8012b02:	f850 3c20 	ldr.w	r3, [r0, #-32]
 8012b06:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b0a:	f850 7c14 	ldr.w	r7, [r0, #-20]
 8012b0e:	f8de 3114 	ldr.w	r3, [lr, #276]	; 0x114
 8012b12:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b16:	f8de 7148 	ldr.w	r7, [lr, #328]	; 0x148
 8012b1a:	f850 3c18 	ldr.w	r3, [r0, #-24]
 8012b1e:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b22:	f850 7c0c 	ldr.w	r7, [r0, #-12]
 8012b26:	f8de 3118 	ldr.w	r3, [lr, #280]	; 0x118
 8012b2a:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b2e:	f8de 7144 	ldr.w	r7, [lr, #324]	; 0x144
 8012b32:	f850 3c10 	ldr.w	r3, [r0, #-16]
 8012b36:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b3a:	f850 7c04 	ldr.w	r7, [r0, #-4]
 8012b3e:	f8de 311c 	ldr.w	r3, [lr, #284]	; 0x11c
 8012b42:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b46:	f8de 7140 	ldr.w	r7, [lr, #320]	; 0x140
 8012b4a:	f850 3c08 	ldr.w	r3, [r0, #-8]
 8012b4e:	fbc7 6503 	smlal	r6, r5, r7, r3
 8012b52:	f8de 71dc 	ldr.w	r7, [lr, #476]	; 0x1dc
 8012b56:	fb82 3404 	smull	r3, r4, r2, r4
 8012b5a:	9508      	str	r5, [sp, #32]
 8012b5c:	fbc7 3401 	smlal	r3, r4, r7, r1
 8012b60:	f8de 5104 	ldr.w	r5, [lr, #260]	; 0x104
 8012b64:	f850 7c38 	ldr.w	r7, [r0, #-56]
 8012b68:	9607      	str	r6, [sp, #28]
 8012b6a:	fb82 2601 	smull	r2, r6, r2, r1
 8012b6e:	fb81 1b0b 	smull	r1, fp, r1, fp
 8012b72:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012b76:	f8de 7184 	ldr.w	r7, [lr, #388]	; 0x184
 8012b7a:	f850 5c38 	ldr.w	r5, [r0, #-56]
 8012b7e:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012b82:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8012b86:	f850 5c34 	ldr.w	r5, [r0, #-52]
 8012b8a:	f146 0600 	adc.w	r6, r6, #0
 8012b8e:	f113 7300 	adds.w	r3, r3, #33554432	; 0x2000000
 8012b92:	f144 0400 	adc.w	r4, r4, #0
 8012b96:	f111 7100 	adds.w	r1, r1, #33554432	; 0x2000000
 8012b9a:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012b9e:	f8de 71d8 	ldr.w	r7, [lr, #472]	; 0x1d8
 8012ba2:	f850 5c38 	ldr.w	r5, [r0, #-56]
 8012ba6:	f14b 0b00 	adc.w	fp, fp, #0
 8012baa:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012bae:	f8de 7188 	ldr.w	r7, [lr, #392]	; 0x188
 8012bb2:	f850 5c2c 	ldr.w	r5, [r0, #-44]
 8012bb6:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012bba:	f850 5c30 	ldr.w	r5, [r0, #-48]
 8012bbe:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012bc2:	f8de 718c 	ldr.w	r7, [lr, #396]	; 0x18c
 8012bc6:	f850 5c28 	ldr.w	r5, [r0, #-40]
 8012bca:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012bce:	f8de 71d4 	ldr.w	r7, [lr, #468]	; 0x1d4
 8012bd2:	f850 5c30 	ldr.w	r5, [r0, #-48]
 8012bd6:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012bda:	f850 5c24 	ldr.w	r5, [r0, #-36]
 8012bde:	f8de 718c 	ldr.w	r7, [lr, #396]	; 0x18c
 8012be2:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012be6:	f850 7c30 	ldr.w	r7, [r0, #-48]
 8012bea:	f8de 5108 	ldr.w	r5, [lr, #264]	; 0x108
 8012bee:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012bf2:	f850 7c28 	ldr.w	r7, [r0, #-40]
 8012bf6:	f8de 510c 	ldr.w	r5, [lr, #268]	; 0x10c
 8012bfa:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012bfe:	f850 7c20 	ldr.w	r7, [r0, #-32]
 8012c02:	f8de 5110 	ldr.w	r5, [lr, #272]	; 0x110
 8012c06:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012c0a:	f850 7c18 	ldr.w	r7, [r0, #-24]
 8012c0e:	f8de 5114 	ldr.w	r5, [lr, #276]	; 0x114
 8012c12:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012c16:	f850 7c10 	ldr.w	r7, [r0, #-16]
 8012c1a:	f8de 5118 	ldr.w	r5, [lr, #280]	; 0x118
 8012c1e:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012c22:	f850 7c08 	ldr.w	r7, [r0, #-8]
 8012c26:	f8de 511c 	ldr.w	r5, [lr, #284]	; 0x11c
 8012c2a:	fbc7 1b05 	smlal	r1, fp, r7, r5
 8012c2e:	9d06      	ldr	r5, [sp, #24]
 8012c30:	f8de 715c 	ldr.w	r7, [lr, #348]	; 0x15c
 8012c34:	fbc5 1b07 	smlal	r1, fp, r5, r7
 8012c38:	f8de 7158 	ldr.w	r7, [lr, #344]	; 0x158
 8012c3c:	9d05      	ldr	r5, [sp, #20]
 8012c3e:	fbca 1b07 	smlal	r1, fp, sl, r7
 8012c42:	f8de 7154 	ldr.w	r7, [lr, #340]	; 0x154
 8012c46:	fbc9 1b07 	smlal	r1, fp, r9, r7
 8012c4a:	f8de 7150 	ldr.w	r7, [lr, #336]	; 0x150
 8012c4e:	fbcc 1b07 	smlal	r1, fp, ip, r7
 8012c52:	f8de 714c 	ldr.w	r7, [lr, #332]	; 0x14c
 8012c56:	fbc5 1b07 	smlal	r1, fp, r5, r7
 8012c5a:	9d04      	ldr	r5, [sp, #16]
 8012c5c:	f8de 7148 	ldr.w	r7, [lr, #328]	; 0x148
 8012c60:	fbc5 1b07 	smlal	r1, fp, r5, r7
 8012c64:	9d03      	ldr	r5, [sp, #12]
 8012c66:	f8de 7144 	ldr.w	r7, [lr, #324]	; 0x144
 8012c6a:	fbc5 1b07 	smlal	r1, fp, r5, r7
 8012c6e:	9d02      	ldr	r5, [sp, #8]
 8012c70:	f8de 7140 	ldr.w	r7, [lr, #320]	; 0x140
 8012c74:	fbc5 1b07 	smlal	r1, fp, r5, r7
 8012c78:	f8de 71d0 	ldr.w	r7, [lr, #464]	; 0x1d0
 8012c7c:	f850 5c28 	ldr.w	r5, [r0, #-40]
  return x >> n;
 8012c80:	0d09      	lsrs	r1, r1, #20
   return (sum + ((int64_t)x * y));
 8012c82:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012c86:	f8de 7190 	ldr.w	r7, [lr, #400]	; 0x190
 8012c8a:	f850 5c1c 	ldr.w	r5, [r0, #-28]
  return x >> n;
 8012c8e:	ea41 310b 	orr.w	r1, r1, fp, lsl #12
   return (sum + ((int64_t)x * y));
 8012c92:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012c96:	f850 5c20 	ldr.w	r5, [r0, #-32]
 8012c9a:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012c9e:	f8de 71cc 	ldr.w	r7, [lr, #460]	; 0x1cc
 8012ca2:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012ca6:	f8de 7194 	ldr.w	r7, [lr, #404]	; 0x194
 8012caa:	f850 5c14 	ldr.w	r5, [r0, #-20]
 8012cae:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012cb2:	f850 5c18 	ldr.w	r5, [r0, #-24]
 8012cb6:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012cba:	f8de 71c8 	ldr.w	r7, [lr, #456]	; 0x1c8
 8012cbe:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012cc2:	f8de 7198 	ldr.w	r7, [lr, #408]	; 0x198
 8012cc6:	f850 5c0c 	ldr.w	r5, [r0, #-12]
 8012cca:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012cce:	f850 5c10 	ldr.w	r5, [r0, #-16]
 8012cd2:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012cd6:	f8de 71c4 	ldr.w	r7, [lr, #452]	; 0x1c4
 8012cda:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012cde:	f8de 719c 	ldr.w	r7, [lr, #412]	; 0x19c
 8012ce2:	f850 5c04 	ldr.w	r5, [r0, #-4]
 8012ce6:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012cea:	f850 5c08 	ldr.w	r5, [r0, #-8]
 8012cee:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012cf2:	f8de 71dc 	ldr.w	r7, [lr, #476]	; 0x1dc
 8012cf6:	9d06      	ldr	r5, [sp, #24]
 8012cf8:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012cfc:	f8de 71d8 	ldr.w	r7, [lr, #472]	; 0x1d8
 8012d00:	9d05      	ldr	r5, [sp, #20]
 8012d02:	fbc7 260a 	smlal	r2, r6, r7, sl
 8012d06:	f8de 71d4 	ldr.w	r7, [lr, #468]	; 0x1d4
 8012d0a:	fbc7 2609 	smlal	r2, r6, r7, r9
 8012d0e:	f8de 71d0 	ldr.w	r7, [lr, #464]	; 0x1d0
	if (sign != (x >> 15))
 8012d12:	ea4f 5961 	mov.w	r9, r1, asr #21
 8012d16:	fbc7 260c 	smlal	r2, r6, r7, ip
 8012d1a:	f8de 71cc 	ldr.w	r7, [lr, #460]	; 0x1cc
 8012d1e:	ebb9 7fe1 	cmp.w	r9, r1, asr #31
 8012d22:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012d26:	f8de 71c8 	ldr.w	r7, [lr, #456]	; 0x1c8
 8012d2a:	9d04      	ldr	r5, [sp, #16]
	sign = x >> 31;
 8012d2c:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 8012d30:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012d34:	f8de 71c4 	ldr.w	r7, [lr, #452]	; 0x1c4
 8012d38:	9d03      	ldr	r5, [sp, #12]
 8012d3a:	fbc7 2605 	smlal	r2, r6, r7, r5
 8012d3e:	f8de 71c0 	ldr.w	r7, [lr, #448]	; 0x1c0
 8012d42:	f850 5c08 	ldr.w	r5, [r0, #-8]
 8012d46:	fbc7 3405 	smlal	r3, r4, r7, r5
 8012d4a:	9d02      	ldr	r5, [sp, #8]
 8012d4c:	fbc7 2605 	smlal	r2, r6, r7, r5
	if (sign != (x >> 15))
 8012d50:	f47f ae3c 	bne.w	80129cc <xmp3fixpt_PolyphaseStereo+0x29c>
	x >>= fracBits;
 8012d54:	1189      	asrs	r1, r1, #6
 8012d56:	e63d      	b.n	80129d4 <xmp3fixpt_PolyphaseStereo+0x2a4>
 8012d58:	119b      	asrs	r3, r3, #6
 8012d5a:	e668      	b.n	8012a2e <xmp3fixpt_PolyphaseStereo+0x2fe>
 8012d5c:	11b6      	asrs	r6, r6, #6
 8012d5e:	e657      	b.n	8012a10 <xmp3fixpt_PolyphaseStereo+0x2e0>
 8012d60:	1192      	asrs	r2, r2, #6
 8012d62:	e645      	b.n	80129f0 <xmp3fixpt_PolyphaseStereo+0x2c0>
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
		pcm += 2;
	}
}
 8012d64:	b00b      	add	sp, #44	; 0x2c
 8012d66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	x >>= fracBits;
 8012d6a:	119b      	asrs	r3, r3, #6
 8012d6c:	e597      	b.n	801289e <xmp3fixpt_PolyphaseStereo+0x16e>
 8012d6e:	119b      	asrs	r3, r3, #6
 8012d70:	e61f      	b.n	80129b2 <xmp3fixpt_PolyphaseStereo+0x282>
 8012d72:	ea4f 19a9 	mov.w	r9, r9, asr #6
 8012d76:	e60e      	b.n	8012996 <xmp3fixpt_PolyphaseStereo+0x266>
 8012d78:	1193      	asrs	r3, r2, #6
 8012d7a:	e59f      	b.n	80128bc <xmp3fixpt_PolyphaseStereo+0x18c>
 8012d7c:	0000      	movs	r0, r0
	...

08012d80 <xmp3fixpt_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 8012d80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012d84:	ed2d 8b02 	vpush	{d8}
 8012d88:	b097      	sub	sp, #92	; 0x5c
 8012d8a:	9203      	str	r2, [sp, #12]
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 8012d8c:	9006      	str	r0, [sp, #24]
 8012d8e:	2800      	cmp	r0, #0
 8012d90:	f000 83f8 	beq.w	8013584 <xmp3fixpt_UnpackScaleFactors+0x804>
 8012d94:	6805      	ldr	r5, [r0, #0]
 8012d96:	ee08 1a10 	vmov	s16, r1
 8012d9a:	4601      	mov	r1, r0
 8012d9c:	2d00      	cmp	r5, #0
 8012d9e:	f000 83f1 	beq.w	8013584 <xmp3fixpt_UnpackScaleFactors+0x804>
 8012da2:	6840      	ldr	r0, [r0, #4]
 8012da4:	9000      	str	r0, [sp, #0]
 8012da6:	2800      	cmp	r0, #0
 8012da8:	f000 83ec 	beq.w	8013584 <xmp3fixpt_UnpackScaleFactors+0x804>
 8012dac:	f8d1 a008 	ldr.w	sl, [r1, #8]
 8012db0:	f1ba 0f00 	cmp.w	sl, #0
 8012db4:	f000 83e6 	beq.w	8013584 <xmp3fixpt_UnpackScaleFactors+0x804>
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));

	/* init GetBits reader */
	startBuf = buf;
	bsi = &bitStreamInfo;
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 8012db8:	6812      	ldr	r2, [r2, #0]
 8012dba:	ac0e      	add	r4, sp, #56	; 0x38
 8012dbc:	4413      	add	r3, r2
 8012dbe:	4620      	mov	r0, r4
 8012dc0:	ee18 2a10 	vmov	r2, s16
 8012dc4:	1dd9      	adds	r1, r3, #7
 8012dc6:	bf48      	it	mi
 8012dc8:	f103 010e 	addmi.w	r1, r3, #14
 8012dcc:	10c9      	asrs	r1, r1, #3
 8012dce:	f7fa f8ef 	bl	800cfb0 <xmp3fixpt_SetBitstreamPointer>
	if (*bitOffset)
 8012dd2:	9b03      	ldr	r3, [sp, #12]
 8012dd4:	6819      	ldr	r1, [r3, #0]
 8012dd6:	2900      	cmp	r1, #0
 8012dd8:	f040 8180 	bne.w	80130dc <xmp3fixpt_UnpackScaleFactors+0x35c>
		GetBits(bsi, *bitOffset);

	if (fh->ver == MPEG1) 
 8012ddc:	782b      	ldrb	r3, [r5, #0]
 8012dde:	2b00      	cmp	r3, #0
 8012de0:	f000 80d7 	beq.w	8012f92 <xmp3fixpt_UnpackScaleFactors+0x212>
	sfCompress = sis->sfCompress;
 8012de4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012de6:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012de8:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);
 8012dec:	6a2a      	ldr	r2, [r5, #32]
	sfCompress = sis->sfCompress;
 8012dee:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8012df2:	011b      	lsls	r3, r3, #4
 8012df4:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8012df8:	9900      	ldr	r1, [sp, #0]
 8012dfa:	440b      	add	r3, r1
 8012dfc:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8012dfe:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012e00:	00db      	lsls	r3, r3, #3
 8012e02:	9302      	str	r3, [sp, #8]
 8012e04:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012e06:	00db      	lsls	r3, r3, #3
 8012e08:	9301      	str	r3, [sp, #4]
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 8012e0a:	f012 0301 	ands.w	r3, r2, #1
 8012e0e:	9305      	str	r3, [sp, #20]
 8012e10:	d006      	beq.n	8012e20 <xmp3fixpt_UnpackScaleFactors+0xa0>
 8012e12:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012e14:	1e5a      	subs	r2, r3, #1
 8012e16:	bf18      	it	ne
 8012e18:	2201      	movne	r2, #1
 8012e1a:	2a00      	cmp	r2, #0
 8012e1c:	f000 831b 	beq.w	8013456 <xmp3fixpt_UnpackScaleFactors+0x6d6>
		if (sfCompress < 400) {
 8012e20:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 8012e24:	f280 8162 	bge.w	80130ec <xmp3fixpt_UnpackScaleFactors+0x36c>
			slen[0] = (sfCompress >> 4) / 5;
 8012e28:	1103      	asrs	r3, r0, #4
 8012e2a:	4aae      	ldr	r2, [pc, #696]	; (80130e4 <xmp3fixpt_UnpackScaleFactors+0x364>)
 8012e2c:	2103      	movs	r1, #3
	intensityScale = 0;
 8012e2e:	f04f 0e00 	mov.w	lr, #0
			slen[0] = (sfCompress >> 4) / 5;
 8012e32:	fb82 2803 	smull	r2, r8, r2, r3
 8012e36:	17c2      	asrs	r2, r0, #31
 8012e38:	4689      	mov	r9, r1
 8012e3a:	2706      	movs	r7, #6
 8012e3c:	ebc2 0868 	rsb	r8, r2, r8, asr #1
 8012e40:	468c      	mov	ip, r1
	preFlag = 0;
 8012e42:	46f3      	mov	fp, lr
 8012e44:	9109      	str	r1, [sp, #36]	; 0x24
			slen[1]= (sfCompress >> 4) % 5;
 8012e46:	eb08 0288 	add.w	r2, r8, r8, lsl #2
			slen[0] = (sfCompress >> 4) / 5;
 8012e4a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1]= (sfCompress >> 4) % 5;
 8012e4e:	1a9b      	subs	r3, r3, r2
 8012e50:	2205      	movs	r2, #5
 8012e52:	930b      	str	r3, [sp, #44]	; 0x2c
			slen[2]= (sfCompress & 0x0f) >> 2;
 8012e54:	f3c0 0381 	ubfx	r3, r0, #2, #2
			slen[3]= (sfCompress & 0x03);
 8012e58:	4008      	ands	r0, r1
 8012e5a:	4616      	mov	r6, r2
			slen[2]= (sfCompress & 0x0f) >> 2;
 8012e5c:	930c      	str	r3, [sp, #48]	; 0x30
			slen[3]= (sfCompress & 0x03);
 8012e5e:	900d      	str	r0, [sp, #52]	; 0x34
			sfcIdx = 0;
 8012e60:	4610      	mov	r0, r2
 8012e62:	e9cd 1107 	strd	r1, r1, [sp, #28]
	if (sis->blockType == 2) 
 8012e66:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8012e68:	9b01      	ldr	r3, [sp, #4]
 8012e6a:	442b      	add	r3, r5
 8012e6c:	9d02      	ldr	r5, [sp, #8]
 8012e6e:	011b      	lsls	r3, r3, #4
 8012e70:	9304      	str	r3, [sp, #16]
 8012e72:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012e74:	441d      	add	r5, r3
 8012e76:	9b04      	ldr	r3, [sp, #16]
 8012e78:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8012e7c:	9d00      	ldr	r5, [sp, #0]
 8012e7e:	442b      	add	r3, r5
 8012e80:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8012e82:	2d02      	cmp	r5, #2
 8012e84:	f000 829d 	beq.w	80133c2 <xmp3fixpt_UnpackScaleFactors+0x642>
	if( (modeExt & 0x01) && (ch == 1) ) {
 8012e88:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012e8a:	2b01      	cmp	r3, #1
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 8012e8c:	e9cd 7612 	strd	r7, r6, [sp, #72]	; 0x48
 8012e90:	e9cd 0214 	strd	r0, r2, [sp, #80]	; 0x50
	if( (modeExt & 0x01) && (ch == 1) ) {
 8012e94:	d103      	bne.n	8012e9e <xmp3fixpt_UnpackScaleFactors+0x11e>
 8012e96:	9b05      	ldr	r3, [sp, #20]
 8012e98:	2b00      	cmp	r3, #0
 8012e9a:	f040 8306 	bne.w	80134aa <xmp3fixpt_UnpackScaleFactors+0x72a>
 8012e9e:	ae0a      	add	r6, sp, #40	; 0x28
 8012ea0:	af12      	add	r7, sp, #72	; 0x48
	sis->preFlag = preFlag;
 8012ea2:	9a22      	ldr	r2, [sp, #136]	; 0x88
	if(sis->blockType == 2) {
 8012ea4:	2d02      	cmp	r5, #2
	sis->preFlag = preFlag;
 8012ea6:	9b01      	ldr	r3, [sp, #4]
 8012ea8:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012eaa:	4413      	add	r3, r2
 8012eac:	9a02      	ldr	r2, [sp, #8]
 8012eae:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8012eb2:	440a      	add	r2, r1
 8012eb4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8012eb8:	9a00      	ldr	r2, [sp, #0]
 8012eba:	4413      	add	r3, r2
 8012ebc:	f8c3 b064 	str.w	fp, [r3, #100]	; 0x64
	if(sis->blockType == 2) {
 8012ec0:	f000 821f 	beq.w	8013302 <xmp3fixpt_UnpackScaleFactors+0x582>
 8012ec4:	9b22      	ldr	r3, [sp, #136]	; 0x88
		sfb = 0;
 8012ec6:	f04f 0800 	mov.w	r8, #0
 8012eca:	46b9      	mov	r9, r7
 8012ecc:	f8cd a01c 	str.w	sl, [sp, #28]
 8012ed0:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8012ed4:	009a      	lsls	r2, r3, #2
 8012ed6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012ed8:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8012edc:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8012ee0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8012ee2:	0152      	lsls	r2, r2, #5
 8012ee4:	9308      	str	r3, [sp, #32]
 8012ee6:	4453      	add	r3, sl
 8012ee8:	9204      	str	r2, [sp, #16]
 8012eea:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012eec:	9309      	str	r3, [sp, #36]	; 0x24
 8012eee:	0152      	lsls	r2, r2, #5
 8012ef0:	9205      	str	r2, [sp, #20]
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8012ef2:	f859 7b04 	ldr.w	r7, [r9], #4
			iipTest = (1 << slen[nrIdx]) - 1;
 8012ef6:	f856 ab04 	ldr.w	sl, [r6], #4
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8012efa:	2f00      	cmp	r7, #0
 8012efc:	dd11      	ble.n	8012f22 <xmp3fixpt_UnpackScaleFactors+0x1a2>
 8012efe:	9b08      	ldr	r3, [sp, #32]
 8012f00:	9a07      	ldr	r2, [sp, #28]
 8012f02:	4443      	add	r3, r8
 8012f04:	eb02 0b03 	add.w	fp, r2, r3
 8012f08:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012f0a:	eb08 0503 	add.w	r5, r8, r3
 8012f0e:	443d      	add	r5, r7
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 8012f10:	4651      	mov	r1, sl
 8012f12:	4620      	mov	r0, r4
 8012f14:	f7fa f852 	bl	800cfbc <xmp3fixpt_GetBits>
 8012f18:	f80b 0b01 	strb.w	r0, [fp], #1
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8012f1c:	45ab      	cmp	fp, r5
 8012f1e:	d1f7      	bne.n	8012f10 <xmp3fixpt_UnpackScaleFactors+0x190>
 8012f20:	44b8      	add	r8, r7
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8012f22:	42a6      	cmp	r6, r4
 8012f24:	d1e5      	bne.n	8012ef2 <xmp3fixpt_UnpackScaleFactors+0x172>
		sfis->l[21] = sfis->l[22] = 0;
 8012f26:	f8dd a01c 	ldr.w	sl, [sp, #28]
 8012f2a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012f2c:	9b05      	ldr	r3, [sp, #20]
 8012f2e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012f30:	1a9b      	subs	r3, r3, r2
 8012f32:	9a04      	ldr	r2, [sp, #16]
 8012f34:	009b      	lsls	r3, r3, #2
 8012f36:	1a52      	subs	r2, r2, r1
 8012f38:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8012f3c:	2200      	movs	r2, #0
 8012f3e:	3315      	adds	r3, #21
 8012f40:	f82a 2003 	strh.w	r2, [sl, r3]

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8012f44:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012f46:	9a01      	ldr	r2, [sp, #4]
 8012f48:	9802      	ldr	r0, [sp, #8]
 8012f4a:	441a      	add	r2, r3
 8012f4c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012f4e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8012f50:	4418      	add	r0, r3
 8012f52:	0112      	lsls	r2, r2, #4
 8012f54:	eb03 0341 	add.w	r3, r3, r1, lsl #1

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8012f58:	ee18 1a10 	vmov	r1, s16
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8012f5c:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 8012f60:	9800      	ldr	r0, [sp, #0]
 8012f62:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8012f66:	4410      	add	r0, r2
 8012f68:	4602      	mov	r2, r0
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8012f6a:	4620      	mov	r0, r4
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8012f6c:	9c06      	ldr	r4, [sp, #24]
 8012f6e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8012f70:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8012f74:	9c03      	ldr	r4, [sp, #12]
 8012f76:	6822      	ldr	r2, [r4, #0]
 8012f78:	f7fa f888 	bl	800d08c <xmp3fixpt_CalcBitsUsed>
	buf += (bitsUsed + *bitOffset) >> 3;
 8012f7c:	6823      	ldr	r3, [r4, #0]
 8012f7e:	4418      	add	r0, r3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8012f80:	f000 0307 	and.w	r3, r0, #7
	buf += (bitsUsed + *bitOffset) >> 3;
 8012f84:	10c0      	asrs	r0, r0, #3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8012f86:	6023      	str	r3, [r4, #0]

	return (buf - startBuf);
}
 8012f88:	b017      	add	sp, #92	; 0x5c
 8012f8a:	ecbd 8b02 	vpop	{d8}
 8012f8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 8012f92:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012f94:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8012f96:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8012f9a:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012f9c:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 8012fa0:	00c9      	lsls	r1, r1, #3
 8012fa2:	011b      	lsls	r3, r3, #4
 8012fa4:	9102      	str	r1, [sp, #8]
 8012fa6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8012faa:	9922      	ldr	r1, [sp, #136]	; 0x88
 8012fac:	9a00      	ldr	r2, [sp, #0]
 8012fae:	00c9      	lsls	r1, r1, #3
 8012fb0:	4413      	add	r3, r2
 8012fb2:	4a4d      	ldr	r2, [pc, #308]	; (80130e8 <xmp3fixpt_UnpackScaleFactors+0x368>)
 8012fb4:	9101      	str	r1, [sp, #4]
 8012fb6:	6b58      	ldr	r0, [r3, #52]	; 0x34
	if (sis->blockType == 2) {
 8012fb8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 8012fba:	eb02 0540 	add.w	r5, r2, r0, lsl #1
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 8012fbe:	f812 9010 	ldrb.w	r9, [r2, r0, lsl #1]
	if (sis->blockType == 2) {
 8012fc2:	2902      	cmp	r1, #2
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 8012fc4:	786e      	ldrb	r6, [r5, #1]
	if (sis->blockType == 2) {
 8012fc6:	f000 8143 	beq.w	8013250 <xmp3fixpt_UnpackScaleFactors+0x4d0>
		if(gr == 0) {
 8012fca:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012fcc:	2b00      	cmp	r3, #0
 8012fce:	f000 8200 	beq.w	80133d2 <xmp3fixpt_UnpackScaleFactors+0x652>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 8012fd2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012fd4:	9a00      	ldr	r2, [sp, #0]
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 8012fd6:	011f      	lsls	r7, r3, #4
 8012fd8:	3708      	adds	r7, #8
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012fda:	59d3      	ldr	r3, [r2, r7]
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 8012fdc:	4417      	add	r7, r2
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012fde:	2b00      	cmp	r3, #0
 8012fe0:	f000 80be 	beq.w	8013160 <xmp3fixpt_UnpackScaleFactors+0x3e0>
 8012fe4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012fe6:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 8012fea:	015b      	lsls	r3, r3, #5
 8012fec:	0092      	lsls	r2, r2, #2
 8012fee:	9305      	str	r3, [sp, #20]
 8012ff0:	1e53      	subs	r3, r2, #1
 8012ff2:	2b02      	cmp	r3, #2
 8012ff4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012ff6:	f240 82d6 	bls.w	80135a6 <xmp3fixpt_UnpackScaleFactors+0x826>
 8012ffa:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8012ffe:	eb0a 0102 	add.w	r1, sl, r2
 8013002:	f85a 0013 	ldr.w	r0, [sl, r3, lsl #1]
 8013006:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801300a:	f841 0013 	str.w	r0, [r1, r3, lsl #1]
 801300e:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 8013012:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8013014:	4452      	add	r2, sl
 8013016:	0149      	lsls	r1, r1, #5
 8013018:	9104      	str	r1, [sp, #16]
 801301a:	7919      	ldrb	r1, [r3, #4]
 801301c:	7111      	strb	r1, [r2, #4]
 801301e:	795b      	ldrb	r3, [r3, #5]
 8013020:	7153      	strb	r3, [r2, #5]
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8013022:	687b      	ldr	r3, [r7, #4]
 8013024:	2b00      	cmp	r3, #0
 8013026:	f000 80bb 	beq.w	80131a0 <xmp3fixpt_UnpackScaleFactors+0x420>
 801302a:	9b04      	ldr	r3, [sp, #16]
 801302c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801302e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8013030:	1a9a      	subs	r2, r3, r2
 8013032:	9b05      	ldr	r3, [sp, #20]
 8013034:	0052      	lsls	r2, r2, #1
 8013036:	1a5b      	subs	r3, r3, r1
 8013038:	1e51      	subs	r1, r2, #1
 801303a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801303e:	009b      	lsls	r3, r3, #2
 8013040:	1a89      	subs	r1, r1, r2
 8013042:	2902      	cmp	r1, #2
 8013044:	f240 82a1 	bls.w	801358a <xmp3fixpt_UnpackScaleFactors+0x80a>
 8013048:	1d91      	adds	r1, r2, #6
 801304a:	eb0a 0003 	add.w	r0, sl, r3
 801304e:	4413      	add	r3, r2
 8013050:	4452      	add	r2, sl
 8013052:	f85a 5001 	ldr.w	r5, [sl, r1]
 8013056:	4453      	add	r3, sl
 8013058:	5045      	str	r5, [r0, r1]
 801305a:	7a92      	ldrb	r2, [r2, #10]
 801305c:	729a      	strb	r2, [r3, #10]
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801305e:	68bb      	ldr	r3, [r7, #8]
 8013060:	2b00      	cmp	r3, #0
 8013062:	f000 80b9 	beq.w	80131d8 <xmp3fixpt_UnpackScaleFactors+0x458>
 8013066:	9b04      	ldr	r3, [sp, #16]
 8013068:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801306a:	9922      	ldr	r1, [sp, #136]	; 0x88
 801306c:	1a9a      	subs	r2, r3, r2
 801306e:	9b05      	ldr	r3, [sp, #20]
 8013070:	0052      	lsls	r2, r2, #1
 8013072:	1a59      	subs	r1, r3, r1
 8013074:	1e53      	subs	r3, r2, #1
 8013076:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801307a:	0089      	lsls	r1, r1, #2
 801307c:	1a9b      	subs	r3, r3, r2
 801307e:	2b02      	cmp	r3, #2
 8013080:	f240 82d7 	bls.w	8013632 <xmp3fixpt_UnpackScaleFactors+0x8b2>
 8013084:	f102 030b 	add.w	r3, r2, #11
 8013088:	eb0a 0002 	add.w	r0, sl, r2
 801308c:	440a      	add	r2, r1
 801308e:	f85a 5003 	ldr.w	r5, [sl, r3]
 8013092:	4453      	add	r3, sl
 8013094:	4452      	add	r2, sl
 8013096:	505d      	str	r5, [r3, r1]
 8013098:	7bc3      	ldrb	r3, [r0, #15]
 801309a:	73d3      	strb	r3, [r2, #15]
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801309c:	68fb      	ldr	r3, [r7, #12]
 801309e:	2b00      	cmp	r3, #0
 80130a0:	f000 81bc 	beq.w	801341c <xmp3fixpt_UnpackScaleFactors+0x69c>
 80130a4:	9b04      	ldr	r3, [sp, #16]
 80130a6:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80130a8:	9922      	ldr	r1, [sp, #136]	; 0x88
 80130aa:	1a9a      	subs	r2, r3, r2
 80130ac:	9b05      	ldr	r3, [sp, #20]
 80130ae:	0052      	lsls	r2, r2, #1
 80130b0:	1a5b      	subs	r3, r3, r1
 80130b2:	1e51      	subs	r1, r2, #1
 80130b4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80130b8:	009b      	lsls	r3, r3, #2
 80130ba:	1a89      	subs	r1, r1, r2
 80130bc:	2902      	cmp	r1, #2
 80130be:	f240 82aa 	bls.w	8013616 <xmp3fixpt_UnpackScaleFactors+0x896>
 80130c2:	f102 0110 	add.w	r1, r2, #16
 80130c6:	eb0a 0003 	add.w	r0, sl, r3
 80130ca:	4413      	add	r3, r2
 80130cc:	4452      	add	r2, sl
 80130ce:	f85a 5001 	ldr.w	r5, [sl, r1]
 80130d2:	4453      	add	r3, sl
 80130d4:	5045      	str	r5, [r0, r1]
 80130d6:	7d12      	ldrb	r2, [r2, #20]
 80130d8:	751a      	strb	r2, [r3, #20]
 80130da:	e726      	b.n	8012f2a <xmp3fixpt_UnpackScaleFactors+0x1aa>
		GetBits(bsi, *bitOffset);
 80130dc:	4620      	mov	r0, r4
 80130de:	f7f9 ff6d 	bl	800cfbc <xmp3fixpt_GetBits>
 80130e2:	e67b      	b.n	8012ddc <xmp3fixpt_UnpackScaleFactors+0x5c>
 80130e4:	66666667 	.word	0x66666667
 80130e8:	08025154 	.word	0x08025154
		} else if (sfCompress < 500) {
 80130ec:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 80130f0:	f2c0 808b 	blt.w	801320a <xmp3fixpt_UnpackScaleFactors+0x48a>
			sfCompress -= 500;
 80130f4:	f5a0 70fa 	sub.w	r0, r0, #500	; 0x1f4
			slen[0] = sfCompress / 3;
 80130f8:	4bc6      	ldr	r3, [pc, #792]	; (8013414 <xmp3fixpt_UnpackScaleFactors+0x694>)
			if (sis->mixedBlock) {
 80130fa:	9a22      	ldr	r2, [sp, #136]	; 0x88
			slen[0] = sfCompress / 3;
 80130fc:	fba3 3800 	umull	r3, r8, r3, r0
			if (sis->mixedBlock) {
 8013100:	9b01      	ldr	r3, [sp, #4]
 8013102:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8013104:	4413      	add	r3, r2
 8013106:	9a02      	ldr	r2, [sp, #8]
			slen[0] = sfCompress / 3;
 8013108:	ea4f 0858 	mov.w	r8, r8, lsr #1
			if (sis->mixedBlock) {
 801310c:	440a      	add	r2, r1
 801310e:	011b      	lsls	r3, r3, #4
			slen[0] = sfCompress / 3;
 8013110:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			if (sis->mixedBlock) {
 8013114:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8013118:	9a00      	ldr	r2, [sp, #0]
 801311a:	4413      	add	r3, r2
			slen[2] = slen[3] = 0;
 801311c:	2200      	movs	r2, #0
			if (sis->mixedBlock) {
 801311e:	f8d3 c040 	ldr.w	ip, [r3, #64]	; 0x40
			slen[1] = sfCompress % 3;
 8013122:	eb08 0348 	add.w	r3, r8, r8, lsl #1
 8013126:	1ac0      	subs	r0, r0, r3
			slen[2] = slen[3] = 0;
 8013128:	2300      	movs	r3, #0
			slen[1] = sfCompress % 3;
 801312a:	900b      	str	r0, [sp, #44]	; 0x2c
			slen[2] = slen[3] = 0;
 801312c:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
			if (sis->mixedBlock) {
 8013130:	f1bc 0f00 	cmp.w	ip, #0
 8013134:	f000 81f1 	beq.w	801351a <xmp3fixpt_UnpackScaleFactors+0x79a>
				slen[1] = slen[0];
 8013138:	2100      	movs	r1, #0
 801313a:	f04f 0906 	mov.w	r9, #6
 801313e:	2303      	movs	r3, #3
 8013140:	260a      	movs	r6, #10
 8013142:	270b      	movs	r7, #11
 8013144:	460a      	mov	r2, r1
 8013146:	468c      	mov	ip, r1
	intensityScale = 0;
 8013148:	468e      	mov	lr, r1
			preFlag = 1;
 801314a:	f04f 0b01 	mov.w	fp, #1
				slen[1] = slen[0];
 801314e:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8013152:	f8cd 9020 	str.w	r9, [sp, #32]
 8013156:	9307      	str	r3, [sp, #28]
 8013158:	e9cd 800b 	strd	r8, r0, [sp, #44]	; 0x2c
 801315c:	4608      	mov	r0, r1
 801315e:	e682      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
 8013160:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8013162:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8013164:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8013168:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
 801316c:	009b      	lsls	r3, r3, #2
 801316e:	0152      	lsls	r2, r2, #5
 8013170:	eb03 0845 	add.w	r8, r3, r5, lsl #1
 8013174:	9204      	str	r2, [sp, #16]
 8013176:	4645      	mov	r5, r8
 8013178:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801317a:	f108 38ff 	add.w	r8, r8, #4294967295
 801317e:	3505      	adds	r5, #5
 8013180:	0152      	lsls	r2, r2, #5
 8013182:	44d0      	add	r8, sl
 8013184:	4455      	add	r5, sl
 8013186:	9205      	str	r2, [sp, #20]
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 8013188:	4649      	mov	r1, r9
 801318a:	4620      	mov	r0, r4
 801318c:	f7f9 ff16 	bl	800cfbc <xmp3fixpt_GetBits>
 8013190:	f808 0f01 	strb.w	r0, [r8, #1]!
 8013194:	45a8      	cmp	r8, r5
 8013196:	d1f7      	bne.n	8013188 <xmp3fixpt_UnpackScaleFactors+0x408>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8013198:	687b      	ldr	r3, [r7, #4]
 801319a:	2b00      	cmp	r3, #0
 801319c:	f47f af45 	bne.w	801302a <xmp3fixpt_UnpackScaleFactors+0x2aa>
 80131a0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80131a2:	9b04      	ldr	r3, [sp, #16]
 80131a4:	9922      	ldr	r1, [sp, #136]	; 0x88
 80131a6:	1a9b      	subs	r3, r3, r2
 80131a8:	9a05      	ldr	r2, [sp, #20]
 80131aa:	005b      	lsls	r3, r3, #1
 80131ac:	1a55      	subs	r5, r2, r1
 80131ae:	f103 0806 	add.w	r8, r3, #6
 80131b2:	330b      	adds	r3, #11
 80131b4:	eb08 0885 	add.w	r8, r8, r5, lsl #2
 80131b8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80131bc:	44d0      	add	r8, sl
 80131be:	4455      	add	r5, sl
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80131c0:	4649      	mov	r1, r9
 80131c2:	4620      	mov	r0, r4
 80131c4:	f7f9 fefa 	bl	800cfbc <xmp3fixpt_GetBits>
 80131c8:	f808 0b01 	strb.w	r0, [r8], #1
 80131cc:	45a8      	cmp	r8, r5
 80131ce:	d1f7      	bne.n	80131c0 <xmp3fixpt_UnpackScaleFactors+0x440>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80131d0:	68bb      	ldr	r3, [r7, #8]
 80131d2:	2b00      	cmp	r3, #0
 80131d4:	f47f af47 	bne.w	8013066 <xmp3fixpt_UnpackScaleFactors+0x2e6>
 80131d8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80131da:	9b04      	ldr	r3, [sp, #16]
 80131dc:	9922      	ldr	r1, [sp, #136]	; 0x88
 80131de:	1a9b      	subs	r3, r3, r2
 80131e0:	9a05      	ldr	r2, [sp, #20]
 80131e2:	005b      	lsls	r3, r3, #1
 80131e4:	1a55      	subs	r5, r2, r1
 80131e6:	f103 080b 	add.w	r8, r3, #11
 80131ea:	3310      	adds	r3, #16
 80131ec:	eb08 0885 	add.w	r8, r8, r5, lsl #2
 80131f0:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80131f4:	44d0      	add	r8, sl
 80131f6:	4455      	add	r5, sl
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 80131f8:	4631      	mov	r1, r6
 80131fa:	4620      	mov	r0, r4
 80131fc:	f7f9 fede 	bl	800cfbc <xmp3fixpt_GetBits>
 8013200:	f808 0b01 	strb.w	r0, [r8], #1
 8013204:	45a8      	cmp	r8, r5
 8013206:	d1f7      	bne.n	80131f8 <xmp3fixpt_UnpackScaleFactors+0x478>
 8013208:	e748      	b.n	801309c <xmp3fixpt_UnpackScaleFactors+0x31c>
			slen[3]= 0;
 801320a:	2300      	movs	r3, #0
			sfCompress -= 400;
 801320c:	f5a0 70c8 	sub.w	r0, r0, #400	; 0x190
			slen[0] = (sfCompress >> 2) / 5;
 8013210:	4a81      	ldr	r2, [pc, #516]	; (8013418 <xmp3fixpt_UnpackScaleFactors+0x698>)
 8013212:	f04f 0903 	mov.w	r9, #3
	intensityScale = 0;
 8013216:	469e      	mov	lr, r3
			slen[3]= 0;
 8013218:	930d      	str	r3, [sp, #52]	; 0x34
			slen[0] = (sfCompress >> 2) / 5;
 801321a:	1083      	asrs	r3, r0, #2
 801321c:	2104      	movs	r1, #4
			slen[2]= (sfCompress & 0x03);
 801321e:	f000 0003 	and.w	r0, r0, #3
 8013222:	2605      	movs	r6, #5
			slen[0] = (sfCompress >> 2) / 5;
 8013224:	fba2 2803 	umull	r2, r8, r2, r3
 8013228:	2706      	movs	r7, #6
			slen[2]= (sfCompress & 0x03);
 801322a:	900c      	str	r0, [sp, #48]	; 0x30
 801322c:	f04f 0c02 	mov.w	ip, #2
			slen[0] = (sfCompress >> 2) / 5;
 8013230:	ea4f 0898 	mov.w	r8, r8, lsr #2
 8013234:	2007      	movs	r0, #7
	preFlag = 0;
 8013236:	46f3      	mov	fp, lr
 8013238:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
			slen[1]= (sfCompress >> 2) % 5;
 801323c:	eb08 0288 	add.w	r2, r8, r8, lsl #2
			slen[0] = (sfCompress >> 2) / 5;
 8013240:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1]= (sfCompress >> 2) % 5;
 8013244:	1a9b      	subs	r3, r3, r2
 8013246:	464a      	mov	r2, r9
 8013248:	930b      	str	r3, [sp, #44]	; 0x2c
			sfcIdx = 1;
 801324a:	e9cd 9107 	strd	r9, r1, [sp, #28]
 801324e:	e60a      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
		if (sis->mixedBlock) {          
 8013250:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013252:	2b00      	cmp	r3, #0
 8013254:	f040 8144 	bne.w	80134e0 <xmp3fixpt_UnpackScaleFactors+0x760>
 8013258:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801325a:	0152      	lsls	r2, r2, #5
 801325c:	9204      	str	r2, [sp, #16]
 801325e:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8013260:	0152      	lsls	r2, r2, #5
 8013262:	9205      	str	r2, [sp, #20]
 8013264:	eb03 0843 	add.w	r8, r3, r3, lsl #1
 8013268:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801326a:	9b05      	ldr	r3, [sp, #20]
 801326c:	9923      	ldr	r1, [sp, #140]	; 0x8c
 801326e:	1a9b      	subs	r3, r3, r2
 8013270:	9a04      	ldr	r2, [sp, #16]
 8013272:	009b      	lsls	r3, r3, #2
 8013274:	1a57      	subs	r7, r2, r1
 8013276:	eb03 0547 	add.w	r5, r3, r7, lsl #1
 801327a:	462f      	mov	r7, r5
 801327c:	44a8      	add	r8, r5
 801327e:	3712      	adds	r7, #18
 8013280:	44d0      	add	r8, sl
 8013282:	4457      	add	r7, sl
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 8013284:	4649      	mov	r1, r9
 8013286:	4620      	mov	r0, r4
 8013288:	f7f9 fe98 	bl	800cfbc <xmp3fixpt_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801328c:	4649      	mov	r1, r9
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 801328e:	f888 0017 	strb.w	r0, [r8, #23]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 8013292:	4620      	mov	r0, r4
 8013294:	f7f9 fe92 	bl	800cfbc <xmp3fixpt_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 8013298:	4649      	mov	r1, r9
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801329a:	f888 0018 	strb.w	r0, [r8, #24]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 801329e:	4620      	mov	r0, r4
 80132a0:	f7f9 fe8c 	bl	800cfbc <xmp3fixpt_GetBits>
		for (      ; sfb < 6; sfb++) {
 80132a4:	f108 0803 	add.w	r8, r8, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 80132a8:	f888 0016 	strb.w	r0, [r8, #22]
		for (      ; sfb < 6; sfb++) {
 80132ac:	4547      	cmp	r7, r8
 80132ae:	d1e9      	bne.n	8013284 <xmp3fixpt_UnpackScaleFactors+0x504>
 80132b0:	4455      	add	r5, sl
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 80132b2:	4631      	mov	r1, r6
 80132b4:	4620      	mov	r0, r4
 80132b6:	f7f9 fe81 	bl	800cfbc <xmp3fixpt_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80132ba:	4631      	mov	r1, r6
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 80132bc:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80132c0:	4620      	mov	r0, r4
 80132c2:	f7f9 fe7b 	bl	800cfbc <xmp3fixpt_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80132c6:	4631      	mov	r1, r6
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80132c8:	f885 002a 	strb.w	r0, [r5, #42]	; 0x2a
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80132cc:	4620      	mov	r0, r4
 80132ce:	f7f9 fe75 	bl	800cfbc <xmp3fixpt_GetBits>
		for (      ; sfb < 12; sfb++) {
 80132d2:	3503      	adds	r5, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80132d4:	f885 0028 	strb.w	r0, [r5, #40]	; 0x28
		for (      ; sfb < 12; sfb++) {
 80132d8:	42bd      	cmp	r5, r7
 80132da:	d1ea      	bne.n	80132b2 <xmp3fixpt_UnpackScaleFactors+0x532>
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 80132dc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80132de:	9b05      	ldr	r3, [sp, #20]
 80132e0:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80132e2:	1a9b      	subs	r3, r3, r2
 80132e4:	9a04      	ldr	r2, [sp, #16]
 80132e6:	009b      	lsls	r3, r3, #2
 80132e8:	1a52      	subs	r2, r2, r1
 80132ea:	2100      	movs	r1, #0
 80132ec:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80132f0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80132f4:	4453      	add	r3, sl
 80132f6:	4452      	add	r2, sl
 80132f8:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
 80132fc:	f8a2 1007 	strh.w	r1, [r2, #7]
 8013300:	e620      	b.n	8012f44 <xmp3fixpt_UnpackScaleFactors+0x1c4>
		if(sis->mixedBlock) {
 8013302:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013304:	2b00      	cmp	r3, #0
 8013306:	f000 80c9 	beq.w	801349c <xmp3fixpt_UnpackScaleFactors+0x71c>
 801330a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801330c:	ebc1 1541 	rsb	r5, r1, r1, lsl #5
 8013310:	014a      	lsls	r2, r1, #5
 8013312:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8013316:	9204      	str	r2, [sp, #16]
 8013318:	009b      	lsls	r3, r3, #2
 801331a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801331c:	eb03 0945 	add.w	r9, r3, r5, lsl #1
 8013320:	0152      	lsls	r2, r2, #5
 8013322:	464d      	mov	r5, r9
 8013324:	f109 39ff 	add.w	r9, r9, #4294967295
 8013328:	9205      	str	r2, [sp, #20]
 801332a:	3505      	adds	r5, #5
 801332c:	44d1      	add	r9, sl
 801332e:	4455      	add	r5, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 8013330:	4641      	mov	r1, r8
 8013332:	4620      	mov	r0, r4
 8013334:	f7f9 fe42 	bl	800cfbc <xmp3fixpt_GetBits>
 8013338:	f809 0f01 	strb.w	r0, [r9, #1]!
			for (sfb=0; sfb < 6; sfb++) {
 801333c:	45a9      	cmp	r9, r5
 801333e:	d1f7      	bne.n	8013330 <xmp3fixpt_UnpackScaleFactors+0x5b0>
			sfb = 3;  /* start sfb for short */
 8013340:	f04f 0b03 	mov.w	fp, #3
			nrIdx = 1;
 8013344:	2301      	movs	r3, #1
 8013346:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8013348:	eb06 0883 	add.w	r8, r6, r3, lsl #2
 801334c:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8013350:	9b05      	ldr	r3, [sp, #20]
 8013352:	eba3 0902 	sub.w	r9, r3, r2
 8013356:	9b04      	ldr	r3, [sp, #16]
 8013358:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801335a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 801335e:	1a9b      	subs	r3, r3, r2
 8013360:	eb09 0343 	add.w	r3, r9, r3, lsl #1
 8013364:	9307      	str	r3, [sp, #28]
 8013366:	4453      	add	r3, sl
 8013368:	9308      	str	r3, [sp, #32]
 801336a:	465b      	mov	r3, fp
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 801336c:	f857 6b04 	ldr.w	r6, [r7], #4
			iipTest = (1 << slen[nrIdx]) - 1;
 8013370:	f858 bb04 	ldr.w	fp, [r8], #4
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8013374:	2e00      	cmp	r6, #0
 8013376:	dd21      	ble.n	80133bc <xmp3fixpt_UnpackScaleFactors+0x63c>
 8013378:	441e      	add	r6, r3
 801337a:	9a07      	ldr	r2, [sp, #28]
 801337c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8013380:	eb06 0546 	add.w	r5, r6, r6, lsl #1
 8013384:	4413      	add	r3, r2
 8013386:	eb0a 0903 	add.w	r9, sl, r3
 801338a:	9b08      	ldr	r3, [sp, #32]
 801338c:	441d      	add	r5, r3
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 801338e:	4659      	mov	r1, fp
 8013390:	4620      	mov	r0, r4
 8013392:	f7f9 fe13 	bl	800cfbc <xmp3fixpt_GetBits>
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 8013396:	4659      	mov	r1, fp
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 8013398:	f889 0017 	strb.w	r0, [r9, #23]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 801339c:	4620      	mov	r0, r4
 801339e:	f7f9 fe0d 	bl	800cfbc <xmp3fixpt_GetBits>
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80133a2:	4659      	mov	r1, fp
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 80133a4:	f889 0018 	strb.w	r0, [r9, #24]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80133a8:	4620      	mov	r0, r4
 80133aa:	f7f9 fe07 	bl	800cfbc <xmp3fixpt_GetBits>
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 80133ae:	f109 0903 	add.w	r9, r9, #3
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80133b2:	f889 0016 	strb.w	r0, [r9, #22]
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 80133b6:	45a9      	cmp	r9, r5
 80133b8:	d1e9      	bne.n	801338e <xmp3fixpt_UnpackScaleFactors+0x60e>
 80133ba:	4633      	mov	r3, r6
		for (    ; nrIdx <= 3; nrIdx++) {
 80133bc:	45a0      	cmp	r8, r4
 80133be:	d1d5      	bne.n	801336c <xmp3fixpt_UnpackScaleFactors+0x5ec>
 80133c0:	e78c      	b.n	80132dc <xmp3fixpt_UnpackScaleFactors+0x55c>
		btIdx = (sis->mixedBlock ? 2 : 1);
 80133c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80133c4:	4662      	mov	r2, ip
 80133c6:	2b00      	cmp	r3, #0
 80133c8:	d141      	bne.n	801344e <xmp3fixpt_UnpackScaleFactors+0x6ce>
 80133ca:	4608      	mov	r0, r1
 80133cc:	464e      	mov	r6, r9
 80133ce:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80133d0:	e55a      	b.n	8012e88 <xmp3fixpt_UnpackScaleFactors+0x108>
 80133d2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80133d4:	ebc3 1543 	rsb	r5, r3, r3, lsl #5
 80133d8:	006d      	lsls	r5, r5, #1
 80133da:	f105 38ff 	add.w	r8, r5, #4294967295
 80133de:	f105 070a 	add.w	r7, r5, #10
 80133e2:	44d0      	add	r8, sl
 80133e4:	4457      	add	r7, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80133e6:	4649      	mov	r1, r9
 80133e8:	4620      	mov	r0, r4
 80133ea:	f7f9 fde7 	bl	800cfbc <xmp3fixpt_GetBits>
 80133ee:	f808 0f01 	strb.w	r0, [r8, #1]!
			for (sfb = 0;  sfb < 11; sfb++) 
 80133f2:	45b8      	cmp	r8, r7
 80133f4:	d1f7      	bne.n	80133e6 <xmp3fixpt_UnpackScaleFactors+0x666>
 80133f6:	f105 070b 	add.w	r7, r5, #11
 80133fa:	3515      	adds	r5, #21
 80133fc:	4457      	add	r7, sl
 80133fe:	4455      	add	r5, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8013400:	4631      	mov	r1, r6
 8013402:	4620      	mov	r0, r4
 8013404:	f7f9 fdda 	bl	800cfbc <xmp3fixpt_GetBits>
 8013408:	f807 0b01 	strb.w	r0, [r7], #1
			for (sfb = 11; sfb < 21; sfb++) 
 801340c:	42bd      	cmp	r5, r7
 801340e:	d1f7      	bne.n	8013400 <xmp3fixpt_UnpackScaleFactors+0x680>
 8013410:	e598      	b.n	8012f44 <xmp3fixpt_UnpackScaleFactors+0x1c4>
 8013412:	bf00      	nop
 8013414:	aaaaaaab 	.word	0xaaaaaaab
 8013418:	cccccccd 	.word	0xcccccccd
 801341c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801341e:	9b04      	ldr	r3, [sp, #16]
 8013420:	9922      	ldr	r1, [sp, #136]	; 0x88
 8013422:	1a9b      	subs	r3, r3, r2
 8013424:	9a05      	ldr	r2, [sp, #20]
 8013426:	005b      	lsls	r3, r3, #1
 8013428:	1a55      	subs	r5, r2, r1
 801342a:	f103 0710 	add.w	r7, r3, #16
 801342e:	3315      	adds	r3, #21
 8013430:	eb07 0785 	add.w	r7, r7, r5, lsl #2
 8013434:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8013438:	4457      	add	r7, sl
 801343a:	4455      	add	r5, sl
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 801343c:	4631      	mov	r1, r6
 801343e:	4620      	mov	r0, r4
 8013440:	f7f9 fdbc 	bl	800cfbc <xmp3fixpt_GetBits>
 8013444:	f807 0b01 	strb.w	r0, [r7], #1
 8013448:	42bd      	cmp	r5, r7
 801344a:	d1f7      	bne.n	801343c <xmp3fixpt_UnpackScaleFactors+0x6bc>
 801344c:	e56d      	b.n	8012f2a <xmp3fixpt_UnpackScaleFactors+0x1aa>
 801344e:	e9dd 6007 	ldrd	r6, r0, [sp, #28]
 8013452:	2706      	movs	r7, #6
 8013454:	e518      	b.n	8012e88 <xmp3fixpt_UnpackScaleFactors+0x108>
		if (sfCompress < 180) {
 8013456:	f5b0 7fb4 	cmp.w	r0, #360	; 0x168
		intensityScale = sfCompress & 0x01;
 801345a:	f000 0e01 	and.w	lr, r0, #1
		sfCompress >>= 1;
 801345e:	ea4f 0360 	mov.w	r3, r0, asr #1
		if (sfCompress < 180) {
 8013462:	db6b      	blt.n	801353c <xmp3fixpt_UnpackScaleFactors+0x7bc>
		} else if (sfCompress < 244) {
 8013464:	2bf3      	cmp	r3, #243	; 0xf3
 8013466:	f300 80b7 	bgt.w	80135d8 <xmp3fixpt_UnpackScaleFactors+0x858>
			sfCompress -= 180;
 801346a:	2103      	movs	r1, #3
 801346c:	3bb4      	subs	r3, #180	; 0xb4
	preFlag = 0;
 801346e:	4693      	mov	fp, r2
			slen[3] = 0;
 8013470:	920d      	str	r2, [sp, #52]	; 0x34
			slen[0] = (sfCompress & 0x3f) >> 4;
 8013472:	ea4f 1823 	mov.w	r8, r3, asr #4
			slen[1] = (sfCompress & 0x0f) >> 2;
 8013476:	f3c3 0281 	ubfx	r2, r3, #2, #2
			slen[2] = (sfCompress & 0x03);
 801347a:	400b      	ands	r3, r1
 801347c:	2006      	movs	r0, #6
			slen[1] = (sfCompress & 0x0f) >> 2;
 801347e:	920b      	str	r2, [sp, #44]	; 0x2c
 8013480:	4689      	mov	r9, r1
			slen[2] = (sfCompress & 0x03);
 8013482:	930c      	str	r3, [sp, #48]	; 0x30
 8013484:	2304      	movs	r3, #4
 8013486:	460a      	mov	r2, r1
 8013488:	4606      	mov	r6, r0
 801348a:	4607      	mov	r7, r0
 801348c:	f04f 0c02 	mov.w	ip, #2
			slen[0] = (sfCompress & 0x3f) >> 4;
 8013490:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			sfcIdx = 4;
 8013494:	9309      	str	r3, [sp, #36]	; 0x24
 8013496:	e9cd 3107 	strd	r3, r1, [sp, #28]
 801349a:	e4e4      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
 801349c:	014a      	lsls	r2, r1, #5
			sfb = 0;
 801349e:	469b      	mov	fp, r3
 80134a0:	9204      	str	r2, [sp, #16]
 80134a2:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80134a4:	0152      	lsls	r2, r2, #5
 80134a6:	9205      	str	r2, [sp, #20]
 80134a8:	e74d      	b.n	8013346 <xmp3fixpt_UnpackScaleFactors+0x5c6>
			sfjs->slen[i] = slen[i];
 80134aa:	ae0a      	add	r6, sp, #40	; 0x28
			sfjs->nr[i] = nr[i];
 80134ac:	af12      	add	r7, sp, #72	; 0x48
		sfjs->intensityScale = intensityScale;
 80134ae:	f8ca e0f8 	str.w	lr, [sl, #248]	; 0xf8
			sfjs->slen[i] = slen[i];
 80134b2:	46b6      	mov	lr, r6
			sfjs->nr[i] = nr[i];
 80134b4:	46bc      	mov	ip, r7
			sfjs->slen[i] = slen[i];
 80134b6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80134ba:	f8ca 00fc 	str.w	r0, [sl, #252]	; 0xfc
 80134be:	f8ca 1100 	str.w	r1, [sl, #256]	; 0x100
 80134c2:	f8ca 2104 	str.w	r2, [sl, #260]	; 0x104
 80134c6:	f8ca 3108 	str.w	r3, [sl, #264]	; 0x108
			sfjs->nr[i] = nr[i];
 80134ca:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80134ce:	f8ca 010c 	str.w	r0, [sl, #268]	; 0x10c
 80134d2:	f8ca 1110 	str.w	r1, [sl, #272]	; 0x110
 80134d6:	f8ca 2114 	str.w	r2, [sl, #276]	; 0x114
 80134da:	f8ca 3118 	str.w	r3, [sl, #280]	; 0x118
		sfjs->intensityScale = intensityScale;
 80134de:	e4e0      	b.n	8012ea2 <xmp3fixpt_UnpackScaleFactors+0x122>
 80134e0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80134e2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80134e4:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80134e8:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
 80134ec:	009b      	lsls	r3, r3, #2
 80134ee:	0152      	lsls	r2, r2, #5
 80134f0:	eb03 0745 	add.w	r7, r3, r5, lsl #1
 80134f4:	9204      	str	r2, [sp, #16]
 80134f6:	463d      	mov	r5, r7
 80134f8:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80134fa:	3f01      	subs	r7, #1
 80134fc:	3507      	adds	r5, #7
 80134fe:	0152      	lsls	r2, r2, #5
 8013500:	4457      	add	r7, sl
 8013502:	4455      	add	r5, sl
 8013504:	9205      	str	r2, [sp, #20]
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 8013506:	4649      	mov	r1, r9
 8013508:	4620      	mov	r0, r4
 801350a:	f7f9 fd57 	bl	800cfbc <xmp3fixpt_GetBits>
 801350e:	f807 0f01 	strb.w	r0, [r7, #1]!
			for (sfb = 0; sfb < 8; sfb++)
 8013512:	42bd      	cmp	r5, r7
 8013514:	d1f7      	bne.n	8013506 <xmp3fixpt_UnpackScaleFactors+0x786>
			sfb = 3;
 8013516:	2303      	movs	r3, #3
 8013518:	e6a4      	b.n	8013264 <xmp3fixpt_UnpackScaleFactors+0x4e4>
 801351a:	f04f 0906 	mov.w	r9, #6
 801351e:	2303      	movs	r3, #3
 8013520:	4661      	mov	r1, ip
 8013522:	4662      	mov	r2, ip
 8013524:	4660      	mov	r0, ip
	intensityScale = 0;
 8013526:	46e6      	mov	lr, ip
 8013528:	260a      	movs	r6, #10
 801352a:	270b      	movs	r7, #11
			preFlag = 1;
 801352c:	f04f 0b01 	mov.w	fp, #1
 8013530:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8013534:	f8cd 9020 	str.w	r9, [sp, #32]
 8013538:	9307      	str	r3, [sp, #28]
 801353a:	e494      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
			slen[0] = (sfCompress / 36);
 801353c:	4946      	ldr	r1, [pc, #280]	; (8013658 <xmp3fixpt_UnpackScaleFactors+0x8d8>)
 801353e:	17c0      	asrs	r0, r0, #31
 8013540:	4694      	mov	ip, r2
	preFlag = 0;
 8013542:	4693      	mov	fp, r2
			slen[0] = (sfCompress / 36);
 8013544:	fb81 1803 	smull	r1, r8, r1, r3
			slen[3] = 0;
 8013548:	920d      	str	r2, [sp, #52]	; 0x34
			slen[0] = (sfCompress / 36);
 801354a:	ebc0 08e8 	rsb	r8, r0, r8, asr #3
			slen[1] = (sfCompress % 36) / 6;
 801354e:	eb08 01c8 	add.w	r1, r8, r8, lsl #3
			slen[0] = (sfCompress / 36);
 8013552:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1] = (sfCompress % 36) / 6;
 8013556:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
 801355a:	4940      	ldr	r1, [pc, #256]	; (801365c <xmp3fixpt_UnpackScaleFactors+0x8dc>)
 801355c:	fb81 0103 	smull	r0, r1, r1, r3
 8013560:	2007      	movs	r0, #7
 8013562:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8013566:	4606      	mov	r6, r0
 8013568:	4607      	mov	r7, r0
 801356a:	910b      	str	r1, [sp, #44]	; 0x2c
			slen[2] = (sfCompress % 36) % 6;
 801356c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8013570:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8013574:	2305      	movs	r3, #5
 8013576:	910c      	str	r1, [sp, #48]	; 0x30
			sfcIdx = 3;
 8013578:	2104      	movs	r1, #4
 801357a:	9307      	str	r3, [sp, #28]
 801357c:	4689      	mov	r9, r1
 801357e:	9109      	str	r1, [sp, #36]	; 0x24
 8013580:	9108      	str	r1, [sp, #32]
 8013582:	e470      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
		return -1;
 8013584:	f04f 30ff 	mov.w	r0, #4294967295
 8013588:	e4fe      	b.n	8012f88 <xmp3fixpt_UnpackScaleFactors+0x208>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801358a:	4413      	add	r3, r2
 801358c:	4452      	add	r2, sl
 801358e:	4453      	add	r3, sl
 8013590:	7991      	ldrb	r1, [r2, #6]
 8013592:	7199      	strb	r1, [r3, #6]
 8013594:	79d1      	ldrb	r1, [r2, #7]
 8013596:	71d9      	strb	r1, [r3, #7]
 8013598:	7a11      	ldrb	r1, [r2, #8]
 801359a:	7219      	strb	r1, [r3, #8]
 801359c:	7a51      	ldrb	r1, [r2, #9]
 801359e:	7259      	strb	r1, [r3, #9]
 80135a0:	7a92      	ldrb	r2, [r2, #10]
 80135a2:	729a      	strb	r2, [r3, #10]
 80135a4:	e55b      	b.n	801305e <xmp3fixpt_UnpackScaleFactors+0x2de>
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80135a6:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
 80135aa:	eb02 0341 	add.w	r3, r2, r1, lsl #1
 80135ae:	f81a 2011 	ldrb.w	r2, [sl, r1, lsl #1]
 80135b2:	f80a 2003 	strb.w	r2, [sl, r3]
 80135b6:	eb0a 0241 	add.w	r2, sl, r1, lsl #1
 80135ba:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80135bc:	4453      	add	r3, sl
 80135be:	0149      	lsls	r1, r1, #5
 80135c0:	9104      	str	r1, [sp, #16]
 80135c2:	7851      	ldrb	r1, [r2, #1]
 80135c4:	7059      	strb	r1, [r3, #1]
 80135c6:	7891      	ldrb	r1, [r2, #2]
 80135c8:	7099      	strb	r1, [r3, #2]
 80135ca:	78d1      	ldrb	r1, [r2, #3]
 80135cc:	70d9      	strb	r1, [r3, #3]
 80135ce:	7911      	ldrb	r1, [r2, #4]
 80135d0:	7119      	strb	r1, [r3, #4]
 80135d2:	7952      	ldrb	r2, [r2, #5]
 80135d4:	715a      	strb	r2, [r3, #5]
 80135d6:	e524      	b.n	8013022 <xmp3fixpt_UnpackScaleFactors+0x2a2>
			sfCompress -= 244;
 80135d8:	3bf4      	subs	r3, #244	; 0xf4
			slen[0] = (sfCompress / 3);
 80135da:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8013660 <xmp3fixpt_UnpackScaleFactors+0x8e0>
			slen[2] = slen[3] = 0;
 80135de:	2608      	movs	r6, #8
 80135e0:	f04f 0904 	mov.w	r9, #4
			slen[0] = (sfCompress / 3);
 80135e4:	fba8 1803 	umull	r1, r8, r8, r3
			slen[2] = slen[3] = 0;
 80135e8:	4694      	mov	ip, r2
 80135ea:	4637      	mov	r7, r6
	preFlag = 0;
 80135ec:	4693      	mov	fp, r2
			slen[0] = (sfCompress / 3);
 80135ee:	ea4f 0858 	mov.w	r8, r8, lsr #1
			slen[1] = (sfCompress % 3);
 80135f2:	eb08 0148 	add.w	r1, r8, r8, lsl #1
			slen[0] = (sfCompress / 3);
 80135f6:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1] = (sfCompress % 3);
 80135fa:	1a5b      	subs	r3, r3, r1
			slen[2] = slen[3] = 0;
 80135fc:	2103      	movs	r1, #3
			slen[1] = (sfCompress % 3);
 80135fe:	930b      	str	r3, [sp, #44]	; 0x2c
			slen[2] = slen[3] = 0;
 8013600:	2305      	movs	r3, #5
 8013602:	9108      	str	r1, [sp, #32]
 8013604:	4618      	mov	r0, r3
 8013606:	9309      	str	r3, [sp, #36]	; 0x24
 8013608:	2306      	movs	r3, #6
 801360a:	ed9f 7b11 	vldr	d7, [pc, #68]	; 8013650 <xmp3fixpt_UnpackScaleFactors+0x8d0>
 801360e:	9307      	str	r3, [sp, #28]
 8013610:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
			sfcIdx = 5;
 8013614:	e427      	b.n	8012e66 <xmp3fixpt_UnpackScaleFactors+0xe6>
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8013616:	4413      	add	r3, r2
 8013618:	4452      	add	r2, sl
 801361a:	4453      	add	r3, sl
 801361c:	7c11      	ldrb	r1, [r2, #16]
 801361e:	7419      	strb	r1, [r3, #16]
 8013620:	7c51      	ldrb	r1, [r2, #17]
 8013622:	7459      	strb	r1, [r3, #17]
 8013624:	7c91      	ldrb	r1, [r2, #18]
 8013626:	7499      	strb	r1, [r3, #18]
 8013628:	7cd1      	ldrb	r1, [r2, #19]
 801362a:	74d9      	strb	r1, [r3, #19]
 801362c:	7d12      	ldrb	r2, [r2, #20]
 801362e:	751a      	strb	r2, [r3, #20]
 8013630:	e47b      	b.n	8012f2a <xmp3fixpt_UnpackScaleFactors+0x1aa>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8013632:	1853      	adds	r3, r2, r1
 8013634:	4452      	add	r2, sl
 8013636:	4453      	add	r3, sl
 8013638:	7ad1      	ldrb	r1, [r2, #11]
 801363a:	72d9      	strb	r1, [r3, #11]
 801363c:	7b11      	ldrb	r1, [r2, #12]
 801363e:	7319      	strb	r1, [r3, #12]
 8013640:	7b51      	ldrb	r1, [r2, #13]
 8013642:	7359      	strb	r1, [r3, #13]
 8013644:	7b91      	ldrb	r1, [r2, #14]
 8013646:	7399      	strb	r1, [r3, #14]
 8013648:	7bd2      	ldrb	r2, [r2, #15]
 801364a:	73da      	strb	r2, [r3, #15]
 801364c:	e526      	b.n	801309c <xmp3fixpt_UnpackScaleFactors+0x31c>
 801364e:	bf00      	nop
	...
 8013658:	38e38e39 	.word	0x38e38e39
 801365c:	2aaaaaab 	.word	0x2aaaaaab
 8013660:	aaaaaaab 	.word	0xaaaaaaab

08013664 <xmp3fixpt_MidSideProc>:
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
	for(i = 0; i < nSamps; i++) {
 8013664:	2900      	cmp	r1, #0
{
 8013666:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	for(i = 0; i < nSamps; i++) {
 801366a:	dd2b      	ble.n	80136c4 <xmp3fixpt_MidSideProc+0x60>
	mOutL = mOutR = 0;
 801366c:	2600      	movs	r6, #0
 801366e:	f1a0 0c04 	sub.w	ip, r0, #4
 8013672:	f600 0efc 	addw	lr, r0, #2300	; 0x8fc
 8013676:	4637      	mov	r7, r6
	for(i = 0; i < nSamps; i++) {
 8013678:	4634      	mov	r4, r6
	__asm__ volatile (
 801367a:	46b0      	mov	r8, r6
		xl = x[0][i];
 801367c:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 8013680:	4640      	mov	r0, r8
		xr = x[1][i];
 8013682:	f85e 5f04 	ldr.w	r5, [lr, #4]!
		x[0][i] = xl + xr;
 8013686:	eb03 0905 	add.w	r9, r3, r5
		x[1][i] = xl - xr;
 801368a:	1b5b      	subs	r3, r3, r5
		x[0][i] = xl + xr;
 801368c:	f8cc 9000 	str.w	r9, [ip]
		x[1][i] = xl - xr;
 8013690:	f8ce 3000 	str.w	r3, [lr]
 8013694:	f8dc 5000 	ldr.w	r5, [ip]
 8013698:	ea85 70e5 	eor.w	r0, r5, r5, asr #31
 801369c:	eba0 70e5 	sub.w	r0, r0, r5, asr #31
		mOutL |= FASTABS(x[0][i]);
 80136a0:	4307      	orrs	r7, r0
 80136a2:	4640      	mov	r0, r8
 80136a4:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 80136a8:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
	for(i = 0; i < nSamps; i++) {
 80136ac:	3401      	adds	r4, #1
		mOutR |= FASTABS(x[1][i]);
 80136ae:	4306      	orrs	r6, r0
	for(i = 0; i < nSamps; i++) {
 80136b0:	42a1      	cmp	r1, r4
 80136b2:	d1e3      	bne.n	801367c <xmp3fixpt_MidSideProc+0x18>
	}
	mOut[0] |= mOutL;
	mOut[1] |= mOutR;
 80136b4:	e9d2 1300 	ldrd	r1, r3, [r2]
	mOut[0] |= mOutL;
 80136b8:	4339      	orrs	r1, r7
	mOut[1] |= mOutR;
 80136ba:	4333      	orrs	r3, r6
 80136bc:	e9c2 1300 	strd	r1, r3, [r2]
}
 80136c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	mOutL = mOutR = 0;
 80136c4:	2600      	movs	r6, #0
 80136c6:	4637      	mov	r7, r6
 80136c8:	e7f4      	b.n	80136b4 <xmp3fixpt_MidSideProc+0x50>
 80136ca:	bf00      	nop

080136cc <xmp3fixpt_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 80136cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80136d0:	b091      	sub	sp, #68	; 0x44
 80136d2:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 80136d4:	900d      	str	r0, [sp, #52]	; 0x34
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 80136d6:	f8d5 a018 	ldr.w	sl, [r5, #24]
 80136da:	f1ba 0f00 	cmp.w	sl, #0
 80136de:	f000 811d 	beq.w	801391c <xmp3fixpt_IntensityProcMPEG1+0x250>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
		cbEndL =   cbi[0].cbEndL + 1;
		cbStartS = cbEndS = 0;
		i = fh->sfBand->l[cbStartL];
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 80136e2:	f10a 30ff 	add.w	r0, sl, #4294967295
 80136e6:	2801      	cmp	r0, #1
 80136e8:	d908      	bls.n	80136fc <xmp3fixpt_IntensityProcMPEG1+0x30>
		i = 3 * fh->sfBand->s[cbStartS];
	}

	sampsLeft = nSamps - i;		/* process to length of left */
	isfTab = (int *)ISFMpeg1[midSideFlag];
	mOutL = mOutR = 0;
 80136ea:	f04f 0800 	mov.w	r8, #0
 80136ee:	46c2      	mov	sl, r8
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
			sampsLeft -= 3;
		}
	}
	mOut[0] = mOutL;
 80136f0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
	mOut[1] = mOutR;
 80136f2:	e9c3 a800 	strd	sl, r8, [r3]
	
	return;
}
 80136f6:	b011      	add	sp, #68	; 0x44
 80136f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		cbStartS = cbi[1].cbEndSMax + 1;
 80136fc:	6aac      	ldr	r4, [r5, #40]	; 0x28
		i = 3 * fh->sfBand->s[cbStartS];
 80136fe:	6b56      	ldr	r6, [r2, #52]	; 0x34
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013700:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
		i = 3 * fh->sfBand->s[cbStartS];
 8013702:	eb06 0044 	add.w	r0, r6, r4, lsl #1
		cbEndS =   cbi[0].cbEndSMax + 1;
 8013706:	692d      	ldr	r5, [r5, #16]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013708:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
		i = 3 * fh->sfBand->s[cbStartS];
 801370c:	f9b0 0030 	ldrsh.w	r0, [r0, #48]	; 0x30
		cbEndS =   cbi[0].cbEndSMax + 1;
 8013710:	950f      	str	r5, [sp, #60]	; 0x3c
		i = 3 * fh->sfBand->s[cbStartS];
 8013712:	eb00 0040 	add.w	r0, r0, r0, lsl #1
	sampsLeft = nSamps - i;		/* process to length of left */
 8013716:	eba1 0c00 	sub.w	ip, r1, r0
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801371a:	497e      	ldr	r1, [pc, #504]	; (8013914 <xmp3fixpt_IntensityProcMPEG1+0x248>)
 801371c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8013720:	f1bc 0f02 	cmp.w	ip, #2
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013724:	920b      	str	r2, [sp, #44]	; 0x2c
		cbStartS = cbi[1].cbEndSMax + 1;
 8013726:	f104 0201 	add.w	r2, r4, #1
 801372a:	9209      	str	r2, [sp, #36]	; 0x24
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801372c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 801372e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8013732:	ddda      	ble.n	80136ea <xmp3fixpt_IntensityProcMPEG1+0x1e>
 8013734:	42ac      	cmp	r4, r5
 8013736:	dad8      	bge.n	80136ea <xmp3fixpt_IntensityProcMPEG1+0x1e>
 8013738:	3418      	adds	r4, #24
	mOutL = mOutR = 0;
 801373a:	f04f 0800 	mov.w	r8, #0
 801373e:	eb06 0144 	add.w	r1, r6, r4, lsl #1
 8013742:	46c2      	mov	sl, r8
 8013744:	4646      	mov	r6, r8
 8013746:	46c1      	mov	r9, r8
			isf = sfis->s[cb][w];
 8013748:	910a      	str	r1, [sp, #40]	; 0x28
 801374a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801374c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8013750:	440b      	add	r3, r1
 8013752:	9308      	str	r3, [sp, #32]
				frs[w] = ISFIIP[midSideFlag][1];
 8013754:	4b70      	ldr	r3, [pc, #448]	; (8013918 <xmp3fixpt_IntensityProcMPEG1+0x24c>)
 8013756:	4413      	add	r3, r2
 8013758:	930e      	str	r3, [sp, #56]	; 0x38
			isf = sfis->s[cb][w];
 801375a:	9b08      	ldr	r3, [sp, #32]
 801375c:	7ddb      	ldrb	r3, [r3, #23]
			if (isf == 7) {
 801375e:	2b07      	cmp	r3, #7
 8013760:	f000 80b4 	beq.w	80138cc <xmp3fixpt_IntensityProcMPEG1+0x200>
				fls[w] = isfTab[isf];
 8013764:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8013766:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 801376a:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 801376c:	9103      	str	r1, [sp, #12]
				frs[w] = isfTab[6] - isfTab[isf];
 801376e:	1a5b      	subs	r3, r3, r1
 8013770:	9304      	str	r3, [sp, #16]
			isf = sfis->s[cb][w];
 8013772:	9b08      	ldr	r3, [sp, #32]
 8013774:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 8013776:	2b07      	cmp	r3, #7
 8013778:	f000 80b5 	beq.w	80138e6 <xmp3fixpt_IntensityProcMPEG1+0x21a>
				fls[w] = isfTab[isf];
 801377c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801377e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 8013782:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 8013784:	9101      	str	r1, [sp, #4]
				frs[w] = isfTab[6] - isfTab[isf];
 8013786:	1a5b      	subs	r3, r3, r1
 8013788:	9305      	str	r3, [sp, #20]
			isf = sfis->s[cb][w];
 801378a:	9b08      	ldr	r3, [sp, #32]
 801378c:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 801378e:	2b07      	cmp	r3, #7
 8013790:	f000 80b6 	beq.w	8013900 <xmp3fixpt_IntensityProcMPEG1+0x234>
				fls[w] = isfTab[isf];
 8013794:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8013796:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 801379a:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 801379c:	9102      	str	r1, [sp, #8]
				frs[w] = isfTab[6] - isfTab[isf];
 801379e:	1a5b      	subs	r3, r3, r1
 80137a0:	9306      	str	r3, [sp, #24]
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80137a2:	990a      	ldr	r1, [sp, #40]	; 0x28
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 80137a4:	f1bc 0f02 	cmp.w	ip, #2
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80137a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80137aa:	460b      	mov	r3, r1
 80137ac:	f9b1 8002 	ldrsh.w	r8, [r1, #2]
 80137b0:	f102 0201 	add.w	r2, r2, #1
 80137b4:	f101 0102 	add.w	r1, r1, #2
 80137b8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80137bc:	920c      	str	r2, [sp, #48]	; 0x30
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 80137be:	bfd8      	it	le
 80137c0:	2200      	movle	r2, #0
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80137c2:	eba8 0803 	sub.w	r8, r8, r3
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 80137c6:	bfc8      	it	gt
 80137c8:	2201      	movgt	r2, #1
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80137ca:	910a      	str	r1, [sp, #40]	; 0x28
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 80137cc:	f1b8 0f00 	cmp.w	r8, #0
 80137d0:	dd6a      	ble.n	80138a8 <xmp3fixpt_IntensityProcMPEG1+0x1dc>
 80137d2:	2a00      	cmp	r2, #0
 80137d4:	d068      	beq.n	80138a8 <xmp3fixpt_IntensityProcMPEG1+0x1dc>
 80137d6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80137d8:	eb0c 0200 	add.w	r2, ip, r0
 80137dc:	f04f 0e00 	mov.w	lr, #0
 80137e0:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80137e4:	9207      	str	r2, [sp, #28]
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 80137e6:	681a      	ldr	r2, [r3, #0]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80137e8:	9c04      	ldr	r4, [sp, #16]
 80137ea:	4611      	mov	r1, r2
 80137ec:	fb84 0101 	smull	r0, r1, r4, r1
 80137f0:	0089      	lsls	r1, r1, #2
	__asm__ volatile (
 80137f2:	4637      	mov	r7, r6
 80137f4:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 80137f8:	ea81 77e1 	eor.w	r7, r1, r1, asr #31
 80137fc:	eba7 77e1 	sub.w	r7, r7, r1, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013800:	9803      	ldr	r0, [sp, #12]
 8013802:	fb80 1202 	smull	r1, r2, r0, r2
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 8013806:	0092      	lsls	r2, r2, #2
	__asm__ volatile (
 8013808:	4635      	mov	r5, r6
 801380a:	601a      	str	r2, [r3, #0]
 801380c:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
 8013810:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 8013814:	685a      	ldr	r2, [r3, #4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013816:	9c05      	ldr	r4, [sp, #20]
 8013818:	4611      	mov	r1, r2
 801381a:	fb84 0101 	smull	r0, r1, r4, r1
 801381e:	0089      	lsls	r1, r1, #2
	__asm__ volatile (
 8013820:	4630      	mov	r0, r6
 8013822:	f8c3 1904 	str.w	r1, [r3, #2308]	; 0x904
 8013826:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 801382a:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801382e:	9c01      	ldr	r4, [sp, #4]
 8013830:	fb84 1202 	smull	r1, r2, r4, r2
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 8013834:	0092      	lsls	r2, r2, #2
	__asm__ volatile (
 8013836:	4631      	mov	r1, r6
 8013838:	605a      	str	r2, [r3, #4]
 801383a:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
 801383e:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 8013842:	689a      	ldr	r2, [r3, #8]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013844:	4614      	mov	r4, r2
 8013846:	9200      	str	r2, [sp, #0]
 8013848:	9a06      	ldr	r2, [sp, #24]
 801384a:	fb82 b404 	smull	fp, r4, r2, r4
 801384e:	00a4      	lsls	r4, r4, #2
	__asm__ volatile (
 8013850:	46b3      	mov	fp, r6
 8013852:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
 8013856:	ea84 7be4 	eor.w	fp, r4, r4, asr #31
 801385a:	ebab 7be4 	sub.w	fp, fp, r4, asr #31
 801385e:	4338      	orrs	r0, r7
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013860:	9a00      	ldr	r2, [sp, #0]
 8013862:	9c02      	ldr	r4, [sp, #8]
 8013864:	ea40 000b 	orr.w	r0, r0, fp
 8013868:	ea49 0900 	orr.w	r9, r9, r0
 801386c:	fb84 0202 	smull	r0, r2, r4, r2
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8013870:	0092      	lsls	r2, r2, #2
	__asm__ volatile (
 8013872:	4630      	mov	r0, r6
 8013874:	609a      	str	r2, [r3, #8]
 8013876:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
 801387a:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
			sampsLeft -= 3;
 801387e:	f1ac 0c03 	sub.w	ip, ip, #3
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8013882:	4329      	orrs	r1, r5
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8013884:	f10e 0e01 	add.w	lr, lr, #1
 8013888:	330c      	adds	r3, #12
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 801388a:	4301      	orrs	r1, r0
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 801388c:	f1bc 0f02 	cmp.w	ip, #2
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8013890:	ea4a 0a01 	orr.w	sl, sl, r1
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8013894:	bfd4      	ite	le
 8013896:	2200      	movle	r2, #0
 8013898:	2201      	movgt	r2, #1
 801389a:	9907      	ldr	r1, [sp, #28]
 801389c:	45f0      	cmp	r8, lr
 801389e:	eba1 000c 	sub.w	r0, r1, ip
 80138a2:	dd01      	ble.n	80138a8 <xmp3fixpt_IntensityProcMPEG1+0x1dc>
 80138a4:	2a00      	cmp	r2, #0
 80138a6:	d19e      	bne.n	80137e6 <xmp3fixpt_IntensityProcMPEG1+0x11a>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80138a8:	9b08      	ldr	r3, [sp, #32]
 80138aa:	9909      	ldr	r1, [sp, #36]	; 0x24
 80138ac:	3303      	adds	r3, #3
 80138ae:	9308      	str	r3, [sp, #32]
 80138b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80138b2:	428b      	cmp	r3, r1
 80138b4:	f340 80b4 	ble.w	8013a20 <xmp3fixpt_IntensityProcMPEG1+0x354>
 80138b8:	2a00      	cmp	r2, #0
 80138ba:	f000 80b1 	beq.w	8013a20 <xmp3fixpt_IntensityProcMPEG1+0x354>
 80138be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80138c0:	9309      	str	r3, [sp, #36]	; 0x24
			isf = sfis->s[cb][w];
 80138c2:	9b08      	ldr	r3, [sp, #32]
 80138c4:	7ddb      	ldrb	r3, [r3, #23]
			if (isf == 7) {
 80138c6:	2b07      	cmp	r3, #7
 80138c8:	f47f af4c 	bne.w	8013764 <xmp3fixpt_IntensityProcMPEG1+0x98>
				fls[w] = ISFIIP[midSideFlag][0];
 80138cc:	4b12      	ldr	r3, [pc, #72]	; (8013918 <xmp3fixpt_IntensityProcMPEG1+0x24c>)
 80138ce:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80138d0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80138d4:	9303      	str	r3, [sp, #12]
				frs[w] = ISFIIP[midSideFlag][1];
 80138d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80138d8:	685b      	ldr	r3, [r3, #4]
 80138da:	9304      	str	r3, [sp, #16]
			isf = sfis->s[cb][w];
 80138dc:	9b08      	ldr	r3, [sp, #32]
 80138de:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 80138e0:	2b07      	cmp	r3, #7
 80138e2:	f47f af4b 	bne.w	801377c <xmp3fixpt_IntensityProcMPEG1+0xb0>
				fls[w] = ISFIIP[midSideFlag][0];
 80138e6:	4b0c      	ldr	r3, [pc, #48]	; (8013918 <xmp3fixpt_IntensityProcMPEG1+0x24c>)
 80138e8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80138ea:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80138ee:	9301      	str	r3, [sp, #4]
				frs[w] = ISFIIP[midSideFlag][1];
 80138f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80138f2:	685b      	ldr	r3, [r3, #4]
 80138f4:	9305      	str	r3, [sp, #20]
			isf = sfis->s[cb][w];
 80138f6:	9b08      	ldr	r3, [sp, #32]
 80138f8:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 80138fa:	2b07      	cmp	r3, #7
 80138fc:	f47f af4a 	bne.w	8013794 <xmp3fixpt_IntensityProcMPEG1+0xc8>
				fls[w] = ISFIIP[midSideFlag][0];
 8013900:	4b05      	ldr	r3, [pc, #20]	; (8013918 <xmp3fixpt_IntensityProcMPEG1+0x24c>)
 8013902:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8013904:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8013908:	9302      	str	r3, [sp, #8]
				frs[w] = ISFIIP[midSideFlag][1];
 801390a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801390c:	685b      	ldr	r3, [r3, #4]
 801390e:	9306      	str	r3, [sp, #24]
 8013910:	e747      	b.n	80137a2 <xmp3fixpt_IntensityProcMPEG1+0xd6>
 8013912:	bf00      	nop
 8013914:	08025184 	.word	0x08025184
 8013918:	08025174 	.word	0x08025174
		i = fh->sfBand->l[cbStartL];
 801391c:	6b50      	ldr	r0, [r2, #52]	; 0x34
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801391e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
		cbStartL = cbi[1].cbEndL + 1;
 8013920:	6aec      	ldr	r4, [r5, #44]	; 0x2c
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013922:	ebc2 0bc2 	rsb	fp, r2, r2, lsl #3
 8013926:	4a43      	ldr	r2, [pc, #268]	; (8013a34 <xmp3fixpt_IntensityProcMPEG1+0x368>)
		cbEndL =   cbi[0].cbEndL + 1;
 8013928:	696d      	ldr	r5, [r5, #20]
		i = fh->sfBand->l[cbStartL];
 801392a:	f104 0801 	add.w	r8, r4, #1
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801392e:	eb02 028b 	add.w	r2, r2, fp, lsl #2
		i = fh->sfBand->l[cbStartL];
 8013932:	f930 9018 	ldrsh.w	r9, [r0, r8, lsl #1]
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8013936:	42ac      	cmp	r4, r5
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013938:	9203      	str	r2, [sp, #12]
 801393a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
	sampsLeft = nSamps - i;		/* process to length of left */
 801393c:	eba1 0709 	sub.w	r7, r1, r9
		cbEndL =   cbi[0].cbEndL + 1;
 8013940:	9501      	str	r5, [sp, #4]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8013942:	ea4f 02c2 	mov.w	r2, r2, lsl #3
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8013946:	da72      	bge.n	8013a2e <xmp3fixpt_IntensityProcMPEG1+0x362>
 8013948:	2f00      	cmp	r7, #0
 801394a:	dd70      	ble.n	8013a2e <xmp3fixpt_IntensityProcMPEG1+0x362>
 801394c:	eb03 0b08 	add.w	fp, r3, r8
 8013950:	43db      	mvns	r3, r3
 8013952:	eb00 0148 	add.w	r1, r0, r8, lsl #1
 8013956:	4656      	mov	r6, sl
 8013958:	9302      	str	r3, [sp, #8]
	mOutL = mOutR = 0;
 801395a:	46d0      	mov	r8, sl
			fr = ISFIIP[midSideFlag][1];
 801395c:	4b36      	ldr	r3, [pc, #216]	; (8013a38 <xmp3fixpt_IntensityProcMPEG1+0x36c>)
 801395e:	9100      	str	r1, [sp, #0]
 8013960:	4413      	add	r3, r2
 8013962:	9304      	str	r3, [sp, #16]
		isf = sfis->l[cb];
 8013964:	f81b 3b01 	ldrb.w	r3, [fp], #1
		if (isf == 7) {
 8013968:	2b07      	cmp	r3, #7
 801396a:	d052      	beq.n	8013a12 <xmp3fixpt_IntensityProcMPEG1+0x346>
			fl = isfTab[isf];	
 801396c:	9a03      	ldr	r2, [sp, #12]
 801396e:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
			fr = isfTab[6] - isfTab[isf];
 8013972:	6994      	ldr	r4, [r2, #24]
 8013974:	1b64      	subs	r4, r4, r5
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8013976:	9900      	ldr	r1, [sp, #0]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8013978:	2f00      	cmp	r7, #0
 801397a:	460a      	mov	r2, r1
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 801397c:	f9b1 c002 	ldrsh.w	ip, [r1, #2]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8013980:	bfd4      	ite	le
 8013982:	2300      	movle	r3, #0
 8013984:	2301      	movgt	r3, #1
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8013986:	f9b2 2000 	ldrsh.w	r2, [r2]
 801398a:	3102      	adds	r1, #2
 801398c:	ebac 0c02 	sub.w	ip, ip, r2
 8013990:	9100      	str	r1, [sp, #0]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8013992:	f1bc 0f00 	cmp.w	ip, #0
 8013996:	dd2f      	ble.n	80139f8 <xmp3fixpt_IntensityProcMPEG1+0x32c>
 8013998:	b373      	cbz	r3, 80139f8 <xmp3fixpt_IntensityProcMPEG1+0x32c>
 801399a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801399c:	eb07 0e09 	add.w	lr, r7, r9
 80139a0:	4639      	mov	r1, r7
 80139a2:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 80139a6:	3804      	subs	r0, #4
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 80139a8:	f850 3f04 	ldr.w	r3, [r0, #4]!
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80139ac:	461a      	mov	r2, r3
 80139ae:	fb84 9202 	smull	r9, r2, r4, r2
 80139b2:	0092      	lsls	r2, r2, #2
	__asm__ volatile (
 80139b4:	46b1      	mov	r9, r6
 80139b6:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
 80139ba:	ea82 79e2 	eor.w	r9, r2, r2, asr #31
 80139be:	eba9 79e2 	sub.w	r9, r9, r2, asr #31
 80139c2:	ea48 0809 	orr.w	r8, r8, r9
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80139c6:	fb85 2303 	smull	r2, r3, r5, r3
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 80139ca:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 80139cc:	4632      	mov	r2, r6
 80139ce:	6003      	str	r3, [r0, #0]
 80139d0:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80139d4:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
			sampsLeft--;
 80139d8:	3901      	subs	r1, #1
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 80139da:	ea4a 0a02 	orr.w	sl, sl, r2
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 80139de:	2900      	cmp	r1, #0
 80139e0:	eba7 0201 	sub.w	r2, r7, r1
 80139e4:	ebae 0901 	sub.w	r9, lr, r1
 80139e8:	bfd4      	ite	le
 80139ea:	2300      	movle	r3, #0
 80139ec:	2301      	movgt	r3, #1
 80139ee:	4594      	cmp	ip, r2
 80139f0:	dd01      	ble.n	80139f6 <xmp3fixpt_IntensityProcMPEG1+0x32a>
 80139f2:	2b00      	cmp	r3, #0
 80139f4:	d1d8      	bne.n	80139a8 <xmp3fixpt_IntensityProcMPEG1+0x2dc>
			sampsLeft--;
 80139f6:	460f      	mov	r7, r1
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 80139f8:	9a02      	ldr	r2, [sp, #8]
 80139fa:	9901      	ldr	r1, [sp, #4]
 80139fc:	445a      	add	r2, fp
 80139fe:	4291      	cmp	r1, r2
 8013a00:	f77f ae76 	ble.w	80136f0 <xmp3fixpt_IntensityProcMPEG1+0x24>
 8013a04:	2b00      	cmp	r3, #0
 8013a06:	f43f ae73 	beq.w	80136f0 <xmp3fixpt_IntensityProcMPEG1+0x24>
		isf = sfis->l[cb];
 8013a0a:	f81b 3b01 	ldrb.w	r3, [fp], #1
		if (isf == 7) {
 8013a0e:	2b07      	cmp	r3, #7
 8013a10:	d1ac      	bne.n	801396c <xmp3fixpt_IntensityProcMPEG1+0x2a0>
			fl = ISFIIP[midSideFlag][0];
 8013a12:	4b09      	ldr	r3, [pc, #36]	; (8013a38 <xmp3fixpt_IntensityProcMPEG1+0x36c>)
 8013a14:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8013a16:	f853 5032 	ldr.w	r5, [r3, r2, lsl #3]
			fr = ISFIIP[midSideFlag][1];
 8013a1a:	9b04      	ldr	r3, [sp, #16]
 8013a1c:	685c      	ldr	r4, [r3, #4]
 8013a1e:	e7aa      	b.n	8013976 <xmp3fixpt_IntensityProcMPEG1+0x2aa>
 8013a20:	46c8      	mov	r8, r9
	mOut[0] = mOutL;
 8013a22:	9b1d      	ldr	r3, [sp, #116]	; 0x74
	mOut[1] = mOutR;
 8013a24:	e9c3 a800 	strd	sl, r8, [r3]
}
 8013a28:	b011      	add	sp, #68	; 0x44
 8013a2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mOutL = mOutR = 0;
 8013a2e:	f04f 0800 	mov.w	r8, #0
 8013a32:	e65d      	b.n	80136f0 <xmp3fixpt_IntensityProcMPEG1+0x24>
 8013a34:	08025184 	.word	0x08025184
 8013a38:	08025174 	.word	0x08025174

08013a3c <xmp3fixpt_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 8013a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013a40:	b0a1      	sub	sp, #132	; 0x84
	int sampsLeft;
	int isf, sfIdx, tmp, il[23];
	int *isfTab;
	int cbStartL, cbStartS, cbEndL, cbEndS;
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013a42:	4e9c      	ldr	r6, [pc, #624]	; (8013cb4 <xmp3fixpt_IntensityProcMPEG2+0x278>)
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
		tmp = (1 << sfjs->slen[r]) - 1;
 8013a44:	f04f 0e01 	mov.w	lr, #1
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013a48:	9f2c      	ldr	r7, [sp, #176]	; 0xb0
{
 8013a4a:	e9dd 842a 	ldrd	r8, r4, [sp, #168]	; 0xa8
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013a4e:	46a4      	mov	ip, r4
 8013a50:	f104 0914 	add.w	r9, r4, #20
	for (k = r = 0; r < 4; r++) {
 8013a54:	2400      	movs	r4, #0
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013a56:	f85c 5b04 	ldr.w	r5, [ip], #4
 8013a5a:	eb07 0545 	add.w	r5, r7, r5, lsl #1
 8013a5e:	eb06 1585 	add.w	r5, r6, r5, lsl #6
 8013a62:	9503      	str	r5, [sp, #12]
		tmp = (1 << sfjs->slen[r]) - 1;
 8013a64:	f85c 5b04 	ldr.w	r5, [ip], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8013a68:	f8dc 700c 	ldr.w	r7, [ip, #12]
		tmp = (1 << sfjs->slen[r]) - 1;
 8013a6c:	fa0e f505 	lsl.w	r5, lr, r5
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8013a70:	2f00      	cmp	r7, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 8013a72:	f105 35ff 	add.w	r5, r5, #4294967295
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8013a76:	dd0a      	ble.n	8013a8e <xmp3fixpt_IntensityProcMPEG2+0x52>
 8013a78:	4427      	add	r7, r4
 8013a7a:	ae09      	add	r6, sp, #36	; 0x24
 8013a7c:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 8013a80:	eb06 0687 	add.w	r6, r6, r7, lsl #2
			il[k] = tmp;
 8013a84:	f844 5b04 	str.w	r5, [r4], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8013a88:	42b4      	cmp	r4, r6
 8013a8a:	d1fb      	bne.n	8013a84 <xmp3fixpt_IntensityProcMPEG2+0x48>
 8013a8c:	463c      	mov	r4, r7
	for (k = r = 0; r < 4; r++) {
 8013a8e:	45cc      	cmp	ip, r9
 8013a90:	d1e8      	bne.n	8013a64 <xmp3fixpt_IntensityProcMPEG2+0x28>
	}

	if (cbi[1].cbType == 0) {
 8013a92:	f8d8 4018 	ldr.w	r4, [r8, #24]
 8013a96:	2c00      	cmp	r4, #0
 8013a98:	f040 8082 	bne.w	8013ba0 <xmp3fixpt_IntensityProcMPEG2+0x164>
		/* long blocks */
		il[21] = il[22] = 1;
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
		i = fh->sfBand->l[cbStartL];
 8013a9c:	6b55      	ldr	r5, [r2, #52]	; 0x34
 8013a9e:	4627      	mov	r7, r4
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 8013aa0:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 8013aa4:	f8d8 6014 	ldr.w	r6, [r8, #20]
 8013aa8:	eb03 0902 	add.w	r9, r3, r2
 8013aac:	f1c3 0301 	rsb	r3, r3, #1
 8013ab0:	9602      	str	r6, [sp, #8]
		il[21] = il[22] = 1;
 8013ab2:	2601      	movs	r6, #1
 8013ab4:	9304      	str	r3, [sp, #16]
 8013ab6:	ab09      	add	r3, sp, #36	; 0x24
 8013ab8:	e9cd 661e 	strd	r6, r6, [sp, #120]	; 0x78
		i = fh->sfBand->l[cbStartL];
 8013abc:	1996      	adds	r6, r2, r6
 8013abe:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8013ac2:	f935 2016 	ldrsh.w	r2, [r5, r6, lsl #1]
		sampsLeft = nSamps - i;
 8013ac6:	eb05 0a46 	add.w	sl, r5, r6, lsl #1

		for(cb = cbStartL; cb < cbEndL; cb++) {
			sfIdx = sfis->l[cb];
			if (sfIdx == il[cb]) {
				fl = ISFIIP[midSideFlag][0];
				fr = ISFIIP[midSideFlag][1];
 8013aca:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 8013acc:	9301      	str	r3, [sp, #4]
		sampsLeft = nSamps - i;
 8013ace:	eba1 0802 	sub.w	r8, r1, r2
				fr = ISFIIP[midSideFlag][1];
 8013ad2:	4b79      	ldr	r3, [pc, #484]	; (8013cb8 <xmp3fixpt_IntensityProcMPEG2+0x27c>)
	mOutL = mOutR = 0;
 8013ad4:	4621      	mov	r1, r4
				fr = ISFIIP[midSideFlag][1];
 8013ad6:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8013ada:	e9cd 0305 	strd	r0, r3, [sp, #20]
		for(cb = cbStartL; cb < cbEndL; cb++) {
 8013ade:	9b04      	ldr	r3, [sp, #16]
 8013ae0:	9802      	ldr	r0, [sp, #8]
 8013ae2:	444b      	add	r3, r9
 8013ae4:	4298      	cmp	r0, r3
 8013ae6:	db49      	blt.n	8013b7c <xmp3fixpt_IntensityProcMPEG2+0x140>
			if (sfIdx == il[cb]) {
 8013ae8:	9d01      	ldr	r5, [sp, #4]
			sfIdx = sfis->l[cb];
 8013aea:	f819 0f01 	ldrb.w	r0, [r9, #1]!
			if (sfIdx == il[cb]) {
 8013aee:	f855 3b04 	ldr.w	r3, [r5], #4
 8013af2:	4283      	cmp	r3, r0
 8013af4:	9501      	str	r5, [sp, #4]
 8013af6:	d047      	beq.n	8013b88 <xmp3fixpt_IntensityProcMPEG2+0x14c>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 8013af8:	1c43      	adds	r3, r0, #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013afa:	07c6      	lsls	r6, r0, #31
				isf = (sfis->l[cb] + 1) >> 1;
 8013afc:	ea4f 0363 	mov.w	r3, r3, asr #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013b00:	d549      	bpl.n	8013b96 <xmp3fixpt_IntensityProcMPEG2+0x15a>
 8013b02:	9d03      	ldr	r5, [sp, #12]
 8013b04:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013b08:	462b      	mov	r3, r5
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013b0a:	681d      	ldr	r5, [r3, #0]
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 8013b0c:	4653      	mov	r3, sl
 8013b0e:	f9ba c002 	ldrsh.w	ip, [sl, #2]
 8013b12:	f10a 0a02 	add.w	sl, sl, #2
 8013b16:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013b1a:	ebac 0c03 	sub.w	ip, ip, r3
 8013b1e:	45c4      	cmp	ip, r8
 8013b20:	bfa8      	it	ge
 8013b22:	46c4      	movge	ip, r8

			for(j = 0; j < n; j++, i++) {
 8013b24:	f1bc 0f00 	cmp.w	ip, #0
 8013b28:	dd25      	ble.n	8013b76 <xmp3fixpt_IntensityProcMPEG2+0x13a>
 8013b2a:	eb0c 0e02 	add.w	lr, ip, r2
 8013b2e:	9b05      	ldr	r3, [sp, #20]
 8013b30:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8013b34:	eb03 068e 	add.w	r6, r3, lr, lsl #2
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8013b38:	f852 3b04 	ldr.w	r3, [r2], #4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013b3c:	fb85 b303 	smull	fp, r3, r5, r3
 8013b40:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8013b42:	46bb      	mov	fp, r7
 8013b44:	f8c2 38fc 	str.w	r3, [r2, #2300]	; 0x8fc
 8013b48:	ea83 7be3 	eor.w	fp, r3, r3, asr #31
 8013b4c:	ebab 7be3 	sub.w	fp, fp, r3, asr #31
 8013b50:	ea41 010b 	orr.w	r1, r1, fp
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013b54:	f852 3c04 	ldr.w	r3, [r2, #-4]
 8013b58:	fb80 b303 	smull	fp, r3, r0, r3
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8013b5c:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8013b5e:	46bb      	mov	fp, r7
 8013b60:	f842 3c04 	str.w	r3, [r2, #-4]
 8013b64:	ea83 7be3 	eor.w	fp, r3, r3, asr #31
 8013b68:	ebab 7be3 	sub.w	fp, fp, r3, asr #31
			for(j = 0; j < n; j++, i++) {
 8013b6c:	4296      	cmp	r6, r2
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8013b6e:	ea44 040b 	orr.w	r4, r4, fp
			for(j = 0; j < n; j++, i++) {
 8013b72:	d1e1      	bne.n	8013b38 <xmp3fixpt_IntensityProcMPEG2+0xfc>
 8013b74:	4672      	mov	r2, lr
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
			if (sampsLeft == 0)		
 8013b76:	ebb8 080c 	subs.w	r8, r8, ip
 8013b7a:	d1b0      	bne.n	8013ade <xmp3fixpt_IntensityProcMPEG2+0xa2>
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
				}
			}
		}
	}
	mOut[0] = mOutL;
 8013b7c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOut[1] = mOutR;
 8013b7e:	e9c3 4100 	strd	r4, r1, [r3]

	return;
}
 8013b82:	b021      	add	sp, #132	; 0x84
 8013b84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fl = ISFIIP[midSideFlag][0];
 8013b88:	4b4b      	ldr	r3, [pc, #300]	; (8013cb8 <xmp3fixpt_IntensityProcMPEG2+0x27c>)
 8013b8a:	982c      	ldr	r0, [sp, #176]	; 0xb0
 8013b8c:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
				fr = ISFIIP[midSideFlag][1];
 8013b90:	9b06      	ldr	r3, [sp, #24]
 8013b92:	685d      	ldr	r5, [r3, #4]
 8013b94:	e7ba      	b.n	8013b0c <xmp3fixpt_IntensityProcMPEG2+0xd0>
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013b96:	9803      	ldr	r0, [sp, #12]
 8013b98:	eb00 0383 	add.w	r3, r0, r3, lsl #2
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013b9c:	6800      	ldr	r0, [r0, #0]
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013b9e:	e7b4      	b.n	8013b0a <xmp3fixpt_IntensityProcMPEG2+0xce>
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013ba0:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8013ba2:	3317      	adds	r3, #23
	mOutL = mOutR = 0;
 8013ba4:	2100      	movs	r1, #0
 8013ba6:	f500 6a10 	add.w	sl, r0, #2304	; 0x900
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013baa:	9207      	str	r2, [sp, #28]
 8013bac:	f108 0204 	add.w	r2, r8, #4
 8013bb0:	9301      	str	r3, [sp, #4]
		il[12] = 1;
 8013bb2:	2301      	movs	r3, #1
 8013bb4:	9206      	str	r2, [sp, #24]
	mOutL = mOutR = 0;
 8013bb6:	460c      	mov	r4, r1
					fr = ISFIIP[midSideFlag][1];
 8013bb8:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8013bba:	468e      	mov	lr, r1
		il[12] = 1;
 8013bbc:	9315      	str	r3, [sp, #84]	; 0x54
					fr = ISFIIP[midSideFlag][1];
 8013bbe:	4b3e      	ldr	r3, [pc, #248]	; (8013cb8 <xmp3fixpt_IntensityProcMPEG2+0x27c>)
		for(w = 0; w < 3; w++) {
 8013bc0:	9104      	str	r1, [sp, #16]
					fr = ISFIIP[midSideFlag][1];
 8013bc2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8013bc6:	9305      	str	r3, [sp, #20]
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8013bc8:	9a06      	ldr	r2, [sp, #24]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013bca:	2703      	movs	r7, #3
 8013bcc:	9e07      	ldr	r6, [sp, #28]
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8013bce:	6993      	ldr	r3, [r2, #24]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013bd0:	46bc      	mov	ip, r7
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8013bd2:	f852 5b04 	ldr.w	r5, [r2], #4
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013bd6:	9f04      	ldr	r7, [sp, #16]
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8013bd8:	9206      	str	r2, [sp, #24]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013bda:	eb06 0243 	add.w	r2, r6, r3, lsl #1
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8013bde:	9502      	str	r5, [sp, #8]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8013be0:	8e12      	ldrh	r2, [r2, #48]	; 0x30
 8013be2:	fb12 720c 	smlabb	r2, r2, ip, r7
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8013be6:	f103 0c01 	add.w	ip, r3, #1
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8013bea:	4565      	cmp	r5, ip
 8013bec:	db48      	blt.n	8013c80 <xmp3fixpt_IntensityProcMPEG2+0x244>
 8013bee:	3318      	adds	r3, #24
 8013bf0:	eb06 0843 	add.w	r8, r6, r3, lsl #1
 8013bf4:	ab09      	add	r3, sp, #36	; 0x24
 8013bf6:	eb03 098c 	add.w	r9, r3, ip, lsl #2
				sfIdx = sfis->s[cb][w];
 8013bfa:	eb0c 034c 	add.w	r3, ip, ip, lsl #1
 8013bfe:	9d01      	ldr	r5, [sp, #4]
 8013c00:	5ced      	ldrb	r5, [r5, r3]
				if (sfIdx == il[cb]) {
 8013c02:	f859 3b04 	ldr.w	r3, [r9], #4
 8013c06:	42ab      	cmp	r3, r5
 8013c08:	d048      	beq.n	8013c9c <xmp3fixpt_IntensityProcMPEG2+0x260>
					isf = (sfis->s[cb][w] + 1) >> 1;
 8013c0a:	1c6b      	adds	r3, r5, #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013c0c:	07ed      	lsls	r5, r5, #31
					isf = (sfis->s[cb][w] + 1) >> 1;
 8013c0e:	ea4f 0363 	mov.w	r3, r3, asr #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013c12:	d54a      	bpl.n	8013caa <xmp3fixpt_IntensityProcMPEG2+0x26e>
 8013c14:	9e03      	ldr	r6, [sp, #12]
 8013c16:	f856 5023 	ldr.w	r5, [r6, r3, lsl #2]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8013c1a:	4633      	mov	r3, r6
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013c1c:	681e      	ldr	r6, [r3, #0]
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8013c1e:	4643      	mov	r3, r8
 8013c20:	f9b8 7002 	ldrsh.w	r7, [r8, #2]
 8013c24:	f10c 0c01 	add.w	ip, ip, #1
 8013c28:	f108 0802 	add.w	r8, r8, #2
 8013c2c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013c30:	1aff      	subs	r7, r7, r3
				for(j = 0; j < n; j++, i+=3) {
 8013c32:	2f00      	cmp	r7, #0
 8013c34:	dd21      	ble.n	8013c7a <xmp3fixpt_IntensityProcMPEG2+0x23e>
 8013c36:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8013c3a:	4417      	add	r7, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013c3c:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
 8013c40:	fb86 b303 	smull	fp, r3, r6, r3
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8013c44:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8013c46:	46f3      	mov	fp, lr
 8013c48:	f84a 3022 	str.w	r3, [sl, r2, lsl #2]
 8013c4c:	ea83 7be3 	eor.w	fp, r3, r3, asr #31
 8013c50:	ebab 7be3 	sub.w	fp, fp, r3, asr #31
 8013c54:	ea41 010b 	orr.w	r1, r1, fp
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8013c58:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
 8013c5c:	fb85 b303 	smull	fp, r3, r5, r3
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8013c60:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8013c62:	46f3      	mov	fp, lr
 8013c64:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
 8013c68:	ea83 7be3 	eor.w	fp, r3, r3, asr #31
 8013c6c:	ebab 7be3 	sub.w	fp, fp, r3, asr #31
				for(j = 0; j < n; j++, i+=3) {
 8013c70:	3203      	adds	r2, #3
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8013c72:	ea44 040b 	orr.w	r4, r4, fp
				for(j = 0; j < n; j++, i+=3) {
 8013c76:	42ba      	cmp	r2, r7
 8013c78:	d1e0      	bne.n	8013c3c <xmp3fixpt_IntensityProcMPEG2+0x200>
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8013c7a:	9b02      	ldr	r3, [sp, #8]
 8013c7c:	4563      	cmp	r3, ip
 8013c7e:	dabc      	bge.n	8013bfa <xmp3fixpt_IntensityProcMPEG2+0x1be>
		for(w = 0; w < 3; w++) {
 8013c80:	9b04      	ldr	r3, [sp, #16]
 8013c82:	9a01      	ldr	r2, [sp, #4]
 8013c84:	3301      	adds	r3, #1
 8013c86:	3201      	adds	r2, #1
 8013c88:	2b03      	cmp	r3, #3
 8013c8a:	9304      	str	r3, [sp, #16]
 8013c8c:	9201      	str	r2, [sp, #4]
 8013c8e:	d19b      	bne.n	8013bc8 <xmp3fixpt_IntensityProcMPEG2+0x18c>
	mOut[0] = mOutL;
 8013c90:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOut[1] = mOutR;
 8013c92:	e9c3 4100 	strd	r4, r1, [r3]
}
 8013c96:	b021      	add	sp, #132	; 0x84
 8013c98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					fl = ISFIIP[midSideFlag][0];
 8013c9c:	4b06      	ldr	r3, [pc, #24]	; (8013cb8 <xmp3fixpt_IntensityProcMPEG2+0x27c>)
 8013c9e:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 8013ca0:	f853 5035 	ldr.w	r5, [r3, r5, lsl #3]
					fr = ISFIIP[midSideFlag][1];
 8013ca4:	9b05      	ldr	r3, [sp, #20]
 8013ca6:	685e      	ldr	r6, [r3, #4]
 8013ca8:	e7b9      	b.n	8013c1e <xmp3fixpt_IntensityProcMPEG2+0x1e2>
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013caa:	9d03      	ldr	r5, [sp, #12]
 8013cac:	eb05 0383 	add.w	r3, r5, r3, lsl #2
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8013cb0:	682d      	ldr	r5, [r5, #0]
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8013cb2:	e7b3      	b.n	8013c1c <xmp3fixpt_IntensityProcMPEG2+0x1e0>
 8013cb4:	080251bc 	.word	0x080251bc
 8013cb8:	08025174 	.word	0x08025174

08013cbc <xmp3fixpt_Subband>:
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8013cbc:	2800      	cmp	r0, #0
 8013cbe:	f000 8083 	beq.w	8013dc8 <xmp3fixpt_Subband+0x10c>
 8013cc2:	68c3      	ldr	r3, [r0, #12]
 8013cc4:	2b00      	cmp	r3, #0
 8013cc6:	d07f      	beq.n	8013dc8 <xmp3fixpt_Subband+0x10c>
{
 8013cc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8013ccc:	6946      	ldr	r6, [r0, #20]
{
 8013cce:	b085      	sub	sp, #20
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8013cd0:	2e00      	cmp	r6, #0
 8013cd2:	d076      	beq.n	8013dc2 <xmp3fixpt_Subband+0x106>
 8013cd4:	6987      	ldr	r7, [r0, #24]
 8013cd6:	2f00      	cmp	r7, #0
 8013cd8:	d073      	beq.n	8013dc2 <xmp3fixpt_Subband+0x106>

	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);

	if (mp3DecInfo->nChans == 2) {
 8013cda:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
		/* stereo */
		for (b = 0; b < BLOCK_SIZE; b++) {
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013cde:	f507 5400 	add.w	r4, r7, #8192	; 0x2000
 8013ce2:	460d      	mov	r5, r1
	if (mp3DecInfo->nChans == 2) {
 8013ce4:	2b02      	cmp	r3, #2
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013ce6:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
	if (mp3DecInfo->nChans == 2) {
 8013cea:	d030      	beq.n	8013d4e <xmp3fixpt_Subband+0x92>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += (2 * NBANDS);
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013cec:	f04f 0900 	mov.w	r9, #0
 8013cf0:	f506 5880 	add.w	r8, r6, #4096	; 0x1000
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013cf4:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 8013dd0 <xmp3fixpt_Subband+0x114>
 8013cf8:	9603      	str	r6, [sp, #12]
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013cfa:	f009 0b01 	and.w	fp, r9, #1
 8013cfe:	9b03      	ldr	r3, [sp, #12]
 8013d00:	f8d8 6b18 	ldr.w	r6, [r8, #2840]	; 0xb18
 8013d04:	4639      	mov	r1, r7
 8013d06:	eb03 10c9 	add.w	r0, r3, r9, lsl #7
 8013d0a:	465b      	mov	r3, fp
 8013d0c:	9600      	str	r6, [sp, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013d0e:	f109 0901 	add.w	r9, r9, #1
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013d12:	f7fa fbab 	bl	800e46c <xmp3fixpt_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013d16:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 8013d1a:	eb0b 130b 	add.w	r3, fp, fp, lsl #4
 8013d1e:	4628      	mov	r0, r5
 8013d20:	4652      	mov	r2, sl
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += NBANDS;
 8013d22:	3540      	adds	r5, #64	; 0x40
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013d24:	eb01 1183 	add.w	r1, r1, r3, lsl #6
 8013d28:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8013d2c:	f7fe fb72 	bl	8012414 <xmp3fixpt_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013d30:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013d34:	f1b9 0f12 	cmp.w	r9, #18
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013d38:	eba2 020b 	sub.w	r2, r2, fp
 8013d3c:	f002 0207 	and.w	r2, r2, #7
 8013d40:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013d44:	d1d9      	bne.n	8013cfa <xmp3fixpt_Subband+0x3e>
		}
	}

	return 0;
 8013d46:	2000      	movs	r0, #0
}
 8013d48:	b005      	add	sp, #20
 8013d4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013d4e:	f506 6310 	add.w	r3, r6, #2304	; 0x900
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 8013d52:	f107 0b80 	add.w	fp, r7, #128	; 0x80
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013d56:	f04f 0900 	mov.w	r9, #0
 8013d5a:	f506 5880 	add.w	r8, r6, #4096	; 0x1000
 8013d5e:	9303      	str	r3, [sp, #12]
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013d60:	f8d8 1b18 	ldr.w	r1, [r8, #2840]	; 0xb18
 8013d64:	f009 0301 	and.w	r3, r9, #1
 8013d68:	4630      	mov	r0, r6
 8013d6a:	f109 0901 	add.w	r9, r9, #1
 8013d6e:	9100      	str	r1, [sp, #0]
 8013d70:	4639      	mov	r1, r7
 8013d72:	469a      	mov	sl, r3
 8013d74:	f7fa fb7a 	bl	800e46c <xmp3fixpt_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 8013d78:	f8d8 1b1c 	ldr.w	r1, [r8, #2844]	; 0xb1c
 8013d7c:	f506 6010 	add.w	r0, r6, #2304	; 0x900
 8013d80:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 8013d84:	4653      	mov	r3, sl
 8013d86:	9100      	str	r1, [sp, #0]
 8013d88:	4659      	mov	r1, fp
 8013d8a:	f7fa fb6f 	bl	800e46c <xmp3fixpt_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013d8e:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 8013d92:	eb0a 120a 	add.w	r2, sl, sl, lsl #4
 8013d96:	4628      	mov	r0, r5
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013d98:	3680      	adds	r6, #128	; 0x80
			pcmBuf += (2 * NBANDS);
 8013d9a:	3580      	adds	r5, #128	; 0x80
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013d9c:	eb01 1182 	add.w	r1, r1, r2, lsl #6
 8013da0:	4a0b      	ldr	r2, [pc, #44]	; (8013dd0 <xmp3fixpt_Subband+0x114>)
 8013da2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8013da6:	f7fe fcc3 	bl	8012730 <xmp3fixpt_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013daa:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013dae:	9b03      	ldr	r3, [sp, #12]
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013db0:	eba2 020a 	sub.w	r2, r2, sl
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013db4:	42b3      	cmp	r3, r6
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013db6:	f002 0207 	and.w	r2, r2, #7
 8013dba:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013dbe:	d1cf      	bne.n	8013d60 <xmp3fixpt_Subband+0xa4>
 8013dc0:	e7c1      	b.n	8013d46 <xmp3fixpt_Subband+0x8a>
		return -1;
 8013dc2:	f04f 30ff 	mov.w	r0, #4294967295
 8013dc6:	e7bf      	b.n	8013d48 <xmp3fixpt_Subband+0x8c>
 8013dc8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8013dcc:	4770      	bx	lr
 8013dce:	bf00      	nop
 8013dd0:	0802553c 	.word	0x0802553c

08013dd4 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
 8013dd4:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
 8013dd6:	2301      	movs	r3, #1
{
 8013dd8:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
 8013dda:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0)
 8013dde:	f005 ff23 	bl	8019c28 <BSP_PlatformIsDetected>
 8013de2:	b908      	cbnz	r0, 8013de8 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
 8013de4:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
 8013de8:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8013dec:	b003      	add	sp, #12
 8013dee:	f85d fb04 	ldr.w	pc, [sp], #4
 8013df2:	bf00      	nop

08013df4 <DrawString.constprop.1>:
		break;
	}
	}
}

void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8013df4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	hdma2d.Init.Mode = DMA2D_R2M;
 8013df8:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8013dfc:	4d87      	ldr	r5, [pc, #540]	; (801401c <DrawString.constprop.1+0x228>)
void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8013dfe:	b087      	sub	sp, #28
 8013e00:	4604      	mov	r4, r0
	hdma2d.Init.Mode = DMA2D_R2M;
 8013e02:	606b      	str	r3, [r5, #4]
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8013e04:	2302      	movs	r3, #2
	hdma2d.Init.OutputOffset = Xpos;
	hdma2d.Instance = DMA2D;
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8013e06:	4628      	mov	r0, r5
void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8013e08:	460f      	mov	r7, r1
 8013e0a:	4616      	mov	r6, r2
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8013e0c:	e9c5 3102 	strd	r3, r1, [r5, #8]
	hdma2d.Instance = DMA2D;
 8013e10:	4b83      	ldr	r3, [pc, #524]	; (8014020 <DrawString.constprop.1+0x22c>)
 8013e12:	602b      	str	r3, [r5, #0]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8013e14:	f7ed fdfe 	bl	8001a14 <HAL_DMA2D_Init>
 8013e18:	2800      	cmp	r0, #0
 8013e1a:	f000 80d6 	beq.w	8013fca <DrawString.constprop.1+0x1d6>
			{
				HAL_DMA2D_PollForTransfer(&hdma2d, 10);
			}
		}
	}
	int xpos = Xpos + 5;
 8013e1e:	1d7b      	adds	r3, r7, #5
	Ypos -= 4;
 8013e20:	3e04      	subs	r6, #4
	uint16_t k = 0;
	int i = 0;
	int l = 0;
	while(str[l] != 0) {
 8013e22:	7822      	ldrb	r2, [r4, #0]
	int xpos = Xpos + 5;
 8013e24:	9302      	str	r3, [sp, #8]
	Ypos -= 4;
 8013e26:	b2b3      	uxth	r3, r6
 8013e28:	9303      	str	r3, [sp, #12]
	while(str[l] != 0) {
 8013e2a:	2a00      	cmp	r2, #0
 8013e2c:	f000 80c8 	beq.w	8013fc0 <DrawString.constprop.1+0x1cc>
 8013e30:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 801402c <DrawString.constprop.1+0x238>
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
						}
						else {
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8013e34:	2034      	movs	r0, #52	; 0x34
 8013e36:	4e7b      	ldr	r6, [pc, #492]	; (8014024 <DrawString.constprop.1+0x230>)
 8013e38:	4d7b      	ldr	r5, [pc, #492]	; (8014028 <DrawString.constprop.1+0x234>)
 8013e3a:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 8014030 <DrawString.constprop.1+0x23c>
 8013e3e:	e00b      	b.n	8013e58 <DrawString.constprop.1+0x64>
				}
			}
			while(i < 12);
			xpos += i;
		}
		if(str[l] > 191) {
 8013e40:	2abf      	cmp	r2, #191	; 0xbf
 8013e42:	d85f      	bhi.n	8013f04 <DrawString.constprop.1+0x110>
				}
			}
			while(i < 12);
			xpos += i;
		}
		if(str[l] == 32) {
 8013e44:	2a20      	cmp	r2, #32
 8013e46:	d102      	bne.n	8013e4e <DrawString.constprop.1+0x5a>
			xpos += 5;
 8013e48:	9b02      	ldr	r3, [sp, #8]
 8013e4a:	3305      	adds	r3, #5
 8013e4c:	9302      	str	r3, [sp, #8]
	while(str[l] != 0) {
 8013e4e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8013e52:	2a00      	cmp	r2, #0
 8013e54:	f000 80b4 	beq.w	8013fc0 <DrawString.constprop.1+0x1cc>
		if((str[l] > 32) && (str[l] < 128)) {
 8013e58:	f1a2 0121 	sub.w	r1, r2, #33	; 0x21
 8013e5c:	b2cb      	uxtb	r3, r1
 8013e5e:	2b5e      	cmp	r3, #94	; 0x5e
 8013e60:	d8ee      	bhi.n	8013e40 <DrawString.constprop.1+0x4c>
 8013e62:	9b02      	ldr	r3, [sp, #8]
 8013e64:	f04f 0c01 	mov.w	ip, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8013e68:	f04f 0a1f 	mov.w	sl, #31
 8013e6c:	3b01      	subs	r3, #1
 8013e6e:	9305      	str	r3, [sp, #20]
 8013e70:	e012      	b.n	8013e98 <DrawString.constprop.1+0xa4>
				if(font[(str[l]-33)*12+i] == 0) {
 8013e72:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 8013e76:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8013e7a:	f838 3017 	ldrh.w	r3, [r8, r7, lsl #1]
 8013e7e:	b92b      	cbnz	r3, 8013e8c <DrawString.constprop.1+0x98>
					if(font[(str[l]-33)*12+i+1] == 0) {
 8013e80:	3701      	adds	r7, #1
 8013e82:	f838 3017 	ldrh.w	r3, [r8, r7, lsl #1]
 8013e86:	2b00      	cmp	r3, #0
 8013e88:	f000 808f 	beq.w	8013faa <DrawString.constprop.1+0x1b6>
			while(i < 12);
 8013e8c:	f10c 0c01 	add.w	ip, ip, #1
 8013e90:	f1bc 0f0d 	cmp.w	ip, #13
 8013e94:	f000 8087 	beq.w	8013fa6 <DrawString.constprop.1+0x1b2>
				if(xpos < 470) {
 8013e98:	9b02      	ldr	r3, [sp, #8]
 8013e9a:	f10c 37ff 	add.w	r7, ip, #4294967295
 8013e9e:	f5b3 7feb 	cmp.w	r3, #470	; 0x1d6
 8013ea2:	dae6      	bge.n	8013e72 <DrawString.constprop.1+0x7e>
 8013ea4:	9b05      	ldr	r3, [sp, #20]
 8013ea6:	9a03      	ldr	r2, [sp, #12]
 8013ea8:	eb03 0e0c 	add.w	lr, r3, ip
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013eac:	f8cd c010 	str.w	ip, [sp, #16]
 8013eb0:	2300      	movs	r3, #0
 8013eb2:	e009      	b.n	8013ec8 <DrawString.constprop.1+0xd4>
					while(k < 13) {
 8013eb4:	3301      	adds	r3, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013eb6:	f04f 3cff 	mov.w	ip, #4294967295
					while(k < 13) {
 8013eba:	3a01      	subs	r2, #1
 8013ebc:	2b0d      	cmp	r3, #13
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013ebe:	f821 c01b 	strh.w	ip, [r1, fp, lsl #1]
					while(k < 13) {
 8013ec2:	d018      	beq.n	8013ef6 <DrawString.constprop.1+0x102>
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 8013ec4:	7821      	ldrb	r1, [r4, #0]
 8013ec6:	3921      	subs	r1, #33	; 0x21
 8013ec8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8013ecc:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8013ed0:	f838 1011 	ldrh.w	r1, [r8, r1, lsl #1]
 8013ed4:	4119      	asrs	r1, r3
 8013ed6:	f011 0f01 	tst.w	r1, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8013eda:	7831      	ldrb	r1, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013edc:	fb00 5101 	mla	r1, r0, r1, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8013ee0:	e9d1 1b17 	ldrd	r1, fp, [r1, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013ee4:	fb0b eb02 	mla	fp, fp, r2, lr
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 8013ee8:	d1e4      	bne.n	8013eb4 <DrawString.constprop.1+0xc0>
					while(k < 13) {
 8013eea:	3301      	adds	r3, #1
 8013eec:	3a01      	subs	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8013eee:	f821 a01b 	strh.w	sl, [r1, fp, lsl #1]
					while(k < 13) {
 8013ef2:	2b0d      	cmp	r3, #13
 8013ef4:	d1e6      	bne.n	8013ec4 <DrawString.constprop.1+0xd0>
				if(font[(str[l]-33)*12+i] == 0) {
 8013ef6:	7823      	ldrb	r3, [r4, #0]
 8013ef8:	f8dd c010 	ldr.w	ip, [sp, #16]
 8013efc:	461a      	mov	r2, r3
 8013efe:	f1a3 0121 	sub.w	r1, r3, #33	; 0x21
 8013f02:	e7b6      	b.n	8013e72 <DrawString.constprop.1+0x7e>
 8013f04:	9902      	ldr	r1, [sp, #8]
 8013f06:	f04f 0c01 	mov.w	ip, #1
 8013f0a:	f1a2 03c0 	sub.w	r3, r2, #192	; 0xc0
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8013f0e:	f04f 0e1f 	mov.w	lr, #31
 8013f12:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f14:	4692      	mov	sl, r2
 8013f16:	9105      	str	r1, [sp, #20]
 8013f18:	e010      	b.n	8013f3c <DrawString.constprop.1+0x148>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 8013f1a:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8013f1e:	eb07 0781 	add.w	r7, r7, r1, lsl #2
 8013f22:	f839 1017 	ldrh.w	r1, [r9, r7, lsl #1]
 8013f26:	b921      	cbnz	r1, 8013f32 <DrawString.constprop.1+0x13e>
					if(ru_font[(str[l]-192)*12+i+1] == 0) {
 8013f28:	3701      	adds	r7, #1
 8013f2a:	f839 1017 	ldrh.w	r1, [r9, r7, lsl #1]
 8013f2e:	2900      	cmp	r1, #0
 8013f30:	d049      	beq.n	8013fc6 <DrawString.constprop.1+0x1d2>
			while(i < 12);
 8013f32:	f10c 0c01 	add.w	ip, ip, #1
 8013f36:	f1bc 0f0d 	cmp.w	ip, #13
 8013f3a:	d03a      	beq.n	8013fb2 <DrawString.constprop.1+0x1be>
				if(xpos < 470) {
 8013f3c:	9a02      	ldr	r2, [sp, #8]
 8013f3e:	f10c 37ff 	add.w	r7, ip, #4294967295
 8013f42:	f5b2 7feb 	cmp.w	r2, #470	; 0x1d6
 8013f46:	dae8      	bge.n	8013f1a <DrawString.constprop.1+0x126>
 8013f48:	9a05      	ldr	r2, [sp, #20]
 8013f4a:	9903      	ldr	r1, [sp, #12]
 8013f4c:	eb02 0a0c 	add.w	sl, r2, ip
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f50:	f8cd c010 	str.w	ip, [sp, #16]
 8013f54:	2200      	movs	r2, #0
 8013f56:	e009      	b.n	8013f6c <DrawString.constprop.1+0x178>
					while(k < 13) {
 8013f58:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f5a:	f04f 3cff 	mov.w	ip, #4294967295
					while(k < 13) {
 8013f5e:	3901      	subs	r1, #1
 8013f60:	2a0d      	cmp	r2, #13
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f62:	f823 c01b 	strh.w	ip, [r3, fp, lsl #1]
					while(k < 13) {
 8013f66:	d018      	beq.n	8013f9a <DrawString.constprop.1+0x1a6>
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 8013f68:	7823      	ldrb	r3, [r4, #0]
 8013f6a:	3bc0      	subs	r3, #192	; 0xc0
 8013f6c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8013f70:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8013f74:	f839 3013 	ldrh.w	r3, [r9, r3, lsl #1]
 8013f78:	4113      	asrs	r3, r2
 8013f7a:	f013 0f01 	tst.w	r3, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8013f7e:	7833      	ldrb	r3, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f80:	fb00 5303 	mla	r3, r0, r3, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8013f84:	e9d3 3b17 	ldrd	r3, fp, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8013f88:	fb0b ab01 	mla	fp, fp, r1, sl
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 8013f8c:	d1e4      	bne.n	8013f58 <DrawString.constprop.1+0x164>
					while(k < 13) {
 8013f8e:	3201      	adds	r2, #1
 8013f90:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8013f92:	f823 e01b 	strh.w	lr, [r3, fp, lsl #1]
					while(k < 13) {
 8013f96:	2a0d      	cmp	r2, #13
 8013f98:	d1e6      	bne.n	8013f68 <DrawString.constprop.1+0x174>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 8013f9a:	7823      	ldrb	r3, [r4, #0]
 8013f9c:	f8dd c010 	ldr.w	ip, [sp, #16]
 8013fa0:	469a      	mov	sl, r3
 8013fa2:	3bc0      	subs	r3, #192	; 0xc0
 8013fa4:	e7b9      	b.n	8013f1a <DrawString.constprop.1+0x126>
 8013fa6:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 8013faa:	9b02      	ldr	r3, [sp, #8]
 8013fac:	4463      	add	r3, ip
 8013fae:	9302      	str	r3, [sp, #8]
 8013fb0:	e746      	b.n	8013e40 <DrawString.constprop.1+0x4c>
 8013fb2:	4652      	mov	r2, sl
 8013fb4:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 8013fb8:	9b02      	ldr	r3, [sp, #8]
 8013fba:	4463      	add	r3, ip
 8013fbc:	9302      	str	r3, [sp, #8]
 8013fbe:	e741      	b.n	8013e44 <DrawString.constprop.1+0x50>
		}
		l++;
	}
}
 8013fc0:	b007      	add	sp, #28
 8013fc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						i++;
 8013fc6:	4652      	mov	r2, sl
						break;
 8013fc8:	e7f6      	b.n	8013fb8 <DrawString.constprop.1+0x1c4>
		if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK)
 8013fca:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8014024 <DrawString.constprop.1+0x230>
 8013fce:	4628      	mov	r0, r5
 8013fd0:	f898 1000 	ldrb.w	r1, [r8]
 8013fd4:	f7ed fe80 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 8013fd8:	2800      	cmp	r0, #0
 8013fda:	f47f af20 	bne.w	8013e1e <DrawString.constprop.1+0x2a>
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 8013fde:	f898 1000 	ldrb.w	r1, [r8]
 8013fe2:	2034      	movs	r0, #52	; 0x34
 8013fe4:	f1a6 0314 	sub.w	r3, r6, #20
 8013fe8:	4a0f      	ldr	r2, [pc, #60]	; (8014028 <DrawString.constprop.1+0x234>)
 8013fea:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8013fee:	fb00 2201 	mla	r2, r0, r1, r2
 8013ff2:	21ff      	movs	r1, #255	; 0xff
 8013ff4:	4628      	mov	r0, r5
 8013ff6:	eb07 1343 	add.w	r3, r7, r3, lsl #5
 8013ffa:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8013ffc:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 8014000:	2314      	movs	r3, #20
 8014002:	9300      	str	r3, [sp, #0]
 8014004:	f5c7 73f0 	rsb	r3, r7, #480	; 0x1e0
 8014008:	f7ed fd5a 	bl	8001ac0 <HAL_DMA2D_Start>
 801400c:	2800      	cmp	r0, #0
 801400e:	f47f af06 	bne.w	8013e1e <DrawString.constprop.1+0x2a>
				HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 8014012:	210a      	movs	r1, #10
 8014014:	4628      	mov	r0, r5
 8014016:	f7ed fdc9 	bl	8001bac <HAL_DMA2D_PollForTransfer>
 801401a:	e700      	b.n	8013e1e <DrawString.constprop.1+0x2a>
 801401c:	20000c94 	.word	0x20000c94
 8014020:	4002b000 	.word	0x4002b000
 8014024:	20000e2c 	.word	0x20000e2c
 8014028:	20000d84 	.word	0x20000d84
 801402c:	08025abc 	.word	0x08025abc
 8014030:	08026650 	.word	0x08026650

08014034 <DrawString.constprop.2>:
void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8014034:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	hdma2d.Init.Mode = DMA2D_R2M;
 8014038:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 801403c:	4d86      	ldr	r5, [pc, #536]	; (8014258 <DrawString.constprop.2+0x224>)
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 801403e:	2302      	movs	r3, #2
void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8014040:	b087      	sub	sp, #28
 8014042:	4604      	mov	r4, r0
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8014044:	4628      	mov	r0, r5
void DrawString(char* str, uint16_t Xpos, uint16_t Ypos, uint32_t color, uint32_t fontcolor)
 8014046:	460e      	mov	r6, r1
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014048:	e9c5 2301 	strd	r2, r3, [r5, #4]
	hdma2d.Init.OutputOffset = Xpos;
 801404c:	220b      	movs	r2, #11
	hdma2d.Instance = DMA2D;
 801404e:	4b83      	ldr	r3, [pc, #524]	; (801425c <DrawString.constprop.2+0x228>)
	hdma2d.Init.OutputOffset = Xpos;
 8014050:	60ea      	str	r2, [r5, #12]
	hdma2d.Instance = DMA2D;
 8014052:	602b      	str	r3, [r5, #0]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8014054:	f7ed fcde 	bl	8001a14 <HAL_DMA2D_Init>
 8014058:	2800      	cmp	r0, #0
 801405a:	f000 80d6 	beq.w	801420a <DrawString.constprop.2+0x1d6>
	Ypos -= 4;
 801405e:	3e04      	subs	r6, #4
	while(str[l] != 0) {
 8014060:	7822      	ldrb	r2, [r4, #0]
	Ypos -= 4;
 8014062:	b2b3      	uxth	r3, r6
 8014064:	9303      	str	r3, [sp, #12]
	while(str[l] != 0) {
 8014066:	2a00      	cmp	r2, #0
 8014068:	f000 80ca 	beq.w	8014200 <DrawString.constprop.2+0x1cc>
	int xpos = Xpos + 5;
 801406c:	2310      	movs	r3, #16
 801406e:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 8014268 <DrawString.constprop.2+0x234>
 8014072:	4e7b      	ldr	r6, [pc, #492]	; (8014260 <DrawString.constprop.2+0x22c>)
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8014074:	2034      	movs	r0, #52	; 0x34
 8014076:	4d7b      	ldr	r5, [pc, #492]	; (8014264 <DrawString.constprop.2+0x230>)
 8014078:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 801426c <DrawString.constprop.2+0x238>
	int xpos = Xpos + 5;
 801407c:	9302      	str	r3, [sp, #8]
 801407e:	e00b      	b.n	8014098 <DrawString.constprop.2+0x64>
		if(str[l] > 191) {
 8014080:	2abf      	cmp	r2, #191	; 0xbf
 8014082:	d85f      	bhi.n	8014144 <DrawString.constprop.2+0x110>
		if(str[l] == 32) {
 8014084:	2a20      	cmp	r2, #32
 8014086:	d102      	bne.n	801408e <DrawString.constprop.2+0x5a>
			xpos += 5;
 8014088:	9b02      	ldr	r3, [sp, #8]
 801408a:	3305      	adds	r3, #5
 801408c:	9302      	str	r3, [sp, #8]
	while(str[l] != 0) {
 801408e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8014092:	2a00      	cmp	r2, #0
 8014094:	f000 80b4 	beq.w	8014200 <DrawString.constprop.2+0x1cc>
		if((str[l] > 32) && (str[l] < 128)) {
 8014098:	f1a2 0121 	sub.w	r1, r2, #33	; 0x21
 801409c:	b2cb      	uxtb	r3, r1
 801409e:	2b5e      	cmp	r3, #94	; 0x5e
 80140a0:	d8ee      	bhi.n	8014080 <DrawString.constprop.2+0x4c>
 80140a2:	9b02      	ldr	r3, [sp, #8]
 80140a4:	f04f 0c01 	mov.w	ip, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 80140a8:	f64f 7aff 	movw	sl, #65535	; 0xffff
 80140ac:	3b01      	subs	r3, #1
 80140ae:	9305      	str	r3, [sp, #20]
 80140b0:	e012      	b.n	80140d8 <DrawString.constprop.2+0xa4>
				if(font[(str[l]-33)*12+i] == 0) {
 80140b2:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 80140b6:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 80140ba:	f838 3017 	ldrh.w	r3, [r8, r7, lsl #1]
 80140be:	b92b      	cbnz	r3, 80140cc <DrawString.constprop.2+0x98>
					if(font[(str[l]-33)*12+i+1] == 0) {
 80140c0:	3701      	adds	r7, #1
 80140c2:	f838 3017 	ldrh.w	r3, [r8, r7, lsl #1]
 80140c6:	2b00      	cmp	r3, #0
 80140c8:	f000 808f 	beq.w	80141ea <DrawString.constprop.2+0x1b6>
			while(i < 12);
 80140cc:	f10c 0c01 	add.w	ip, ip, #1
 80140d0:	f1bc 0f0d 	cmp.w	ip, #13
 80140d4:	f000 8087 	beq.w	80141e6 <DrawString.constprop.2+0x1b2>
				if(xpos < 470) {
 80140d8:	9b02      	ldr	r3, [sp, #8]
 80140da:	f10c 37ff 	add.w	r7, ip, #4294967295
 80140de:	f5b3 7feb 	cmp.w	r3, #470	; 0x1d6
 80140e2:	dae6      	bge.n	80140b2 <DrawString.constprop.2+0x7e>
 80140e4:	9b05      	ldr	r3, [sp, #20]
 80140e6:	9a03      	ldr	r2, [sp, #12]
 80140e8:	eb03 0e0c 	add.w	lr, r3, ip
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80140ec:	f8cd c010 	str.w	ip, [sp, #16]
 80140f0:	2300      	movs	r3, #0
 80140f2:	e009      	b.n	8014108 <DrawString.constprop.2+0xd4>
					while(k < 13) {
 80140f4:	3301      	adds	r3, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80140f6:	f04f 0c00 	mov.w	ip, #0
					while(k < 13) {
 80140fa:	3a01      	subs	r2, #1
 80140fc:	2b0d      	cmp	r3, #13
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80140fe:	f821 c01b 	strh.w	ip, [r1, fp, lsl #1]
					while(k < 13) {
 8014102:	d018      	beq.n	8014136 <DrawString.constprop.2+0x102>
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 8014104:	7821      	ldrb	r1, [r4, #0]
 8014106:	3921      	subs	r1, #33	; 0x21
 8014108:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801410c:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8014110:	f838 1011 	ldrh.w	r1, [r8, r1, lsl #1]
 8014114:	4119      	asrs	r1, r3
 8014116:	f011 0f01 	tst.w	r1, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801411a:	7831      	ldrb	r1, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801411c:	fb00 5101 	mla	r1, r0, r1, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8014120:	e9d1 1b17 	ldrd	r1, fp, [r1, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8014124:	fb0b eb02 	mla	fp, fp, r2, lr
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 8014128:	d1e4      	bne.n	80140f4 <DrawString.constprop.2+0xc0>
					while(k < 13) {
 801412a:	3301      	adds	r3, #1
 801412c:	3a01      	subs	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 801412e:	f821 a01b 	strh.w	sl, [r1, fp, lsl #1]
					while(k < 13) {
 8014132:	2b0d      	cmp	r3, #13
 8014134:	d1e6      	bne.n	8014104 <DrawString.constprop.2+0xd0>
				if(font[(str[l]-33)*12+i] == 0) {
 8014136:	7823      	ldrb	r3, [r4, #0]
 8014138:	f8dd c010 	ldr.w	ip, [sp, #16]
 801413c:	461a      	mov	r2, r3
 801413e:	f1a3 0121 	sub.w	r1, r3, #33	; 0x21
 8014142:	e7b6      	b.n	80140b2 <DrawString.constprop.2+0x7e>
 8014144:	9902      	ldr	r1, [sp, #8]
 8014146:	f04f 0c01 	mov.w	ip, #1
 801414a:	f1a2 03c0 	sub.w	r3, r2, #192	; 0xc0
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 801414e:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8014152:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8014154:	4692      	mov	sl, r2
 8014156:	9105      	str	r1, [sp, #20]
 8014158:	e010      	b.n	801417c <DrawString.constprop.2+0x148>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 801415a:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801415e:	eb07 0781 	add.w	r7, r7, r1, lsl #2
 8014162:	f839 1017 	ldrh.w	r1, [r9, r7, lsl #1]
 8014166:	b921      	cbnz	r1, 8014172 <DrawString.constprop.2+0x13e>
					if(ru_font[(str[l]-192)*12+i+1] == 0) {
 8014168:	3701      	adds	r7, #1
 801416a:	f839 1017 	ldrh.w	r1, [r9, r7, lsl #1]
 801416e:	2900      	cmp	r1, #0
 8014170:	d049      	beq.n	8014206 <DrawString.constprop.2+0x1d2>
			while(i < 12);
 8014172:	f10c 0c01 	add.w	ip, ip, #1
 8014176:	f1bc 0f0d 	cmp.w	ip, #13
 801417a:	d03a      	beq.n	80141f2 <DrawString.constprop.2+0x1be>
				if(xpos < 470) {
 801417c:	9a02      	ldr	r2, [sp, #8]
 801417e:	f10c 37ff 	add.w	r7, ip, #4294967295
 8014182:	f5b2 7feb 	cmp.w	r2, #470	; 0x1d6
 8014186:	dae8      	bge.n	801415a <DrawString.constprop.2+0x126>
 8014188:	9a05      	ldr	r2, [sp, #20]
 801418a:	9903      	ldr	r1, [sp, #12]
 801418c:	eb02 0a0c 	add.w	sl, r2, ip
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8014190:	f8cd c010 	str.w	ip, [sp, #16]
 8014194:	2200      	movs	r2, #0
 8014196:	e009      	b.n	80141ac <DrawString.constprop.2+0x178>
					while(k < 13) {
 8014198:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801419a:	f04f 0c00 	mov.w	ip, #0
					while(k < 13) {
 801419e:	3901      	subs	r1, #1
 80141a0:	2a0d      	cmp	r2, #13
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80141a2:	f823 c01b 	strh.w	ip, [r3, fp, lsl #1]
					while(k < 13) {
 80141a6:	d018      	beq.n	80141da <DrawString.constprop.2+0x1a6>
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 80141a8:	7823      	ldrb	r3, [r4, #0]
 80141aa:	3bc0      	subs	r3, #192	; 0xc0
 80141ac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80141b0:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80141b4:	f839 3013 	ldrh.w	r3, [r9, r3, lsl #1]
 80141b8:	4113      	asrs	r3, r2
 80141ba:	f013 0f01 	tst.w	r3, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 80141be:	7833      	ldrb	r3, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80141c0:	fb00 5303 	mla	r3, r0, r3, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 80141c4:	e9d3 3b17 	ldrd	r3, fp, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80141c8:	fb0b ab01 	mla	fp, fp, r1, sl
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 80141cc:	d1e4      	bne.n	8014198 <DrawString.constprop.2+0x164>
					while(k < 13) {
 80141ce:	3201      	adds	r2, #1
 80141d0:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 80141d2:	f823 e01b 	strh.w	lr, [r3, fp, lsl #1]
					while(k < 13) {
 80141d6:	2a0d      	cmp	r2, #13
 80141d8:	d1e6      	bne.n	80141a8 <DrawString.constprop.2+0x174>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 80141da:	7823      	ldrb	r3, [r4, #0]
 80141dc:	f8dd c010 	ldr.w	ip, [sp, #16]
 80141e0:	469a      	mov	sl, r3
 80141e2:	3bc0      	subs	r3, #192	; 0xc0
 80141e4:	e7b9      	b.n	801415a <DrawString.constprop.2+0x126>
 80141e6:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 80141ea:	9b02      	ldr	r3, [sp, #8]
 80141ec:	4463      	add	r3, ip
 80141ee:	9302      	str	r3, [sp, #8]
 80141f0:	e746      	b.n	8014080 <DrawString.constprop.2+0x4c>
 80141f2:	4652      	mov	r2, sl
 80141f4:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 80141f8:	9b02      	ldr	r3, [sp, #8]
 80141fa:	4463      	add	r3, ip
 80141fc:	9302      	str	r3, [sp, #8]
 80141fe:	e741      	b.n	8014084 <DrawString.constprop.2+0x50>
}
 8014200:	b007      	add	sp, #28
 8014202:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						i++;
 8014206:	4652      	mov	r2, sl
						break;
 8014208:	e7f6      	b.n	80141f8 <DrawString.constprop.2+0x1c4>
		if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK)
 801420a:	4f15      	ldr	r7, [pc, #84]	; (8014260 <DrawString.constprop.2+0x22c>)
 801420c:	4628      	mov	r0, r5
 801420e:	7839      	ldrb	r1, [r7, #0]
 8014210:	f7ed fd62 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 8014214:	2800      	cmp	r0, #0
 8014216:	f47f af22 	bne.w	801405e <DrawString.constprop.2+0x2a>
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 801421a:	f1a6 0314 	sub.w	r3, r6, #20
 801421e:	7839      	ldrb	r1, [r7, #0]
 8014220:	2034      	movs	r0, #52	; 0x34
 8014222:	4a10      	ldr	r2, [pc, #64]	; (8014264 <DrawString.constprop.2+0x230>)
 8014224:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8014228:	fb00 2201 	mla	r2, r0, r1, r2
 801422c:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8014230:	019b      	lsls	r3, r3, #6
 8014232:	4628      	mov	r0, r5
 8014234:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8014236:	3316      	adds	r3, #22
 8014238:	441a      	add	r2, r3
 801423a:	2314      	movs	r3, #20
 801423c:	9300      	str	r3, [sp, #0]
 801423e:	f240 13d5 	movw	r3, #469	; 0x1d5
 8014242:	f7ed fc3d 	bl	8001ac0 <HAL_DMA2D_Start>
 8014246:	2800      	cmp	r0, #0
 8014248:	f47f af09 	bne.w	801405e <DrawString.constprop.2+0x2a>
				HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 801424c:	210a      	movs	r1, #10
 801424e:	4628      	mov	r0, r5
 8014250:	f7ed fcac 	bl	8001bac <HAL_DMA2D_PollForTransfer>
 8014254:	e703      	b.n	801405e <DrawString.constprop.2+0x2a>
 8014256:	bf00      	nop
 8014258:	20000c94 	.word	0x20000c94
 801425c:	4002b000 	.word	0x4002b000
 8014260:	20000e2c 	.word	0x20000e2c
 8014264:	20000d84 	.word	0x20000d84
 8014268:	08025abc 	.word	0x08025abc
 801426c:	08026650 	.word	0x08026650

08014270 <VLine.constprop.0>:
void VLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length, uint32_t color)
 8014270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014274:	f8df 8080 	ldr.w	r8, [pc, #128]	; 80142f8 <VLine.constprop.0+0x88>
void VLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length, uint32_t color)
 8014278:	4616      	mov	r6, r2
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 801427a:	4b1c      	ldr	r3, [pc, #112]	; (80142ec <VLine.constprop.0+0x7c>)
 801427c:	2234      	movs	r2, #52	; 0x34
 801427e:	f898 4000 	ldrb.w	r4, [r8]
void VLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length, uint32_t color)
 8014282:	b082      	sub	sp, #8
 8014284:	4605      	mov	r5, r0
 8014286:	460f      	mov	r7, r1
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014288:	fb02 3304 	mla	r3, r2, r4, r3
    hdma2d.Init.Mode = DMA2D_R2M;
 801428c:	4c18      	ldr	r4, [pc, #96]	; (80142f0 <VLine.constprop.0+0x80>)
 801428e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014292:	4620      	mov	r0, r4
    hdma2d.Init.Mode = DMA2D_R2M;
 8014294:	6062      	str	r2, [r4, #4]
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014296:	e9d3 a917 	ldrd	sl, r9, [r3, #92]	; 0x5c
    hdma2d.Init.ColorMode = DMA2D_RGB565;
 801429a:	2302      	movs	r3, #2
 801429c:	60a3      	str	r3, [r4, #8]
    hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - 1;
 801429e:	f109 33ff 	add.w	r3, r9, #4294967295
 80142a2:	60e3      	str	r3, [r4, #12]
    hdma2d.Instance = DMA2D;
 80142a4:	4b13      	ldr	r3, [pc, #76]	; (80142f4 <VLine.constprop.0+0x84>)
 80142a6:	6023      	str	r3, [r4, #0]
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80142a8:	f7ed fbb4 	bl	8001a14 <HAL_DMA2D_Init>
 80142ac:	b110      	cbz	r0, 80142b4 <VLine.constprop.0+0x44>
}
 80142ae:	b002      	add	sp, #8
 80142b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    	if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK) {
 80142b4:	f898 1000 	ldrb.w	r1, [r8]
 80142b8:	4620      	mov	r0, r4
 80142ba:	f7ed fd0d 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 80142be:	2800      	cmp	r0, #0
 80142c0:	d1f5      	bne.n	80142ae <VLine.constprop.0+0x3e>
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 80142c2:	2304      	movs	r3, #4
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 80142c4:	fb09 5207 	mla	r2, r9, r7, r5
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 80142c8:	4631      	mov	r1, r6
 80142ca:	4620      	mov	r0, r4
 80142cc:	9300      	str	r3, [sp, #0]
 80142ce:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
 80142d2:	2301      	movs	r3, #1
 80142d4:	f7ed fbf4 	bl	8001ac0 <HAL_DMA2D_Start>
 80142d8:	2800      	cmp	r0, #0
 80142da:	d1e8      	bne.n	80142ae <VLine.constprop.0+0x3e>
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80142dc:	210a      	movs	r1, #10
 80142de:	4620      	mov	r0, r4
}
 80142e0:	b002      	add	sp, #8
 80142e2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80142e6:	f7ed bc61 	b.w	8001bac <HAL_DMA2D_PollForTransfer>
 80142ea:	bf00      	nop
 80142ec:	20000d84 	.word	0x20000d84
 80142f0:	20000c94 	.word	0x20000c94
 80142f4:	4002b000 	.word	0x4002b000
 80142f8:	20000e2c 	.word	0x20000e2c

080142fc <ClearLayer>:
{
 80142fc:	b510      	push	{r4, lr}
	hdma2d.Init.OutputOffset = 0;
 80142fe:	4c11      	ldr	r4, [pc, #68]	; (8014344 <ClearLayer+0x48>)
 8014300:	2300      	movs	r3, #0
{
 8014302:	b082      	sub	sp, #8
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014304:	4620      	mov	r0, r4
	hdma2d.Init.OutputOffset = 0;
 8014306:	60e3      	str	r3, [r4, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014308:	f7ed fb84 	bl	8001a14 <HAL_DMA2D_Init>
 801430c:	b108      	cbz	r0, 8014312 <ClearLayer+0x16>
}
 801430e:	b002      	add	sp, #8
 8014310:	bd10      	pop	{r4, pc}
		if(HAL_DMA2D_Start(&hdma2d, 0, hltdc.LayerCfg[ActiveLayer].FBStartAdress,
 8014312:	4b0d      	ldr	r3, [pc, #52]	; (8014348 <ClearLayer+0x4c>)
 8014314:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8014318:	4a0c      	ldr	r2, [pc, #48]	; (801434c <ClearLayer+0x50>)
 801431a:	4601      	mov	r1, r0
 801431c:	781b      	ldrb	r3, [r3, #0]
 801431e:	fb0c 2203 	mla	r2, ip, r3, r2
 8014322:	e9d2 3018 	ldrd	r3, r0, [r2, #96]	; 0x60
 8014326:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8014328:	9000      	str	r0, [sp, #0]
 801432a:	4620      	mov	r0, r4
 801432c:	f7ed fbc8 	bl	8001ac0 <HAL_DMA2D_Start>
 8014330:	2800      	cmp	r0, #0
 8014332:	d1ec      	bne.n	801430e <ClearLayer+0x12>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8014334:	2164      	movs	r1, #100	; 0x64
 8014336:	4620      	mov	r0, r4
}
 8014338:	b002      	add	sp, #8
 801433a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 801433e:	f7ed bc35 	b.w	8001bac <HAL_DMA2D_PollForTransfer>
 8014342:	bf00      	nop
 8014344:	20000c94 	.word	0x20000c94
 8014348:	20000e2c 	.word	0x20000e2c
 801434c:	20000d84 	.word	0x20000d84

08014350 <ChangeLayers>:
{
 8014350:	b538      	push	{r3, r4, r5, lr}
	if(ActiveLayer == 0) {
 8014352:	4c0d      	ldr	r4, [pc, #52]	; (8014388 <ChangeLayers+0x38>)
 8014354:	7825      	ldrb	r5, [r4, #0]
 8014356:	b98d      	cbnz	r5, 801437c <ChangeLayers+0x2c>
		HAL_LTDC_SetAlpha_NoReload(&hltdc, 255, ActiveLayer++);
 8014358:	2301      	movs	r3, #1
 801435a:	462a      	mov	r2, r5
 801435c:	21ff      	movs	r1, #255	; 0xff
 801435e:	480b      	ldr	r0, [pc, #44]	; (801438c <ChangeLayers+0x3c>)
 8014360:	7023      	strb	r3, [r4, #0]
		HAL_LTDC_SetAlpha_NoReload(&hltdc, 255, ActiveLayer--);
 8014362:	f7ef fe45 	bl	8003ff0 <HAL_LTDC_SetAlpha_NoReload>
		HAL_LTDC_SetAlpha_NoReload(&hltdc, 0, ActiveLayer);
 8014366:	7822      	ldrb	r2, [r4, #0]
 8014368:	2100      	movs	r1, #0
 801436a:	4808      	ldr	r0, [pc, #32]	; (801438c <ChangeLayers+0x3c>)
 801436c:	f7ef fe40 	bl	8003ff0 <HAL_LTDC_SetAlpha_NoReload>
	HAL_LTDC_Reload(&hltdc, LTDC_RELOAD_VERTICAL_BLANKING);
 8014370:	2102      	movs	r1, #2
 8014372:	4806      	ldr	r0, [pc, #24]	; (801438c <ChangeLayers+0x3c>)
}
 8014374:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	HAL_LTDC_Reload(&hltdc, LTDC_RELOAD_VERTICAL_BLANKING);
 8014378:	f7ef be14 	b.w	8003fa4 <HAL_LTDC_Reload>
		HAL_LTDC_SetAlpha_NoReload(&hltdc, 255, ActiveLayer--);
 801437c:	1e6b      	subs	r3, r5, #1
 801437e:	462a      	mov	r2, r5
 8014380:	21ff      	movs	r1, #255	; 0xff
 8014382:	4802      	ldr	r0, [pc, #8]	; (801438c <ChangeLayers+0x3c>)
 8014384:	7023      	strb	r3, [r4, #0]
 8014386:	e7ec      	b.n	8014362 <ChangeLayers+0x12>
 8014388:	20000e2c 	.word	0x20000e2c
 801438c:	20000d84 	.word	0x20000d84

08014390 <SetBeatGrid>:
	if(position != file_pos_wide) {
 8014390:	4a4b      	ldr	r2, [pc, #300]	; (80144c0 <SetBeatGrid+0x130>)
 8014392:	4b4c      	ldr	r3, [pc, #304]	; (80144c4 <SetBeatGrid+0x134>)
 8014394:	6811      	ldr	r1, [r2, #0]
 8014396:	681b      	ldr	r3, [r3, #0]
 8014398:	4299      	cmp	r1, r3
{
 801439a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(position != file_pos_wide) {
 801439e:	f000 8087 	beq.w	80144b0 <SetBeatGrid+0x120>
		if(stretch > 1) {
 80143a2:	4949      	ldr	r1, [pc, #292]	; (80144c8 <SetBeatGrid+0x138>)
 80143a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
		position = file_pos_wide;
 80143a8:	6013      	str	r3, [r2, #0]
		if(stretch > 1) {
 80143aa:	ed91 7a00 	vldr	s14, [r1]
 80143ae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80143b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80143b6:	dd1f      	ble.n	80143f8 <SetBeatGrid+0x68>
			while((position % (int32_t)(stretch)) != (check % (int32_t)(stretch))) {
 80143b8:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80143bc:	6811      	ldr	r1, [r2, #0]
 80143be:	4e43      	ldr	r6, [pc, #268]	; (80144cc <SetBeatGrid+0x13c>)
 80143c0:	ee17 0a90 	vmov	r0, s15
 80143c4:	6833      	ldr	r3, [r6, #0]
 80143c6:	fb91 f4f0 	sdiv	r4, r1, r0
 80143ca:	fb00 1114 	mls	r1, r0, r4, r1
 80143ce:	fb93 f4f0 	sdiv	r4, r3, r0
 80143d2:	fb00 3314 	mls	r3, r0, r4, r3
 80143d6:	4299      	cmp	r1, r3
 80143d8:	d00e      	beq.n	80143f8 <SetBeatGrid+0x68>
				position++;
 80143da:	6813      	ldr	r3, [r2, #0]
 80143dc:	3301      	adds	r3, #1
 80143de:	6013      	str	r3, [r2, #0]
			while((position % (int32_t)(stretch)) != (check % (int32_t)(stretch))) {
 80143e0:	6811      	ldr	r1, [r2, #0]
 80143e2:	6833      	ldr	r3, [r6, #0]
 80143e4:	fb91 f5f0 	sdiv	r5, r1, r0
 80143e8:	fb93 f4f0 	sdiv	r4, r3, r0
 80143ec:	fb00 1115 	mls	r1, r0, r5, r1
 80143f0:	fb00 3314 	mls	r3, r0, r4, r3
 80143f4:	4299      	cmp	r1, r3
 80143f6:	d1f0      	bne.n	80143da <SetBeatGrid+0x4a>
	int32_t check = position + (-240)*stretch;
 80143f8:	edd2 7a00 	vldr	s15, [r2]
	beat = 0;
 80143fc:	2100      	movs	r1, #0
	int32_t check = position + (-240)*stretch;
 80143fe:	eddf 6a34 	vldr	s13, [pc, #208]	; 80144d0 <SetBeatGrid+0x140>
 8014402:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	beat = 0;
 8014406:	4d33      	ldr	r5, [pc, #204]	; (80144d4 <SetBeatGrid+0x144>)
	first_beat = 0;
 8014408:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 80144e4 <SetBeatGrid+0x154>
	beat = 0;
 801440c:	6029      	str	r1, [r5, #0]
	int32_t check = position + (-240)*stretch;
 801440e:	eee7 7a26 	vfma.f32	s15, s14, s13
	first_beat = 0;
 8014412:	f8ce 1000 	str.w	r1, [lr]
	int32_t check = position + (-240)*stretch;
 8014416:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801441a:	ee17 0a90 	vmov	r0, s15
	if(check > 0) {
 801441e:	4288      	cmp	r0, r1
 8014420:	dd1e      	ble.n	8014460 <SetBeatGrid+0xd0>
		while(((int32_t)(rekordbox.timeindex[first_beat]*150/1000 <= check)) && (first_beat <= rekordbox.timezones)) {
 8014422:	4c2d      	ldr	r4, [pc, #180]	; (80144d8 <SetBeatGrid+0x148>)
 8014424:	2696      	movs	r6, #150	; 0x96
 8014426:	4f2d      	ldr	r7, [pc, #180]	; (80144dc <SetBeatGrid+0x14c>)
 8014428:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 801442c:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8014430:	fb06 f303 	mul.w	r3, r6, r3
 8014434:	fba7 c303 	umull	ip, r3, r7, r3
 8014438:	ebb0 1f93 	cmp.w	r0, r3, lsr #6
 801443c:	d310      	bcc.n	8014460 <SetBeatGrid+0xd0>
 801443e:	f8d4 c500 	ldr.w	ip, [r4, #1280]	; 0x500
 8014442:	4c27      	ldr	r4, [pc, #156]	; (80144e0 <SetBeatGrid+0x150>)
 8014444:	f854 3f04 	ldr.w	r3, [r4, #4]!
			first_beat++;
 8014448:	3101      	adds	r1, #1
		while(((int32_t)(rekordbox.timeindex[first_beat]*150/1000 <= check)) && (first_beat <= rekordbox.timezones)) {
 801444a:	fb06 f303 	mul.w	r3, r6, r3
 801444e:	fba7 8303 	umull	r8, r3, r7, r3
 8014452:	ebb0 1f93 	cmp.w	r0, r3, lsr #6
 8014456:	d301      	bcc.n	801445c <SetBeatGrid+0xcc>
 8014458:	4561      	cmp	r1, ip
 801445a:	d9f3      	bls.n	8014444 <SetBeatGrid+0xb4>
 801445c:	f8ce 1000 	str.w	r1, [lr]
	if(position > 0) {
 8014460:	6813      	ldr	r3, [r2, #0]
 8014462:	2b00      	cmp	r3, #0
 8014464:	dd22      	ble.n	80144ac <SetBeatGrid+0x11c>
		while((rekordbox.timeindex[beat]*150/1000 <= position) && (beat <= rekordbox.timezones)) {
 8014466:	491c      	ldr	r1, [pc, #112]	; (80144d8 <SetBeatGrid+0x148>)
 8014468:	f04f 0c96 	mov.w	ip, #150	; 0x96
 801446c:	4e1b      	ldr	r6, [pc, #108]	; (80144dc <SetBeatGrid+0x14c>)
 801446e:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8014472:	6810      	ldr	r0, [r2, #0]
 8014474:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8014478:	fb0c f303 	mul.w	r3, ip, r3
 801447c:	fba6 4303 	umull	r4, r3, r6, r3
 8014480:	ebb0 1f93 	cmp.w	r0, r3, lsr #6
 8014484:	d318      	bcc.n	80144b8 <SetBeatGrid+0x128>
 8014486:	f8d1 e500 	ldr.w	lr, [r1, #1280]	; 0x500
 801448a:	2100      	movs	r1, #0
 801448c:	4814      	ldr	r0, [pc, #80]	; (80144e0 <SetBeatGrid+0x150>)
 801448e:	f850 3f04 	ldr.w	r3, [r0, #4]!
 8014492:	460f      	mov	r7, r1
 8014494:	6814      	ldr	r4, [r2, #0]
			beat++;
 8014496:	3101      	adds	r1, #1
		while((rekordbox.timeindex[beat]*150/1000 <= position) && (beat <= rekordbox.timezones)) {
 8014498:	fb0c f303 	mul.w	r3, ip, r3
 801449c:	fba6 8303 	umull	r8, r3, r6, r3
 80144a0:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
 80144a4:	d301      	bcc.n	80144aa <SetBeatGrid+0x11a>
 80144a6:	458e      	cmp	lr, r1
 80144a8:	d2f1      	bcs.n	801448e <SetBeatGrid+0xfe>
		beat--;
 80144aa:	602f      	str	r7, [r5, #0]
}
 80144ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if(stretch > 1) {
 80144b0:	4b05      	ldr	r3, [pc, #20]	; (80144c8 <SetBeatGrid+0x138>)
 80144b2:	ed93 7a00 	vldr	s14, [r3]
 80144b6:	e79f      	b.n	80143f8 <SetBeatGrid+0x68>
		while((rekordbox.timeindex[beat]*150/1000 <= position) && (beat <= rekordbox.timezones)) {
 80144b8:	f04f 37ff 	mov.w	r7, #4294967295
 80144bc:	e7f5      	b.n	80144aa <SetBeatGrid+0x11a>
 80144be:	bf00      	nop
 80144c0:	20000c90 	.word	0x20000c90
 80144c4:	2000ec8c 	.word	0x2000ec8c
 80144c8:	20000028 	.word	0x20000028
 80144cc:	20000c68 	.word	0x20000c68
 80144d0:	c3700000 	.word	0xc3700000
 80144d4:	20000c64 	.word	0x20000c64
 80144d8:	200154f0 	.word	0x200154f0
 80144dc:	10624dd3 	.word	0x10624dd3
 80144e0:	20016cb4 	.word	0x20016cb4
 80144e4:	20000c84 	.word	0x20000c84

080144e8 <VLine>:
{
 80144e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 80144ec:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8014570 <VLine+0x88>
{
 80144f0:	461f      	mov	r7, r3
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 80144f2:	4c1c      	ldr	r4, [pc, #112]	; (8014564 <VLine+0x7c>)
 80144f4:	2334      	movs	r3, #52	; 0x34
 80144f6:	f899 c000 	ldrb.w	ip, [r9]
{
 80144fa:	b083      	sub	sp, #12
 80144fc:	4605      	mov	r5, r0
 80144fe:	4688      	mov	r8, r1
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014500:	fb03 4c0c 	mla	ip, r3, ip, r4
    hdma2d.Init.Mode = DMA2D_R2M;
 8014504:	4c18      	ldr	r4, [pc, #96]	; (8014568 <VLine+0x80>)
 8014506:	f44f 3340 	mov.w	r3, #196608	; 0x30000
{
 801450a:	4616      	mov	r6, r2
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 801450c:	4620      	mov	r0, r4
    hdma2d.Init.Mode = DMA2D_R2M;
 801450e:	6063      	str	r3, [r4, #4]
    hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014510:	2302      	movs	r3, #2
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014512:	e9dc ba17 	ldrd	fp, sl, [ip, #92]	; 0x5c
    hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014516:	60a3      	str	r3, [r4, #8]
    hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - 1;
 8014518:	f10a 33ff 	add.w	r3, sl, #4294967295
 801451c:	60e3      	str	r3, [r4, #12]
    hdma2d.Instance = DMA2D;
 801451e:	4b13      	ldr	r3, [pc, #76]	; (801456c <VLine+0x84>)
 8014520:	6023      	str	r3, [r4, #0]
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014522:	f7ed fa77 	bl	8001a14 <HAL_DMA2D_Init>
 8014526:	b110      	cbz	r0, 801452e <VLine+0x46>
}
 8014528:	b003      	add	sp, #12
 801452a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    	if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK) {
 801452e:	f899 1000 	ldrb.w	r1, [r9]
 8014532:	4620      	mov	r0, r4
 8014534:	f7ed fbd0 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 8014538:	2800      	cmp	r0, #0
 801453a:	d1f5      	bne.n	8014528 <VLine+0x40>
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 801453c:	fb0a 5208 	mla	r2, sl, r8, r5
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 8014540:	4639      	mov	r1, r7
 8014542:	2301      	movs	r3, #1
 8014544:	4620      	mov	r0, r4
 8014546:	eb0b 0242 	add.w	r2, fp, r2, lsl #1
 801454a:	9600      	str	r6, [sp, #0]
 801454c:	f7ed fab8 	bl	8001ac0 <HAL_DMA2D_Start>
 8014550:	2800      	cmp	r0, #0
 8014552:	d1e9      	bne.n	8014528 <VLine+0x40>
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 8014554:	210a      	movs	r1, #10
 8014556:	4620      	mov	r0, r4
}
 8014558:	b003      	add	sp, #12
 801455a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 801455e:	f7ed bb25 	b.w	8001bac <HAL_DMA2D_PollForTransfer>
 8014562:	bf00      	nop
 8014564:	20000d84 	.word	0x20000d84
 8014568:	20000c94 	.word	0x20000c94
 801456c:	4002b000 	.word	0x4002b000
 8014570:	20000e2c 	.word	0x20000e2c

08014574 <HLine>:
{
 8014574:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014578:	f8df 9080 	ldr.w	r9, [pc, #128]	; 80145fc <HLine+0x88>
{
 801457c:	461e      	mov	r6, r3
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 801457e:	4c1c      	ldr	r4, [pc, #112]	; (80145f0 <HLine+0x7c>)
 8014580:	2334      	movs	r3, #52	; 0x34
 8014582:	f899 c000 	ldrb.w	ip, [r9]
{
 8014586:	4617      	mov	r7, r2
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014588:	f44f 3240 	mov.w	r2, #196608	; 0x30000
{
 801458c:	b083      	sub	sp, #12
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 801458e:	fb03 4c0c 	mla	ip, r3, ip, r4
	hdma2d.Init.Mode = DMA2D_R2M;
 8014592:	4c18      	ldr	r4, [pc, #96]	; (80145f4 <HLine+0x80>)
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014594:	2302      	movs	r3, #2
{
 8014596:	4605      	mov	r5, r0
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014598:	4620      	mov	r0, r4
{
 801459a:	4688      	mov	r8, r1
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 801459c:	e9c4 2301 	strd	r2, r3, [r4, #4]
	hdma2d.Init.OutputOffset = 0;
 80145a0:	2300      	movs	r3, #0
 80145a2:	60e3      	str	r3, [r4, #12]
	hdma2d.Instance = DMA2D;
 80145a4:	4b14      	ldr	r3, [pc, #80]	; (80145f8 <HLine+0x84>)
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 80145a6:	e9dc ab17 	ldrd	sl, fp, [ip, #92]	; 0x5c
	hdma2d.Instance = DMA2D;
 80145aa:	6023      	str	r3, [r4, #0]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80145ac:	f7ed fa32 	bl	8001a14 <HAL_DMA2D_Init>
 80145b0:	b110      	cbz	r0, 80145b8 <HLine+0x44>
}
 80145b2:	b003      	add	sp, #12
 80145b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	 	if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK) {
 80145b8:	f899 1000 	ldrb.w	r1, [r9]
 80145bc:	4620      	mov	r0, r4
 80145be:	f7ed fb8b 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 80145c2:	2800      	cmp	r0, #0
 80145c4:	d1f5      	bne.n	80145b2 <HLine+0x3e>
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 80145c6:	fb0b 5208 	mla	r2, fp, r8, r5
	   		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, Length, 1) == HAL_OK) {
 80145ca:	2501      	movs	r5, #1
 80145cc:	463b      	mov	r3, r7
 80145ce:	4631      	mov	r1, r6
 80145d0:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
 80145d4:	4620      	mov	r0, r4
 80145d6:	9500      	str	r5, [sp, #0]
 80145d8:	f7ed fa72 	bl	8001ac0 <HAL_DMA2D_Start>
 80145dc:	2800      	cmp	r0, #0
 80145de:	d1e8      	bne.n	80145b2 <HLine+0x3e>
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80145e0:	210a      	movs	r1, #10
 80145e2:	4620      	mov	r0, r4
}
 80145e4:	b003      	add	sp, #12
 80145e6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80145ea:	f7ed badf 	b.w	8001bac <HAL_DMA2D_PollForTransfer>
 80145ee:	bf00      	nop
 80145f0:	20000d84 	.word	0x20000d84
 80145f4:	20000c94 	.word	0x20000c94
 80145f8:	4002b000 	.word	0x4002b000
 80145fc:	20000e2c 	.word	0x20000e2c

08014600 <DrawDigit>:
{
 8014600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014604:	ed2d 8b02 	vpush	{d8}
 8014608:	b085      	sub	sp, #20
 801460a:	461e      	mov	r6, r3
 801460c:	460d      	mov	r5, r1
 801460e:	4614      	mov	r4, r2
 8014610:	9b10      	ldr	r3, [sp, #64]	; 0x40
	switch(digit) {
 8014612:	2809      	cmp	r0, #9
 8014614:	f200 83c7 	bhi.w	8014da6 <DrawDigit+0x7a6>
 8014618:	e8df f010 	tbh	[pc, r0, lsl #1]
 801461c:	00fb0083 	.word	0x00fb0083
 8014620:	01900126 	.word	0x01900126
 8014624:	023f01ef 	.word	0x023f01ef
 8014628:	030a029a 	.word	0x030a029a
 801462c:	000a0342 	.word	0x000a0342
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014630:	f101 0801 	add.w	r8, r1, #1
 8014634:	1eb7      	subs	r7, r6, #2
 8014636:	b2b6      	uxth	r6, r6
 8014638:	4621      	mov	r1, r4
 801463a:	b2bf      	uxth	r7, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801463c:	f105 0a02 	add.w	sl, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014640:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014644:	f104 0901 	add.w	r9, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014648:	463a      	mov	r2, r7
 801464a:	9302      	str	r3, [sp, #8]
 801464c:	4640      	mov	r0, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801464e:	fa1f fa8a 	uxth.w	sl, sl
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014652:	f7ff ff8f 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014656:	9601      	str	r6, [sp, #4]
 8014658:	3e04      	subs	r6, #4
 801465a:	fa1f f989 	uxth.w	r9, r9
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 801465e:	f104 0b02 	add.w	fp, r4, #2
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014662:	9b02      	ldr	r3, [sp, #8]
 8014664:	b2b6      	uxth	r6, r6
 8014666:	4649      	mov	r1, r9
 8014668:	4650      	mov	r0, sl
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 801466a:	fa1f fb8b 	uxth.w	fp, fp
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801466e:	4632      	mov	r2, r6
 8014670:	f7ff ff80 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014674:	4628      	mov	r0, r5
 8014676:	9b02      	ldr	r3, [sp, #8]
 8014678:	463a      	mov	r2, r7
 801467a:	4649      	mov	r1, r9
 801467c:	f7ff ff34 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014680:	4640      	mov	r0, r8
 8014682:	9b02      	ldr	r3, [sp, #8]
 8014684:	4632      	mov	r2, r6
 8014686:	4659      	mov	r1, fp
 8014688:	f7ff ff2e 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 801468c:	9b01      	ldr	r3, [sp, #4]
 801468e:	4640      	mov	r0, r8
 8014690:	463a      	mov	r2, r7
 8014692:	eb04 0443 	add.w	r4, r4, r3, lsl #1
 8014696:	9b02      	ldr	r3, [sp, #8]
 8014698:	b2a4      	uxth	r4, r4
 801469a:	1ea1      	subs	r1, r4, #2
 801469c:	b289      	uxth	r1, r1
 801469e:	f7ff ff69 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 80146a2:	1ee1      	subs	r1, r4, #3
 80146a4:	9b02      	ldr	r3, [sp, #8]
 80146a6:	4632      	mov	r2, r6
 80146a8:	b289      	uxth	r1, r1
 80146aa:	4650      	mov	r0, sl
 80146ac:	f7ff ff62 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 80146b0:	9b01      	ldr	r3, [sp, #4]
 80146b2:	4640      	mov	r0, r8
 80146b4:	463a      	mov	r2, r7
 80146b6:	1ae4      	subs	r4, r4, r3
 80146b8:	9b02      	ldr	r3, [sp, #8]
 80146ba:	b2a4      	uxth	r4, r4
 80146bc:	1e61      	subs	r1, r4, #1
 80146be:	b289      	uxth	r1, r1
 80146c0:	f7ff ff58 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 80146c4:	1ea1      	subs	r1, r4, #2
 80146c6:	4650      	mov	r0, sl
 80146c8:	9b02      	ldr	r3, [sp, #8]
 80146ca:	b289      	uxth	r1, r1
 80146cc:	4632      	mov	r2, r6
 80146ce:	f7ff ff51 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80146d2:	9b01      	ldr	r3, [sp, #4]
 80146d4:	4621      	mov	r1, r4
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80146d6:	3401      	adds	r4, #1
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80146d8:	441d      	add	r5, r3
 80146da:	9b02      	ldr	r3, [sp, #8]
 80146dc:	463a      	mov	r2, r7
 80146de:	b2ad      	uxth	r5, r5
 80146e0:	9301      	str	r3, [sp, #4]
 80146e2:	f105 38ff 	add.w	r8, r5, #4294967295
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80146e6:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80146e8:	fa1f f888 	uxth.w	r8, r8
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80146ec:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80146ee:	4640      	mov	r0, r8
 80146f0:	f7ff fefa 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80146f4:	9b01      	ldr	r3, [sp, #4]
 80146f6:	b2a1      	uxth	r1, r4
 80146f8:	4632      	mov	r2, r6
 80146fa:	4628      	mov	r0, r5
 80146fc:	f7ff fef4 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014700:	9b01      	ldr	r3, [sp, #4]
 8014702:	463a      	mov	r2, r7
 8014704:	4649      	mov	r1, r9
 8014706:	4640      	mov	r0, r8
 8014708:	f7ff feee 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 801470c:	9b01      	ldr	r3, [sp, #4]
 801470e:	4632      	mov	r2, r6
 8014710:	4659      	mov	r1, fp
 8014712:	4628      	mov	r0, r5
}
 8014714:	b005      	add	sp, #20
 8014716:	ecbd 8b02 	vpop	{d8}
 801471a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 801471e:	f7ff bee3 	b.w	80144e8 <VLine>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014722:	f101 0801 	add.w	r8, r1, #1
 8014726:	1eb7      	subs	r7, r6, #2
 8014728:	b2b6      	uxth	r6, r6
 801472a:	4621      	mov	r1, r4
 801472c:	b2bf      	uxth	r7, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801472e:	f105 0b02 	add.w	fp, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014732:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014736:	f104 0901 	add.w	r9, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 801473a:	463a      	mov	r2, r7
 801473c:	9302      	str	r3, [sp, #8]
 801473e:	4640      	mov	r0, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014740:	fa1f f989 	uxth.w	r9, r9
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014744:	f7ff ff16 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014748:	9601      	str	r6, [sp, #4]
 801474a:	3e04      	subs	r6, #4
 801474c:	fa1f fb8b 	uxth.w	fp, fp
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014750:	f104 0a02 	add.w	sl, r4, #2
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014754:	9b02      	ldr	r3, [sp, #8]
 8014756:	b2b6      	uxth	r6, r6
 8014758:	4649      	mov	r1, r9
 801475a:	4658      	mov	r0, fp
 801475c:	4632      	mov	r2, r6
 801475e:	f7ff ff09 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014762:	4628      	mov	r0, r5
 8014764:	9b02      	ldr	r3, [sp, #8]
 8014766:	463a      	mov	r2, r7
 8014768:	4649      	mov	r1, r9
 801476a:	f7ff febd 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 801476e:	4640      	mov	r0, r8
 8014770:	fa1f f18a 	uxth.w	r1, sl
 8014774:	9b02      	ldr	r3, [sp, #8]
 8014776:	4632      	mov	r2, r6
 8014778:	ee08 1a10 	vmov	s16, r1
 801477c:	f7ff feb4 	bl	80144e8 <VLine>
		VLine(Xpos, Ypos + width, width - 2, color);
 8014780:	9b01      	ldr	r3, [sp, #4]
 8014782:	4628      	mov	r0, r5
 8014784:	463a      	mov	r2, r7
 8014786:	441c      	add	r4, r3
 8014788:	9b02      	ldr	r3, [sp, #8]
 801478a:	fa1f fa84 	uxth.w	sl, r4
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 801478e:	f10a 0401 	add.w	r4, sl, #1
		VLine(Xpos, Ypos + width, width - 2, color);
 8014792:	4651      	mov	r1, sl
 8014794:	f7ff fea8 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 8014798:	4640      	mov	r0, r8
 801479a:	b2a4      	uxth	r4, r4
 801479c:	9b02      	ldr	r3, [sp, #8]
 801479e:	4632      	mov	r2, r6
 80147a0:	4621      	mov	r1, r4
 80147a2:	f7ff fea1 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 80147a6:	9b01      	ldr	r3, [sp, #4]
 80147a8:	4640      	mov	r0, r8
 80147aa:	463a      	mov	r2, r7
 80147ac:	eb03 080a 	add.w	r8, r3, sl
 80147b0:	9b02      	ldr	r3, [sp, #8]
 80147b2:	fa1f f888 	uxth.w	r8, r8
 80147b6:	f1a8 0102 	sub.w	r1, r8, #2
 80147ba:	b289      	uxth	r1, r1
 80147bc:	f7ff feda 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 80147c0:	f1a8 0103 	sub.w	r1, r8, #3
 80147c4:	4658      	mov	r0, fp
 80147c6:	9b02      	ldr	r3, [sp, #8]
 80147c8:	b289      	uxth	r1, r1
 80147ca:	4632      	mov	r2, r6
 80147cc:	f7ff fed2 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80147d0:	9b01      	ldr	r3, [sp, #4]
 80147d2:	4651      	mov	r1, sl
 80147d4:	463a      	mov	r2, r7
 80147d6:	441d      	add	r5, r3
 80147d8:	9b02      	ldr	r3, [sp, #8]
 80147da:	b2ad      	uxth	r5, r5
 80147dc:	9301      	str	r3, [sp, #4]
 80147de:	f105 38ff 	add.w	r8, r5, #4294967295
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80147e2:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80147e4:	fa1f f888 	uxth.w	r8, r8
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80147e8:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80147ea:	4640      	mov	r0, r8
 80147ec:	f7ff fe7c 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80147f0:	4621      	mov	r1, r4
 80147f2:	9b01      	ldr	r3, [sp, #4]
 80147f4:	4632      	mov	r2, r6
 80147f6:	4628      	mov	r0, r5
 80147f8:	f7ff fe76 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 80147fc:	9b01      	ldr	r3, [sp, #4]
 80147fe:	463a      	mov	r2, r7
 8014800:	4649      	mov	r1, r9
 8014802:	4640      	mov	r0, r8
 8014804:	f7ff fe70 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 8014808:	9b01      	ldr	r3, [sp, #4]
 801480a:	4632      	mov	r2, r6
 801480c:	ee18 1a10 	vmov	r1, s16
 8014810:	e77f      	b.n	8014712 <DrawDigit+0x112>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014812:	4435      	add	r5, r6
 8014814:	b2b7      	uxth	r7, r6
 8014816:	eb06 0804 	add.w	r8, r6, r4
 801481a:	3e02      	subs	r6, #2
 801481c:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 801481e:	3f04      	subs	r7, #4
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014820:	fa1f f888 	uxth.w	r8, r8
 8014824:	9301      	str	r3, [sp, #4]
 8014826:	f105 39ff 	add.w	r9, r5, #4294967295
 801482a:	b2b6      	uxth	r6, r6
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 801482c:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 801482e:	4641      	mov	r1, r8
 8014830:	fa1f f989 	uxth.w	r9, r9
 8014834:	4632      	mov	r2, r6
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014836:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014838:	4648      	mov	r0, r9
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 801483a:	b2bf      	uxth	r7, r7
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 801483c:	f7ff fe54 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014840:	f108 0101 	add.w	r1, r8, #1
 8014844:	9b01      	ldr	r3, [sp, #4]
 8014846:	4628      	mov	r0, r5
 8014848:	b289      	uxth	r1, r1
 801484a:	463a      	mov	r2, r7
 801484c:	f7ff fe4c 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014850:	1c61      	adds	r1, r4, #1
 8014852:	4632      	mov	r2, r6
 8014854:	4648      	mov	r0, r9
 8014856:	b289      	uxth	r1, r1
 8014858:	9b01      	ldr	r3, [sp, #4]
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 801485a:	f7ff fe45 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 801485e:	1ca1      	adds	r1, r4, #2
 8014860:	9b01      	ldr	r3, [sp, #4]
 8014862:	463a      	mov	r2, r7
 8014864:	b289      	uxth	r1, r1
 8014866:	e754      	b.n	8014712 <DrawDigit+0x112>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014868:	f101 0801 	add.w	r8, r1, #1
 801486c:	1eb7      	subs	r7, r6, #2
 801486e:	b2b6      	uxth	r6, r6
 8014870:	4621      	mov	r1, r4
 8014872:	b2bf      	uxth	r7, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014874:	f105 0a02 	add.w	sl, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014878:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801487c:	f104 0b01 	add.w	fp, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014880:	463a      	mov	r2, r7
 8014882:	9302      	str	r3, [sp, #8]
 8014884:	4640      	mov	r0, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014886:	fa1f fa8a 	uxth.w	sl, sl
		HLine(Xpos + 1, Ypos, width - 2, color);
 801488a:	f7ff fe73 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801488e:	9601      	str	r6, [sp, #4]
 8014890:	3e04      	subs	r6, #4
 8014892:	fa1f f28b 	uxth.w	r2, fp
 8014896:	9b02      	ldr	r3, [sp, #8]
 8014898:	4650      	mov	r0, sl
 801489a:	b2b6      	uxth	r6, r6
 801489c:	4611      	mov	r1, r2
 801489e:	ee08 2a10 	vmov	s16, r2
 80148a2:	4632      	mov	r2, r6
 80148a4:	f7ff fe66 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + width, width - 2, color);
 80148a8:	9b01      	ldr	r3, [sp, #4]
 80148aa:	4628      	mov	r0, r5
 80148ac:	463a      	mov	r2, r7
 80148ae:	1919      	adds	r1, r3, r4
 80148b0:	9b02      	ldr	r3, [sp, #8]
 80148b2:	fa1f fb81 	uxth.w	fp, r1
 80148b6:	4659      	mov	r1, fp
 80148b8:	f7ff fe16 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 80148bc:	f10b 0101 	add.w	r1, fp, #1
 80148c0:	9b02      	ldr	r3, [sp, #8]
 80148c2:	4632      	mov	r2, r6
 80148c4:	b289      	uxth	r1, r1
 80148c6:	4640      	mov	r0, r8
 80148c8:	f7ff fe0e 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 80148cc:	9b01      	ldr	r3, [sp, #4]
 80148ce:	463a      	mov	r2, r7
 80148d0:	4640      	mov	r0, r8
 80148d2:	eb03 090b 	add.w	r9, r3, fp
 80148d6:	9b02      	ldr	r3, [sp, #8]
 80148d8:	fa1f f989 	uxth.w	r9, r9
 80148dc:	f1a9 0102 	sub.w	r1, r9, #2
 80148e0:	b289      	uxth	r1, r1
 80148e2:	f7ff fe47 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 80148e6:	f1a9 0103 	sub.w	r1, r9, #3
 80148ea:	9b02      	ldr	r3, [sp, #8]
 80148ec:	4632      	mov	r2, r6
 80148ee:	b289      	uxth	r1, r1
 80148f0:	4650      	mov	r0, sl
 80148f2:	f7ff fe3f 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 80148f6:	f10b 31ff 	add.w	r1, fp, #4294967295
 80148fa:	4640      	mov	r0, r8
 80148fc:	9b02      	ldr	r3, [sp, #8]
 80148fe:	b289      	uxth	r1, r1
 8014900:	463a      	mov	r2, r7
 8014902:	f7ff fe37 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014906:	f1ab 0102 	sub.w	r1, fp, #2
 801490a:	4650      	mov	r0, sl
 801490c:	9b02      	ldr	r3, [sp, #8]
 801490e:	b289      	uxth	r1, r1
 8014910:	4632      	mov	r2, r6
 8014912:	f7ff fe2f 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014916:	9b01      	ldr	r3, [sp, #4]
 8014918:	463a      	mov	r2, r7
 801491a:	ee18 1a10 	vmov	r1, s16
 801491e:	441d      	add	r5, r3
 8014920:	9b02      	ldr	r3, [sp, #8]
 8014922:	b2ad      	uxth	r5, r5
 8014924:	9301      	str	r3, [sp, #4]
 8014926:	1e68      	subs	r0, r5, #1
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 8014928:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 801492a:	b280      	uxth	r0, r0
 801492c:	f7ff fddc 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 8014930:	1ca1      	adds	r1, r4, #2
 8014932:	9b01      	ldr	r3, [sp, #4]
 8014934:	4632      	mov	r2, r6
 8014936:	b289      	uxth	r1, r1
 8014938:	b2a8      	uxth	r0, r5
 801493a:	e6eb      	b.n	8014714 <DrawDigit+0x114>
		HLine(Xpos + 1, Ypos, width - 2, color);
 801493c:	f101 0a01 	add.w	sl, r1, #1
 8014940:	f1a6 0802 	sub.w	r8, r6, #2
 8014944:	b2b6      	uxth	r6, r6
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014946:	f105 0902 	add.w	r9, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 801494a:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801494e:	f104 0b01 	add.w	fp, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014952:	fa1f fa8a 	uxth.w	sl, sl
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014956:	1f37      	subs	r7, r6, #4
 8014958:	fa1f f989 	uxth.w	r9, r9
		HLine(Xpos + 1, Ypos, width - 2, color);
 801495c:	4621      	mov	r1, r4
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801495e:	b2bf      	uxth	r7, r7
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014960:	4650      	mov	r0, sl
 8014962:	4642      	mov	r2, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014964:	fa1f fb8b 	uxth.w	fp, fp
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014968:	9301      	str	r3, [sp, #4]
 801496a:	f7ff fe03 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 801496e:	9b01      	ldr	r3, [sp, #4]
 8014970:	4648      	mov	r0, r9
 8014972:	4659      	mov	r1, fp
 8014974:	463a      	mov	r2, r7
 8014976:	9302      	str	r3, [sp, #8]
 8014978:	f7ff fdfc 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 801497c:	9601      	str	r6, [sp, #4]
 801497e:	eb04 0646 	add.w	r6, r4, r6, lsl #1
 8014982:	9b02      	ldr	r3, [sp, #8]
 8014984:	4642      	mov	r2, r8
 8014986:	b2b6      	uxth	r6, r6
 8014988:	4650      	mov	r0, sl
 801498a:	1eb1      	subs	r1, r6, #2
 801498c:	b289      	uxth	r1, r1
 801498e:	f7ff fdf1 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014992:	1ef1      	subs	r1, r6, #3
 8014994:	4648      	mov	r0, r9
 8014996:	9b02      	ldr	r3, [sp, #8]
 8014998:	b289      	uxth	r1, r1
 801499a:	463a      	mov	r2, r7
 801499c:	f7ff fdea 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 80149a0:	9b01      	ldr	r3, [sp, #4]
 80149a2:	4650      	mov	r0, sl
 80149a4:	4642      	mov	r2, r8
 80149a6:	1af6      	subs	r6, r6, r3
 80149a8:	9b02      	ldr	r3, [sp, #8]
 80149aa:	b2b6      	uxth	r6, r6
 80149ac:	1e71      	subs	r1, r6, #1
 80149ae:	b289      	uxth	r1, r1
 80149b0:	f7ff fde0 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 80149b4:	1eb1      	subs	r1, r6, #2
 80149b6:	4648      	mov	r0, r9
 80149b8:	9b02      	ldr	r3, [sp, #8]
 80149ba:	b289      	uxth	r1, r1
 80149bc:	463a      	mov	r2, r7
 80149be:	f7ff fdd9 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80149c2:	9b01      	ldr	r3, [sp, #4]
 80149c4:	4631      	mov	r1, r6
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80149c6:	3601      	adds	r6, #1
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80149c8:	441d      	add	r5, r3
 80149ca:	9b02      	ldr	r3, [sp, #8]
 80149cc:	4642      	mov	r2, r8
 80149ce:	b2ad      	uxth	r5, r5
 80149d0:	9301      	str	r3, [sp, #4]
 80149d2:	f105 39ff 	add.w	r9, r5, #4294967295
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80149d6:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80149d8:	fa1f f989 	uxth.w	r9, r9
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80149dc:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 80149de:	4648      	mov	r0, r9
 80149e0:	f7ff fd82 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 80149e4:	9b01      	ldr	r3, [sp, #4]
 80149e6:	b2b1      	uxth	r1, r6
 80149e8:	463a      	mov	r2, r7
 80149ea:	4628      	mov	r0, r5
 80149ec:	f7ff fd7c 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 80149f0:	9b01      	ldr	r3, [sp, #4]
 80149f2:	4642      	mov	r2, r8
 80149f4:	4659      	mov	r1, fp
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 80149f6:	4648      	mov	r0, r9
 80149f8:	e72f      	b.n	801485a <DrawDigit+0x25a>
		VLine(Xpos, Ypos + 1, width - 2, color);
 80149fa:	f104 0901 	add.w	r9, r4, #1
 80149fe:	f1a6 0802 	sub.w	r8, r6, #2
 8014a02:	b2b6      	uxth	r6, r6
 8014a04:	4628      	mov	r0, r5
 8014a06:	fa1f f888 	uxth.w	r8, r8
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014a0a:	f104 0a02 	add.w	sl, r4, #2
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014a0e:	fa1f f989 	uxth.w	r9, r9
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014a12:	1f37      	subs	r7, r6, #4
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014a14:	4642      	mov	r2, r8
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014a16:	4434      	add	r4, r6
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014a18:	4649      	mov	r1, r9
 8014a1a:	9301      	str	r3, [sp, #4]
 8014a1c:	f7ff fd64 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014a20:	1c68      	adds	r0, r5, #1
 8014a22:	b2bf      	uxth	r7, r7
 8014a24:	9b01      	ldr	r3, [sp, #4]
 8014a26:	fa1f fa8a 	uxth.w	sl, sl
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a2a:	442e      	add	r6, r5
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014a2c:	b2a4      	uxth	r4, r4
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014a2e:	463a      	mov	r2, r7
 8014a30:	b280      	uxth	r0, r0
 8014a32:	4651      	mov	r1, sl
 8014a34:	9302      	str	r3, [sp, #8]
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a36:	b2b6      	uxth	r6, r6
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014a38:	9001      	str	r0, [sp, #4]
 8014a3a:	f7ff fd55 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014a3e:	1e61      	subs	r1, r4, #1
 8014a40:	9b02      	ldr	r3, [sp, #8]
 8014a42:	9801      	ldr	r0, [sp, #4]
 8014a44:	4642      	mov	r2, r8
 8014a46:	b289      	uxth	r1, r1
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a48:	f106 3bff 	add.w	fp, r6, #4294967295
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014a4c:	9301      	str	r3, [sp, #4]
 8014a4e:	f7ff fd91 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014a52:	1ea1      	subs	r1, r4, #2
 8014a54:	1ca8      	adds	r0, r5, #2
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014a56:	3e02      	subs	r6, #2
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014a58:	9b01      	ldr	r3, [sp, #4]
 8014a5a:	b289      	uxth	r1, r1
 8014a5c:	463a      	mov	r2, r7
 8014a5e:	b280      	uxth	r0, r0
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a60:	fa1f fb8b 	uxth.w	fp, fp
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014a64:	f7ff fd86 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a68:	4621      	mov	r1, r4
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014a6a:	b2b6      	uxth	r6, r6
 8014a6c:	3401      	adds	r4, #1
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014a6e:	9b01      	ldr	r3, [sp, #4]
 8014a70:	4642      	mov	r2, r8
 8014a72:	4658      	mov	r0, fp
 8014a74:	f7ff fd38 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014a78:	9b01      	ldr	r3, [sp, #4]
 8014a7a:	b2a1      	uxth	r1, r4
 8014a7c:	463a      	mov	r2, r7
 8014a7e:	4630      	mov	r0, r6
 8014a80:	f7ff fd32 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014a84:	9b01      	ldr	r3, [sp, #4]
 8014a86:	4642      	mov	r2, r8
 8014a88:	4649      	mov	r1, r9
 8014a8a:	4658      	mov	r0, fp
 8014a8c:	f7ff fd2c 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 8014a90:	9b01      	ldr	r3, [sp, #4]
 8014a92:	463a      	mov	r2, r7
 8014a94:	4651      	mov	r1, sl
 8014a96:	4630      	mov	r0, r6
 8014a98:	e63c      	b.n	8014714 <DrawDigit+0x114>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014a9a:	f101 0901 	add.w	r9, r1, #1
 8014a9e:	f1a6 0802 	sub.w	r8, r6, #2
 8014aa2:	b2b6      	uxth	r6, r6
 8014aa4:	4621      	mov	r1, r4
 8014aa6:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014aaa:	f105 0a02 	add.w	sl, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014aae:	fa1f f989 	uxth.w	r9, r9
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014ab2:	1f37      	subs	r7, r6, #4
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014ab4:	4642      	mov	r2, r8
 8014ab6:	9301      	str	r3, [sp, #4]
 8014ab8:	4648      	mov	r0, r9
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014aba:	b2bf      	uxth	r7, r7
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014abc:	f7ff fd5a 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014ac0:	1c61      	adds	r1, r4, #1
 8014ac2:	fa1f fa8a 	uxth.w	sl, sl
 8014ac6:	9b01      	ldr	r3, [sp, #4]
 8014ac8:	b289      	uxth	r1, r1
 8014aca:	463a      	mov	r2, r7
 8014acc:	4650      	mov	r0, sl
 8014ace:	9102      	str	r1, [sp, #8]
 8014ad0:	f7ff fd50 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014ad4:	9b01      	ldr	r3, [sp, #4]
 8014ad6:	4642      	mov	r2, r8
 8014ad8:	9902      	ldr	r1, [sp, #8]
 8014ada:	4628      	mov	r0, r5
 8014adc:	f7ff fd04 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014ae0:	1ca1      	adds	r1, r4, #2
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 8014ae2:	eb04 0446 	add.w	r4, r4, r6, lsl #1
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014ae6:	9b01      	ldr	r3, [sp, #4]
 8014ae8:	b289      	uxth	r1, r1
 8014aea:	463a      	mov	r2, r7
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 8014aec:	b2a4      	uxth	r4, r4
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014aee:	4648      	mov	r0, r9
 8014af0:	f7ff fcfa 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 8014af4:	9b01      	ldr	r3, [sp, #4]
 8014af6:	1ea1      	subs	r1, r4, #2
 8014af8:	4642      	mov	r2, r8
 8014afa:	4648      	mov	r0, r9
 8014afc:	b289      	uxth	r1, r1
 8014afe:	f7ff fd39 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014b02:	1ee1      	subs	r1, r4, #3
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014b04:	1ba4      	subs	r4, r4, r6
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014b06:	9b01      	ldr	r3, [sp, #4]
 8014b08:	b289      	uxth	r1, r1
 8014b0a:	463a      	mov	r2, r7
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014b0c:	b2a4      	uxth	r4, r4
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014b0e:	4650      	mov	r0, sl
 8014b10:	f7ff fd30 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014b14:	442e      	add	r6, r5
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014b16:	1e61      	subs	r1, r4, #1
 8014b18:	4648      	mov	r0, r9
 8014b1a:	9b01      	ldr	r3, [sp, #4]
 8014b1c:	4642      	mov	r2, r8
 8014b1e:	b289      	uxth	r1, r1
 8014b20:	f7ff fd28 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014b24:	1ea1      	subs	r1, r4, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014b26:	b2b6      	uxth	r6, r6
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014b28:	4650      	mov	r0, sl
 8014b2a:	b289      	uxth	r1, r1
 8014b2c:	9b01      	ldr	r3, [sp, #4]
 8014b2e:	463a      	mov	r2, r7
 8014b30:	f7ff fd20 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014b34:	1e70      	subs	r0, r6, #1
 8014b36:	4642      	mov	r2, r8
 8014b38:	9b01      	ldr	r3, [sp, #4]
 8014b3a:	4621      	mov	r1, r4
 8014b3c:	b280      	uxth	r0, r0
 8014b3e:	f7ff fcd3 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014b42:	3e02      	subs	r6, #2
 8014b44:	1c61      	adds	r1, r4, #1
 8014b46:	9b01      	ldr	r3, [sp, #4]
 8014b48:	463a      	mov	r2, r7
 8014b4a:	b2b0      	uxth	r0, r6
 8014b4c:	b289      	uxth	r1, r1
 8014b4e:	e5e1      	b.n	8014714 <DrawDigit+0x114>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014b50:	f101 0801 	add.w	r8, r1, #1
 8014b54:	1eb7      	subs	r7, r6, #2
 8014b56:	b2b6      	uxth	r6, r6
 8014b58:	4621      	mov	r1, r4
 8014b5a:	b2bf      	uxth	r7, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014b5c:	f105 0a02 	add.w	sl, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014b60:	fa1f f888 	uxth.w	r8, r8
 8014b64:	9302      	str	r3, [sp, #8]
 8014b66:	463a      	mov	r2, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014b68:	fa1f fa8a 	uxth.w	sl, sl
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014b6c:	4640      	mov	r0, r8
 8014b6e:	f7ff fd01 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014b72:	9601      	str	r6, [sp, #4]
 8014b74:	3e04      	subs	r6, #4
 8014b76:	1c61      	adds	r1, r4, #1
 8014b78:	9b02      	ldr	r3, [sp, #8]
 8014b7a:	4650      	mov	r0, sl
 8014b7c:	b2b6      	uxth	r6, r6
 8014b7e:	b289      	uxth	r1, r1
 8014b80:	4632      	mov	r2, r6
 8014b82:	9103      	str	r1, [sp, #12]
 8014b84:	f7ff fcf6 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014b88:	4628      	mov	r0, r5
 8014b8a:	9b02      	ldr	r3, [sp, #8]
 8014b8c:	463a      	mov	r2, r7
 8014b8e:	9903      	ldr	r1, [sp, #12]
 8014b90:	f7ff fcaa 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014b94:	1ca1      	adds	r1, r4, #2
 8014b96:	9b02      	ldr	r3, [sp, #8]
 8014b98:	4632      	mov	r2, r6
 8014b9a:	b289      	uxth	r1, r1
 8014b9c:	4640      	mov	r0, r8
 8014b9e:	f7ff fca3 	bl	80144e8 <VLine>
		VLine(Xpos, Ypos + width, width - 2, color);
 8014ba2:	9b01      	ldr	r3, [sp, #4]
 8014ba4:	4628      	mov	r0, r5
 8014ba6:	463a      	mov	r2, r7
 8014ba8:	441c      	add	r4, r3
 8014baa:	9b02      	ldr	r3, [sp, #8]
 8014bac:	b2a4      	uxth	r4, r4
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 8014bae:	f104 0b01 	add.w	fp, r4, #1
		VLine(Xpos, Ypos + width, width - 2, color);
 8014bb2:	4621      	mov	r1, r4
 8014bb4:	f7ff fc98 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 8014bb8:	9b02      	ldr	r3, [sp, #8]
 8014bba:	fa1f fb8b 	uxth.w	fp, fp
 8014bbe:	4632      	mov	r2, r6
 8014bc0:	4640      	mov	r0, r8
 8014bc2:	4659      	mov	r1, fp
 8014bc4:	f7ff fc90 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 8014bc8:	9b01      	ldr	r3, [sp, #4]
 8014bca:	463a      	mov	r2, r7
 8014bcc:	4640      	mov	r0, r8
 8014bce:	eb03 0904 	add.w	r9, r3, r4
 8014bd2:	9b02      	ldr	r3, [sp, #8]
 8014bd4:	fa1f f989 	uxth.w	r9, r9
 8014bd8:	f1a9 0102 	sub.w	r1, r9, #2
 8014bdc:	b289      	uxth	r1, r1
 8014bde:	f7ff fcc9 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014be2:	f1a9 0103 	sub.w	r1, r9, #3
 8014be6:	9b02      	ldr	r3, [sp, #8]
 8014be8:	4632      	mov	r2, r6
 8014bea:	b289      	uxth	r1, r1
 8014bec:	4650      	mov	r0, sl
 8014bee:	f7ff fcc1 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014bf2:	1e61      	subs	r1, r4, #1
 8014bf4:	4640      	mov	r0, r8
 8014bf6:	9b02      	ldr	r3, [sp, #8]
 8014bf8:	b289      	uxth	r1, r1
 8014bfa:	463a      	mov	r2, r7
 8014bfc:	f7ff fcba 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014c00:	1ea1      	subs	r1, r4, #2
 8014c02:	4650      	mov	r0, sl
 8014c04:	9b02      	ldr	r3, [sp, #8]
 8014c06:	b289      	uxth	r1, r1
 8014c08:	4632      	mov	r2, r6
 8014c0a:	f7ff fcb3 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014c0e:	9b01      	ldr	r3, [sp, #4]
 8014c10:	463a      	mov	r2, r7
 8014c12:	4621      	mov	r1, r4
 8014c14:	441d      	add	r5, r3
 8014c16:	9b02      	ldr	r3, [sp, #8]
 8014c18:	b2ad      	uxth	r5, r5
 8014c1a:	9301      	str	r3, [sp, #4]
 8014c1c:	1e68      	subs	r0, r5, #1
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014c1e:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014c20:	b280      	uxth	r0, r0
 8014c22:	f7ff fc61 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014c26:	9b01      	ldr	r3, [sp, #4]
 8014c28:	4632      	mov	r2, r6
 8014c2a:	4659      	mov	r1, fp
 8014c2c:	b2a8      	uxth	r0, r5
 8014c2e:	e571      	b.n	8014714 <DrawDigit+0x114>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014c30:	fa1f f986 	uxth.w	r9, r6
 8014c34:	3e02      	subs	r6, #2
 8014c36:	1c48      	adds	r0, r1, #1
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014c38:	f104 0801 	add.w	r8, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014c3c:	b2b6      	uxth	r6, r6
 8014c3e:	4621      	mov	r1, r4
 8014c40:	b280      	uxth	r0, r0
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014c42:	f1a9 0704 	sub.w	r7, r9, #4
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014c46:	4632      	mov	r2, r6
 8014c48:	9301      	str	r3, [sp, #4]
 8014c4a:	f7ff fc93 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014c4e:	1ca8      	adds	r0, r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014c50:	444d      	add	r5, r9
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014c52:	fa1f f888 	uxth.w	r8, r8
 8014c56:	b2bf      	uxth	r7, r7
 8014c58:	9b01      	ldr	r3, [sp, #4]
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014c5a:	b2ad      	uxth	r5, r5
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014c5c:	4641      	mov	r1, r8
 8014c5e:	b280      	uxth	r0, r0
 8014c60:	463a      	mov	r2, r7
 8014c62:	f7ff fc87 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014c66:	eb09 0004 	add.w	r0, r9, r4
 8014c6a:	f105 39ff 	add.w	r9, r5, #4294967295
 8014c6e:	9b01      	ldr	r3, [sp, #4]
 8014c70:	fa1f fa80 	uxth.w	sl, r0
 8014c74:	4632      	mov	r2, r6
 8014c76:	fa1f f989 	uxth.w	r9, r9
 8014c7a:	4651      	mov	r1, sl
 8014c7c:	4648      	mov	r0, r9
 8014c7e:	f7ff fc33 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014c82:	1ea8      	subs	r0, r5, #2
 8014c84:	f10a 0101 	add.w	r1, sl, #1
 8014c88:	9b01      	ldr	r3, [sp, #4]
 8014c8a:	b285      	uxth	r5, r0
 8014c8c:	463a      	mov	r2, r7
 8014c8e:	b289      	uxth	r1, r1
 8014c90:	4628      	mov	r0, r5
 8014c92:	f7ff fc29 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014c96:	9b01      	ldr	r3, [sp, #4]
 8014c98:	4632      	mov	r2, r6
 8014c9a:	4641      	mov	r1, r8
 8014c9c:	4648      	mov	r0, r9
 8014c9e:	e5dc      	b.n	801485a <DrawDigit+0x25a>
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014ca0:	f101 0801 	add.w	r8, r1, #1
 8014ca4:	1eb7      	subs	r7, r6, #2
 8014ca6:	b2b6      	uxth	r6, r6
 8014ca8:	4621      	mov	r1, r4
 8014caa:	b2bf      	uxth	r7, r7
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014cac:	f105 0a02 	add.w	sl, r5, #2
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014cb0:	fa1f f888 	uxth.w	r8, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014cb4:	f104 0901 	add.w	r9, r4, #1
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014cb8:	463a      	mov	r2, r7
 8014cba:	9302      	str	r3, [sp, #8]
 8014cbc:	4640      	mov	r0, r8
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014cbe:	fa1f fa8a 	uxth.w	sl, sl
		HLine(Xpos + 1, Ypos, width - 2, color);
 8014cc2:	f7ff fc57 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + 1, width - 4, color);
 8014cc6:	9601      	str	r6, [sp, #4]
 8014cc8:	3e04      	subs	r6, #4
 8014cca:	fa1f f989 	uxth.w	r9, r9
 8014cce:	9b02      	ldr	r3, [sp, #8]
 8014cd0:	4650      	mov	r0, sl
 8014cd2:	b2b6      	uxth	r6, r6
 8014cd4:	4649      	mov	r1, r9
 8014cd6:	4632      	mov	r2, r6
 8014cd8:	f7ff fc4c 	bl	8014574 <HLine>
		VLine(Xpos, Ypos + 1, width - 2, color);
 8014cdc:	4628      	mov	r0, r5
 8014cde:	9b02      	ldr	r3, [sp, #8]
 8014ce0:	463a      	mov	r2, r7
 8014ce2:	4649      	mov	r1, r9
 8014ce4:	f7ff fc00 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + 2, width - 4, color);
 8014ce8:	1ca2      	adds	r2, r4, #2
 8014cea:	9b02      	ldr	r3, [sp, #8]
 8014cec:	4640      	mov	r0, r8
 8014cee:	b291      	uxth	r1, r2
 8014cf0:	4632      	mov	r2, r6
 8014cf2:	ee08 1a10 	vmov	s16, r1
 8014cf6:	f7ff fbf7 	bl	80144e8 <VLine>
		VLine(Xpos, Ypos + width, width - 2, color);
 8014cfa:	9b01      	ldr	r3, [sp, #4]
 8014cfc:	4628      	mov	r0, r5
 8014cfe:	463a      	mov	r2, r7
 8014d00:	441c      	add	r4, r3
 8014d02:	9b02      	ldr	r3, [sp, #8]
 8014d04:	b2a4      	uxth	r4, r4
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 8014d06:	f104 0b01 	add.w	fp, r4, #1
		VLine(Xpos, Ypos + width, width - 2, color);
 8014d0a:	4621      	mov	r1, r4
 8014d0c:	f7ff fbec 	bl	80144e8 <VLine>
		VLine(Xpos + 1, Ypos + width + 1, width - 4, color);
 8014d10:	9b02      	ldr	r3, [sp, #8]
 8014d12:	fa1f fb8b 	uxth.w	fp, fp
 8014d16:	4632      	mov	r2, r6
 8014d18:	4640      	mov	r0, r8
 8014d1a:	4659      	mov	r1, fp
 8014d1c:	f7ff fbe4 	bl	80144e8 <VLine>
		HLine(Xpos + 1, Ypos + (width * 2) - 2, width - 2, color);
 8014d20:	9b01      	ldr	r3, [sp, #4]
 8014d22:	4640      	mov	r0, r8
 8014d24:	191a      	adds	r2, r3, r4
 8014d26:	9b02      	ldr	r3, [sp, #8]
 8014d28:	b292      	uxth	r2, r2
 8014d2a:	9303      	str	r3, [sp, #12]
 8014d2c:	4611      	mov	r1, r2
 8014d2e:	463a      	mov	r2, r7
 8014d30:	9102      	str	r1, [sp, #8]
 8014d32:	3902      	subs	r1, #2
 8014d34:	b289      	uxth	r1, r1
 8014d36:	f7ff fc1d 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + (width * 2) - 3, width - 4, color);
 8014d3a:	9a02      	ldr	r2, [sp, #8]
 8014d3c:	9b03      	ldr	r3, [sp, #12]
 8014d3e:	4650      	mov	r0, sl
 8014d40:	1ed1      	subs	r1, r2, #3
 8014d42:	4632      	mov	r2, r6
 8014d44:	9302      	str	r3, [sp, #8]
 8014d46:	b289      	uxth	r1, r1
 8014d48:	f7ff fc14 	bl	8014574 <HLine>
		HLine(Xpos + 1, Ypos + width - 1, width - 2, color);
 8014d4c:	1e61      	subs	r1, r4, #1
 8014d4e:	4640      	mov	r0, r8
 8014d50:	9b02      	ldr	r3, [sp, #8]
 8014d52:	b289      	uxth	r1, r1
 8014d54:	463a      	mov	r2, r7
 8014d56:	f7ff fc0d 	bl	8014574 <HLine>
		HLine(Xpos + 2, Ypos + width - 2, width - 4, color);
 8014d5a:	1ea1      	subs	r1, r4, #2
 8014d5c:	4650      	mov	r0, sl
 8014d5e:	9b02      	ldr	r3, [sp, #8]
 8014d60:	b289      	uxth	r1, r1
 8014d62:	4632      	mov	r2, r6
 8014d64:	f7ff fc06 	bl	8014574 <HLine>
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014d68:	9b01      	ldr	r3, [sp, #4]
 8014d6a:	4621      	mov	r1, r4
 8014d6c:	463a      	mov	r2, r7
 8014d6e:	441d      	add	r5, r3
 8014d70:	9b02      	ldr	r3, [sp, #8]
 8014d72:	b2ad      	uxth	r5, r5
 8014d74:	9301      	str	r3, [sp, #4]
 8014d76:	1e6c      	subs	r4, r5, #1
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014d78:	3d02      	subs	r5, #2
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014d7a:	b2a4      	uxth	r4, r4
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014d7c:	b2ad      	uxth	r5, r5
		VLine(Xpos + width - 1, Ypos + width, width - 2, color);
 8014d7e:	4620      	mov	r0, r4
 8014d80:	f7ff fbb2 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + width + 1, width - 4, color);
 8014d84:	4659      	mov	r1, fp
 8014d86:	9b01      	ldr	r3, [sp, #4]
 8014d88:	4632      	mov	r2, r6
 8014d8a:	4628      	mov	r0, r5
 8014d8c:	f7ff fbac 	bl	80144e8 <VLine>
		VLine(Xpos + width - 1, Ypos + 1, width - 2, color);
 8014d90:	9b01      	ldr	r3, [sp, #4]
 8014d92:	463a      	mov	r2, r7
 8014d94:	4649      	mov	r1, r9
 8014d96:	4620      	mov	r0, r4
 8014d98:	f7ff fba6 	bl	80144e8 <VLine>
		VLine(Xpos + width - 2, Ypos + 2, width - 4, color);
 8014d9c:	9b01      	ldr	r3, [sp, #4]
 8014d9e:	4632      	mov	r2, r6
 8014da0:	ee18 1a10 	vmov	r1, s16
 8014da4:	e4b5      	b.n	8014712 <DrawDigit+0x112>
}
 8014da6:	b005      	add	sp, #20
 8014da8:	ecbd 8b02 	vpop	{d8}
 8014dac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08014db0 <DrawLowSpectrum>:
{
 8014db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014db4:	4cd0      	ldr	r4, [pc, #832]	; (80150f8 <DrawLowSpectrum+0x348>)
 8014db6:	b089      	sub	sp, #36	; 0x24
 8014db8:	f8df a35c 	ldr.w	sl, [pc, #860]	; 8015118 <DrawLowSpectrum+0x368>
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014dbc:	f04f 0834 	mov.w	r8, #52	; 0x34
 8014dc0:	1c63      	adds	r3, r4, #1
 8014dc2:	f8df b358 	ldr.w	fp, [pc, #856]	; 801511c <DrawLowSpectrum+0x36c>
 8014dc6:	f8df 9348 	ldr.w	r9, [pc, #840]	; 8015110 <DrawLowSpectrum+0x360>
 8014dca:	9304      	str	r3, [sp, #16]
 8014dcc:	e002      	b.n	8014dd4 <DrawLowSpectrum+0x24>
	for(i = 0; i < 400; i++)
 8014dce:	4bcb      	ldr	r3, [pc, #812]	; (80150fc <DrawLowSpectrum+0x34c>)
 8014dd0:	42a3      	cmp	r3, r4
 8014dd2:	d044      	beq.n	8014e5e <DrawLowSpectrum+0xae>
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014dd4:	f89a 3000 	ldrb.w	r3, [sl]
    hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014dd8:	2202      	movs	r2, #2
    hdma2d.Init.Mode = DMA2D_R2M;
 8014dda:	f44f 3140 	mov.w	r1, #196608	; 0x30000
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014dde:	4648      	mov	r0, r9
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014de0:	fb08 b303 	mla	r3, r8, r3, fp
 8014de4:	4627      	mov	r7, r4
    hdma2d.Init.ColorMode = DMA2D_RGB565;
 8014de6:	f8c9 2008 	str.w	r2, [r9, #8]
    hdma2d.Instance = DMA2D;
 8014dea:	4ac5      	ldr	r2, [pc, #788]	; (8015100 <DrawLowSpectrum+0x350>)
		color = (uint32_t)(lowp_wavebuffer[i] & 0xE0); // read color data - first 3 bits
 8014dec:	f814 6f01 	ldrb.w	r6, [r4, #1]!
    hdma2d.Init.Mode = DMA2D_R2M;
 8014df0:	f8c9 1004 	str.w	r1, [r9, #4]
    hdma2d.Instance = DMA2D;
 8014df4:	f8c9 2000 	str.w	r2, [r9]
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014df8:	e9d3 3517 	ldrd	r3, r5, [r3, #92]	; 0x5c
 8014dfc:	9303      	str	r3, [sp, #12]
    hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - 1;
 8014dfe:	1e6b      	subs	r3, r5, #1
 8014e00:	f8c9 300c 	str.w	r3, [r9, #12]
    if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8014e04:	f7ec fe06 	bl	8001a14 <HAL_DMA2D_Init>
 8014e08:	2800      	cmp	r0, #0
 8014e0a:	d1e0      	bne.n	8014dce <DrawLowSpectrum+0x1e>
    	if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK) {
 8014e0c:	f89a 1000 	ldrb.w	r1, [sl]
 8014e10:	4648      	mov	r0, r9
 8014e12:	f7ec ff61 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 8014e16:	2800      	cmp	r0, #0
 8014e18:	d1d9      	bne.n	8014dce <DrawLowSpectrum+0x1e>
 8014e1a:	f006 031f 	and.w	r3, r6, #31
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014e1e:	9904      	ldr	r1, [sp, #16]
		color = (uint32_t)(lowp_wavebuffer[i] & 0xE0); // read color data - first 3 bits
 8014e20:	f006 06e0 	and.w	r6, r6, #224	; 0xe0
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014e24:	3729      	adds	r7, #41	; 0x29
		VLine(i + 40, 250 - height, height, color);
 8014e26:	f1c3 02fa 	rsb	r2, r3, #250	; 0xfa
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 8014e2a:	9300      	str	r3, [sp, #0]
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014e2c:	1a7f      	subs	r7, r7, r1
		color |= (uint32_t)(lowp_wavebuffer[i] & 0xE0);
 8014e2e:	ea46 2606 	orr.w	r6, r6, r6, lsl #8
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014e32:	b292      	uxth	r2, r2
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 8014e34:	2301      	movs	r3, #1
		color <<= 8;
 8014e36:	0231      	lsls	r1, r6, #8
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 8014e38:	4648      	mov	r0, r9
    Xaddress = (hltdc.LayerCfg[ActiveLayer].FBStartAdress) + 2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos + Xpos);
 8014e3a:	fb05 7202 	mla	r2, r5, r2, r7
    		if (HAL_DMA2D_Start(&hdma2d, color, Xaddress, 1, Length) == HAL_OK) {
 8014e3e:	9d03      	ldr	r5, [sp, #12]
 8014e40:	f041 01ff 	orr.w	r1, r1, #255	; 0xff
 8014e44:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 8014e48:	f7ec fe3a 	bl	8001ac0 <HAL_DMA2D_Start>
 8014e4c:	2800      	cmp	r0, #0
 8014e4e:	d1be      	bne.n	8014dce <DrawLowSpectrum+0x1e>
    			HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 8014e50:	210a      	movs	r1, #10
 8014e52:	4648      	mov	r0, r9
 8014e54:	f7ec feaa 	bl	8001bac <HAL_DMA2D_PollForTransfer>
	for(i = 0; i < 400; i++)
 8014e58:	4ba8      	ldr	r3, [pc, #672]	; (80150fc <DrawLowSpectrum+0x34c>)
 8014e5a:	42a3      	cmp	r3, r4
 8014e5c:	d1ba      	bne.n	8014dd4 <DrawLowSpectrum+0x24>
	VLine(397, 174, 32, 0x00FFFFFF);
 8014e5e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8014e62:	2220      	movs	r2, #32
 8014e64:	21ae      	movs	r1, #174	; 0xae
 8014e66:	f240 108d 	movw	r0, #397	; 0x18d
 8014e6a:	f7ff fb3d 	bl	80144e8 <VLine>
	VLine(453, 174, 32, 0x00FFFFFF);
 8014e6e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8014e72:	2220      	movs	r2, #32
 8014e74:	21ae      	movs	r1, #174	; 0xae
 8014e76:	f240 10c5 	movw	r0, #453	; 0x1c5
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014e7a:	25ad      	movs	r5, #173	; 0xad
	VLine(453, 174, 32, 0x00FFFFFF);
 8014e7c:	f7ff fb34 	bl	80144e8 <VLine>
	HLine(399, 172, 53, 0x00FFFFFF);
 8014e80:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8014e84:	2235      	movs	r2, #53	; 0x35
 8014e86:	21ac      	movs	r1, #172	; 0xac
 8014e88:	f240 108f 	movw	r0, #399	; 0x18f
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014e8c:	f240 76ff 	movw	r6, #2047	; 0x7ff
	HLine(399, 172, 53, 0x00FFFFFF);
 8014e90:	f7ff fb70 	bl	8014574 <HLine>
	HLine(399, 207, 53, 0x00FFFFFF);
 8014e94:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8014e98:	2235      	movs	r2, #53	; 0x35
 8014e9a:	21cf      	movs	r1, #207	; 0xcf
 8014e9c:	f240 108f 	movw	r0, #399	; 0x18f
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014ea0:	24ce      	movs	r4, #206	; 0xce
	HLine(399, 207, 53, 0x00FFFFFF);
 8014ea2:	f7ff fb67 	bl	8014574 <HLine>
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014ea6:	f89a 2000 	ldrb.w	r2, [sl]
 8014eaa:	2134      	movs	r1, #52	; 0x34
 8014eac:	4895      	ldr	r0, [pc, #596]	; (8015104 <DrawLowSpectrum+0x354>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8014eae:	f04f 0ecd 	mov.w	lr, #205	; 0xcd
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014eb2:	fb01 b202 	mla	r2, r1, r2, fp
 8014eb6:	f100 0c28 	add.w	ip, r0, #40	; 0x28
 8014eba:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8014ebe:	fb05 f303 	mul.w	r3, r5, r3
 8014ec2:	f503 73c7 	add.w	r3, r3, #398	; 0x18e
 8014ec6:	f822 6013 	strh.w	r6, [r2, r3, lsl #1]
 8014eca:	2200      	movs	r2, #0
 8014ecc:	f89a 7000 	ldrb.w	r7, [sl]
 8014ed0:	fb01 b707 	mla	r7, r1, r7, fp
 8014ed4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014ed6:	fb05 f303 	mul.w	r3, r5, r3
 8014eda:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
 8014edc:	f503 73e2 	add.w	r3, r3, #452	; 0x1c4
 8014ee0:	f825 6013 	strh.w	r6, [r5, r3, lsl #1]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8014ee4:	f64f 75ff 	movw	r5, #65535	; 0xffff
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8014ee8:	f89a 8000 	ldrb.w	r8, [sl]
 8014eec:	fb01 b808 	mla	r8, r1, r8, fp
 8014ef0:	e9d8 8317 	ldrd	r8, r3, [r8, #92]	; 0x5c
 8014ef4:	fb04 f303 	mul.w	r3, r4, r3
 8014ef8:	f503 73c7 	add.w	r3, r3, #398	; 0x18e
 8014efc:	f828 6013 	strh.w	r6, [r8, r3, lsl #1]
 8014f00:	f89a 8000 	ldrb.w	r8, [sl]
 8014f04:	fb01 b808 	mla	r8, r1, r8, fp
 8014f08:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
 8014f0c:	fb04 f303 	mul.w	r3, r4, r3
 8014f10:	f8d8 405c 	ldr.w	r4, [r8, #92]	; 0x5c
 8014f14:	f503 73e2 	add.w	r3, r3, #452	; 0x1c4
 8014f18:	f824 6013 	strh.w	r6, [r4, r3, lsl #1]
	while(i < width) {
 8014f1c:	e04f      	b.n	8014fbe <DrawLowSpectrum+0x20e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f1e:	f89a 8000 	ldrb.w	r8, [sl]
 8014f22:	fb01 b808 	mla	r8, r1, r8, fp
 8014f26:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8014f2a:	fb0e 2404 	mla	r4, lr, r4, r2
 8014f2e:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014f32:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8014f36:	f013 0602 	ands.w	r6, r3, #2
 8014f3a:	d154      	bne.n	8014fe6 <DrawLowSpectrum+0x236>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f3c:	f89a 8000 	ldrb.w	r8, [sl]
 8014f40:	27cc      	movs	r7, #204	; 0xcc
 8014f42:	fb01 b808 	mla	r8, r1, r8, fp
 8014f46:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8014f4a:	fb07 2404 	mla	r4, r7, r4, r2
 8014f4e:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014f52:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8014f56:	f013 0604 	ands.w	r6, r3, #4
 8014f5a:	d154      	bne.n	8015006 <DrawLowSpectrum+0x256>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f5c:	f89a 8000 	ldrb.w	r8, [sl]
 8014f60:	27cb      	movs	r7, #203	; 0xcb
 8014f62:	fb01 b808 	mla	r8, r1, r8, fp
 8014f66:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8014f6a:	fb07 2404 	mla	r4, r7, r4, r2
 8014f6e:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014f72:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8014f76:	f013 0608 	ands.w	r6, r3, #8
 8014f7a:	d154      	bne.n	8015026 <DrawLowSpectrum+0x276>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f7c:	f89a 8000 	ldrb.w	r8, [sl]
 8014f80:	27ca      	movs	r7, #202	; 0xca
			if(((element[i] >> k) & 1) == 1) {
 8014f82:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f86:	fb01 b808 	mla	r8, r1, r8, fp
 8014f8a:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8014f8e:	fb07 2404 	mla	r4, r7, r4, r2
 8014f92:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014f96:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8014f9a:	d154      	bne.n	8015046 <DrawLowSpectrum+0x296>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014f9c:	f89a 6000 	ldrb.w	r6, [sl]
 8014fa0:	27c9      	movs	r7, #201	; 0xc9
	while(i < width) {
 8014fa2:	4584      	cmp	ip, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014fa4:	fb01 b606 	mla	r6, r1, r6, fp
 8014fa8:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8014fac:	fb07 2404 	mla	r4, r7, r4, r2
	while(i < width) {
 8014fb0:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8014fb4:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014fb8:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8014fbc:	d054      	beq.n	8015068 <DrawLowSpectrum+0x2b8>
			if(((element[i] >> k) & 1) == 1) {
 8014fbe:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 8014fc2:	f013 0601 	ands.w	r6, r3, #1
 8014fc6:	d0aa      	beq.n	8014f1e <DrawLowSpectrum+0x16e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8014fc8:	f89a 6000 	ldrb.w	r6, [sl]
 8014fcc:	fb01 b606 	mla	r6, r1, r6, fp
 8014fd0:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8014fd4:	fb0e 2404 	mla	r4, lr, r4, r2
 8014fd8:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014fdc:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8014fe0:	f013 0602 	ands.w	r6, r3, #2
 8014fe4:	d0aa      	beq.n	8014f3c <DrawLowSpectrum+0x18c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8014fe6:	f89a 6000 	ldrb.w	r6, [sl]
 8014fea:	27cc      	movs	r7, #204	; 0xcc
 8014fec:	fb01 b606 	mla	r6, r1, r6, fp
 8014ff0:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8014ff4:	fb07 2404 	mla	r4, r7, r4, r2
 8014ff8:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8014ffc:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015000:	f013 0604 	ands.w	r6, r3, #4
 8015004:	d0aa      	beq.n	8014f5c <DrawLowSpectrum+0x1ac>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015006:	f89a 6000 	ldrb.w	r6, [sl]
 801500a:	27cb      	movs	r7, #203	; 0xcb
 801500c:	fb01 b606 	mla	r6, r1, r6, fp
 8015010:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015014:	fb07 2404 	mla	r4, r7, r4, r2
 8015018:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 801501c:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015020:	f013 0608 	ands.w	r6, r3, #8
 8015024:	d0aa      	beq.n	8014f7c <DrawLowSpectrum+0x1cc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015026:	f89a 6000 	ldrb.w	r6, [sl]
 801502a:	27ca      	movs	r7, #202	; 0xca
			if(((element[i] >> k) & 1) == 1) {
 801502c:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015030:	fb01 b606 	mla	r6, r1, r6, fp
 8015034:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015038:	fb07 2404 	mla	r4, r7, r4, r2
 801503c:	f504 74d7 	add.w	r4, r4, #430	; 0x1ae
 8015040:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015044:	d0aa      	beq.n	8014f9c <DrawLowSpectrum+0x1ec>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015046:	f89a 4000 	ldrb.w	r4, [sl]
 801504a:	26c9      	movs	r6, #201	; 0xc9
	while(i < width) {
 801504c:	4584      	cmp	ip, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801504e:	fb01 b404 	mla	r4, r1, r4, fp
 8015052:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015056:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 801505a:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801505e:	f503 73d7 	add.w	r3, r3, #430	; 0x1ae
 8015062:	f824 5013 	strh.w	r5, [r4, r3, lsl #1]
	while(i < width) {
 8015066:	d1aa      	bne.n	8014fbe <DrawLowSpectrum+0x20e>
	VLine(40, 252, 4, 0x00FFFFFF);
 8015068:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 801506c:	21fc      	movs	r1, #252	; 0xfc
 801506e:	2028      	movs	r0, #40	; 0x28
 8015070:	f7ff f8fe 	bl	8014270 <VLine.constprop.0>
	VLine(440, 252, 4, 0x00FFFFFF);
 8015074:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8015078:	21fc      	movs	r1, #252	; 0xfc
 801507a:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
 801507e:	f7ff f8f7 	bl	8014270 <VLine.constprop.0>
	HLine(40, 252, 400, 0x00FFFFFF);
 8015082:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8015086:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801508a:	21fc      	movs	r1, #252	; 0xfc
 801508c:	2028      	movs	r0, #40	; 0x28
 801508e:	f7ff fa71 	bl	8014574 <HLine>
	HLine(40, 256, 401, 0x00FFFFFF);
 8015092:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8015096:	f240 1291 	movw	r2, #401	; 0x191
 801509a:	f44f 7180 	mov.w	r1, #256	; 0x100
 801509e:	2028      	movs	r0, #40	; 0x28
 80150a0:	f7ff fa68 	bl	8014574 <HLine>
	if(display.timemode == 0) {
 80150a4:	4b18      	ldr	r3, [pc, #96]	; (8015108 <DrawLowSpectrum+0x358>)
 80150a6:	781a      	ldrb	r2, [r3, #0]
 80150a8:	2a00      	cmp	r2, #0
 80150aa:	f001 85ad 	beq.w	8016c08 <DrawLowSpectrum+0x1e58>
	if(display.trackbarmode == 0) {
 80150ae:	4b16      	ldr	r3, [pc, #88]	; (8015108 <DrawLowSpectrum+0x358>)
 80150b0:	791b      	ldrb	r3, [r3, #4]
 80150b2:	2b00      	cmp	r3, #0
 80150b4:	f040 84b7 	bne.w	8015a26 <DrawLowSpectrum+0xc76>
		Rectangle(file_pos+40, 253, 400-file_pos, 3, 0x00FFFFFF);
 80150b8:	4914      	ldr	r1, [pc, #80]	; (801510c <DrawLowSpectrum+0x35c>)
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80150ba:	2334      	movs	r3, #52	; 0x34
 80150bc:	f89a 2000 	ldrb.w	r2, [sl]
		Rectangle(file_pos+40, 253, 400-file_pos, 3, 0x00FFFFFF);
 80150c0:	880f      	ldrh	r7, [r1, #0]
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80150c2:	fb03 b202 	mla	r2, r3, r2, fp
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80150c6:	4812      	ldr	r0, [pc, #72]	; (8015110 <DrawLowSpectrum+0x360>)
		Rectangle(file_pos+40, 253, 400-file_pos, 3, 0x00FFFFFF);
 80150c8:	f5c7 74c8 	rsb	r4, r7, #400	; 0x190
 80150cc:	9107      	str	r1, [sp, #28]
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 80150ce:	b2a4      	uxth	r4, r4
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80150d0:	e9d2 5617 	ldrd	r5, r6, [r2, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 80150d4:	1b33      	subs	r3, r6, r4
 80150d6:	f8c9 300c 	str.w	r3, [r9, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80150da:	f7ec fc9b 	bl	8001a14 <HAL_DMA2D_Init>
 80150de:	2800      	cmp	r0, #0
 80150e0:	f002 8596 	beq.w	8017c10 <DrawLowSpectrum+0x2e60>
	while(i < rekordbox.minutes) {
 80150e4:	4b0b      	ldr	r3, [pc, #44]	; (8015114 <DrawLowSpectrum+0x364>)
 80150e6:	f893 3b90 	ldrb.w	r3, [r3, #2960]	; 0xb90
 80150ea:	2b00      	cmp	r3, #0
 80150ec:	d036      	beq.n	801515c <DrawLowSpectrum+0x3ac>
 80150ee:	4b09      	ldr	r3, [pc, #36]	; (8015114 <DrawLowSpectrum+0x364>)
 80150f0:	2400      	movs	r4, #0
 80150f2:	f503 6529 	add.w	r5, r3, #2704	; 0xa90
 80150f6:	e01f      	b.n	8015138 <DrawLowSpectrum+0x388>
 80150f8:	2000f0df 	.word	0x2000f0df
 80150fc:	2000f26f 	.word	0x2000f26f
 8015100:	4002b000 	.word	0x4002b000
 8015104:	08025a4a 	.word	0x08025a4a
 8015108:	20000c70 	.word	0x20000c70
 801510c:	2000ec88 	.word	0x2000ec88
 8015110:	20000c94 	.word	0x20000c94
 8015114:	200174f0 	.word	0x200174f0
 8015118:	20000e2c 	.word	0x20000e2c
 801511c:	20000d84 	.word	0x20000d84
			VLine(40 + rekordbox.remminticks[i], 260, 4, 0x00FFFFFF);
 8015120:	f835 0b02 	ldrh.w	r0, [r5], #2
		i++;
 8015124:	3401      	adds	r4, #1
			VLine(40 + rekordbox.remminticks[i], 260, 4, 0x00FFFFFF);
 8015126:	3028      	adds	r0, #40	; 0x28
			VLine(40 + rekordbox.elminticks[i], 260, 4, 0x00FFFFFF);
 8015128:	b280      	uxth	r0, r0
 801512a:	f7ff f8a1 	bl	8014270 <VLine.constprop.0>
	while(i < rekordbox.minutes) {
 801512e:	4ba5      	ldr	r3, [pc, #660]	; (80153c4 <DrawLowSpectrum+0x614>)
 8015130:	f893 3b90 	ldrb.w	r3, [r3, #2960]	; 0xb90
 8015134:	42a3      	cmp	r3, r4
 8015136:	d911      	bls.n	801515c <DrawLowSpectrum+0x3ac>
		if(display.timemode == 0) {
 8015138:	4ba3      	ldr	r3, [pc, #652]	; (80153c8 <DrawLowSpectrum+0x618>)
			VLine(40 + rekordbox.remminticks[i], 260, 4, 0x00FFFFFF);
 801513a:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 801513e:	f44f 7182 	mov.w	r1, #260	; 0x104
		if(display.timemode == 0) {
 8015142:	781b      	ldrb	r3, [r3, #0]
 8015144:	2b00      	cmp	r3, #0
 8015146:	d0eb      	beq.n	8015120 <DrawLowSpectrum+0x370>
			VLine(40 + rekordbox.elminticks[i], 260, 4, 0x00FFFFFF);
 8015148:	f8b5 0080 	ldrh.w	r0, [r5, #128]	; 0x80
 801514c:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8015150:	f44f 7182 	mov.w	r1, #260	; 0x104
		i++;
 8015154:	3401      	adds	r4, #1
			VLine(40 + rekordbox.elminticks[i], 260, 4, 0x00FFFFFF);
 8015156:	3028      	adds	r0, #40	; 0x28
	while(i < rekordbox.minutes) {
 8015158:	3502      	adds	r5, #2
 801515a:	e7e5      	b.n	8015128 <DrawLowSpectrum+0x378>
 801515c:	4c9b      	ldr	r4, [pc, #620]	; (80153cc <DrawLowSpectrum+0x61c>)
 801515e:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015160:	2134      	movs	r1, #52	; 0x34
 8015162:	f04f 0ecc 	mov.w	lr, #204	; 0xcc
 8015166:	f64f 70ff 	movw	r0, #65535	; 0xffff
 801516a:	f04f 0ccb 	mov.w	ip, #203	; 0xcb
 801516e:	27ca      	movs	r7, #202	; 0xca
 8015170:	e087      	b.n	8015282 <DrawLowSpectrum+0x4d2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015172:	f89a 9000 	ldrb.w	r9, [sl]
 8015176:	fb01 b909 	mla	r9, r1, r9, fp
 801517a:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 801517e:	fb0e 2505 	mla	r5, lr, r5, r2
 8015182:	f205 1577 	addw	r5, r5, #375	; 0x177
 8015186:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801518a:	f013 0802 	ands.w	r8, r3, #2
 801518e:	f040 808e 	bne.w	80152ae <DrawLowSpectrum+0x4fe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015192:	f89a 9000 	ldrb.w	r9, [sl]
 8015196:	fb01 b909 	mla	r9, r1, r9, fp
 801519a:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 801519e:	fb0c 2505 	mla	r5, ip, r5, r2
 80151a2:	f205 1577 	addw	r5, r5, #375	; 0x177
 80151a6:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80151aa:	f013 0804 	ands.w	r8, r3, #4
 80151ae:	f040 808e 	bne.w	80152ce <DrawLowSpectrum+0x51e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80151b2:	f89a 9000 	ldrb.w	r9, [sl]
 80151b6:	fb01 b909 	mla	r9, r1, r9, fp
 80151ba:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 80151be:	fb07 2505 	mla	r5, r7, r5, r2
 80151c2:	f205 1577 	addw	r5, r5, #375	; 0x177
 80151c6:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80151ca:	f013 0808 	ands.w	r8, r3, #8
 80151ce:	f040 808e 	bne.w	80152ee <DrawLowSpectrum+0x53e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80151d2:	f89a 9000 	ldrb.w	r9, [sl]
 80151d6:	26c9      	movs	r6, #201	; 0xc9
 80151d8:	fb01 b909 	mla	r9, r1, r9, fp
 80151dc:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 80151e0:	fb06 2505 	mla	r5, r6, r5, r2
 80151e4:	f205 1577 	addw	r5, r5, #375	; 0x177
 80151e8:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80151ec:	f013 0810 	ands.w	r8, r3, #16
 80151f0:	f040 808e 	bne.w	8015310 <DrawLowSpectrum+0x560>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80151f4:	f89a 9000 	ldrb.w	r9, [sl]
 80151f8:	26c8      	movs	r6, #200	; 0xc8
 80151fa:	fb01 b909 	mla	r9, r1, r9, fp
 80151fe:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 8015202:	fb06 2505 	mla	r5, r6, r5, r2
 8015206:	f205 1577 	addw	r5, r5, #375	; 0x177
 801520a:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801520e:	f013 0820 	ands.w	r8, r3, #32
 8015212:	f040 808e 	bne.w	8015332 <DrawLowSpectrum+0x582>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015216:	f89a 9000 	ldrb.w	r9, [sl]
 801521a:	26c7      	movs	r6, #199	; 0xc7
 801521c:	fb01 b909 	mla	r9, r1, r9, fp
 8015220:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 8015224:	fb06 2505 	mla	r5, r6, r5, r2
 8015228:	f205 1577 	addw	r5, r5, #375	; 0x177
 801522c:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015230:	f013 0840 	ands.w	r8, r3, #64	; 0x40
 8015234:	f040 808e 	bne.w	8015354 <DrawLowSpectrum+0x5a4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015238:	f89a 9000 	ldrb.w	r9, [sl]
 801523c:	26c6      	movs	r6, #198	; 0xc6
			if(((element[i] >> k) & 1) == 1) {
 801523e:	f013 0380 	ands.w	r3, r3, #128	; 0x80
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015242:	fb01 b909 	mla	r9, r1, r9, fp
 8015246:	e9d9 9517 	ldrd	r9, r5, [r9, #92]	; 0x5c
 801524a:	fb06 2505 	mla	r5, r6, r5, r2
 801524e:	f205 1577 	addw	r5, r5, #375	; 0x177
 8015252:	f829 8015 	strh.w	r8, [r9, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015256:	f040 808e 	bne.w	8015376 <DrawLowSpectrum+0x5c6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801525a:	f89a 8000 	ldrb.w	r8, [sl]
 801525e:	f04f 09c5 	mov.w	r9, #197	; 0xc5
 8015262:	fb01 b808 	mla	r8, r1, r8, fp
 8015266:	f8d8 5060 	ldr.w	r5, [r8, #96]	; 0x60
 801526a:	f8d8 805c 	ldr.w	r8, [r8, #92]	; 0x5c
 801526e:	fb09 2505 	mla	r5, r9, r5, r2
	while(i < width) {
 8015272:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015274:	f205 1577 	addw	r5, r5, #375	; 0x177
	while(i < width) {
 8015278:	2a07      	cmp	r2, #7
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801527a:	f828 3015 	strh.w	r3, [r8, r5, lsl #1]
	while(i < width) {
 801527e:	f000 808c 	beq.w	801539a <DrawLowSpectrum+0x5ea>
			if(((element[i] >> k) & 1) == 1) {
 8015282:	f834 3f02 	ldrh.w	r3, [r4, #2]!
 8015286:	f013 0801 	ands.w	r8, r3, #1
 801528a:	f43f af72 	beq.w	8015172 <DrawLowSpectrum+0x3c2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801528e:	f89a 8000 	ldrb.w	r8, [sl]
 8015292:	fb01 b808 	mla	r8, r1, r8, fp
 8015296:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 801529a:	fb0e 2505 	mla	r5, lr, r5, r2
 801529e:	f205 1577 	addw	r5, r5, #375	; 0x177
 80152a2:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80152a6:	f013 0802 	ands.w	r8, r3, #2
 80152aa:	f43f af72 	beq.w	8015192 <DrawLowSpectrum+0x3e2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80152ae:	f89a 8000 	ldrb.w	r8, [sl]
 80152b2:	fb01 b808 	mla	r8, r1, r8, fp
 80152b6:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 80152ba:	fb0c 2505 	mla	r5, ip, r5, r2
 80152be:	f205 1577 	addw	r5, r5, #375	; 0x177
 80152c2:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80152c6:	f013 0804 	ands.w	r8, r3, #4
 80152ca:	f43f af72 	beq.w	80151b2 <DrawLowSpectrum+0x402>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80152ce:	f89a 8000 	ldrb.w	r8, [sl]
 80152d2:	fb01 b808 	mla	r8, r1, r8, fp
 80152d6:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 80152da:	fb07 2505 	mla	r5, r7, r5, r2
 80152de:	f205 1577 	addw	r5, r5, #375	; 0x177
 80152e2:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80152e6:	f013 0808 	ands.w	r8, r3, #8
 80152ea:	f43f af72 	beq.w	80151d2 <DrawLowSpectrum+0x422>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80152ee:	f89a 8000 	ldrb.w	r8, [sl]
 80152f2:	26c9      	movs	r6, #201	; 0xc9
 80152f4:	fb01 b808 	mla	r8, r1, r8, fp
 80152f8:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 80152fc:	fb06 2505 	mla	r5, r6, r5, r2
 8015300:	f205 1577 	addw	r5, r5, #375	; 0x177
 8015304:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015308:	f013 0810 	ands.w	r8, r3, #16
 801530c:	f43f af72 	beq.w	80151f4 <DrawLowSpectrum+0x444>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015310:	f89a 8000 	ldrb.w	r8, [sl]
 8015314:	26c8      	movs	r6, #200	; 0xc8
 8015316:	fb01 b808 	mla	r8, r1, r8, fp
 801531a:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 801531e:	fb06 2505 	mla	r5, r6, r5, r2
 8015322:	f205 1577 	addw	r5, r5, #375	; 0x177
 8015326:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801532a:	f013 0820 	ands.w	r8, r3, #32
 801532e:	f43f af72 	beq.w	8015216 <DrawLowSpectrum+0x466>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015332:	f89a 8000 	ldrb.w	r8, [sl]
 8015336:	26c7      	movs	r6, #199	; 0xc7
 8015338:	fb01 b808 	mla	r8, r1, r8, fp
 801533c:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 8015340:	fb06 2505 	mla	r5, r6, r5, r2
 8015344:	f205 1577 	addw	r5, r5, #375	; 0x177
 8015348:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801534c:	f013 0840 	ands.w	r8, r3, #64	; 0x40
 8015350:	f43f af72 	beq.w	8015238 <DrawLowSpectrum+0x488>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015354:	f89a 8000 	ldrb.w	r8, [sl]
 8015358:	26c6      	movs	r6, #198	; 0xc6
			if(((element[i] >> k) & 1) == 1) {
 801535a:	f013 0380 	ands.w	r3, r3, #128	; 0x80
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801535e:	fb01 b808 	mla	r8, r1, r8, fp
 8015362:	e9d8 8517 	ldrd	r8, r5, [r8, #92]	; 0x5c
 8015366:	fb06 2505 	mla	r5, r6, r5, r2
 801536a:	f205 1577 	addw	r5, r5, #375	; 0x177
 801536e:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015372:	f43f af72 	beq.w	801525a <DrawLowSpectrum+0x4aa>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015376:	f89a 5000 	ldrb.w	r5, [sl]
 801537a:	f04f 08c5 	mov.w	r8, #197	; 0xc5
 801537e:	fb01 b505 	mla	r5, r1, r5, fp
 8015382:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8015384:	6ded      	ldr	r5, [r5, #92]	; 0x5c
 8015386:	fb08 2303 	mla	r3, r8, r3, r2
	while(i < width) {
 801538a:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801538c:	f203 1377 	addw	r3, r3, #375	; 0x177
	while(i < width) {
 8015390:	2a07      	cmp	r2, #7
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015392:	f825 0013 	strh.w	r0, [r5, r3, lsl #1]
	while(i < width) {
 8015396:	f47f af74 	bne.w	8015282 <DrawLowSpectrum+0x4d2>
	if(trak.percent < 0) DrawElement(10, 2, 308, 195, 0x00FFFFFF, minus);
 801539a:	4b0d      	ldr	r3, [pc, #52]	; (80153d0 <DrawLowSpectrum+0x620>)
 801539c:	edd3 7a01 	vldr	s15, [r3, #4]
 80153a0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80153a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80153a8:	f100 874a 	bmi.w	8016240 <DrawLowSpectrum+0x1490>
 80153ac:	4d09      	ldr	r5, [pc, #36]	; (80153d4 <DrawLowSpectrum+0x624>)
 80153ae:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80153b0:	2134      	movs	r1, #52	; 0x34
 80153b2:	f04f 0ec7 	mov.w	lr, #199	; 0xc7
 80153b6:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80153ba:	f04f 0cc6 	mov.w	ip, #198	; 0xc6
 80153be:	27c5      	movs	r7, #197	; 0xc5
 80153c0:	e0bd      	b.n	801553e <DrawLowSpectrum+0x78e>
 80153c2:	bf00      	nop
 80153c4:	200174f0 	.word	0x200174f0
 80153c8:	20000c70 	.word	0x20000c70
 80153cc:	0802646e 	.word	0x0802646e
 80153d0:	2000fa7c 	.word	0x2000fa7c
 80153d4:	08026590 	.word	0x08026590
 80153d8:	461c4000 	.word	0x461c4000
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80153dc:	f89a 8000 	ldrb.w	r8, [sl]
 80153e0:	fb01 b808 	mla	r8, r1, r8, fp
 80153e4:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 80153e8:	fb0e 2404 	mla	r4, lr, r4, r2
 80153ec:	f504 749a 	add.w	r4, r4, #308	; 0x134
 80153f0:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80153f4:	f013 0602 	ands.w	r6, r3, #2
 80153f8:	f040 80b7 	bne.w	801556a <DrawLowSpectrum+0x7ba>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80153fc:	f89a 8000 	ldrb.w	r8, [sl]
 8015400:	fb01 b808 	mla	r8, r1, r8, fp
 8015404:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8015408:	fb0c 2404 	mla	r4, ip, r4, r2
 801540c:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015410:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015414:	f013 0604 	ands.w	r6, r3, #4
 8015418:	f040 80b7 	bne.w	801558a <DrawLowSpectrum+0x7da>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801541c:	f89a 8000 	ldrb.w	r8, [sl]
 8015420:	fb01 b808 	mla	r8, r1, r8, fp
 8015424:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8015428:	fb07 2404 	mla	r4, r7, r4, r2
 801542c:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015430:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015434:	f013 0608 	ands.w	r6, r3, #8
 8015438:	f040 80b7 	bne.w	80155aa <DrawLowSpectrum+0x7fa>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801543c:	f89a 8000 	ldrb.w	r8, [sl]
 8015440:	f04f 09c4 	mov.w	r9, #196	; 0xc4
 8015444:	fb01 b808 	mla	r8, r1, r8, fp
 8015448:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 801544c:	fb09 2404 	mla	r4, r9, r4, r2
 8015450:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015454:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015458:	f013 0610 	ands.w	r6, r3, #16
 801545c:	f040 80b7 	bne.w	80155ce <DrawLowSpectrum+0x81e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015460:	f89a 8000 	ldrb.w	r8, [sl]
 8015464:	fb01 b808 	mla	r8, r1, r8, fp
 8015468:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 801546c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8015470:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 8015474:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015478:	4414      	add	r4, r2
 801547a:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801547e:	f013 0620 	ands.w	r6, r3, #32
 8015482:	f040 80b7 	bne.w	80155f4 <DrawLowSpectrum+0x844>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015486:	f89a 8000 	ldrb.w	r8, [sl]
 801548a:	f04f 09c2 	mov.w	r9, #194	; 0xc2
 801548e:	fb01 b808 	mla	r8, r1, r8, fp
 8015492:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8015496:	fb09 2404 	mla	r4, r9, r4, r2
 801549a:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801549e:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80154a2:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 80154a6:	f040 80b7 	bne.w	8015618 <DrawLowSpectrum+0x868>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80154aa:	f89a 8000 	ldrb.w	r8, [sl]
 80154ae:	fb01 b808 	mla	r8, r1, r8, fp
 80154b2:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 80154b6:	eb04 0944 	add.w	r9, r4, r4, lsl #1
 80154ba:	eb04 1489 	add.w	r4, r4, r9, lsl #6
 80154be:	f504 749a 	add.w	r4, r4, #308	; 0x134
 80154c2:	4414      	add	r4, r2
 80154c4:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80154c8:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 80154cc:	f040 80b7 	bne.w	801563e <DrawLowSpectrum+0x88e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80154d0:	f89a 8000 	ldrb.w	r8, [sl]
 80154d4:	fb01 b808 	mla	r8, r1, r8, fp
 80154d8:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 80154dc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80154e0:	eb02 1484 	add.w	r4, r2, r4, lsl #6
 80154e4:	f504 749a 	add.w	r4, r4, #308	; 0x134
 80154e8:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80154ec:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 80154f0:	f040 80b7 	bne.w	8015662 <DrawLowSpectrum+0x8b2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80154f4:	f89a 8000 	ldrb.w	r8, [sl]
			if(((element[i] >> k) & 1) == 1) {
 80154f8:	f413 7300 	ands.w	r3, r3, #512	; 0x200
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80154fc:	fb01 b808 	mla	r8, r1, r8, fp
 8015500:	e9d8 8417 	ldrd	r8, r4, [r8, #92]	; 0x5c
 8015504:	eb04 0944 	add.w	r9, r4, r4, lsl #1
 8015508:	ebc4 1489 	rsb	r4, r4, r9, lsl #6
 801550c:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015510:	4414      	add	r4, r2
 8015512:	f828 6014 	strh.w	r6, [r8, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015516:	f040 80b7 	bne.w	8015688 <DrawLowSpectrum+0x8d8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801551a:	f89a 6000 	ldrb.w	r6, [sl]
 801551e:	f04f 08be 	mov.w	r8, #190	; 0xbe
 8015522:	fb01 b606 	mla	r6, r1, r6, fp
 8015526:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801552a:	fb08 2404 	mla	r4, r8, r4, r2
	while(i < width) {
 801552e:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015530:	f504 749a 	add.w	r4, r4, #308	; 0x134
	while(i < width) {
 8015534:	2a0a      	cmp	r2, #10
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015536:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 801553a:	f000 80b6 	beq.w	80156aa <DrawLowSpectrum+0x8fa>
			if(((element[i] >> k) & 1) == 1) {
 801553e:	f835 3b02 	ldrh.w	r3, [r5], #2
 8015542:	f013 0601 	ands.w	r6, r3, #1
 8015546:	f43f af49 	beq.w	80153dc <DrawLowSpectrum+0x62c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801554a:	f89a 6000 	ldrb.w	r6, [sl]
 801554e:	fb01 b606 	mla	r6, r1, r6, fp
 8015552:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015556:	fb0e 2404 	mla	r4, lr, r4, r2
 801555a:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801555e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015562:	f013 0602 	ands.w	r6, r3, #2
 8015566:	f43f af49 	beq.w	80153fc <DrawLowSpectrum+0x64c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801556a:	f89a 6000 	ldrb.w	r6, [sl]
 801556e:	fb01 b606 	mla	r6, r1, r6, fp
 8015572:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015576:	fb0c 2404 	mla	r4, ip, r4, r2
 801557a:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801557e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015582:	f013 0604 	ands.w	r6, r3, #4
 8015586:	f43f af49 	beq.w	801541c <DrawLowSpectrum+0x66c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801558a:	f89a 6000 	ldrb.w	r6, [sl]
 801558e:	fb01 b606 	mla	r6, r1, r6, fp
 8015592:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015596:	fb07 2404 	mla	r4, r7, r4, r2
 801559a:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801559e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80155a2:	f013 0608 	ands.w	r6, r3, #8
 80155a6:	f43f af49 	beq.w	801543c <DrawLowSpectrum+0x68c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80155aa:	f89a 6000 	ldrb.w	r6, [sl]
 80155ae:	f04f 08c4 	mov.w	r8, #196	; 0xc4
 80155b2:	fb01 b606 	mla	r6, r1, r6, fp
 80155b6:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80155ba:	fb08 2404 	mla	r4, r8, r4, r2
 80155be:	f504 749a 	add.w	r4, r4, #308	; 0x134
 80155c2:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80155c6:	f013 0610 	ands.w	r6, r3, #16
 80155ca:	f43f af49 	beq.w	8015460 <DrawLowSpectrum+0x6b0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80155ce:	f89a 6000 	ldrb.w	r6, [sl]
 80155d2:	fb01 b606 	mla	r6, r1, r6, fp
 80155d6:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80155da:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80155de:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 80155e2:	f504 749a 	add.w	r4, r4, #308	; 0x134
 80155e6:	4414      	add	r4, r2
 80155e8:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80155ec:	f013 0620 	ands.w	r6, r3, #32
 80155f0:	f43f af49 	beq.w	8015486 <DrawLowSpectrum+0x6d6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80155f4:	f89a 6000 	ldrb.w	r6, [sl]
 80155f8:	f04f 08c2 	mov.w	r8, #194	; 0xc2
 80155fc:	fb01 b606 	mla	r6, r1, r6, fp
 8015600:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015604:	fb08 2404 	mla	r4, r8, r4, r2
 8015608:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801560c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015610:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 8015614:	f43f af49 	beq.w	80154aa <DrawLowSpectrum+0x6fa>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015618:	f89a 6000 	ldrb.w	r6, [sl]
 801561c:	fb01 b606 	mla	r6, r1, r6, fp
 8015620:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015624:	eb04 0844 	add.w	r8, r4, r4, lsl #1
 8015628:	eb04 1488 	add.w	r4, r4, r8, lsl #6
 801562c:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015630:	4414      	add	r4, r2
 8015632:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015636:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 801563a:	f43f af49 	beq.w	80154d0 <DrawLowSpectrum+0x720>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801563e:	f89a 6000 	ldrb.w	r6, [sl]
 8015642:	fb01 b606 	mla	r6, r1, r6, fp
 8015646:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801564a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 801564e:	eb02 1484 	add.w	r4, r2, r4, lsl #6
 8015652:	f504 749a 	add.w	r4, r4, #308	; 0x134
 8015656:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801565a:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 801565e:	f43f af49 	beq.w	80154f4 <DrawLowSpectrum+0x744>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015662:	f89a 6000 	ldrb.w	r6, [sl]
			if(((element[i] >> k) & 1) == 1) {
 8015666:	f413 7300 	ands.w	r3, r3, #512	; 0x200
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801566a:	fb01 b606 	mla	r6, r1, r6, fp
 801566e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015672:	eb04 0844 	add.w	r8, r4, r4, lsl #1
 8015676:	ebc4 1488 	rsb	r4, r4, r8, lsl #6
 801567a:	f504 749a 	add.w	r4, r4, #308	; 0x134
 801567e:	4414      	add	r4, r2
 8015680:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015684:	f43f af49 	beq.w	801551a <DrawLowSpectrum+0x76a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015688:	f89a 4000 	ldrb.w	r4, [sl]
 801568c:	26be      	movs	r6, #190	; 0xbe
 801568e:	fb01 b404 	mla	r4, r1, r4, fp
 8015692:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015696:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 801569a:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801569c:	f503 739a 	add.w	r3, r3, #308	; 0x134
	while(i < width) {
 80156a0:	2a0a      	cmp	r2, #10
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80156a2:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
	while(i < width) {
 80156a6:	f47f af4a 	bne.w	801553e <DrawLowSpectrum+0x78e>
	uint16_t percent = (abs)(trak.percent * 10000);
 80156aa:	ed1f 7ab5 	vldr	s14, [pc, #-724]	; 80153d8 <DrawLowSpectrum+0x628>
	if(display.pitchmode == 0) {
 80156ae:	4bc6      	ldr	r3, [pc, #792]	; (80159c8 <DrawLowSpectrum+0xc18>)
	uint16_t percent = (abs)(trak.percent * 10000);
 80156b0:	ee67 7a87 	vmul.f32	s15, s15, s14
	if(display.pitchmode == 0) {
 80156b4:	785a      	ldrb	r2, [r3, #1]
	uint16_t percent = (abs)(trak.percent * 10000);
 80156b6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80156ba:	ee17 8a90 	vmov	r8, s15
 80156be:	f1b8 0f00 	cmp.w	r8, #0
 80156c2:	bfb8      	it	lt
 80156c4:	f1c8 0800 	rsblt	r8, r8, #0
 80156c8:	fa1f f388 	uxth.w	r3, r8
 80156cc:	9303      	str	r3, [sp, #12]
	if(display.pitchmode == 0) {
 80156ce:	2a00      	cmp	r2, #0
 80156d0:	f001 8347 	beq.w	8016d62 <DrawLowSpectrum+0x1fb2>
	else if(display.pitchmode == 1) {
 80156d4:	2a01      	cmp	r2, #1
 80156d6:	f002 8486 	beq.w	8017fe6 <DrawLowSpectrum+0x3236>
	else if(display.pitchmode == 2) {
 80156da:	2a02      	cmp	r2, #2
 80156dc:	f002 82b3 	beq.w	8017c46 <DrawLowSpectrum+0x2e96>
	else if(display.pitchmode == 3) {
 80156e0:	2a03      	cmp	r2, #3
 80156e2:	f002 8656 	beq.w	8018392 <DrawLowSpectrum+0x35e2>
 80156e6:	48b9      	ldr	r0, [pc, #740]	; (80159cc <DrawLowSpectrum+0xc1c>)
 80156e8:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80156ea:	2134      	movs	r1, #52	; 0x34
 80156ec:	f04f 08b2 	mov.w	r8, #178	; 0xb2
 80156f0:	f100 0e44 	add.w	lr, r0, #68	; 0x44
 80156f4:	f64f 75ff 	movw	r5, #65535	; 0xffff
 80156f8:	f04f 0cb1 	mov.w	ip, #177	; 0xb1
 80156fc:	e04b      	b.n	8015796 <DrawLowSpectrum+0x9e6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80156fe:	f89a 9000 	ldrb.w	r9, [sl]
 8015702:	fb01 b909 	mla	r9, r1, r9, fp
 8015706:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 801570a:	fb08 2404 	mla	r4, r8, r4, r2
 801570e:	3428      	adds	r4, #40	; 0x28
 8015710:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015714:	f013 0602 	ands.w	r6, r3, #2
 8015718:	d150      	bne.n	80157bc <DrawLowSpectrum+0xa0c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801571a:	f89a 9000 	ldrb.w	r9, [sl]
 801571e:	fb01 b909 	mla	r9, r1, r9, fp
 8015722:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015726:	fb0c 2404 	mla	r4, ip, r4, r2
 801572a:	3428      	adds	r4, #40	; 0x28
 801572c:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015730:	f013 0604 	ands.w	r6, r3, #4
 8015734:	d150      	bne.n	80157d8 <DrawLowSpectrum+0xa28>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015736:	f89a 9000 	ldrb.w	r9, [sl]
 801573a:	27b0      	movs	r7, #176	; 0xb0
 801573c:	fb01 b909 	mla	r9, r1, r9, fp
 8015740:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015744:	fb07 2404 	mla	r4, r7, r4, r2
 8015748:	3428      	adds	r4, #40	; 0x28
 801574a:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801574e:	f013 0608 	ands.w	r6, r3, #8
 8015752:	d150      	bne.n	80157f6 <DrawLowSpectrum+0xa46>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015754:	f89a 9000 	ldrb.w	r9, [sl]
 8015758:	27af      	movs	r7, #175	; 0xaf
			if(((element[i] >> k) & 1) == 1) {
 801575a:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801575e:	fb01 b909 	mla	r9, r1, r9, fp
 8015762:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015766:	fb07 2404 	mla	r4, r7, r4, r2
 801576a:	f104 0428 	add.w	r4, r4, #40	; 0x28
 801576e:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015772:	d150      	bne.n	8015816 <DrawLowSpectrum+0xa66>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015774:	f89a 6000 	ldrb.w	r6, [sl]
 8015778:	27ae      	movs	r7, #174	; 0xae
	while(i < width) {
 801577a:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801577c:	fb01 b606 	mla	r6, r1, r6, fp
 8015780:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015784:	fb07 2404 	mla	r4, r7, r4, r2
	while(i < width) {
 8015788:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801578c:	f104 0428 	add.w	r4, r4, #40	; 0x28
 8015790:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8015794:	d050      	beq.n	8015838 <DrawLowSpectrum+0xa88>
			if(((element[i] >> k) & 1) == 1) {
 8015796:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 801579a:	f013 0601 	ands.w	r6, r3, #1
 801579e:	d0ae      	beq.n	80156fe <DrawLowSpectrum+0x94e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80157a0:	f89a 6000 	ldrb.w	r6, [sl]
 80157a4:	fb01 b606 	mla	r6, r1, r6, fp
 80157a8:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80157ac:	fb08 2404 	mla	r4, r8, r4, r2
 80157b0:	3428      	adds	r4, #40	; 0x28
 80157b2:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80157b6:	f013 0602 	ands.w	r6, r3, #2
 80157ba:	d0ae      	beq.n	801571a <DrawLowSpectrum+0x96a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80157bc:	f89a 6000 	ldrb.w	r6, [sl]
 80157c0:	fb01 b606 	mla	r6, r1, r6, fp
 80157c4:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80157c8:	fb0c 2404 	mla	r4, ip, r4, r2
 80157cc:	3428      	adds	r4, #40	; 0x28
 80157ce:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80157d2:	f013 0604 	ands.w	r6, r3, #4
 80157d6:	d0ae      	beq.n	8015736 <DrawLowSpectrum+0x986>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80157d8:	f89a 6000 	ldrb.w	r6, [sl]
 80157dc:	27b0      	movs	r7, #176	; 0xb0
 80157de:	fb01 b606 	mla	r6, r1, r6, fp
 80157e2:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80157e6:	fb07 2404 	mla	r4, r7, r4, r2
 80157ea:	3428      	adds	r4, #40	; 0x28
 80157ec:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80157f0:	f013 0608 	ands.w	r6, r3, #8
 80157f4:	d0ae      	beq.n	8015754 <DrawLowSpectrum+0x9a4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80157f6:	f89a 6000 	ldrb.w	r6, [sl]
 80157fa:	27af      	movs	r7, #175	; 0xaf
			if(((element[i] >> k) & 1) == 1) {
 80157fc:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015800:	fb01 b606 	mla	r6, r1, r6, fp
 8015804:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015808:	fb07 2404 	mla	r4, r7, r4, r2
 801580c:	f104 0428 	add.w	r4, r4, #40	; 0x28
 8015810:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015814:	d0ae      	beq.n	8015774 <DrawLowSpectrum+0x9c4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015816:	f89a 4000 	ldrb.w	r4, [sl]
 801581a:	26ae      	movs	r6, #174	; 0xae
	while(i < width) {
 801581c:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801581e:	fb01 b404 	mla	r4, r1, r4, fp
 8015822:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015826:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 801582a:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801582e:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8015832:	f824 5013 	strh.w	r5, [r4, r3, lsl #1]
	while(i < width) {
 8015836:	d1ae      	bne.n	8015796 <DrawLowSpectrum+0x9e6>
 8015838:	4865      	ldr	r0, [pc, #404]	; (80159d0 <DrawLowSpectrum+0xc20>)
 801583a:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801583c:	2134      	movs	r1, #52	; 0x34
 801583e:	f04f 08b2 	mov.w	r8, #178	; 0xb2
 8015842:	f100 0e3e 	add.w	lr, r0, #62	; 0x3e
 8015846:	f64f 75ff 	movw	r5, #65535	; 0xffff
 801584a:	f04f 0cb1 	mov.w	ip, #177	; 0xb1
 801584e:	e04e      	b.n	80158ee <DrawLowSpectrum+0xb3e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015850:	f89a 9000 	ldrb.w	r9, [sl]
 8015854:	fb01 b909 	mla	r9, r1, r9, fp
 8015858:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 801585c:	fb08 2404 	mla	r4, r8, r4, r2
 8015860:	f504 749b 	add.w	r4, r4, #310	; 0x136
 8015864:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015868:	f013 0602 	ands.w	r6, r3, #2
 801586c:	d153      	bne.n	8015916 <DrawLowSpectrum+0xb66>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801586e:	f89a 9000 	ldrb.w	r9, [sl]
 8015872:	fb01 b909 	mla	r9, r1, r9, fp
 8015876:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 801587a:	fb0c 2404 	mla	r4, ip, r4, r2
 801587e:	f504 749b 	add.w	r4, r4, #310	; 0x136
 8015882:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015886:	f013 0604 	ands.w	r6, r3, #4
 801588a:	d153      	bne.n	8015934 <DrawLowSpectrum+0xb84>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801588c:	f89a 9000 	ldrb.w	r9, [sl]
 8015890:	27b0      	movs	r7, #176	; 0xb0
 8015892:	fb01 b909 	mla	r9, r1, r9, fp
 8015896:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 801589a:	fb07 2404 	mla	r4, r7, r4, r2
 801589e:	f504 749b 	add.w	r4, r4, #310	; 0x136
 80158a2:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80158a6:	f013 0608 	ands.w	r6, r3, #8
 80158aa:	d153      	bne.n	8015954 <DrawLowSpectrum+0xba4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80158ac:	f89a 9000 	ldrb.w	r9, [sl]
 80158b0:	27af      	movs	r7, #175	; 0xaf
			if(((element[i] >> k) & 1) == 1) {
 80158b2:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80158b6:	fb01 b909 	mla	r9, r1, r9, fp
 80158ba:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 80158be:	fb07 2404 	mla	r4, r7, r4, r2
 80158c2:	f504 749b 	add.w	r4, r4, #310	; 0x136
 80158c6:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80158ca:	d153      	bne.n	8015974 <DrawLowSpectrum+0xbc4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80158cc:	f89a 6000 	ldrb.w	r6, [sl]
 80158d0:	27ae      	movs	r7, #174	; 0xae
	while(i < width) {
 80158d2:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80158d4:	fb01 b606 	mla	r6, r1, r6, fp
 80158d8:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80158dc:	fb07 2404 	mla	r4, r7, r4, r2
	while(i < width) {
 80158e0:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80158e4:	f504 749b 	add.w	r4, r4, #310	; 0x136
 80158e8:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 80158ec:	d053      	beq.n	8015996 <DrawLowSpectrum+0xbe6>
			if(((element[i] >> k) & 1) == 1) {
 80158ee:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 80158f2:	f013 0601 	ands.w	r6, r3, #1
 80158f6:	d0ab      	beq.n	8015850 <DrawLowSpectrum+0xaa0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80158f8:	f89a 6000 	ldrb.w	r6, [sl]
 80158fc:	fb01 b606 	mla	r6, r1, r6, fp
 8015900:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015904:	fb08 2404 	mla	r4, r8, r4, r2
 8015908:	f504 749b 	add.w	r4, r4, #310	; 0x136
 801590c:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015910:	f013 0602 	ands.w	r6, r3, #2
 8015914:	d0ab      	beq.n	801586e <DrawLowSpectrum+0xabe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015916:	f89a 6000 	ldrb.w	r6, [sl]
 801591a:	fb01 b606 	mla	r6, r1, r6, fp
 801591e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015922:	fb0c 2404 	mla	r4, ip, r4, r2
 8015926:	f504 749b 	add.w	r4, r4, #310	; 0x136
 801592a:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801592e:	f013 0604 	ands.w	r6, r3, #4
 8015932:	d0ab      	beq.n	801588c <DrawLowSpectrum+0xadc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015934:	f89a 6000 	ldrb.w	r6, [sl]
 8015938:	27b0      	movs	r7, #176	; 0xb0
 801593a:	fb01 b606 	mla	r6, r1, r6, fp
 801593e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015942:	fb07 2404 	mla	r4, r7, r4, r2
 8015946:	f504 749b 	add.w	r4, r4, #310	; 0x136
 801594a:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801594e:	f013 0608 	ands.w	r6, r3, #8
 8015952:	d0ab      	beq.n	80158ac <DrawLowSpectrum+0xafc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015954:	f89a 6000 	ldrb.w	r6, [sl]
 8015958:	27af      	movs	r7, #175	; 0xaf
			if(((element[i] >> k) & 1) == 1) {
 801595a:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801595e:	fb01 b606 	mla	r6, r1, r6, fp
 8015962:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015966:	fb07 2404 	mla	r4, r7, r4, r2
 801596a:	f504 749b 	add.w	r4, r4, #310	; 0x136
 801596e:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015972:	d0ab      	beq.n	80158cc <DrawLowSpectrum+0xb1c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015974:	f89a 4000 	ldrb.w	r4, [sl]
 8015978:	26ae      	movs	r6, #174	; 0xae
	while(i < width) {
 801597a:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801597c:	fb01 b404 	mla	r4, r1, r4, fp
 8015980:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015984:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 8015988:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801598c:	f503 739b 	add.w	r3, r3, #310	; 0x136
 8015990:	f824 5013 	strh.w	r5, [r4, r3, lsl #1]
	while(i < width) {
 8015994:	d1ab      	bne.n	80158ee <DrawLowSpectrum+0xb3e>
	if(display.cuemode == 1) {
 8015996:	4b0c      	ldr	r3, [pc, #48]	; (80159c8 <DrawLowSpectrum+0xc18>)
 8015998:	789b      	ldrb	r3, [r3, #2]
 801599a:	2b01      	cmp	r3, #1
 801599c:	f001 85ac 	beq.w	80174f8 <DrawLowSpectrum+0x2748>
	if(display.quantize == 1) {
 80159a0:	4b09      	ldr	r3, [pc, #36]	; (80159c8 <DrawLowSpectrum+0xc18>)
 80159a2:	7c5b      	ldrb	r3, [r3, #17]
 80159a4:	2b01      	cmp	r3, #1
 80159a6:	f001 84ff 	beq.w	80173a8 <DrawLowSpectrum+0x25f8>
	if(display.mastertempomode == 1) {
 80159aa:	4b07      	ldr	r3, [pc, #28]	; (80159c8 <DrawLowSpectrum+0xc18>)
 80159ac:	795b      	ldrb	r3, [r3, #5]
 80159ae:	2b01      	cmp	r3, #1
 80159b0:	f001 8368 	beq.w	8017084 <DrawLowSpectrum+0x22d4>
 80159b4:	22ff      	movs	r2, #255	; 0xff
 80159b6:	4c07      	ldr	r4, [pc, #28]	; (80159d4 <DrawLowSpectrum+0xc24>)
 80159b8:	20a5      	movs	r0, #165	; 0xa5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80159ba:	2534      	movs	r5, #52	; 0x34
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80159bc:	f64f 76ff 	movw	r6, #65535	; 0xffff
 80159c0:	4613      	mov	r3, r2
	if(display.mastertempomode == 1) {
 80159c2:	22cc      	movs	r2, #204	; 0xcc
 80159c4:	e016      	b.n	80159f4 <DrawLowSpectrum+0xc44>
 80159c6:	bf00      	nop
 80159c8:	20000c70 	.word	0x20000c70
 80159cc:	08026c9e 	.word	0x08026c9e
 80159d0:	08026c5e 	.word	0x08026c5e
 80159d4:	08026450 	.word	0x08026450
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80159d8:	f89a 3000 	ldrb.w	r3, [sl]
 80159dc:	fb05 b303 	mla	r3, r5, r3, fp
 80159e0:	e9d3 7117 	ldrd	r7, r1, [r3, #92]	; 0x5c
 80159e4:	fb01 0302 	mla	r3, r1, r2, r0
		while(k < height) {
 80159e8:	3a01      	subs	r2, #1
 80159ea:	2abc      	cmp	r2, #188	; 0xbc
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80159ec:	f827 6013 	strh.w	r6, [r7, r3, lsl #1]
		while(k < height) {
 80159f0:	d013      	beq.n	8015a1a <DrawLowSpectrum+0xc6a>
			if(((element[i] >> k) & 1) == 1) {
 80159f2:	8823      	ldrh	r3, [r4, #0]
 80159f4:	f1c2 01cc 	rsb	r1, r2, #204	; 0xcc
 80159f8:	410b      	asrs	r3, r1
 80159fa:	f013 0301 	ands.w	r3, r3, #1
 80159fe:	d1eb      	bne.n	80159d8 <DrawLowSpectrum+0xc28>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015a00:	f89a 1000 	ldrb.w	r1, [sl]
 8015a04:	fb05 b101 	mla	r1, r5, r1, fp
 8015a08:	e9d1 c717 	ldrd	ip, r7, [r1, #92]	; 0x5c
 8015a0c:	fb07 0102 	mla	r1, r7, r2, r0
		while(k < height) {
 8015a10:	3a01      	subs	r2, #1
 8015a12:	2abc      	cmp	r2, #188	; 0xbc
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015a14:	f82c 3011 	strh.w	r3, [ip, r1, lsl #1]
		while(k < height) {
 8015a18:	d1eb      	bne.n	80159f2 <DrawLowSpectrum+0xc42>
	while(i < width) {
 8015a1a:	3001      	adds	r0, #1
 8015a1c:	28b4      	cmp	r0, #180	; 0xb4
 8015a1e:	d01d      	beq.n	8015a5c <DrawLowSpectrum+0xcac>
			if(((element[i] >> k) & 1) == 1) {
 8015a20:	f834 3f02 	ldrh.w	r3, [r4, #2]!
 8015a24:	e7cd      	b.n	80159c2 <DrawLowSpectrum+0xc12>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8015a26:	2234      	movs	r2, #52	; 0x34
 8015a28:	f89a 3000 	ldrb.w	r3, [sl]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8015a2c:	4881      	ldr	r0, [pc, #516]	; (8015c34 <DrawLowSpectrum+0xe84>)
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8015a2e:	fb02 b303 	mla	r3, r2, r3, fp
		Rectangle(40, 253, file_pos, 3, 0x00FFFFFF);
 8015a32:	4a81      	ldr	r2, [pc, #516]	; (8015c38 <DrawLowSpectrum+0xe88>)
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8015a34:	e9d3 5417 	ldrd	r5, r4, [r3, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8015a38:	8816      	ldrh	r6, [r2, #0]
		Rectangle(40, 253, file_pos, 3, 0x00FFFFFF);
 8015a3a:	9207      	str	r2, [sp, #28]
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8015a3c:	1ba3      	subs	r3, r4, r6
 8015a3e:	f8c9 300c 	str.w	r3, [r9, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8015a42:	f7eb ffe7 	bl	8001a14 <HAL_DMA2D_Init>
 8015a46:	2800      	cmp	r0, #0
 8015a48:	f47f ab4c 	bne.w	80150e4 <DrawLowSpectrum+0x334>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8015a4c:	ebc4 1284 	rsb	r2, r4, r4, lsl #6
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8015a50:	4633      	mov	r3, r6
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8015a52:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8015a56:	3228      	adds	r2, #40	; 0x28
 8015a58:	f002 b8e3 	b.w	8017c22 <DrawLowSpectrum+0x2e72>
 8015a5c:	4d77      	ldr	r5, [pc, #476]	; (8015c3c <DrawLowSpectrum+0xe8c>)
	while(i < width) {
 8015a5e:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015a60:	2134      	movs	r1, #52	; 0x34
 8015a62:	f04f 08cc 	mov.w	r8, #204	; 0xcc
 8015a66:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8015a6a:	f04f 0ecb 	mov.w	lr, #203	; 0xcb
 8015a6e:	f04f 0cca 	mov.w	ip, #202	; 0xca
 8015a72:	e066      	b.n	8015b42 <DrawLowSpectrum+0xd92>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015a74:	f89a 9000 	ldrb.w	r9, [sl]
 8015a78:	fb01 b909 	mla	r9, r1, r9, fp
 8015a7c:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015a80:	fb08 2404 	mla	r4, r8, r4, r2
 8015a84:	34d5      	adds	r4, #213	; 0xd5
 8015a86:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015a8a:	f013 0602 	ands.w	r6, r3, #2
 8015a8e:	d16b      	bne.n	8015b68 <DrawLowSpectrum+0xdb8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015a90:	f89a 9000 	ldrb.w	r9, [sl]
 8015a94:	fb01 b909 	mla	r9, r1, r9, fp
 8015a98:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015a9c:	fb0e 2404 	mla	r4, lr, r4, r2
 8015aa0:	34d5      	adds	r4, #213	; 0xd5
 8015aa2:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015aa6:	f013 0604 	ands.w	r6, r3, #4
 8015aaa:	d16b      	bne.n	8015b84 <DrawLowSpectrum+0xdd4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015aac:	f89a 9000 	ldrb.w	r9, [sl]
 8015ab0:	fb01 b909 	mla	r9, r1, r9, fp
 8015ab4:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015ab8:	fb0c 2404 	mla	r4, ip, r4, r2
 8015abc:	34d5      	adds	r4, #213	; 0xd5
 8015abe:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015ac2:	f013 0608 	ands.w	r6, r3, #8
 8015ac6:	d16b      	bne.n	8015ba0 <DrawLowSpectrum+0xdf0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015ac8:	f89a 9000 	ldrb.w	r9, [sl]
 8015acc:	27c9      	movs	r7, #201	; 0xc9
 8015ace:	fb01 b909 	mla	r9, r1, r9, fp
 8015ad2:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015ad6:	fb07 2404 	mla	r4, r7, r4, r2
 8015ada:	34d5      	adds	r4, #213	; 0xd5
 8015adc:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015ae0:	f013 0610 	ands.w	r6, r3, #16
 8015ae4:	d16b      	bne.n	8015bbe <DrawLowSpectrum+0xe0e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015ae6:	f89a 9000 	ldrb.w	r9, [sl]
 8015aea:	27c8      	movs	r7, #200	; 0xc8
 8015aec:	fb01 b909 	mla	r9, r1, r9, fp
 8015af0:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015af4:	fb07 2404 	mla	r4, r7, r4, r2
 8015af8:	34d5      	adds	r4, #213	; 0xd5
 8015afa:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015afe:	f013 0620 	ands.w	r6, r3, #32
 8015b02:	d16b      	bne.n	8015bdc <DrawLowSpectrum+0xe2c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015b04:	f89a 9000 	ldrb.w	r9, [sl]
 8015b08:	27c7      	movs	r7, #199	; 0xc7
			if(((element[i] >> k) & 1) == 1) {
 8015b0a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015b0e:	fb01 b909 	mla	r9, r1, r9, fp
 8015b12:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015b16:	fb07 2404 	mla	r4, r7, r4, r2
 8015b1a:	f104 04d5 	add.w	r4, r4, #213	; 0xd5
 8015b1e:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015b22:	d16b      	bne.n	8015bfc <DrawLowSpectrum+0xe4c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015b24:	f89a 6000 	ldrb.w	r6, [sl]
 8015b28:	27c6      	movs	r7, #198	; 0xc6
 8015b2a:	fb01 b606 	mla	r6, r1, r6, fp
 8015b2e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015b32:	fb07 2404 	mla	r4, r7, r4, r2
	while(i < width) {
 8015b36:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015b38:	34d5      	adds	r4, #213	; 0xd5
	while(i < width) {
 8015b3a:	2a06      	cmp	r2, #6
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015b3c:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8015b40:	d06b      	beq.n	8015c1a <DrawLowSpectrum+0xe6a>
			if(((element[i] >> k) & 1) == 1) {
 8015b42:	f835 3b02 	ldrh.w	r3, [r5], #2
 8015b46:	f013 0601 	ands.w	r6, r3, #1
 8015b4a:	d093      	beq.n	8015a74 <DrawLowSpectrum+0xcc4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015b4c:	f89a 6000 	ldrb.w	r6, [sl]
 8015b50:	fb01 b606 	mla	r6, r1, r6, fp
 8015b54:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015b58:	fb08 2404 	mla	r4, r8, r4, r2
 8015b5c:	34d5      	adds	r4, #213	; 0xd5
 8015b5e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015b62:	f013 0602 	ands.w	r6, r3, #2
 8015b66:	d093      	beq.n	8015a90 <DrawLowSpectrum+0xce0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015b68:	f89a 6000 	ldrb.w	r6, [sl]
 8015b6c:	fb01 b606 	mla	r6, r1, r6, fp
 8015b70:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015b74:	fb0e 2404 	mla	r4, lr, r4, r2
 8015b78:	34d5      	adds	r4, #213	; 0xd5
 8015b7a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015b7e:	f013 0604 	ands.w	r6, r3, #4
 8015b82:	d093      	beq.n	8015aac <DrawLowSpectrum+0xcfc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015b84:	f89a 6000 	ldrb.w	r6, [sl]
 8015b88:	fb01 b606 	mla	r6, r1, r6, fp
 8015b8c:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015b90:	fb0c 2404 	mla	r4, ip, r4, r2
 8015b94:	34d5      	adds	r4, #213	; 0xd5
 8015b96:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015b9a:	f013 0608 	ands.w	r6, r3, #8
 8015b9e:	d093      	beq.n	8015ac8 <DrawLowSpectrum+0xd18>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015ba0:	f89a 6000 	ldrb.w	r6, [sl]
 8015ba4:	27c9      	movs	r7, #201	; 0xc9
 8015ba6:	fb01 b606 	mla	r6, r1, r6, fp
 8015baa:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015bae:	fb07 2404 	mla	r4, r7, r4, r2
 8015bb2:	34d5      	adds	r4, #213	; 0xd5
 8015bb4:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015bb8:	f013 0610 	ands.w	r6, r3, #16
 8015bbc:	d093      	beq.n	8015ae6 <DrawLowSpectrum+0xd36>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015bbe:	f89a 6000 	ldrb.w	r6, [sl]
 8015bc2:	27c8      	movs	r7, #200	; 0xc8
 8015bc4:	fb01 b606 	mla	r6, r1, r6, fp
 8015bc8:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015bcc:	fb07 2404 	mla	r4, r7, r4, r2
 8015bd0:	34d5      	adds	r4, #213	; 0xd5
 8015bd2:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015bd6:	f013 0620 	ands.w	r6, r3, #32
 8015bda:	d093      	beq.n	8015b04 <DrawLowSpectrum+0xd54>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015bdc:	f89a 6000 	ldrb.w	r6, [sl]
 8015be0:	27c7      	movs	r7, #199	; 0xc7
			if(((element[i] >> k) & 1) == 1) {
 8015be2:	f013 0340 	ands.w	r3, r3, #64	; 0x40
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015be6:	fb01 b606 	mla	r6, r1, r6, fp
 8015bea:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015bee:	fb07 2404 	mla	r4, r7, r4, r2
 8015bf2:	f104 04d5 	add.w	r4, r4, #213	; 0xd5
 8015bf6:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015bfa:	d093      	beq.n	8015b24 <DrawLowSpectrum+0xd74>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015bfc:	f89a 4000 	ldrb.w	r4, [sl]
 8015c00:	26c6      	movs	r6, #198	; 0xc6
 8015c02:	fb01 b404 	mla	r4, r1, r4, fp
 8015c06:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015c0a:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 8015c0e:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015c10:	33d5      	adds	r3, #213	; 0xd5
	while(i < width) {
 8015c12:	2a06      	cmp	r2, #6
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015c14:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
	while(i < width) {
 8015c18:	d193      	bne.n	8015b42 <DrawLowSpectrum+0xd92>
 8015c1a:	4d09      	ldr	r5, [pc, #36]	; (8015c40 <DrawLowSpectrum+0xe90>)
 8015c1c:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015c1e:	2134      	movs	r1, #52	; 0x34
 8015c20:	f04f 08cc 	mov.w	r8, #204	; 0xcc
 8015c24:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8015c28:	f04f 0ecb 	mov.w	lr, #203	; 0xcb
 8015c2c:	f04f 0cca 	mov.w	ip, #202	; 0xca
 8015c30:	e060      	b.n	8015cf4 <DrawLowSpectrum+0xf44>
 8015c32:	bf00      	nop
 8015c34:	20000c94 	.word	0x20000c94
 8015c38:	2000ec88 	.word	0x2000ec88
 8015c3c:	08026c54 	.word	0x08026c54
 8015c40:	08026344 	.word	0x08026344
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015c44:	f89a 9000 	ldrb.w	r9, [sl]
 8015c48:	fb01 b909 	mla	r9, r1, r9, fp
 8015c4c:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015c50:	fb08 2404 	mla	r4, r8, r4, r2
 8015c54:	34fc      	adds	r4, #252	; 0xfc
 8015c56:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015c5a:	f013 0602 	ands.w	r6, r3, #2
 8015c5e:	d15c      	bne.n	8015d1a <DrawLowSpectrum+0xf6a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015c60:	f89a 9000 	ldrb.w	r9, [sl]
 8015c64:	fb01 b909 	mla	r9, r1, r9, fp
 8015c68:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015c6c:	fb0e 2404 	mla	r4, lr, r4, r2
 8015c70:	34fc      	adds	r4, #252	; 0xfc
 8015c72:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015c76:	f013 0604 	ands.w	r6, r3, #4
 8015c7a:	d15c      	bne.n	8015d36 <DrawLowSpectrum+0xf86>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015c7c:	f89a 9000 	ldrb.w	r9, [sl]
 8015c80:	fb01 b909 	mla	r9, r1, r9, fp
 8015c84:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015c88:	fb0c 2404 	mla	r4, ip, r4, r2
 8015c8c:	34fc      	adds	r4, #252	; 0xfc
 8015c8e:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015c92:	f013 0608 	ands.w	r6, r3, #8
 8015c96:	d15c      	bne.n	8015d52 <DrawLowSpectrum+0xfa2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015c98:	f89a 9000 	ldrb.w	r9, [sl]
 8015c9c:	27c9      	movs	r7, #201	; 0xc9
 8015c9e:	fb01 b909 	mla	r9, r1, r9, fp
 8015ca2:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015ca6:	fb07 2404 	mla	r4, r7, r4, r2
 8015caa:	34fc      	adds	r4, #252	; 0xfc
 8015cac:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015cb0:	f013 0610 	ands.w	r6, r3, #16
 8015cb4:	d15c      	bne.n	8015d70 <DrawLowSpectrum+0xfc0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015cb6:	f89a 9000 	ldrb.w	r9, [sl]
 8015cba:	27c8      	movs	r7, #200	; 0xc8
			if(((element[i] >> k) & 1) == 1) {
 8015cbc:	f013 0320 	ands.w	r3, r3, #32
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015cc0:	fb01 b909 	mla	r9, r1, r9, fp
 8015cc4:	e9d9 9417 	ldrd	r9, r4, [r9, #92]	; 0x5c
 8015cc8:	fb07 2404 	mla	r4, r7, r4, r2
 8015ccc:	f104 04fc 	add.w	r4, r4, #252	; 0xfc
 8015cd0:	f829 6014 	strh.w	r6, [r9, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015cd4:	d15c      	bne.n	8015d90 <DrawLowSpectrum+0xfe0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015cd6:	f89a 6000 	ldrb.w	r6, [sl]
 8015cda:	27c7      	movs	r7, #199	; 0xc7
 8015cdc:	fb01 b606 	mla	r6, r1, r6, fp
 8015ce0:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015ce4:	fb07 2404 	mla	r4, r7, r4, r2
	while(i < width) {
 8015ce8:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015cea:	34fc      	adds	r4, #252	; 0xfc
	while(i < width) {
 8015cec:	2a05      	cmp	r2, #5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8015cee:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8015cf2:	d05c      	beq.n	8015dae <DrawLowSpectrum+0xffe>
			if(((element[i] >> k) & 1) == 1) {
 8015cf4:	f835 3b02 	ldrh.w	r3, [r5], #2
 8015cf8:	f013 0601 	ands.w	r6, r3, #1
 8015cfc:	d0a2      	beq.n	8015c44 <DrawLowSpectrum+0xe94>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015cfe:	f89a 6000 	ldrb.w	r6, [sl]
 8015d02:	fb01 b606 	mla	r6, r1, r6, fp
 8015d06:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015d0a:	fb08 2404 	mla	r4, r8, r4, r2
 8015d0e:	34fc      	adds	r4, #252	; 0xfc
 8015d10:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015d14:	f013 0602 	ands.w	r6, r3, #2
 8015d18:	d0a2      	beq.n	8015c60 <DrawLowSpectrum+0xeb0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d1a:	f89a 6000 	ldrb.w	r6, [sl]
 8015d1e:	fb01 b606 	mla	r6, r1, r6, fp
 8015d22:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015d26:	fb0e 2404 	mla	r4, lr, r4, r2
 8015d2a:	34fc      	adds	r4, #252	; 0xfc
 8015d2c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015d30:	f013 0604 	ands.w	r6, r3, #4
 8015d34:	d0a2      	beq.n	8015c7c <DrawLowSpectrum+0xecc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d36:	f89a 6000 	ldrb.w	r6, [sl]
 8015d3a:	fb01 b606 	mla	r6, r1, r6, fp
 8015d3e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015d42:	fb0c 2404 	mla	r4, ip, r4, r2
 8015d46:	34fc      	adds	r4, #252	; 0xfc
 8015d48:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015d4c:	f013 0608 	ands.w	r6, r3, #8
 8015d50:	d0a2      	beq.n	8015c98 <DrawLowSpectrum+0xee8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d52:	f89a 6000 	ldrb.w	r6, [sl]
 8015d56:	27c9      	movs	r7, #201	; 0xc9
 8015d58:	fb01 b606 	mla	r6, r1, r6, fp
 8015d5c:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015d60:	fb07 2404 	mla	r4, r7, r4, r2
 8015d64:	34fc      	adds	r4, #252	; 0xfc
 8015d66:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015d6a:	f013 0610 	ands.w	r6, r3, #16
 8015d6e:	d0a2      	beq.n	8015cb6 <DrawLowSpectrum+0xf06>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d70:	f89a 6000 	ldrb.w	r6, [sl]
 8015d74:	27c8      	movs	r7, #200	; 0xc8
			if(((element[i] >> k) & 1) == 1) {
 8015d76:	f013 0320 	ands.w	r3, r3, #32
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d7a:	fb01 b606 	mla	r6, r1, r6, fp
 8015d7e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8015d82:	fb07 2404 	mla	r4, r7, r4, r2
 8015d86:	f104 04fc 	add.w	r4, r4, #252	; 0xfc
 8015d8a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8015d8e:	d0a2      	beq.n	8015cd6 <DrawLowSpectrum+0xf26>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015d90:	f89a 4000 	ldrb.w	r4, [sl]
 8015d94:	26c7      	movs	r6, #199	; 0xc7
 8015d96:	fb01 b404 	mla	r4, r1, r4, fp
 8015d9a:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8015d9e:	fb06 2303 	mla	r3, r6, r3, r2
	while(i < width) {
 8015da2:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015da4:	33fc      	adds	r3, #252	; 0xfc
	while(i < width) {
 8015da6:	2a05      	cmp	r2, #5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015da8:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
	while(i < width) {
 8015dac:	d1a2      	bne.n	8015cf4 <DrawLowSpectrum+0xf44>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015dae:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8015db2:	f89a 2000 	ldrb.w	r2, [sl]
 8015db6:	f04f 08cc 	mov.w	r8, #204	; 0xcc
 8015dba:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8015dbe:	fb0c b202 	mla	r2, ip, r2, fp
 8015dc2:	f04f 0ecb 	mov.w	lr, #203	; 0xcb
 8015dc6:	20ca      	movs	r0, #202	; 0xca
 8015dc8:	26c9      	movs	r6, #201	; 0xc9
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015dca:	f06f 477f 	mvn.w	r7, #4278190080	; 0xff000000
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015dce:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8015dd2:	fb08 f303 	mul.w	r3, r8, r3
 8015dd6:	33fc      	adds	r3, #252	; 0xfc
 8015dd8:	f822 4013 	strh.w	r4, [r2, r3, lsl #1]
 8015ddc:	f89a 2000 	ldrb.w	r2, [sl]
 8015de0:	fb0c b202 	mla	r2, ip, r2, fp
 8015de4:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8015de8:	fb0e f303 	mul.w	r3, lr, r3
 8015dec:	33fc      	adds	r3, #252	; 0xfc
 8015dee:	f822 4013 	strh.w	r4, [r2, r3, lsl #1]
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015df2:	230d      	movs	r3, #13
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015df4:	f89a 1000 	ldrb.w	r1, [sl]
 8015df8:	fb0c b101 	mla	r1, ip, r1, fp
 8015dfc:	e9d1 1217 	ldrd	r1, r2, [r1, #92]	; 0x5c
 8015e00:	fb00 f202 	mul.w	r2, r0, r2
 8015e04:	32fc      	adds	r2, #252	; 0xfc
 8015e06:	f821 4012 	strh.w	r4, [r1, r2, lsl #1]
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e0a:	22b7      	movs	r2, #183	; 0xb7
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e0c:	f89a 5000 	ldrb.w	r5, [sl]
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e10:	2128      	movs	r1, #40	; 0x28
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e12:	fb0c b505 	mla	r5, ip, r5, fp
 8015e16:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8015e1a:	fb06 f000 	mul.w	r0, r6, r0
 8015e1e:	26ca      	movs	r6, #202	; 0xca
 8015e20:	30fc      	adds	r0, #252	; 0xfc
 8015e22:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
 8015e26:	f89a 5000 	ldrb.w	r5, [sl]
 8015e2a:	fb0c b505 	mla	r5, ip, r5, fp
 8015e2e:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8015e32:	fb08 f000 	mul.w	r0, r8, r0
 8015e36:	30fd      	adds	r0, #253	; 0xfd
 8015e38:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
 8015e3c:	f89a 5000 	ldrb.w	r5, [sl]
 8015e40:	fb0c b505 	mla	r5, ip, r5, fp
 8015e44:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8015e48:	fb0e f000 	mul.w	r0, lr, r0
 8015e4c:	30fd      	adds	r0, #253	; 0xfd
 8015e4e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
 8015e52:	f89a 5000 	ldrb.w	r5, [sl]
 8015e56:	fb0c b505 	mla	r5, ip, r5, fp
 8015e5a:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8015e5e:	fb06 f000 	mul.w	r0, r6, r0
 8015e62:	26c9      	movs	r6, #201	; 0xc9
 8015e64:	30fd      	adds	r0, #253	; 0xfd
 8015e66:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
 8015e6a:	f89a 5000 	ldrb.w	r5, [sl]
 8015e6e:	fb0c b505 	mla	r5, ip, r5, fp
 8015e72:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8015e76:	fb06 f000 	mul.w	r0, r6, r0
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e7a:	4ebc      	ldr	r6, [pc, #752]	; (801616c <DrawLowSpectrum+0x13bc>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e7c:	30fd      	adds	r0, #253	; 0xfd
 8015e7e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
 8015e82:	f89a 9000 	ldrb.w	r9, [sl]
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e86:	4dba      	ldr	r5, [pc, #744]	; (8016170 <DrawLowSpectrum+0x13c0>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e88:	fb0c b909 	mla	r9, ip, r9, fp
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e8c:	6828      	ldr	r0, [r5, #0]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e8e:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 8015e92:	f8d9 905c 	ldr.w	r9, [r9, #92]	; 0x5c
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015e96:	3001      	adds	r0, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015e98:	fb08 f505 	mul.w	r5, r8, r5
 8015e9c:	35fe      	adds	r5, #254	; 0xfe
 8015e9e:	f829 4015 	strh.w	r4, [r9, r5, lsl #1]
 8015ea2:	f89a 8000 	ldrb.w	r8, [sl]
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015ea6:	fb86 9500 	smull	r9, r5, r6, r0
 8015eaa:	17c0      	asrs	r0, r0, #31
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015eac:	26ca      	movs	r6, #202	; 0xca
 8015eae:	fb0c b808 	mla	r8, ip, r8, fp
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015eb2:	ebc0 00a5 	rsb	r0, r0, r5, asr #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015eb6:	f8d8 5060 	ldr.w	r5, [r8, #96]	; 0x60
 8015eba:	f8d8 805c 	ldr.w	r8, [r8, #92]	; 0x5c
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015ebe:	b2c0      	uxtb	r0, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015ec0:	fb0e f505 	mul.w	r5, lr, r5
 8015ec4:	35fe      	adds	r5, #254	; 0xfe
 8015ec6:	f828 4015 	strh.w	r4, [r8, r5, lsl #1]
 8015eca:	f89a e000 	ldrb.w	lr, [sl]
 8015ece:	fb0c be0e 	mla	lr, ip, lr, fp
 8015ed2:	f8de 5060 	ldr.w	r5, [lr, #96]	; 0x60
 8015ed6:	f8de e05c 	ldr.w	lr, [lr, #92]	; 0x5c
 8015eda:	fb06 f505 	mul.w	r5, r6, r5
 8015ede:	26c9      	movs	r6, #201	; 0xc9
 8015ee0:	35fe      	adds	r5, #254	; 0xfe
 8015ee2:	f82e 4015 	strh.w	r4, [lr, r5, lsl #1]
 8015ee6:	f89a 5000 	ldrb.w	r5, [sl]
 8015eea:	fb0c bc05 	mla	ip, ip, r5, fp
 8015eee:	f8dc 5060 	ldr.w	r5, [ip, #96]	; 0x60
 8015ef2:	f8dc c05c 	ldr.w	ip, [ip, #92]	; 0x5c
 8015ef6:	fb06 f505 	mul.w	r5, r6, r5
	DrawDigit((Track_number + 1) % 10, 60, 183, 13, 0x00FFFFFF);
 8015efa:	4e9c      	ldr	r6, [pc, #624]	; (801616c <DrawLowSpectrum+0x13bc>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8015efc:	35fe      	adds	r5, #254	; 0xfe
 8015efe:	f82c 4015 	strh.w	r4, [ip, r5, lsl #1]
	DrawDigit((Track_number + 1) % 10, 60, 183, 13, 0x00FFFFFF);
 8015f02:	4d9b      	ldr	r5, [pc, #620]	; (8016170 <DrawLowSpectrum+0x13c0>)
	DrawDigit((Track_number + 1) / 10, 40, 183, 13, 0x00FFFFFF);
 8015f04:	9700      	str	r7, [sp, #0]
 8015f06:	f7fe fb7b 	bl	8014600 <DrawDigit>
	DrawDigit((Track_number + 1) % 10, 60, 183, 13, 0x00FFFFFF);
 8015f0a:	6828      	ldr	r0, [r5, #0]
 8015f0c:	230d      	movs	r3, #13
 8015f0e:	22b7      	movs	r2, #183	; 0xb7
 8015f10:	3001      	adds	r0, #1
 8015f12:	213c      	movs	r1, #60	; 0x3c
 8015f14:	9700      	str	r7, [sp, #0]
 8015f16:	fb86 4500 	smull	r4, r5, r6, r0
 8015f1a:	17c4      	asrs	r4, r0, #31
 8015f1c:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
 8015f20:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8015f24:	eba0 0044 	sub.w	r0, r0, r4, lsl #1
 8015f28:	b2c0      	uxtb	r0, r0
 8015f2a:	f7fe fb69 	bl	8014600 <DrawDigit>
	if(display.timemode == 0) {
 8015f2e:	4b91      	ldr	r3, [pc, #580]	; (8016174 <DrawLowSpectrum+0x13c4>)
 8015f30:	781b      	ldrb	r3, [r3, #0]
		DrawDigit(rmin / 10, 134, 184, 11, 0x00FFFFFF);
 8015f32:	9700      	str	r7, [sp, #0]
	if(display.timemode == 0) {
 8015f34:	2b00      	cmp	r3, #0
 8015f36:	f040 8133 	bne.w	80161a0 <DrawLowSpectrum+0x13f0>
		DrawDigit(rmin / 10, 134, 184, 11, 0x00FFFFFF);
 8015f3a:	f8df 8260 	ldr.w	r8, [pc, #608]	; 801619c <DrawLowSpectrum+0x13ec>
 8015f3e:	22b8      	movs	r2, #184	; 0xb8
 8015f40:	230b      	movs	r3, #11
 8015f42:	2186      	movs	r1, #134	; 0x86
 8015f44:	f998 0000 	ldrsb.w	r0, [r8]
		DrawDigit(rsec / 10, 185, 184, 11, 0x00FFFFFF);
 8015f48:	4d8b      	ldr	r5, [pc, #556]	; (8016178 <DrawLowSpectrum+0x13c8>)
		DrawDigit(rmin / 10, 134, 184, 11, 0x00FFFFFF);
 8015f4a:	fb86 6c00 	smull	r6, ip, r6, r0
 8015f4e:	17c0      	asrs	r0, r0, #31
		DrawDigit(rmin % 10, 148, 184, 11, 0x00FFFFFF);
 8015f50:	4e86      	ldr	r6, [pc, #536]	; (801616c <DrawLowSpectrum+0x13bc>)
		DrawDigit(rmin / 10, 134, 184, 11, 0x00FFFFFF);
 8015f52:	ebc0 00ac 	rsb	r0, r0, ip, asr #2
		DrawDigit(rfr / 20, 224, 184, 11, 0x00FFFFFF);
 8015f56:	4c89      	ldr	r4, [pc, #548]	; (801617c <DrawLowSpectrum+0x13cc>)
		DrawDigit(rmin / 10, 134, 184, 11, 0x00FFFFFF);
 8015f58:	b2c0      	uxtb	r0, r0
 8015f5a:	f7fe fb51 	bl	8014600 <DrawDigit>
		DrawDigit(rmin % 10, 148, 184, 11, 0x00FFFFFF);
 8015f5e:	f998 1000 	ldrsb.w	r1, [r8]
 8015f62:	230b      	movs	r3, #11
 8015f64:	9700      	str	r7, [sp, #0]
 8015f66:	fb86 2001 	smull	r2, r0, r6, r1
 8015f6a:	17ca      	asrs	r2, r1, #31
 8015f6c:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 8015f70:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8015f74:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 8015f78:	2194      	movs	r1, #148	; 0x94
 8015f7a:	b2d0      	uxtb	r0, r2
 8015f7c:	22b8      	movs	r2, #184	; 0xb8
 8015f7e:	f7fe fb3f 	bl	8014600 <DrawDigit>
		DrawDigit(rsec / 10, 185, 184, 11, 0x00FFFFFF);
 8015f82:	9700      	str	r7, [sp, #0]
 8015f84:	f995 0000 	ldrsb.w	r0, [r5]
 8015f88:	22b8      	movs	r2, #184	; 0xb8
 8015f8a:	230b      	movs	r3, #11
 8015f8c:	21b9      	movs	r1, #185	; 0xb9
 8015f8e:	fb86 6c00 	smull	r6, ip, r6, r0
 8015f92:	17c0      	asrs	r0, r0, #31
 8015f94:	ebc0 00ac 	rsb	r0, r0, ip, asr #2
 8015f98:	b2c0      	uxtb	r0, r0
 8015f9a:	f7fe fb31 	bl	8014600 <DrawDigit>
		DrawDigit(rsec % 10, 199, 184, 11, 0x00FFFFFF);
 8015f9e:	f995 1000 	ldrsb.w	r1, [r5]
 8015fa2:	4d72      	ldr	r5, [pc, #456]	; (801616c <DrawLowSpectrum+0x13bc>)
 8015fa4:	230b      	movs	r3, #11
 8015fa6:	9700      	str	r7, [sp, #0]
 8015fa8:	fb85 2001 	smull	r2, r0, r5, r1
 8015fac:	17ca      	asrs	r2, r1, #31
 8015fae:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 8015fb2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8015fb6:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 8015fba:	21c7      	movs	r1, #199	; 0xc7
 8015fbc:	b2d0      	uxtb	r0, r2
 8015fbe:	22b8      	movs	r2, #184	; 0xb8
 8015fc0:	f7fe fb1e 	bl	8014600 <DrawDigit>
		DrawDigit(rfr / 20, 224, 184, 11, 0x00FFFFFF);
 8015fc4:	9700      	str	r7, [sp, #0]
 8015fc6:	f9b4 3000 	ldrsh.w	r3, [r4]
 8015fca:	fb85 2003 	smull	r2, r0, r5, r3
 8015fce:	17db      	asrs	r3, r3, #31
 8015fd0:	ebc3 00e0 	rsb	r0, r3, r0, asr #3
 8015fd4:	b2c0      	uxtb	r0, r0
		DrawDigit(fr / 20, 224, 184, 11, 0x00FFFFFF);
 8015fd6:	22b8      	movs	r2, #184	; 0xb8
 8015fd8:	230b      	movs	r3, #11
 8015fda:	21e0      	movs	r1, #224	; 0xe0
 8015fdc:	f7fe fb10 	bl	8014600 <DrawDigit>
		DrawDigit((fr / 2) % 10, 238, 184, 11, 0x00FFFFFF);
 8015fe0:	f9b4 3000 	ldrsh.w	r3, [r4]
 8015fe4:	4961      	ldr	r1, [pc, #388]	; (801616c <DrawLowSpectrum+0x13bc>)
 8015fe6:	2b00      	cmp	r3, #0
 8015fe8:	bfb8      	it	lt
 8015fea:	3301      	addlt	r3, #1
 8015fec:	105b      	asrs	r3, r3, #1
 8015fee:	fb81 2103 	smull	r2, r1, r1, r3
 8015ff2:	17da      	asrs	r2, r3, #31
 8015ff4:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 8015ff8:	21ee      	movs	r1, #238	; 0xee
 8015ffa:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8015ffe:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
 8016002:	22b8      	movs	r2, #184	; 0xb8
 8016004:	b2d8      	uxtb	r0, r3
 8016006:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801600a:	9300      	str	r3, [sp, #0]
 801600c:	230b      	movs	r3, #11
 801600e:	f7fe faf7 	bl	8014600 <DrawDigit>
	uint16_t bpm = rekordbox.bpm[beat] * (1 + trak.percent);
 8016012:	4b5b      	ldr	r3, [pc, #364]	; (8016180 <DrawLowSpectrum+0x13d0>)
 8016014:	4a5b      	ldr	r2, [pc, #364]	; (8016184 <DrawLowSpectrum+0x13d4>)
 8016016:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801601a:	edd3 7a01 	vldr	s15, [r3, #4]
 801601e:	4b5a      	ldr	r3, [pc, #360]	; (8016188 <DrawLowSpectrum+0x13d8>)
 8016020:	ee37 7a87 	vadd.f32	s14, s15, s14
 8016024:	681b      	ldr	r3, [r3, #0]
 8016026:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 801602a:	f8b3 3504 	ldrh.w	r3, [r3, #1284]	; 0x504
 801602e:	ee07 3a90 	vmov	s15, r3
	if(bpm / 10000 > 0) {
 8016032:	f242 730f 	movw	r3, #9999	; 0x270f
	uint16_t bpm = rekordbox.bpm[beat] * (1 + trak.percent);
 8016036:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801603a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801603e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8016042:	ee17 2a90 	vmov	r2, s15
 8016046:	b294      	uxth	r4, r2
	if(bpm / 10000 > 0) {
 8016048:	429c      	cmp	r4, r3
 801604a:	f200 87f3 	bhi.w	8017034 <DrawLowSpectrum+0x2284>
	if(bpm / 1000 > 0) {
 801604e:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
 8016052:	f080 87fc 	bcs.w	801704e <DrawLowSpectrum+0x229e>
		DrawDigit(((bpm / 100) % 100) / 10, 415, 176, 10, 0x00FFFFFF);
 8016056:	4e4d      	ldr	r6, [pc, #308]	; (801618c <DrawLowSpectrum+0x13dc>)
 8016058:	fba6 3604 	umull	r3, r6, r6, r4
 801605c:	0976      	lsrs	r6, r6, #5
	DrawDigit(((bpm / 100) % 100) % 10, 430, 176, 10, 0x00FFFFFF);
 801605e:	4d4c      	ldr	r5, [pc, #304]	; (8016190 <DrawLowSpectrum+0x13e0>)
 8016060:	f06f 477f 	mvn.w	r7, #4278190080	; 0xff000000
 8016064:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8016068:	fba5 2306 	umull	r2, r3, r5, r6
 801606c:	22b0      	movs	r2, #176	; 0xb0
 801606e:	9700      	str	r7, [sp, #0]
 8016070:	08db      	lsrs	r3, r3, #3
 8016072:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8016076:	eba6 0343 	sub.w	r3, r6, r3, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801607a:	26c2      	movs	r6, #194	; 0xc2
	DrawDigit(((bpm / 100) % 100) % 10, 430, 176, 10, 0x00FFFFFF);
 801607c:	b2d8      	uxtb	r0, r3
 801607e:	230a      	movs	r3, #10
 8016080:	f7fe fabe 	bl	8014600 <DrawDigit>
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 8016084:	fba5 2304 	umull	r2, r3, r5, r4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016088:	f64f 7cff 	movw	ip, #65535	; 0xffff
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 801608c:	08db      	lsrs	r3, r3, #3
 801608e:	fba5 1203 	umull	r1, r2, r5, r3
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016092:	f89a 1000 	ldrb.w	r1, [sl]
 8016096:	2534      	movs	r5, #52	; 0x34
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 8016098:	08d2      	lsrs	r2, r2, #3
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801609a:	fb05 b101 	mla	r1, r5, r1, fp
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 801609e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80160a2:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80160a6:	e9d1 1217 	ldrd	r1, r2, [r1, #92]	; 0x5c
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 80160aa:	b2d8      	uxtb	r0, r3
 80160ac:	2307      	movs	r3, #7
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80160ae:	fb06 f202 	mul.w	r2, r6, r2
 80160b2:	f502 72dd 	add.w	r2, r2, #442	; 0x1ba
 80160b6:	f821 c012 	strh.w	ip, [r1, r2, lsl #1]
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 80160ba:	22b6      	movs	r2, #182	; 0xb6
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80160bc:	f89a e000 	ldrb.w	lr, [sl]
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 80160c0:	f240 11bd 	movw	r1, #445	; 0x1bd
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80160c4:	fb05 be0e 	mla	lr, r5, lr, fp
 80160c8:	e9de e417 	ldrd	lr, r4, [lr, #92]	; 0x5c
 80160cc:	eb04 0844 	add.w	r8, r4, r4, lsl #1
 80160d0:	eb04 1488 	add.w	r4, r4, r8, lsl #6
 80160d4:	f504 74dd 	add.w	r4, r4, #442	; 0x1ba
 80160d8:	f82e c014 	strh.w	ip, [lr, r4, lsl #1]
 80160dc:	f89a e000 	ldrb.w	lr, [sl]
 80160e0:	fb05 be0e 	mla	lr, r5, lr, fp
 80160e4:	f8de 4060 	ldr.w	r4, [lr, #96]	; 0x60
 80160e8:	fb06 f404 	mul.w	r4, r6, r4
 80160ec:	f8de 605c 	ldr.w	r6, [lr, #92]	; 0x5c
 80160f0:	f204 14bb 	addw	r4, r4, #443	; 0x1bb
 80160f4:	f826 c014 	strh.w	ip, [r6, r4, lsl #1]
 80160f8:	f89a 6000 	ldrb.w	r6, [sl]
 80160fc:	fb05 b606 	mla	r6, r5, r6, fp
 8016100:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016104:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 8016108:	eb04 148e 	add.w	r4, r4, lr, lsl #6
 801610c:	f204 14bb 	addw	r4, r4, #443	; 0x1bb
 8016110:	f826 c014 	strh.w	ip, [r6, r4, lsl #1]
	DrawDigit((bpm / 10) % 10, 445, 182, 7, 0x00FFFFFF);
 8016114:	9700      	str	r7, [sp, #0]
 8016116:	f7fe fa73 	bl	8014600 <DrawDigit>
	if(rekordbox.state == 1) {
 801611a:	4b1e      	ldr	r3, [pc, #120]	; (8016194 <DrawLowSpectrum+0x13e4>)
 801611c:	f893 23d4 	ldrb.w	r2, [r3, #980]	; 0x3d4
 8016120:	2a01      	cmp	r2, #1
 8016122:	f000 83a7 	beq.w	8016874 <DrawLowSpectrum+0x1ac4>
	if(rekordbox.cues > 1) {
 8016126:	4b1c      	ldr	r3, [pc, #112]	; (8016198 <DrawLowSpectrum+0x13e8>)
 8016128:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801612c:	2b01      	cmp	r3, #1
 801612e:	9305      	str	r3, [sp, #20]
 8016130:	f300 80d3 	bgt.w	80162da <DrawLowSpectrum+0x152a>
	if(display.loop == 1) {
 8016134:	4b0f      	ldr	r3, [pc, #60]	; (8016174 <DrawLowSpectrum+0x13c4>)
 8016136:	7c1b      	ldrb	r3, [r3, #16]
 8016138:	2b01      	cmp	r3, #1
 801613a:	f001 8357 	beq.w	80177ec <DrawLowSpectrum+0x2a3c>
	VLine(40 + file_pos, 220, 40, 0x00FFFFFF);
 801613e:	9c07      	ldr	r4, [sp, #28]
 8016140:	2228      	movs	r2, #40	; 0x28
 8016142:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8016146:	21dc      	movs	r1, #220	; 0xdc
 8016148:	6820      	ldr	r0, [r4, #0]
 801614a:	4410      	add	r0, r2
 801614c:	b280      	uxth	r0, r0
 801614e:	f7fe f9cb 	bl	80144e8 <VLine>
	VLine(41 + file_pos, 220, 40, 0x00FFFFFF);
 8016152:	6820      	ldr	r0, [r4, #0]
 8016154:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8016158:	2228      	movs	r2, #40	; 0x28
 801615a:	3029      	adds	r0, #41	; 0x29
 801615c:	21dc      	movs	r1, #220	; 0xdc
 801615e:	b280      	uxth	r0, r0
}
 8016160:	b009      	add	sp, #36	; 0x24
 8016162:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	VLine(41 + file_pos, 220, 40, 0x00FFFFFF);
 8016166:	f7fe b9bf 	b.w	80144e8 <VLine>
 801616a:	bf00      	nop
 801616c:	66666667 	.word	0x66666667
 8016170:	2000e9fc 	.word	0x2000e9fc
 8016174:	20000c70 	.word	0x20000c70
 8016178:	2000fa71 	.word	0x2000fa71
 801617c:	2000fa6e 	.word	0x2000fa6e
 8016180:	2000fa7c 	.word	0x2000fa7c
 8016184:	200154f0 	.word	0x200154f0
 8016188:	20000c64 	.word	0x20000c64
 801618c:	51eb851f 	.word	0x51eb851f
 8016190:	cccccccd 	.word	0xcccccccd
 8016194:	200184f0 	.word	0x200184f0
 8016198:	200174f0 	.word	0x200174f0
 801619c:	2000fa70 	.word	0x2000fa70
		DrawDigit(min / 10, 134, 184, 11, 0x00FFFFFF);
 80161a0:	f8df 8168 	ldr.w	r8, [pc, #360]	; 801630c <DrawLowSpectrum+0x155c>
 80161a4:	22b8      	movs	r2, #184	; 0xb8
 80161a6:	4e54      	ldr	r6, [pc, #336]	; (80162f8 <DrawLowSpectrum+0x1548>)
 80161a8:	230b      	movs	r3, #11
 80161aa:	f998 0000 	ldrsb.w	r0, [r8]
 80161ae:	2186      	movs	r1, #134	; 0x86
		DrawDigit(sec / 10, 185, 184, 11, 0x00FFFFFF);
 80161b0:	4d52      	ldr	r5, [pc, #328]	; (80162fc <DrawLowSpectrum+0x154c>)
		DrawDigit(min / 10, 134, 184, 11, 0x00FFFFFF);
 80161b2:	fb86 6c00 	smull	r6, ip, r6, r0
 80161b6:	17c0      	asrs	r0, r0, #31
		DrawDigit(min % 10, 148, 184, 11, 0x00FFFFFF);
 80161b8:	4e4f      	ldr	r6, [pc, #316]	; (80162f8 <DrawLowSpectrum+0x1548>)
		DrawDigit(min / 10, 134, 184, 11, 0x00FFFFFF);
 80161ba:	ebc0 00ac 	rsb	r0, r0, ip, asr #2
		DrawDigit(fr / 20, 224, 184, 11, 0x00FFFFFF);
 80161be:	4c50      	ldr	r4, [pc, #320]	; (8016300 <DrawLowSpectrum+0x1550>)
		DrawDigit(min / 10, 134, 184, 11, 0x00FFFFFF);
 80161c0:	b2c0      	uxtb	r0, r0
 80161c2:	f7fe fa1d 	bl	8014600 <DrawDigit>
		DrawDigit(min % 10, 148, 184, 11, 0x00FFFFFF);
 80161c6:	f998 1000 	ldrsb.w	r1, [r8]
 80161ca:	230b      	movs	r3, #11
 80161cc:	9700      	str	r7, [sp, #0]
 80161ce:	fb86 2001 	smull	r2, r0, r6, r1
 80161d2:	17ca      	asrs	r2, r1, #31
 80161d4:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 80161d8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80161dc:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 80161e0:	2194      	movs	r1, #148	; 0x94
 80161e2:	b2d0      	uxtb	r0, r2
 80161e4:	22b8      	movs	r2, #184	; 0xb8
 80161e6:	f7fe fa0b 	bl	8014600 <DrawDigit>
		DrawDigit(sec / 10, 185, 184, 11, 0x00FFFFFF);
 80161ea:	9700      	str	r7, [sp, #0]
 80161ec:	f995 0000 	ldrsb.w	r0, [r5]
 80161f0:	22b8      	movs	r2, #184	; 0xb8
 80161f2:	230b      	movs	r3, #11
 80161f4:	21b9      	movs	r1, #185	; 0xb9
 80161f6:	fb86 6c00 	smull	r6, ip, r6, r0
 80161fa:	17c0      	asrs	r0, r0, #31
 80161fc:	ebc0 00ac 	rsb	r0, r0, ip, asr #2
 8016200:	b2c0      	uxtb	r0, r0
 8016202:	f7fe f9fd 	bl	8014600 <DrawDigit>
		DrawDigit(sec % 10, 199, 184, 11, 0x00FFFFFF);
 8016206:	f995 1000 	ldrsb.w	r1, [r5]
 801620a:	4d3b      	ldr	r5, [pc, #236]	; (80162f8 <DrawLowSpectrum+0x1548>)
 801620c:	230b      	movs	r3, #11
 801620e:	9700      	str	r7, [sp, #0]
 8016210:	fb85 2001 	smull	r2, r0, r5, r1
 8016214:	17ca      	asrs	r2, r1, #31
 8016216:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 801621a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801621e:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 8016222:	21c7      	movs	r1, #199	; 0xc7
 8016224:	b2d0      	uxtb	r0, r2
 8016226:	22b8      	movs	r2, #184	; 0xb8
 8016228:	f7fe f9ea 	bl	8014600 <DrawDigit>
		DrawDigit(fr / 20, 224, 184, 11, 0x00FFFFFF);
 801622c:	9700      	str	r7, [sp, #0]
 801622e:	f9b4 3000 	ldrsh.w	r3, [r4]
 8016232:	fb85 2603 	smull	r2, r6, r5, r3
 8016236:	17db      	asrs	r3, r3, #31
 8016238:	ebc3 06e6 	rsb	r6, r3, r6, asr #3
 801623c:	b2f0      	uxtb	r0, r6
 801623e:	e6ca      	b.n	8015fd6 <DrawLowSpectrum+0x1226>
 8016240:	4830      	ldr	r0, [pc, #192]	; (8016304 <DrawLowSpectrum+0x1554>)
	if(trak.percent < 0) DrawElement(10, 2, 308, 195, 0x00FFFFFF, minus);
 8016242:	2100      	movs	r1, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016244:	2434      	movs	r4, #52	; 0x34
 8016246:	f64f 77ff 	movw	r7, #65535	; 0xffff
 801624a:	26c2      	movs	r6, #194	; 0xc2
 801624c:	e021      	b.n	8016292 <DrawLowSpectrum+0x14e2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801624e:	f89a c000 	ldrb.w	ip, [sl]
			if(((element[i] >> k) & 1) == 1) {
 8016252:	f013 0302 	ands.w	r3, r3, #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016256:	fb04 bc0c 	mla	ip, r4, ip, fp
 801625a:	e9dc c217 	ldrd	ip, r2, [ip, #92]	; 0x5c
 801625e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8016262:	eb02 1282 	add.w	r2, r2, r2, lsl #6
 8016266:	f502 729a 	add.w	r2, r2, #308	; 0x134
 801626a:	440a      	add	r2, r1
 801626c:	f82c 5012 	strh.w	r5, [ip, r2, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016270:	d126      	bne.n	80162c0 <DrawLowSpectrum+0x1510>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016272:	f89a 5000 	ldrb.w	r5, [sl]
 8016276:	fb04 b505 	mla	r5, r4, r5, fp
 801627a:	e9d5 5217 	ldrd	r5, r2, [r5, #92]	; 0x5c
 801627e:	fb06 1202 	mla	r2, r6, r2, r1
 8016282:	f502 729a 	add.w	r2, r2, #308	; 0x134
 8016286:	f825 3012 	strh.w	r3, [r5, r2, lsl #1]
	while(i < width) {
 801628a:	3101      	adds	r1, #1
 801628c:	290a      	cmp	r1, #10
 801628e:	f43f aa0c 	beq.w	80156aa <DrawLowSpectrum+0x8fa>
			if(((element[i] >> k) & 1) == 1) {
 8016292:	f830 3b02 	ldrh.w	r3, [r0], #2
 8016296:	f013 0501 	ands.w	r5, r3, #1
 801629a:	d0d8      	beq.n	801624e <DrawLowSpectrum+0x149e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801629c:	f89a 5000 	ldrb.w	r5, [sl]
			if(((element[i] >> k) & 1) == 1) {
 80162a0:	f013 0302 	ands.w	r3, r3, #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80162a4:	fb04 b505 	mla	r5, r4, r5, fp
 80162a8:	e9d5 5217 	ldrd	r5, r2, [r5, #92]	; 0x5c
 80162ac:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80162b0:	eb02 1282 	add.w	r2, r2, r2, lsl #6
 80162b4:	f502 729a 	add.w	r2, r2, #308	; 0x134
 80162b8:	440a      	add	r2, r1
 80162ba:	f825 7012 	strh.w	r7, [r5, r2, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80162be:	d0d8      	beq.n	8016272 <DrawLowSpectrum+0x14c2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80162c0:	f89a 2000 	ldrb.w	r2, [sl]
 80162c4:	fb04 b202 	mla	r2, r4, r2, fp
 80162c8:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 80162cc:	fb06 1303 	mla	r3, r6, r3, r1
 80162d0:	f503 739a 	add.w	r3, r3, #308	; 0x134
 80162d4:	f822 7013 	strh.w	r7, [r2, r3, lsl #1]
 80162d8:	e7d7      	b.n	801628a <DrawLowSpectrum+0x14da>
 80162da:	4d0b      	ldr	r5, [pc, #44]	; (8016308 <DrawLowSpectrum+0x1558>)
	if(rekordbox.cues > 1) {
 80162dc:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80162de:	2134      	movs	r1, #52	; 0x34
 80162e0:	f04f 08e6 	mov.w	r8, #230	; 0xe6
 80162e4:	f105 0e48 	add.w	lr, r5, #72	; 0x48
 80162e8:	f44f 4478 	mov.w	r4, #63488	; 0xf800
 80162ec:	f04f 09e5 	mov.w	r9, #229	; 0xe5
 80162f0:	f04f 0cdd 	mov.w	ip, #221	; 0xdd
 80162f4:	9503      	str	r5, [sp, #12]
 80162f6:	e0bf      	b.n	8016478 <DrawLowSpectrum+0x16c8>
 80162f8:	66666667 	.word	0x66666667
 80162fc:	2000fa72 	.word	0x2000fa72
 8016300:	2000f0d8 	.word	0x2000f0d8
 8016304:	0802643c 	.word	0x0802643c
 8016308:	080263f2 	.word	0x080263f2
 801630c:	2000f270 	.word	0x2000f270
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016310:	f89a 6000 	ldrb.w	r6, [sl]
 8016314:	fb01 b606 	mla	r6, r1, r6, fp
 8016318:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801631c:	fb08 2000 	mla	r0, r8, r0, r2
 8016320:	3001      	adds	r0, #1
 8016322:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016326:	f013 0502 	ands.w	r5, r3, #2
 801632a:	f040 80bc 	bne.w	80164a6 <DrawLowSpectrum+0x16f6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801632e:	f89a 6000 	ldrb.w	r6, [sl]
 8016332:	fb01 b606 	mla	r6, r1, r6, fp
 8016336:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801633a:	fb09 2000 	mla	r0, r9, r0, r2
 801633e:	3001      	adds	r0, #1
 8016340:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016344:	f013 0504 	ands.w	r5, r3, #4
 8016348:	f040 80bc 	bne.w	80164c4 <DrawLowSpectrum+0x1714>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801634c:	f89a 6000 	ldrb.w	r6, [sl]
 8016350:	27e4      	movs	r7, #228	; 0xe4
 8016352:	fb01 b606 	mla	r6, r1, r6, fp
 8016356:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801635a:	fb07 2000 	mla	r0, r7, r0, r2
 801635e:	3001      	adds	r0, #1
 8016360:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016364:	f013 0508 	ands.w	r5, r3, #8
 8016368:	f040 80bc 	bne.w	80164e4 <DrawLowSpectrum+0x1734>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801636c:	f89a 6000 	ldrb.w	r6, [sl]
 8016370:	27e3      	movs	r7, #227	; 0xe3
 8016372:	fb01 b606 	mla	r6, r1, r6, fp
 8016376:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801637a:	fb07 2000 	mla	r0, r7, r0, r2
 801637e:	3001      	adds	r0, #1
 8016380:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016384:	f013 0510 	ands.w	r5, r3, #16
 8016388:	f040 80bc 	bne.w	8016504 <DrawLowSpectrum+0x1754>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801638c:	f89a 6000 	ldrb.w	r6, [sl]
 8016390:	27e2      	movs	r7, #226	; 0xe2
 8016392:	fb01 b606 	mla	r6, r1, r6, fp
 8016396:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801639a:	fb07 2000 	mla	r0, r7, r0, r2
 801639e:	3001      	adds	r0, #1
 80163a0:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80163a4:	f013 0520 	ands.w	r5, r3, #32
 80163a8:	f040 80bc 	bne.w	8016524 <DrawLowSpectrum+0x1774>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80163ac:	f89a 6000 	ldrb.w	r6, [sl]
 80163b0:	fb01 b606 	mla	r6, r1, r6, fp
 80163b4:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80163b8:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 80163bc:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 80163c0:	3001      	adds	r0, #1
 80163c2:	4410      	add	r0, r2
 80163c4:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80163c8:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 80163cc:	f040 80bc 	bne.w	8016548 <DrawLowSpectrum+0x1798>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80163d0:	f89a 6000 	ldrb.w	r6, [sl]
 80163d4:	fb01 b606 	mla	r6, r1, r6, fp
 80163d8:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80163dc:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80163e0:	eb02 1040 	add.w	r0, r2, r0, lsl #5
 80163e4:	3001      	adds	r0, #1
 80163e6:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80163ea:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 80163ee:	f040 80bc 	bne.w	801656a <DrawLowSpectrum+0x17ba>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80163f2:	f89a 6000 	ldrb.w	r6, [sl]
 80163f6:	fb01 b606 	mla	r6, r1, r6, fp
 80163fa:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80163fe:	ebc0 07c0 	rsb	r7, r0, r0, lsl #3
 8016402:	ebc0 1047 	rsb	r0, r0, r7, lsl #5
 8016406:	3001      	adds	r0, #1
 8016408:	4410      	add	r0, r2
 801640a:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801640e:	f413 7580 	ands.w	r5, r3, #256	; 0x100
 8016412:	f040 80bc 	bne.w	801658e <DrawLowSpectrum+0x17de>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016416:	f89a 6000 	ldrb.w	r6, [sl]
 801641a:	27de      	movs	r7, #222	; 0xde
 801641c:	fb01 b606 	mla	r6, r1, r6, fp
 8016420:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016424:	fb07 2000 	mla	r0, r7, r0, r2
 8016428:	3001      	adds	r0, #1
 801642a:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801642e:	f413 7500 	ands.w	r5, r3, #512	; 0x200
 8016432:	f040 80bc 	bne.w	80165ae <DrawLowSpectrum+0x17fe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016436:	f89a 6000 	ldrb.w	r6, [sl]
			if(((element[i] >> k) & 1) == 1) {
 801643a:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801643e:	fb01 b606 	mla	r6, r1, r6, fp
 8016442:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016446:	fb0c 2000 	mla	r0, ip, r0, r2
 801644a:	f100 0001 	add.w	r0, r0, #1
 801644e:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016452:	f040 80bc 	bne.w	80165ce <DrawLowSpectrum+0x181e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016456:	f89a 5000 	ldrb.w	r5, [sl]
 801645a:	26dc      	movs	r6, #220	; 0xdc
 801645c:	fb01 b505 	mla	r5, r1, r5, fp
 8016460:	6e28      	ldr	r0, [r5, #96]	; 0x60
 8016462:	6ded      	ldr	r5, [r5, #92]	; 0x5c
 8016464:	fb06 2000 	mla	r0, r6, r0, r2
	while(i < width) {
 8016468:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801646a:	3001      	adds	r0, #1
 801646c:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
	while(i < width) {
 8016470:	9b03      	ldr	r3, [sp, #12]
 8016472:	459e      	cmp	lr, r3
 8016474:	f000 80bc 	beq.w	80165f0 <DrawLowSpectrum+0x1840>
			if(((element[i] >> k) & 1) == 1) {
 8016478:	9803      	ldr	r0, [sp, #12]
 801647a:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 801647e:	f013 0501 	ands.w	r5, r3, #1
 8016482:	9003      	str	r0, [sp, #12]
 8016484:	f43f af44 	beq.w	8016310 <DrawLowSpectrum+0x1560>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016488:	f89a 5000 	ldrb.w	r5, [sl]
 801648c:	fb01 b505 	mla	r5, r1, r5, fp
 8016490:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8016494:	fb08 2000 	mla	r0, r8, r0, r2
 8016498:	3001      	adds	r0, #1
 801649a:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801649e:	f013 0502 	ands.w	r5, r3, #2
 80164a2:	f43f af44 	beq.w	801632e <DrawLowSpectrum+0x157e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80164a6:	f89a 5000 	ldrb.w	r5, [sl]
 80164aa:	fb01 b505 	mla	r5, r1, r5, fp
 80164ae:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80164b2:	fb09 2000 	mla	r0, r9, r0, r2
 80164b6:	3001      	adds	r0, #1
 80164b8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80164bc:	f013 0504 	ands.w	r5, r3, #4
 80164c0:	f43f af44 	beq.w	801634c <DrawLowSpectrum+0x159c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80164c4:	f89a 5000 	ldrb.w	r5, [sl]
 80164c8:	26e4      	movs	r6, #228	; 0xe4
 80164ca:	fb01 b505 	mla	r5, r1, r5, fp
 80164ce:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80164d2:	fb06 2000 	mla	r0, r6, r0, r2
 80164d6:	3001      	adds	r0, #1
 80164d8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80164dc:	f013 0508 	ands.w	r5, r3, #8
 80164e0:	f43f af44 	beq.w	801636c <DrawLowSpectrum+0x15bc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80164e4:	f89a 5000 	ldrb.w	r5, [sl]
 80164e8:	26e3      	movs	r6, #227	; 0xe3
 80164ea:	fb01 b505 	mla	r5, r1, r5, fp
 80164ee:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80164f2:	fb06 2000 	mla	r0, r6, r0, r2
 80164f6:	3001      	adds	r0, #1
 80164f8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80164fc:	f013 0510 	ands.w	r5, r3, #16
 8016500:	f43f af44 	beq.w	801638c <DrawLowSpectrum+0x15dc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016504:	f89a 5000 	ldrb.w	r5, [sl]
 8016508:	26e2      	movs	r6, #226	; 0xe2
 801650a:	fb01 b505 	mla	r5, r1, r5, fp
 801650e:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8016512:	fb06 2000 	mla	r0, r6, r0, r2
 8016516:	3001      	adds	r0, #1
 8016518:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801651c:	f013 0520 	ands.w	r5, r3, #32
 8016520:	f43f af44 	beq.w	80163ac <DrawLowSpectrum+0x15fc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016524:	f89a 5000 	ldrb.w	r5, [sl]
 8016528:	fb01 b505 	mla	r5, r1, r5, fp
 801652c:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8016530:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016534:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016538:	3001      	adds	r0, #1
 801653a:	4410      	add	r0, r2
 801653c:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016540:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8016544:	f43f af44 	beq.w	80163d0 <DrawLowSpectrum+0x1620>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016548:	f89a 5000 	ldrb.w	r5, [sl]
 801654c:	fb01 b505 	mla	r5, r1, r5, fp
 8016550:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8016554:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8016558:	eb02 1040 	add.w	r0, r2, r0, lsl #5
 801655c:	3001      	adds	r0, #1
 801655e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016562:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 8016566:	f43f af44 	beq.w	80163f2 <DrawLowSpectrum+0x1642>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801656a:	f89a 5000 	ldrb.w	r5, [sl]
 801656e:	fb01 b505 	mla	r5, r1, r5, fp
 8016572:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8016576:	ebc0 06c0 	rsb	r6, r0, r0, lsl #3
 801657a:	ebc0 1046 	rsb	r0, r0, r6, lsl #5
 801657e:	3001      	adds	r0, #1
 8016580:	4410      	add	r0, r2
 8016582:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016586:	f413 7580 	ands.w	r5, r3, #256	; 0x100
 801658a:	f43f af44 	beq.w	8016416 <DrawLowSpectrum+0x1666>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801658e:	f89a 5000 	ldrb.w	r5, [sl]
 8016592:	26de      	movs	r6, #222	; 0xde
 8016594:	fb01 b505 	mla	r5, r1, r5, fp
 8016598:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 801659c:	fb06 2000 	mla	r0, r6, r0, r2
 80165a0:	3001      	adds	r0, #1
 80165a2:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80165a6:	f413 7500 	ands.w	r5, r3, #512	; 0x200
 80165aa:	f43f af44 	beq.w	8016436 <DrawLowSpectrum+0x1686>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80165ae:	f89a 5000 	ldrb.w	r5, [sl]
			if(((element[i] >> k) & 1) == 1) {
 80165b2:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80165b6:	fb01 b505 	mla	r5, r1, r5, fp
 80165ba:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80165be:	fb0c 2000 	mla	r0, ip, r0, r2
 80165c2:	f100 0001 	add.w	r0, r0, #1
 80165c6:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80165ca:	f43f af44 	beq.w	8016456 <DrawLowSpectrum+0x16a6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80165ce:	f89a 0000 	ldrb.w	r0, [sl]
 80165d2:	25dc      	movs	r5, #220	; 0xdc
 80165d4:	fb01 b000 	mla	r0, r1, r0, fp
 80165d8:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80165da:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80165dc:	fb05 2303 	mla	r3, r5, r3, r2
	while(i < width) {
 80165e0:	3201      	adds	r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80165e2:	3301      	adds	r3, #1
 80165e4:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
	while(i < width) {
 80165e8:	9b03      	ldr	r3, [sp, #12]
 80165ea:	459e      	cmp	lr, r3
 80165ec:	f47f af44 	bne.w	8016478 <DrawLowSpectrum+0x16c8>
		for(i = 1; i < rekordbox.cues; i++) {
 80165f0:	4bae      	ldr	r3, [pc, #696]	; (80168ac <DrawLowSpectrum+0x1afc>)
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 80165f2:	2434      	movs	r4, #52	; 0x34
		for(i = 1; i < rekordbox.cues; i++) {
 80165f4:	49ae      	ldr	r1, [pc, #696]	; (80168b0 <DrawLowSpectrum+0x1b00>)
 80165f6:	4aaf      	ldr	r2, [pc, #700]	; (80168b4 <DrawLowSpectrum+0x1b04>)
 80165f8:	1a5b      	subs	r3, r3, r1
 80165fa:	f502 7948 	add.w	r9, r2, #800	; 0x320
 80165fe:	9203      	str	r2, [sp, #12]
 8016600:	9306      	str	r3, [sp, #24]
 8016602:	e008      	b.n	8016616 <DrawLowSpectrum+0x1866>
			if(rekordbox.cue_singleloop[i] == 2) {
 8016604:	2b02      	cmp	r3, #2
 8016606:	f000 80d7 	beq.w	80167b8 <DrawLowSpectrum+0x1a08>
		for(i = 1; i < rekordbox.cues; i++) {
 801660a:	9b06      	ldr	r3, [sp, #24]
 801660c:	9a05      	ldr	r2, [sp, #20]
 801660e:	444b      	add	r3, r9
 8016610:	429a      	cmp	r2, r3
 8016612:	f67f ad8f 	bls.w	8016134 <DrawLowSpectrum+0x1384>
			uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8016616:	4ba8      	ldr	r3, [pc, #672]	; (80168b8 <DrawLowSpectrum+0x1b08>)
 8016618:	f8d3 2a88 	ldr.w	r2, [r3, #2696]	; 0xa88
					(float)rekordbox.cue_start_position[i]/rekordbox.spectrum_size;
 801661c:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
			uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8016620:	ee07 2a90 	vmov	s15, r2
					(float)rekordbox.cue_start_position[i]/rekordbox.spectrum_size;
 8016624:	9304      	str	r3, [sp, #16]
			uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8016626:	eef8 6a67 	vcvt.f32.u32	s13, s15
					(float)rekordbox.cue_start_position[i]/rekordbox.spectrum_size;
 801662a:	ee07 3a90 	vmov	s15, r3
 801662e:	9b03      	ldr	r3, [sp, #12]
 8016630:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8016634:	edd3 7a01 	vldr	s15, [r3, #4]
 8016638:	3304      	adds	r3, #4
 801663a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801663e:	9303      	str	r3, [sp, #12]
			uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8016640:	ee67 7aa6 	vmul.f32	s15, s15, s13
					(float)rekordbox.cue_start_position[i]/rekordbox.spectrum_size;
 8016644:	ee87 6a87 	vdiv.f32	s12, s15, s14
			uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8016648:	eefc 7ac6 	vcvt.u32.f32	s15, s12
 801664c:	ee17 3a90 	vmov	r3, s15
 8016650:	b29d      	uxth	r5, r3
			if(rekordbox.cue_singleloop[i] == 1) {
 8016652:	f819 3f01 	ldrb.w	r3, [r9, #1]!
 8016656:	2b01      	cmp	r3, #1
 8016658:	d1d4      	bne.n	8016604 <DrawLowSpectrum+0x1854>
				DrawElement(9, 5, 37+start_pos, 219, 0x00FF0000, hot_cue);
 801665a:	f105 0125 	add.w	r1, r5, #37	; 0x25
 801665e:	4e97      	ldr	r6, [pc, #604]	; (80168bc <DrawLowSpectrum+0x1b0c>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016660:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016662:	f04f 0cdb 	mov.w	ip, #219	; 0xdb
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016666:	b289      	uxth	r1, r1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016668:	f44f 4578 	mov.w	r5, #63488	; 0xf800
 801666c:	f04f 08da 	mov.w	r8, #218	; 0xda
 8016670:	f8cd 9010 	str.w	r9, [sp, #16]
 8016674:	e04c      	b.n	8016710 <DrawLowSpectrum+0x1960>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016676:	f89a e000 	ldrb.w	lr, [sl]
 801667a:	fb04 be0e 	mla	lr, r4, lr, fp
 801667e:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 8016682:	fb0c 1000 	mla	r0, ip, r0, r1
 8016686:	4410      	add	r0, r2
 8016688:	f82e 7010 	strh.w	r7, [lr, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801668c:	f013 0702 	ands.w	r7, r3, #2
 8016690:	d151      	bne.n	8016736 <DrawLowSpectrum+0x1986>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016692:	f89a e000 	ldrb.w	lr, [sl]
 8016696:	fb04 be0e 	mla	lr, r4, lr, fp
 801669a:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 801669e:	fb08 1000 	mla	r0, r8, r0, r1
 80166a2:	4410      	add	r0, r2
 80166a4:	f82e 7010 	strh.w	r7, [lr, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80166a8:	f013 0704 	ands.w	r7, r3, #4
 80166ac:	d151      	bne.n	8016752 <DrawLowSpectrum+0x19a2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80166ae:	f89a e000 	ldrb.w	lr, [sl]
 80166b2:	fb04 be0e 	mla	lr, r4, lr, fp
 80166b6:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 80166ba:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80166be:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 80166c2:	4408      	add	r0, r1
 80166c4:	4410      	add	r0, r2
 80166c6:	f82e 7010 	strh.w	r7, [lr, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80166ca:	f013 0708 	ands.w	r7, r3, #8
 80166ce:	d151      	bne.n	8016774 <DrawLowSpectrum+0x19c4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80166d0:	f89a e000 	ldrb.w	lr, [sl]
 80166d4:	f04f 09d8 	mov.w	r9, #216	; 0xd8
			if(((element[i] >> k) & 1) == 1) {
 80166d8:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80166dc:	fb04 be0e 	mla	lr, r4, lr, fp
 80166e0:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 80166e4:	fb09 1000 	mla	r0, r9, r0, r1
 80166e8:	4410      	add	r0, r2
 80166ea:	f82e 7010 	strh.w	r7, [lr, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80166ee:	d151      	bne.n	8016794 <DrawLowSpectrum+0x19e4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80166f0:	f89a 7000 	ldrb.w	r7, [sl]
 80166f4:	f04f 0ed7 	mov.w	lr, #215	; 0xd7
 80166f8:	fb04 b707 	mla	r7, r4, r7, fp
 80166fc:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 8016700:	fb0e 1000 	mla	r0, lr, r0, r1
 8016704:	4410      	add	r0, r2
	while(i < width) {
 8016706:	3201      	adds	r2, #1
 8016708:	2a09      	cmp	r2, #9
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801670a:	f827 3010 	strh.w	r3, [r7, r0, lsl #1]
	while(i < width) {
 801670e:	d050      	beq.n	80167b2 <DrawLowSpectrum+0x1a02>
			if(((element[i] >> k) & 1) == 1) {
 8016710:	f836 3f02 	ldrh.w	r3, [r6, #2]!
 8016714:	f013 0701 	ands.w	r7, r3, #1
 8016718:	d0ad      	beq.n	8016676 <DrawLowSpectrum+0x18c6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801671a:	f89a 7000 	ldrb.w	r7, [sl]
 801671e:	fb04 b707 	mla	r7, r4, r7, fp
 8016722:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 8016726:	fb0c 1000 	mla	r0, ip, r0, r1
 801672a:	4410      	add	r0, r2
 801672c:	f827 5010 	strh.w	r5, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016730:	f013 0702 	ands.w	r7, r3, #2
 8016734:	d0ad      	beq.n	8016692 <DrawLowSpectrum+0x18e2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016736:	f89a 7000 	ldrb.w	r7, [sl]
 801673a:	fb04 b707 	mla	r7, r4, r7, fp
 801673e:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 8016742:	fb08 1000 	mla	r0, r8, r0, r1
 8016746:	4410      	add	r0, r2
 8016748:	f827 5010 	strh.w	r5, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801674c:	f013 0704 	ands.w	r7, r3, #4
 8016750:	d0ad      	beq.n	80166ae <DrawLowSpectrum+0x18fe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016752:	f89a 7000 	ldrb.w	r7, [sl]
 8016756:	fb04 b707 	mla	r7, r4, r7, fp
 801675a:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 801675e:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8016762:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 8016766:	4408      	add	r0, r1
 8016768:	4410      	add	r0, r2
 801676a:	f827 5010 	strh.w	r5, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801676e:	f013 0708 	ands.w	r7, r3, #8
 8016772:	d0ad      	beq.n	80166d0 <DrawLowSpectrum+0x1920>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016774:	f89a 7000 	ldrb.w	r7, [sl]
 8016778:	f04f 0ed8 	mov.w	lr, #216	; 0xd8
			if(((element[i] >> k) & 1) == 1) {
 801677c:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016780:	fb04 b707 	mla	r7, r4, r7, fp
 8016784:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 8016788:	fb0e 1000 	mla	r0, lr, r0, r1
 801678c:	4410      	add	r0, r2
 801678e:	f827 5010 	strh.w	r5, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016792:	d0ad      	beq.n	80166f0 <DrawLowSpectrum+0x1940>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016794:	f89a 0000 	ldrb.w	r0, [sl]
 8016798:	27d7      	movs	r7, #215	; 0xd7
 801679a:	fb04 b000 	mla	r0, r4, r0, fp
 801679e:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 80167a2:	fb07 1303 	mla	r3, r7, r3, r1
 80167a6:	4413      	add	r3, r2
	while(i < width) {
 80167a8:	3201      	adds	r2, #1
 80167aa:	2a09      	cmp	r2, #9
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80167ac:	f820 5013 	strh.w	r5, [r0, r3, lsl #1]
	while(i < width) {
 80167b0:	d1ae      	bne.n	8016710 <DrawLowSpectrum+0x1960>
 80167b2:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80167b6:	e728      	b.n	801660a <DrawLowSpectrum+0x185a>
					(float)rekordbox.cue_end_position[i]/rekordbox.spectrum_size;
 80167b8:	9b03      	ldr	r3, [sp, #12]
				VLine(40+start_pos, 220, 40, 0x0000FF00);
 80167ba:	f105 0028 	add.w	r0, r5, #40	; 0x28
 80167be:	2228      	movs	r2, #40	; 0x28
 80167c0:	21dc      	movs	r1, #220	; 0xdc
					(float)rekordbox.cue_end_position[i]/rekordbox.spectrum_size;
 80167c2:	f8d3 3190 	ldr.w	r3, [r3, #400]	; 0x190
				VLine(40+start_pos, 220, 40, 0x0000FF00);
 80167c6:	b280      	uxth	r0, r0
				Pixel(41+start_pos, 220, 0x0000FF00);
 80167c8:	3529      	adds	r5, #41	; 0x29
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 80167ca:	f44f 68fc 	mov.w	r8, #2016	; 0x7e0
					(float)rekordbox.cue_end_position[i]/rekordbox.spectrum_size;
 80167ce:	ee07 3a90 	vmov	s15, r3
 80167d2:	9304      	str	r3, [sp, #16]
				VLine(40+start_pos, 220, 40, 0x0000FF00);
 80167d4:	f44f 437f 	mov.w	r3, #65280	; 0xff00
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 80167d8:	b2ad      	uxth	r5, r5
					(float)rekordbox.cue_end_position[i]/rekordbox.spectrum_size;
 80167da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
				uint16_t end_pos = rekordbox.lowp_spectrum_size*
 80167de:	ee67 6aa6 	vmul.f32	s13, s15, s13
					(float)rekordbox.cue_end_position[i]/rekordbox.spectrum_size;
 80167e2:	eec6 7a87 	vdiv.f32	s15, s13, s14
				uint16_t end_pos = rekordbox.lowp_spectrum_size*
 80167e6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80167ea:	ee17 6a90 	vmov	r6, s15
				VLine(40+start_pos, 220, 40, 0x0000FF00);
 80167ee:	f7fd fe7b 	bl	80144e8 <VLine>
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 80167f2:	f89a 3000 	ldrb.w	r3, [sl]
 80167f6:	21dc      	movs	r1, #220	; 0xdc
				uint16_t end_pos = rekordbox.lowp_spectrum_size*
 80167f8:	b2b6      	uxth	r6, r6
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 80167fa:	fb04 b303 	mla	r3, r4, r3, fp
				VLine(40+end_pos, 220, 40, 0x0000FF00);
 80167fe:	f106 0028 	add.w	r0, r6, #40	; 0x28
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8016802:	e9d3 7217 	ldrd	r7, r2, [r3, #92]	; 0x5c
				VLine(40+end_pos, 220, 40, 0x0000FF00);
 8016806:	b280      	uxth	r0, r0
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8016808:	fb01 5302 	mla	r3, r1, r2, r5
				VLine(40+end_pos, 220, 40, 0x0000FF00);
 801680c:	2228      	movs	r2, #40	; 0x28
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 801680e:	f827 8013 	strh.w	r8, [r7, r3, lsl #1]
				VLine(40+end_pos, 220, 40, 0x0000FF00);
 8016812:	f44f 437f 	mov.w	r3, #65280	; 0xff00
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8016816:	f89a 7000 	ldrb.w	r7, [sl]
 801681a:	fb04 b707 	mla	r7, r4, r7, fp
 801681e:	e9d7 ec17 	ldrd	lr, ip, [r7, #92]	; 0x5c
 8016822:	eb0c 17cc 	add.w	r7, ip, ip, lsl #7
 8016826:	eb0c 0747 	add.w	r7, ip, r7, lsl #1
 801682a:	442f      	add	r7, r5
 801682c:	f82e 8017 	strh.w	r8, [lr, r7, lsl #1]
				VLine(40+end_pos, 220, 40, 0x0000FF00);
 8016830:	f7fd fe5a 	bl	80144e8 <VLine>
				Pixel(39+end_pos, 220, 0x0000FF00);
 8016834:	f106 0327 	add.w	r3, r6, #39	; 0x27
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8016838:	f89a 0000 	ldrb.w	r0, [sl]
 801683c:	21dc      	movs	r1, #220	; 0xdc
 801683e:	b29a      	uxth	r2, r3
		for(i = 1; i < rekordbox.cues; i++) {
 8016840:	4b1d      	ldr	r3, [pc, #116]	; (80168b8 <DrawLowSpectrum+0x1b08>)
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8016842:	fb04 b000 	mla	r0, r4, r0, fp
		for(i = 1; i < rekordbox.cues; i++) {
 8016846:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801684a:	9305      	str	r3, [sp, #20]
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 801684c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 801684e:	fb01 2303 	mla	r3, r1, r3, r2
 8016852:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8016854:	f821 8013 	strh.w	r8, [r1, r3, lsl #1]
 8016858:	f89a 1000 	ldrb.w	r1, [sl]
 801685c:	fb04 b101 	mla	r1, r4, r1, fp
 8016860:	e9d1 1317 	ldrd	r1, r3, [r1, #92]	; 0x5c
 8016864:	eb03 10c3 	add.w	r0, r3, r3, lsl #7
 8016868:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 801686c:	4413      	add	r3, r2
 801686e:	f821 8013 	strh.w	r8, [r1, r3, lsl #1]
}
 8016872:	e6ca      	b.n	801660a <DrawLowSpectrum+0x185a>
		if(rekordbox.cue_start_position[0] != 0) {
 8016874:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016876:	2b00      	cmp	r3, #0
 8016878:	f43f ac55 	beq.w	8016126 <DrawLowSpectrum+0x1376>
				*400/rekordbox.spectrum_size), 219, 0x00FFFF00, hot_cue);
 801687c:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8016880:	f8df c038 	ldr.w	ip, [pc, #56]	; 80168bc <DrawLowSpectrum+0x1b0c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016884:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016886:	f04f 0edb 	mov.w	lr, #219	; 0xdb
				*400/rekordbox.spectrum_size), 219, 0x00FFFF00, hot_cue);
 801688a:	fb03 f101 	mul.w	r1, r3, r1
 801688e:	4b0a      	ldr	r3, [pc, #40]	; (80168b8 <DrawLowSpectrum+0x1b08>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016890:	f64f 74e0 	movw	r4, #65504	; 0xffe0
 8016894:	f04f 08da 	mov.w	r8, #218	; 0xda
				*400/rekordbox.spectrum_size), 219, 0x00FFFF00, hot_cue);
 8016898:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801689c:	f04f 09d8 	mov.w	r9, #216	; 0xd8
				*400/rekordbox.spectrum_size), 219, 0x00FFFF00, hot_cue);
 80168a0:	fbb1 f1f3 	udiv	r1, r1, r3
			DrawElement(9, 5, 36+(rekordbox.cue_start_position[0]
 80168a4:	3124      	adds	r1, #36	; 0x24
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80168a6:	b289      	uxth	r1, r1
 80168a8:	e054      	b.n	8016954 <DrawLowSpectrum+0x1ba4>
 80168aa:	bf00      	nop
 80168ac:	ffffcc99 	.word	0xffffcc99
 80168b0:	200154f0 	.word	0x200154f0
 80168b4:	20018538 	.word	0x20018538
 80168b8:	200174f0 	.word	0x200174f0
 80168bc:	0802634e 	.word	0x0802634e
 80168c0:	f89a 7000 	ldrb.w	r7, [sl]
 80168c4:	fb05 b707 	mla	r7, r5, r7, fp
 80168c8:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 80168cc:	fb0e 1000 	mla	r0, lr, r0, r1
 80168d0:	4410      	add	r0, r2
 80168d2:	f827 6010 	strh.w	r6, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80168d6:	f013 0602 	ands.w	r6, r3, #2
 80168da:	d14e      	bne.n	801697a <DrawLowSpectrum+0x1bca>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80168dc:	f89a 7000 	ldrb.w	r7, [sl]
 80168e0:	fb05 b707 	mla	r7, r5, r7, fp
 80168e4:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 80168e8:	fb08 1000 	mla	r0, r8, r0, r1
 80168ec:	4410      	add	r0, r2
 80168ee:	f827 6010 	strh.w	r6, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80168f2:	f013 0604 	ands.w	r6, r3, #4
 80168f6:	d14e      	bne.n	8016996 <DrawLowSpectrum+0x1be6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80168f8:	f89a 7000 	ldrb.w	r7, [sl]
 80168fc:	fb05 b707 	mla	r7, r5, r7, fp
 8016900:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 8016904:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8016908:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 801690c:	4408      	add	r0, r1
 801690e:	4410      	add	r0, r2
 8016910:	f827 6010 	strh.w	r6, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016914:	f013 0608 	ands.w	r6, r3, #8
 8016918:	d14e      	bne.n	80169b8 <DrawLowSpectrum+0x1c08>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801691a:	f89a 7000 	ldrb.w	r7, [sl]
			if(((element[i] >> k) & 1) == 1) {
 801691e:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016922:	fb05 b707 	mla	r7, r5, r7, fp
 8016926:	e9d7 7017 	ldrd	r7, r0, [r7, #92]	; 0x5c
 801692a:	fb09 1000 	mla	r0, r9, r0, r1
 801692e:	4410      	add	r0, r2
 8016930:	f827 6010 	strh.w	r6, [r7, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016934:	d14e      	bne.n	80169d4 <DrawLowSpectrum+0x1c24>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016936:	f89a 6000 	ldrb.w	r6, [sl]
 801693a:	27d7      	movs	r7, #215	; 0xd7
 801693c:	fb05 b606 	mla	r6, r5, r6, fp
 8016940:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016944:	fb07 1000 	mla	r0, r7, r0, r1
 8016948:	4410      	add	r0, r2
	while(i < width) {
 801694a:	3201      	adds	r2, #1
 801694c:	2a09      	cmp	r2, #9
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801694e:	f826 3010 	strh.w	r3, [r6, r0, lsl #1]
	while(i < width) {
 8016952:	d04e      	beq.n	80169f2 <DrawLowSpectrum+0x1c42>
			if(((element[i] >> k) & 1) == 1) {
 8016954:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
 8016958:	f013 0601 	ands.w	r6, r3, #1
 801695c:	d0b0      	beq.n	80168c0 <DrawLowSpectrum+0x1b10>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801695e:	f89a 6000 	ldrb.w	r6, [sl]
 8016962:	fb05 b606 	mla	r6, r5, r6, fp
 8016966:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801696a:	fb0e 1000 	mla	r0, lr, r0, r1
 801696e:	4410      	add	r0, r2
 8016970:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016974:	f013 0602 	ands.w	r6, r3, #2
 8016978:	d0b0      	beq.n	80168dc <DrawLowSpectrum+0x1b2c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801697a:	f89a 6000 	ldrb.w	r6, [sl]
 801697e:	fb05 b606 	mla	r6, r5, r6, fp
 8016982:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016986:	fb08 1000 	mla	r0, r8, r0, r1
 801698a:	4410      	add	r0, r2
 801698c:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016990:	f013 0604 	ands.w	r6, r3, #4
 8016994:	d0b0      	beq.n	80168f8 <DrawLowSpectrum+0x1b48>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016996:	f89a 6000 	ldrb.w	r6, [sl]
 801699a:	fb05 b606 	mla	r6, r5, r6, fp
 801699e:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80169a2:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80169a6:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 80169aa:	4408      	add	r0, r1
 80169ac:	4410      	add	r0, r2
 80169ae:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80169b2:	f013 0608 	ands.w	r6, r3, #8
 80169b6:	d0b0      	beq.n	801691a <DrawLowSpectrum+0x1b6a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80169b8:	f89a 6000 	ldrb.w	r6, [sl]
			if(((element[i] >> k) & 1) == 1) {
 80169bc:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80169c0:	fb05 b606 	mla	r6, r5, r6, fp
 80169c4:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80169c8:	fb09 1000 	mla	r0, r9, r0, r1
 80169cc:	4410      	add	r0, r2
 80169ce:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80169d2:	d0b0      	beq.n	8016936 <DrawLowSpectrum+0x1b86>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80169d4:	f89a 0000 	ldrb.w	r0, [sl]
 80169d8:	26d7      	movs	r6, #215	; 0xd7
 80169da:	fb05 b000 	mla	r0, r5, r0, fp
 80169de:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 80169e2:	fb06 1303 	mla	r3, r6, r3, r1
 80169e6:	4413      	add	r3, r2
	while(i < width) {
 80169e8:	3201      	adds	r2, #1
 80169ea:	2a09      	cmp	r2, #9
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80169ec:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
	while(i < width) {
 80169f0:	d1b0      	bne.n	8016954 <DrawLowSpectrum+0x1ba4>
 80169f2:	4de1      	ldr	r5, [pc, #900]	; (8016d78 <DrawLowSpectrum+0x1fc8>)
 80169f4:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80169f6:	2134      	movs	r1, #52	; 0x34
 80169f8:	f44f 4078 	mov.w	r0, #63488	; 0xf800
 80169fc:	f105 0e48 	add.w	lr, r5, #72	; 0x48
 8016a00:	f04f 08fa 	mov.w	r8, #250	; 0xfa
 8016a04:	e0b9      	b.n	8016b7a <DrawLowSpectrum+0x1dca>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016a06:	f89a 7000 	ldrb.w	r7, [sl]
 8016a0a:	fb01 b707 	mla	r7, r1, r7, fp
 8016a0e:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016a12:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 8016a16:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8016a1a:	3401      	adds	r4, #1
 8016a1c:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016a20:	f013 0602 	ands.w	r6, r3, #2
 8016a24:	f040 80c0 	bne.w	8016ba8 <DrawLowSpectrum+0x1df8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016a28:	f89a 7000 	ldrb.w	r7, [sl]
 8016a2c:	fb01 b707 	mla	r7, r1, r7, fp
 8016a30:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016a34:	eb04 1cc4 	add.w	ip, r4, r4, lsl #7
 8016a38:	eb04 044c 	add.w	r4, r4, ip, lsl #1
 8016a3c:	3401      	adds	r4, #1
 8016a3e:	4414      	add	r4, r2
 8016a40:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016a44:	f013 0604 	ands.w	r6, r3, #4
 8016a48:	f040 80c0 	bne.w	8016bcc <DrawLowSpectrum+0x1e1c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016a4c:	f89a 7000 	ldrb.w	r7, [sl]
 8016a50:	fb01 b707 	mla	r7, r1, r7, fp
 8016a54:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016a58:	eb04 14c4 	add.w	r4, r4, r4, lsl #7
 8016a5c:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8016a60:	3401      	adds	r4, #1
 8016a62:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016a66:	f013 0608 	ands.w	r6, r3, #8
 8016a6a:	f040 80c0 	bne.w	8016bee <DrawLowSpectrum+0x1e3e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016a6e:	f89a 7000 	ldrb.w	r7, [sl]
 8016a72:	fb01 b707 	mla	r7, r1, r7, fp
 8016a76:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016a7a:	eb04 2404 	add.w	r4, r4, r4, lsl #8
 8016a7e:	3401      	adds	r4, #1
 8016a80:	4414      	add	r4, r2
 8016a82:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016a86:	f89a 6000 	ldrb.w	r6, [sl]
			if(((element[i] >> k) & 1) == 1) {
 8016a8a:	f013 0710 	ands.w	r7, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016a8e:	fb01 b606 	mla	r6, r1, r6, fp
 8016a92:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016a96:	eb02 2404 	add.w	r4, r2, r4, lsl #8
 8016a9a:	f104 0401 	add.w	r4, r4, #1
			if(((element[i] >> k) & 1) == 1) {
 8016a9e:	f041 8474 	bne.w	801838a <DrawLowSpectrum+0x35da>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016aa2:	f826 7014 	strh.w	r7, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016aa6:	f013 0620 	ands.w	r6, r3, #32
 8016aaa:	f041 8460 	bne.w	801836e <DrawLowSpectrum+0x35be>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016aae:	f89a 7000 	ldrb.w	r7, [sl]
 8016ab2:	fb01 b707 	mla	r7, r1, r7, fp
 8016ab6:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016aba:	ebc4 2404 	rsb	r4, r4, r4, lsl #8
 8016abe:	3401      	adds	r4, #1
 8016ac0:	4414      	add	r4, r2
 8016ac2:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ac6:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 8016aca:	f041 8441 	bne.w	8018350 <DrawLowSpectrum+0x35a0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016ace:	f89a 7000 	ldrb.w	r7, [sl]
 8016ad2:	fb01 b707 	mla	r7, r1, r7, fp
 8016ad6:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016ada:	ebc4 14c4 	rsb	r4, r4, r4, lsl #7
 8016ade:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8016ae2:	3401      	adds	r4, #1
 8016ae4:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ae8:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 8016aec:	f041 8420 	bne.w	8018330 <DrawLowSpectrum+0x3580>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016af0:	f89a 7000 	ldrb.w	r7, [sl]
 8016af4:	fb01 b707 	mla	r7, r1, r7, fp
 8016af8:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016afc:	ebc4 1c84 	rsb	ip, r4, r4, lsl #6
 8016b00:	eb04 048c 	add.w	r4, r4, ip, lsl #2
 8016b04:	3401      	adds	r4, #1
 8016b06:	4414      	add	r4, r2
 8016b08:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016b0c:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 8016b10:	f041 83ff 	bne.w	8018312 <DrawLowSpectrum+0x3562>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016b14:	f89a 7000 	ldrb.w	r7, [sl]
 8016b18:	fb01 b707 	mla	r7, r1, r7, fp
 8016b1c:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016b20:	ebc4 1484 	rsb	r4, r4, r4, lsl #6
 8016b24:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8016b28:	3401      	adds	r4, #1
 8016b2a:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016b2e:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 8016b32:	f041 83de 	bne.w	80182f2 <DrawLowSpectrum+0x3542>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016b36:	f89a 7000 	ldrb.w	r7, [sl]
 8016b3a:	fb01 b707 	mla	r7, r1, r7, fp
 8016b3e:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8016b42:	ebc4 1c84 	rsb	ip, r4, r4, lsl #6
 8016b46:	ebc4 048c 	rsb	r4, r4, ip, lsl #2
 8016b4a:	3401      	adds	r4, #1
 8016b4c:	4414      	add	r4, r2
 8016b4e:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016b52:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
 8016b56:	f041 83bf 	bne.w	80182d8 <DrawLowSpectrum+0x3528>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016b5a:	f89a 6000 	ldrb.w	r6, [sl]
 8016b5e:	fb01 b606 	mla	r6, r1, r6, fp
 8016b62:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016b66:	fb08 2404 	mla	r4, r8, r4, r2
 8016b6a:	3401      	adds	r4, #1
 8016b6c:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8016b70:	45ae      	cmp	lr, r5
 8016b72:	f102 0201 	add.w	r2, r2, #1
 8016b76:	f43f aad6 	beq.w	8016126 <DrawLowSpectrum+0x1376>
			if(((element[i] >> k) & 1) == 1) {
 8016b7a:	f835 3f02 	ldrh.w	r3, [r5, #2]!
 8016b7e:	f013 0601 	ands.w	r6, r3, #1
 8016b82:	f43f af40 	beq.w	8016a06 <DrawLowSpectrum+0x1c56>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016b86:	f89a 6000 	ldrb.w	r6, [sl]
 8016b8a:	fb01 b606 	mla	r6, r1, r6, fp
 8016b8e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016b92:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 8016b96:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8016b9a:	3401      	adds	r4, #1
 8016b9c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ba0:	f013 0602 	ands.w	r6, r3, #2
 8016ba4:	f43f af40 	beq.w	8016a28 <DrawLowSpectrum+0x1c78>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016ba8:	f89a 6000 	ldrb.w	r6, [sl]
 8016bac:	fb01 b606 	mla	r6, r1, r6, fp
 8016bb0:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016bb4:	eb04 17c4 	add.w	r7, r4, r4, lsl #7
 8016bb8:	eb04 0447 	add.w	r4, r4, r7, lsl #1
 8016bbc:	3401      	adds	r4, #1
 8016bbe:	4414      	add	r4, r2
 8016bc0:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016bc4:	f013 0604 	ands.w	r6, r3, #4
 8016bc8:	f43f af40 	beq.w	8016a4c <DrawLowSpectrum+0x1c9c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016bcc:	f89a 6000 	ldrb.w	r6, [sl]
 8016bd0:	fb01 b606 	mla	r6, r1, r6, fp
 8016bd4:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016bd8:	eb04 14c4 	add.w	r4, r4, r4, lsl #7
 8016bdc:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8016be0:	3401      	adds	r4, #1
 8016be2:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016be6:	f013 0608 	ands.w	r6, r3, #8
 8016bea:	f43f af40 	beq.w	8016a6e <DrawLowSpectrum+0x1cbe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016bee:	f89a 6000 	ldrb.w	r6, [sl]
 8016bf2:	fb01 b606 	mla	r6, r1, r6, fp
 8016bf6:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8016bfa:	eb04 2404 	add.w	r4, r4, r4, lsl #8
 8016bfe:	3401      	adds	r4, #1
 8016c00:	4414      	add	r4, r2
 8016c02:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 8016c06:	e73e      	b.n	8016a86 <DrawLowSpectrum+0x1cd6>
 8016c08:	4c5c      	ldr	r4, [pc, #368]	; (8016d7c <DrawLowSpectrum+0x1fcc>)
 8016c0a:	2134      	movs	r1, #52	; 0x34
 8016c0c:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8016c10:	f04f 08bb 	mov.w	r8, #187	; 0xbb
 8016c14:	f104 0c4a 	add.w	ip, r4, #74	; 0x4a
 8016c18:	46a6      	mov	lr, r4
 8016c1a:	e050      	b.n	8016cbe <DrawLowSpectrum+0x1f0e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c1c:	f89a 6000 	ldrb.w	r6, [sl]
 8016c20:	fb01 b606 	mla	r6, r1, r6, fp
 8016c24:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016c28:	eb00 0740 	add.w	r7, r0, r0, lsl #1
 8016c2c:	ebc0 1087 	rsb	r0, r0, r7, lsl #6
 8016c30:	3054      	adds	r0, #84	; 0x54
 8016c32:	4410      	add	r0, r2
 8016c34:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016c38:	f013 0402 	ands.w	r4, r3, #2
 8016c3c:	d155      	bne.n	8016cea <DrawLowSpectrum+0x1f3a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c3e:	f89a 6000 	ldrb.w	r6, [sl]
 8016c42:	27be      	movs	r7, #190	; 0xbe
 8016c44:	fb01 b606 	mla	r6, r1, r6, fp
 8016c48:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016c4c:	fb07 2000 	mla	r0, r7, r0, r2
 8016c50:	3054      	adds	r0, #84	; 0x54
 8016c52:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016c56:	f013 0404 	ands.w	r4, r3, #4
 8016c5a:	d155      	bne.n	8016d08 <DrawLowSpectrum+0x1f58>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c5c:	f89a 6000 	ldrb.w	r6, [sl]
 8016c60:	fb01 b606 	mla	r6, r1, r6, fp
 8016c64:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016c68:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8016c6c:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8016c70:	3054      	adds	r0, #84	; 0x54
 8016c72:	4410      	add	r0, r2
 8016c74:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016c78:	f013 0408 	ands.w	r4, r3, #8
 8016c7c:	d155      	bne.n	8016d2a <DrawLowSpectrum+0x1f7a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c7e:	f89a 6000 	ldrb.w	r6, [sl]
 8016c82:	27bc      	movs	r7, #188	; 0xbc
			if(((element[i] >> k) & 1) == 1) {
 8016c84:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c88:	fb01 b606 	mla	r6, r1, r6, fp
 8016c8c:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016c90:	fb07 2000 	mla	r0, r7, r0, r2
 8016c94:	f100 0054 	add.w	r0, r0, #84	; 0x54
 8016c98:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016c9c:	d155      	bne.n	8016d4a <DrawLowSpectrum+0x1f9a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016c9e:	f89a 4000 	ldrb.w	r4, [sl]
 8016ca2:	fb01 b404 	mla	r4, r1, r4, fp
 8016ca6:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8016caa:	fb08 2000 	mla	r0, r8, r0, r2
 8016cae:	3054      	adds	r0, #84	; 0x54
 8016cb0:	f824 3010 	strh.w	r3, [r4, r0, lsl #1]
	while(i < width) {
 8016cb4:	45f4      	cmp	ip, lr
 8016cb6:	f102 0201 	add.w	r2, r2, #1
 8016cba:	f43e a9f8 	beq.w	80150ae <DrawLowSpectrum+0x2fe>
			if(((element[i] >> k) & 1) == 1) {
 8016cbe:	f83e 3f02 	ldrh.w	r3, [lr, #2]!
 8016cc2:	f013 0401 	ands.w	r4, r3, #1
 8016cc6:	d0a9      	beq.n	8016c1c <DrawLowSpectrum+0x1e6c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016cc8:	f89a 4000 	ldrb.w	r4, [sl]
 8016ccc:	fb01 b404 	mla	r4, r1, r4, fp
 8016cd0:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8016cd4:	eb00 0640 	add.w	r6, r0, r0, lsl #1
 8016cd8:	ebc0 1086 	rsb	r0, r0, r6, lsl #6
 8016cdc:	3054      	adds	r0, #84	; 0x54
 8016cde:	4410      	add	r0, r2
 8016ce0:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ce4:	f013 0402 	ands.w	r4, r3, #2
 8016ce8:	d0a9      	beq.n	8016c3e <DrawLowSpectrum+0x1e8e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016cea:	f89a 4000 	ldrb.w	r4, [sl]
 8016cee:	26be      	movs	r6, #190	; 0xbe
 8016cf0:	fb01 b404 	mla	r4, r1, r4, fp
 8016cf4:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8016cf8:	fb06 2000 	mla	r0, r6, r0, r2
 8016cfc:	3054      	adds	r0, #84	; 0x54
 8016cfe:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016d02:	f013 0404 	ands.w	r4, r3, #4
 8016d06:	d0a9      	beq.n	8016c5c <DrawLowSpectrum+0x1eac>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016d08:	f89a 4000 	ldrb.w	r4, [sl]
 8016d0c:	fb01 b404 	mla	r4, r1, r4, fp
 8016d10:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8016d14:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8016d18:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8016d1c:	3054      	adds	r0, #84	; 0x54
 8016d1e:	4410      	add	r0, r2
 8016d20:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016d24:	f013 0408 	ands.w	r4, r3, #8
 8016d28:	d0a9      	beq.n	8016c7e <DrawLowSpectrum+0x1ece>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016d2a:	f89a 4000 	ldrb.w	r4, [sl]
 8016d2e:	26bc      	movs	r6, #188	; 0xbc
			if(((element[i] >> k) & 1) == 1) {
 8016d30:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016d34:	fb01 b404 	mla	r4, r1, r4, fp
 8016d38:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8016d3c:	fb06 2000 	mla	r0, r6, r0, r2
 8016d40:	f100 0054 	add.w	r0, r0, #84	; 0x54
 8016d44:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016d48:	d0a9      	beq.n	8016c9e <DrawLowSpectrum+0x1eee>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016d4a:	f89a 0000 	ldrb.w	r0, [sl]
 8016d4e:	fb01 b000 	mla	r0, r1, r0, fp
 8016d52:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 8016d56:	fb08 2303 	mla	r3, r8, r3, r2
 8016d5a:	3354      	adds	r3, #84	; 0x54
 8016d5c:	f820 5013 	strh.w	r5, [r0, r3, lsl #1]
 8016d60:	e7a8      	b.n	8016cb4 <DrawLowSpectrum+0x1f04>
 8016d62:	4d07      	ldr	r5, [pc, #28]	; (8016d80 <DrawLowSpectrum+0x1fd0>)
 8016d64:	2134      	movs	r1, #52	; 0x34
 8016d66:	f04f 08e6 	mov.w	r8, #230	; 0xe6
 8016d6a:	f44f 4478 	mov.w	r4, #63488	; 0xf800
 8016d6e:	f105 0e44 	add.w	lr, r5, #68	; 0x44
 8016d72:	f04f 0ce5 	mov.w	ip, #229	; 0xe5
 8016d76:	e077      	b.n	8016e68 <DrawLowSpectrum+0x20b8>
 8016d78:	08025a72 	.word	0x08025a72
 8016d7c:	08026602 	.word	0x08026602
 8016d80:	0802654a 	.word	0x0802654a
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016d84:	f89a 9000 	ldrb.w	r9, [sl]
 8016d88:	fb01 b909 	mla	r9, r1, r9, fp
 8016d8c:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016d90:	fb08 2000 	mla	r0, r8, r0, r2
 8016d94:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016d98:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016d9c:	f013 0602 	ands.w	r6, r3, #2
 8016da0:	d176      	bne.n	8016e90 <DrawLowSpectrum+0x20e0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016da2:	f89a 9000 	ldrb.w	r9, [sl]
 8016da6:	fb01 b909 	mla	r9, r1, r9, fp
 8016daa:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016dae:	fb0c 2000 	mla	r0, ip, r0, r2
 8016db2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016db6:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016dba:	f013 0604 	ands.w	r6, r3, #4
 8016dbe:	d176      	bne.n	8016eae <DrawLowSpectrum+0x20fe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016dc0:	f89a 9000 	ldrb.w	r9, [sl]
 8016dc4:	27e4      	movs	r7, #228	; 0xe4
 8016dc6:	fb01 b909 	mla	r9, r1, r9, fp
 8016dca:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016dce:	fb07 2000 	mla	r0, r7, r0, r2
 8016dd2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016dd6:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016dda:	f013 0608 	ands.w	r6, r3, #8
 8016dde:	d176      	bne.n	8016ece <DrawLowSpectrum+0x211e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016de0:	f89a 9000 	ldrb.w	r9, [sl]
 8016de4:	27e3      	movs	r7, #227	; 0xe3
 8016de6:	fb01 b909 	mla	r9, r1, r9, fp
 8016dea:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016dee:	fb07 2000 	mla	r0, r7, r0, r2
 8016df2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016df6:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016dfa:	f013 0610 	ands.w	r6, r3, #16
 8016dfe:	d176      	bne.n	8016eee <DrawLowSpectrum+0x213e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e00:	f89a 9000 	ldrb.w	r9, [sl]
 8016e04:	27e2      	movs	r7, #226	; 0xe2
 8016e06:	fb01 b909 	mla	r9, r1, r9, fp
 8016e0a:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016e0e:	fb07 2000 	mla	r0, r7, r0, r2
 8016e12:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016e16:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016e1a:	f013 0620 	ands.w	r6, r3, #32
 8016e1e:	d176      	bne.n	8016f0e <DrawLowSpectrum+0x215e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e20:	f89a 9000 	ldrb.w	r9, [sl]
			if(((element[i] >> k) & 1) == 1) {
 8016e24:	f013 0340 	ands.w	r3, r3, #64	; 0x40
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e28:	fb01 b909 	mla	r9, r1, r9, fp
 8016e2c:	e9d9 9017 	ldrd	r9, r0, [r9, #92]	; 0x5c
 8016e30:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016e34:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016e38:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016e3c:	4410      	add	r0, r2
 8016e3e:	f829 6010 	strh.w	r6, [r9, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016e42:	d176      	bne.n	8016f32 <DrawLowSpectrum+0x2182>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e44:	f89a 6000 	ldrb.w	r6, [sl]
	while(i < width) {
 8016e48:	45ae      	cmp	lr, r5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e4a:	fb01 b606 	mla	r6, r1, r6, fp
 8016e4e:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016e52:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8016e56:	eb02 1040 	add.w	r0, r2, r0, lsl #5
	while(i < width) {
 8016e5a:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8016e5e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016e62:	f826 3010 	strh.w	r3, [r6, r0, lsl #1]
	while(i < width) {
 8016e66:	d076      	beq.n	8016f56 <DrawLowSpectrum+0x21a6>
			if(((element[i] >> k) & 1) == 1) {
 8016e68:	f835 3f02 	ldrh.w	r3, [r5, #2]!
 8016e6c:	f013 0601 	ands.w	r6, r3, #1
 8016e70:	d088      	beq.n	8016d84 <DrawLowSpectrum+0x1fd4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016e72:	f89a 6000 	ldrb.w	r6, [sl]
 8016e76:	fb01 b606 	mla	r6, r1, r6, fp
 8016e7a:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016e7e:	fb08 2000 	mla	r0, r8, r0, r2
 8016e82:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016e86:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016e8a:	f013 0602 	ands.w	r6, r3, #2
 8016e8e:	d088      	beq.n	8016da2 <DrawLowSpectrum+0x1ff2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016e90:	f89a 6000 	ldrb.w	r6, [sl]
 8016e94:	fb01 b606 	mla	r6, r1, r6, fp
 8016e98:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016e9c:	fb0c 2000 	mla	r0, ip, r0, r2
 8016ea0:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016ea4:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ea8:	f013 0604 	ands.w	r6, r3, #4
 8016eac:	d088      	beq.n	8016dc0 <DrawLowSpectrum+0x2010>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016eae:	f89a 6000 	ldrb.w	r6, [sl]
 8016eb2:	27e4      	movs	r7, #228	; 0xe4
 8016eb4:	fb01 b606 	mla	r6, r1, r6, fp
 8016eb8:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016ebc:	fb07 2000 	mla	r0, r7, r0, r2
 8016ec0:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016ec4:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ec8:	f013 0608 	ands.w	r6, r3, #8
 8016ecc:	d088      	beq.n	8016de0 <DrawLowSpectrum+0x2030>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016ece:	f89a 6000 	ldrb.w	r6, [sl]
 8016ed2:	27e3      	movs	r7, #227	; 0xe3
 8016ed4:	fb01 b606 	mla	r6, r1, r6, fp
 8016ed8:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016edc:	fb07 2000 	mla	r0, r7, r0, r2
 8016ee0:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016ee4:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016ee8:	f013 0610 	ands.w	r6, r3, #16
 8016eec:	d088      	beq.n	8016e00 <DrawLowSpectrum+0x2050>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016eee:	f89a 6000 	ldrb.w	r6, [sl]
 8016ef2:	27e2      	movs	r7, #226	; 0xe2
 8016ef4:	fb01 b606 	mla	r6, r1, r6, fp
 8016ef8:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016efc:	fb07 2000 	mla	r0, r7, r0, r2
 8016f00:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016f04:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016f08:	f013 0620 	ands.w	r6, r3, #32
 8016f0c:	d088      	beq.n	8016e20 <DrawLowSpectrum+0x2070>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f0e:	f89a 6000 	ldrb.w	r6, [sl]
			if(((element[i] >> k) & 1) == 1) {
 8016f12:	f013 0340 	ands.w	r3, r3, #64	; 0x40
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f16:	fb01 b606 	mla	r6, r1, r6, fp
 8016f1a:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8016f1e:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016f22:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8016f26:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8016f2a:	4410      	add	r0, r2
 8016f2c:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8016f30:	d088      	beq.n	8016e44 <DrawLowSpectrum+0x2094>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f32:	f89a 0000 	ldrb.w	r0, [sl]
	while(i < width) {
 8016f36:	45ae      	cmp	lr, r5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f38:	fb01 b000 	mla	r0, r1, r0, fp
 8016f3c:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 8016f40:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8016f44:	eb02 1343 	add.w	r3, r2, r3, lsl #5
	while(i < width) {
 8016f48:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f4c:	f203 13bd 	addw	r3, r3, #445	; 0x1bd
 8016f50:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
	while(i < width) {
 8016f54:	d188      	bne.n	8016e68 <DrawLowSpectrum+0x20b8>
		if(percent / 10000 > 0) {
 8016f56:	f242 730f 	movw	r3, #9999	; 0x270f
 8016f5a:	9a03      	ldr	r2, [sp, #12]
 8016f5c:	429a      	cmp	r2, r3
 8016f5e:	f201 8191 	bhi.w	8018284 <DrawLowSpectrum+0x34d4>
		if(percent / 1000 > 0) {
 8016f62:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 8016f66:	4613      	mov	r3, r2
 8016f68:	f081 819a 	bcs.w	80182a0 <DrawLowSpectrum+0x34f0>
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 8016f6c:	4c4b      	ldr	r4, [pc, #300]	; (801709c <DrawLowSpectrum+0x22ec>)
 8016f6e:	fba4 3403 	umull	r3, r4, r4, r3
 8016f72:	0964      	lsrs	r4, r4, #5
		DrawDigit(((percent / 100) % 100) % 10, 345, 186, 10, 0x00FFFFFF);
 8016f74:	4b4a      	ldr	r3, [pc, #296]	; (80170a0 <DrawLowSpectrum+0x22f0>)
 8016f76:	f06f 487f 	mvn.w	r8, #4278190080	; 0xff000000
 8016f7a:	f240 1159 	movw	r1, #345	; 0x159
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f7e:	26cc      	movs	r6, #204	; 0xcc
		DrawDigit(((percent / 100) % 100) % 10, 345, 186, 10, 0x00FFFFFF);
 8016f80:	fba3 2304 	umull	r2, r3, r3, r4
 8016f84:	22ba      	movs	r2, #186	; 0xba
 8016f86:	f8cd 8000 	str.w	r8, [sp]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f8a:	25cb      	movs	r5, #203	; 0xcb
		DrawDigit(((percent / 100) % 100) % 10, 345, 186, 10, 0x00FFFFFF);
 8016f8c:	08db      	lsrs	r3, r3, #3
 8016f8e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8016f92:	eba4 0343 	sub.w	r3, r4, r3, lsl #1
 8016f96:	b2d8      	uxtb	r0, r3
 8016f98:	230a      	movs	r3, #10
 8016f9a:	f7fd fb31 	bl	8014600 <DrawDigit>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016f9e:	f89a 2000 	ldrb.w	r2, [sl]
 8016fa2:	2034      	movs	r0, #52	; 0x34
 8016fa4:	f64f 71ff 	movw	r1, #65535	; 0xffff
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fa8:	9c03      	ldr	r4, [sp, #12]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016faa:	fb00 b202 	mla	r2, r0, r2, fp
 8016fae:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8016fb2:	fb06 f303 	mul.w	r3, r6, r3
 8016fb6:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8016fba:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 8016fbe:	f89a 7000 	ldrb.w	r7, [sl]
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fc2:	4b36      	ldr	r3, [pc, #216]	; (801709c <DrawLowSpectrum+0x22ec>)
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fc4:	fb00 b707 	mla	r7, r0, r7, fp
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fc8:	fba3 c304 	umull	ip, r3, r3, r4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fcc:	e9d7 7217 	ldrd	r7, r2, [r7, #92]	; 0x5c
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fd0:	095b      	lsrs	r3, r3, #5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fd2:	fb05 f202 	mul.w	r2, r5, r2
 8016fd6:	f502 72b2 	add.w	r2, r2, #356	; 0x164
 8016fda:	f827 1012 	strh.w	r1, [r7, r2, lsl #1]
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fde:	2764      	movs	r7, #100	; 0x64
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fe0:	f89a 2000 	ldrb.w	r2, [sl]
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fe4:	fb07 4713 	mls	r7, r7, r3, r4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fe8:	fb00 b202 	mla	r2, r0, r2, fp
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016fec:	b2bf      	uxth	r7, r7
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016fee:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8016ff0:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8016ff2:	2f04      	cmp	r7, #4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8016ff4:	fb06 f303 	mul.w	r3, r6, r3
 8016ff8:	f203 1365 	addw	r3, r3, #357	; 0x165
 8016ffc:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 8017000:	f89a 3000 	ldrb.w	r3, [sl]
 8017004:	fb00 b003 	mla	r0, r0, r3, fp
 8017008:	6e03      	ldr	r3, [r0, #96]	; 0x60
 801700a:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 801700c:	bf88      	it	hi
 801700e:	2005      	movhi	r0, #5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017010:	fb05 f303 	mul.w	r3, r5, r3
		else DrawDigit(0, 360, 186, 10, 0x00FFFFFF);
 8017014:	bf98      	it	ls
 8017016:	2000      	movls	r0, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017018:	f203 1365 	addw	r3, r3, #357	; 0x165
 801701c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
		if(percent % 100 >= 5) DrawDigit(5, 360, 186, 10, 0x00FFFFFF);
 8017020:	230a      	movs	r3, #10
 8017022:	22ba      	movs	r2, #186	; 0xba
 8017024:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8017028:	f8cd 8000 	str.w	r8, [sp]
		else DrawDigit(0, 360, 186, 10, 0x00FFFFFF);
 801702c:	f7fd fae8 	bl	8014600 <DrawDigit>
 8017030:	f7fe bb59 	b.w	80156e6 <DrawLowSpectrum+0x936>
		DrawDigit(bpm / 10000, 400, 176, 10, 0x00FFFFFF);
 8017034:	481b      	ldr	r0, [pc, #108]	; (80170a4 <DrawLowSpectrum+0x22f4>)
 8017036:	22b0      	movs	r2, #176	; 0xb0
 8017038:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801703c:	fba0 3004 	umull	r3, r0, r0, r4
 8017040:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8017044:	0b40      	lsrs	r0, r0, #13
 8017046:	9300      	str	r3, [sp, #0]
 8017048:	230a      	movs	r3, #10
 801704a:	f7fd fad9 	bl	8014600 <DrawDigit>
		DrawDigit(((bpm / 100) % 100) / 10, 415, 176, 10, 0x00FFFFFF);
 801704e:	4a13      	ldr	r2, [pc, #76]	; (801709c <DrawLowSpectrum+0x22ec>)
 8017050:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8017054:	2064      	movs	r0, #100	; 0x64
 8017056:	4912      	ldr	r1, [pc, #72]	; (80170a0 <DrawLowSpectrum+0x22f0>)
 8017058:	9300      	str	r3, [sp, #0]
 801705a:	fba2 5304 	umull	r5, r3, r2, r4
 801705e:	095b      	lsrs	r3, r3, #5
 8017060:	fba2 5203 	umull	r5, r2, r2, r3
 8017064:	0956      	lsrs	r6, r2, #5
 8017066:	22b0      	movs	r2, #176	; 0xb0
 8017068:	fb00 3316 	mls	r3, r0, r6, r3
 801706c:	b29e      	uxth	r6, r3
 801706e:	fba1 3106 	umull	r3, r1, r1, r6
 8017072:	230a      	movs	r3, #10
 8017074:	f3c1 00c7 	ubfx	r0, r1, #3, #8
 8017078:	f240 119f 	movw	r1, #415	; 0x19f
 801707c:	f7fd fac0 	bl	8014600 <DrawDigit>
 8017080:	f7fe bfed 	b.w	801605e <DrawLowSpectrum+0x12ae>
 8017084:	4d08      	ldr	r5, [pc, #32]	; (80170a8 <DrawLowSpectrum+0x22f8>)
	if(display.mastertempomode == 1) {
 8017086:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017088:	2134      	movs	r1, #52	; 0x34
 801708a:	f04f 0eb7 	mov.w	lr, #183	; 0xb7
 801708e:	f105 0844 	add.w	r8, r5, #68	; 0x44
 8017092:	f44f 4078 	mov.w	r0, #63488	; 0xf800
 8017096:	f04f 09b6 	mov.w	r9, #182	; 0xb6
 801709a:	e0c9      	b.n	8017230 <DrawLowSpectrum+0x2480>
 801709c:	51eb851f 	.word	0x51eb851f
 80170a0:	cccccccd 	.word	0xcccccccd
 80170a4:	d1b71759 	.word	0xd1b71759
 80170a8:	080263ae 	.word	0x080263ae
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80170ac:	f89a 7000 	ldrb.w	r7, [sl]
 80170b0:	fb01 b707 	mla	r7, r1, r7, fp
 80170b4:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80170b8:	fb0e 2404 	mla	r4, lr, r4, r2
 80170bc:	f204 1463 	addw	r4, r4, #355	; 0x163
 80170c0:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80170c4:	f013 0602 	ands.w	r6, r3, #2
 80170c8:	f040 80c8 	bne.w	801725c <DrawLowSpectrum+0x24ac>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80170cc:	f89a 7000 	ldrb.w	r7, [sl]
 80170d0:	fb01 b707 	mla	r7, r1, r7, fp
 80170d4:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80170d8:	fb09 2404 	mla	r4, r9, r4, r2
 80170dc:	f204 1463 	addw	r4, r4, #355	; 0x163
 80170e0:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80170e4:	f013 0604 	ands.w	r6, r3, #4
 80170e8:	f040 80c8 	bne.w	801727c <DrawLowSpectrum+0x24cc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80170ec:	f89a 7000 	ldrb.w	r7, [sl]
 80170f0:	f04f 0cb5 	mov.w	ip, #181	; 0xb5
 80170f4:	fb01 b707 	mla	r7, r1, r7, fp
 80170f8:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80170fc:	fb0c 2404 	mla	r4, ip, r4, r2
 8017100:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017104:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017108:	f013 0608 	ands.w	r6, r3, #8
 801710c:	f040 80c7 	bne.w	801729e <DrawLowSpectrum+0x24ee>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017110:	f89a 7000 	ldrb.w	r7, [sl]
 8017114:	f04f 0cb4 	mov.w	ip, #180	; 0xb4
 8017118:	fb01 b707 	mla	r7, r1, r7, fp
 801711c:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017120:	fb0c 2404 	mla	r4, ip, r4, r2
 8017124:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017128:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801712c:	f013 0610 	ands.w	r6, r3, #16
 8017130:	f040 80c6 	bne.w	80172c0 <DrawLowSpectrum+0x2510>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017134:	f89a 7000 	ldrb.w	r7, [sl]
 8017138:	f04f 0cb3 	mov.w	ip, #179	; 0xb3
 801713c:	fb01 b707 	mla	r7, r1, r7, fp
 8017140:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017144:	fb0c 2404 	mla	r4, ip, r4, r2
 8017148:	f204 1463 	addw	r4, r4, #355	; 0x163
 801714c:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017150:	f013 0620 	ands.w	r6, r3, #32
 8017154:	f040 80c5 	bne.w	80172e2 <DrawLowSpectrum+0x2532>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017158:	f89a 7000 	ldrb.w	r7, [sl]
 801715c:	f04f 0cb2 	mov.w	ip, #178	; 0xb2
 8017160:	fb01 b707 	mla	r7, r1, r7, fp
 8017164:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017168:	fb0c 2404 	mla	r4, ip, r4, r2
 801716c:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017170:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017174:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 8017178:	f040 80c4 	bne.w	8017304 <DrawLowSpectrum+0x2554>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801717c:	f89a 7000 	ldrb.w	r7, [sl]
 8017180:	f04f 0cb1 	mov.w	ip, #177	; 0xb1
 8017184:	fb01 b707 	mla	r7, r1, r7, fp
 8017188:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 801718c:	fb0c 2404 	mla	r4, ip, r4, r2
 8017190:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017194:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017198:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 801719c:	f040 80c3 	bne.w	8017326 <DrawLowSpectrum+0x2576>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80171a0:	f89a 7000 	ldrb.w	r7, [sl]
 80171a4:	f04f 0cb0 	mov.w	ip, #176	; 0xb0
 80171a8:	fb01 b707 	mla	r7, r1, r7, fp
 80171ac:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80171ae:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 80171b0:	fb0c 2404 	mla	r4, ip, r4, r2
 80171b4:	f204 1463 	addw	r4, r4, #355	; 0x163
 80171b8:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80171bc:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 80171c0:	f040 80c2 	bne.w	8017348 <DrawLowSpectrum+0x2598>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80171c4:	f89a 7000 	ldrb.w	r7, [sl]
 80171c8:	f04f 0caf 	mov.w	ip, #175	; 0xaf
 80171cc:	fb01 b707 	mla	r7, r1, r7, fp
 80171d0:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80171d2:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 80171d4:	fb0c 2404 	mla	r4, ip, r4, r2
 80171d8:	f204 1463 	addw	r4, r4, #355	; 0x163
 80171dc:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80171e0:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 80171e4:	f040 80c1 	bne.w	801736a <DrawLowSpectrum+0x25ba>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80171e8:	f89a 7000 	ldrb.w	r7, [sl]
 80171ec:	f04f 0cae 	mov.w	ip, #174	; 0xae
			if(((element[i] >> k) & 1) == 1) {
 80171f0:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80171f4:	fb01 b707 	mla	r7, r1, r7, fp
 80171f8:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 80171fa:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 80171fc:	fb0c 2404 	mla	r4, ip, r4, r2
 8017200:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017204:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017208:	f040 80c0 	bne.w	801738c <DrawLowSpectrum+0x25dc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801720c:	f89a 6000 	ldrb.w	r6, [sl]
 8017210:	27ad      	movs	r7, #173	; 0xad
 8017212:	fb01 b606 	mla	r6, r1, r6, fp
 8017216:	6e34      	ldr	r4, [r6, #96]	; 0x60
 8017218:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 801721a:	fb07 2404 	mla	r4, r7, r4, r2
 801721e:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017222:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8017226:	45a8      	cmp	r8, r5
 8017228:	f102 0201 	add.w	r2, r2, #1
 801722c:	f43e abc2 	beq.w	80159b4 <DrawLowSpectrum+0xc04>
			if(((element[i] >> k) & 1) == 1) {
 8017230:	f835 3f02 	ldrh.w	r3, [r5, #2]!
 8017234:	f013 0601 	ands.w	r6, r3, #1
 8017238:	f43f af38 	beq.w	80170ac <DrawLowSpectrum+0x22fc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801723c:	f89a 6000 	ldrb.w	r6, [sl]
 8017240:	fb01 b606 	mla	r6, r1, r6, fp
 8017244:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017248:	fb0e 2404 	mla	r4, lr, r4, r2
 801724c:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017250:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017254:	f013 0602 	ands.w	r6, r3, #2
 8017258:	f43f af38 	beq.w	80170cc <DrawLowSpectrum+0x231c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801725c:	f89a 6000 	ldrb.w	r6, [sl]
 8017260:	fb01 b606 	mla	r6, r1, r6, fp
 8017264:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017268:	fb09 2404 	mla	r4, r9, r4, r2
 801726c:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017270:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017274:	f013 0604 	ands.w	r6, r3, #4
 8017278:	f43f af38 	beq.w	80170ec <DrawLowSpectrum+0x233c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801727c:	f89a 6000 	ldrb.w	r6, [sl]
 8017280:	27b5      	movs	r7, #181	; 0xb5
 8017282:	fb01 b606 	mla	r6, r1, r6, fp
 8017286:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801728a:	fb07 2404 	mla	r4, r7, r4, r2
 801728e:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017292:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017296:	f013 0608 	ands.w	r6, r3, #8
 801729a:	f43f af39 	beq.w	8017110 <DrawLowSpectrum+0x2360>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801729e:	f89a 6000 	ldrb.w	r6, [sl]
 80172a2:	27b4      	movs	r7, #180	; 0xb4
 80172a4:	fb01 b606 	mla	r6, r1, r6, fp
 80172a8:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80172ac:	fb07 2404 	mla	r4, r7, r4, r2
 80172b0:	f204 1463 	addw	r4, r4, #355	; 0x163
 80172b4:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80172b8:	f013 0610 	ands.w	r6, r3, #16
 80172bc:	f43f af3a 	beq.w	8017134 <DrawLowSpectrum+0x2384>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80172c0:	f89a 6000 	ldrb.w	r6, [sl]
 80172c4:	27b3      	movs	r7, #179	; 0xb3
 80172c6:	fb01 b606 	mla	r6, r1, r6, fp
 80172ca:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80172ce:	fb07 2404 	mla	r4, r7, r4, r2
 80172d2:	f204 1463 	addw	r4, r4, #355	; 0x163
 80172d6:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80172da:	f013 0620 	ands.w	r6, r3, #32
 80172de:	f43f af3b 	beq.w	8017158 <DrawLowSpectrum+0x23a8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80172e2:	f89a 6000 	ldrb.w	r6, [sl]
 80172e6:	27b2      	movs	r7, #178	; 0xb2
 80172e8:	fb01 b606 	mla	r6, r1, r6, fp
 80172ec:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80172f0:	fb07 2404 	mla	r4, r7, r4, r2
 80172f4:	f204 1463 	addw	r4, r4, #355	; 0x163
 80172f8:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80172fc:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 8017300:	f43f af3c 	beq.w	801717c <DrawLowSpectrum+0x23cc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017304:	f89a 6000 	ldrb.w	r6, [sl]
 8017308:	27b1      	movs	r7, #177	; 0xb1
 801730a:	fb01 b606 	mla	r6, r1, r6, fp
 801730e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017312:	fb07 2404 	mla	r4, r7, r4, r2
 8017316:	f204 1463 	addw	r4, r4, #355	; 0x163
 801731a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801731e:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 8017322:	f43f af3d 	beq.w	80171a0 <DrawLowSpectrum+0x23f0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017326:	f89a 6000 	ldrb.w	r6, [sl]
 801732a:	27b0      	movs	r7, #176	; 0xb0
 801732c:	fb01 b606 	mla	r6, r1, r6, fp
 8017330:	6e34      	ldr	r4, [r6, #96]	; 0x60
 8017332:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 8017334:	fb07 2404 	mla	r4, r7, r4, r2
 8017338:	f204 1463 	addw	r4, r4, #355	; 0x163
 801733c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017340:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 8017344:	f43f af3e 	beq.w	80171c4 <DrawLowSpectrum+0x2414>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017348:	f89a 6000 	ldrb.w	r6, [sl]
 801734c:	27af      	movs	r7, #175	; 0xaf
 801734e:	fb01 b606 	mla	r6, r1, r6, fp
 8017352:	6e34      	ldr	r4, [r6, #96]	; 0x60
 8017354:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 8017356:	fb07 2404 	mla	r4, r7, r4, r2
 801735a:	f204 1463 	addw	r4, r4, #355	; 0x163
 801735e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017362:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 8017366:	f43f af3f 	beq.w	80171e8 <DrawLowSpectrum+0x2438>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801736a:	f89a 6000 	ldrb.w	r6, [sl]
 801736e:	27ae      	movs	r7, #174	; 0xae
			if(((element[i] >> k) & 1) == 1) {
 8017370:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017374:	fb01 b606 	mla	r6, r1, r6, fp
 8017378:	6e34      	ldr	r4, [r6, #96]	; 0x60
 801737a:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 801737c:	fb07 2404 	mla	r4, r7, r4, r2
 8017380:	f204 1463 	addw	r4, r4, #355	; 0x163
 8017384:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017388:	f43f af40 	beq.w	801720c <DrawLowSpectrum+0x245c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801738c:	f89a 4000 	ldrb.w	r4, [sl]
 8017390:	26ad      	movs	r6, #173	; 0xad
 8017392:	fb01 b404 	mla	r4, r1, r4, fp
 8017396:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8017398:	6de4      	ldr	r4, [r4, #92]	; 0x5c
 801739a:	fb06 2303 	mla	r3, r6, r3, r2
 801739e:	f203 1363 	addw	r3, r3, #355	; 0x163
 80173a2:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
 80173a6:	e73e      	b.n	8017226 <DrawLowSpectrum+0x2476>
 80173a8:	4859      	ldr	r0, [pc, #356]	; (8017510 <DrawLowSpectrum+0x2760>)
	if(display.quantize == 1) {
 80173aa:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80173ac:	2134      	movs	r1, #52	; 0x34
 80173ae:	f04f 0cb2 	mov.w	ip, #178	; 0xb2
 80173b2:	f100 0e60 	add.w	lr, r0, #96	; 0x60
 80173b6:	f44f 4578 	mov.w	r5, #63488	; 0xf800
 80173ba:	f04f 08b1 	mov.w	r8, #177	; 0xb1
 80173be:	f04f 09b0 	mov.w	r9, #176	; 0xb0
 80173c2:	e04d      	b.n	8017460 <DrawLowSpectrum+0x26b0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80173c4:	f89a 7000 	ldrb.w	r7, [sl]
 80173c8:	fb01 b707 	mla	r7, r1, r7, fp
 80173cc:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80173d0:	fb0c 2404 	mla	r4, ip, r4, r2
 80173d4:	34c8      	adds	r4, #200	; 0xc8
 80173d6:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80173da:	f013 0602 	ands.w	r6, r3, #2
 80173de:	d152      	bne.n	8017486 <DrawLowSpectrum+0x26d6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80173e0:	f89a 7000 	ldrb.w	r7, [sl]
 80173e4:	fb01 b707 	mla	r7, r1, r7, fp
 80173e8:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80173ec:	fb08 2404 	mla	r4, r8, r4, r2
 80173f0:	34c8      	adds	r4, #200	; 0xc8
 80173f2:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80173f6:	f013 0604 	ands.w	r6, r3, #4
 80173fa:	d152      	bne.n	80174a2 <DrawLowSpectrum+0x26f2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80173fc:	f89a 7000 	ldrb.w	r7, [sl]
 8017400:	fb01 b707 	mla	r7, r1, r7, fp
 8017404:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017408:	fb09 2404 	mla	r4, r9, r4, r2
 801740c:	34c8      	adds	r4, #200	; 0xc8
 801740e:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017412:	f013 0608 	ands.w	r6, r3, #8
 8017416:	d152      	bne.n	80174be <DrawLowSpectrum+0x270e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017418:	f89a 7000 	ldrb.w	r7, [sl]
			if(((element[i] >> k) & 1) == 1) {
 801741c:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017420:	fb01 b707 	mla	r7, r1, r7, fp
 8017424:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017428:	9703      	str	r7, [sp, #12]
 801742a:	f04f 07af 	mov.w	r7, #175	; 0xaf
 801742e:	fb07 2404 	mla	r4, r7, r4, r2
 8017432:	9f03      	ldr	r7, [sp, #12]
 8017434:	f104 04c8 	add.w	r4, r4, #200	; 0xc8
 8017438:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801743c:	d14f      	bne.n	80174de <DrawLowSpectrum+0x272e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801743e:	f89a 6000 	ldrb.w	r6, [sl]
 8017442:	27ae      	movs	r7, #174	; 0xae
 8017444:	fb01 b606 	mla	r6, r1, r6, fp
 8017448:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801744c:	fb07 2404 	mla	r4, r7, r4, r2
 8017450:	34c8      	adds	r4, #200	; 0xc8
 8017452:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8017456:	4586      	cmp	lr, r0
 8017458:	f102 0201 	add.w	r2, r2, #1
 801745c:	f43e aaa5 	beq.w	80159aa <DrawLowSpectrum+0xbfa>
			if(((element[i] >> k) & 1) == 1) {
 8017460:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 8017464:	f013 0601 	ands.w	r6, r3, #1
 8017468:	d0ac      	beq.n	80173c4 <DrawLowSpectrum+0x2614>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801746a:	f89a 6000 	ldrb.w	r6, [sl]
 801746e:	fb01 b606 	mla	r6, r1, r6, fp
 8017472:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017476:	fb0c 2404 	mla	r4, ip, r4, r2
 801747a:	34c8      	adds	r4, #200	; 0xc8
 801747c:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017480:	f013 0602 	ands.w	r6, r3, #2
 8017484:	d0ac      	beq.n	80173e0 <DrawLowSpectrum+0x2630>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017486:	f89a 6000 	ldrb.w	r6, [sl]
 801748a:	fb01 b606 	mla	r6, r1, r6, fp
 801748e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017492:	fb08 2404 	mla	r4, r8, r4, r2
 8017496:	34c8      	adds	r4, #200	; 0xc8
 8017498:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801749c:	f013 0604 	ands.w	r6, r3, #4
 80174a0:	d0ac      	beq.n	80173fc <DrawLowSpectrum+0x264c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80174a2:	f89a 6000 	ldrb.w	r6, [sl]
 80174a6:	fb01 b606 	mla	r6, r1, r6, fp
 80174aa:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80174ae:	fb09 2404 	mla	r4, r9, r4, r2
 80174b2:	34c8      	adds	r4, #200	; 0xc8
 80174b4:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80174b8:	f013 0608 	ands.w	r6, r3, #8
 80174bc:	d0ac      	beq.n	8017418 <DrawLowSpectrum+0x2668>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80174be:	f89a 6000 	ldrb.w	r6, [sl]
 80174c2:	27af      	movs	r7, #175	; 0xaf
			if(((element[i] >> k) & 1) == 1) {
 80174c4:	f013 0310 	ands.w	r3, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80174c8:	fb01 b606 	mla	r6, r1, r6, fp
 80174cc:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80174d0:	fb07 2404 	mla	r4, r7, r4, r2
 80174d4:	f104 04c8 	add.w	r4, r4, #200	; 0xc8
 80174d8:	f826 5014 	strh.w	r5, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80174dc:	d0af      	beq.n	801743e <DrawLowSpectrum+0x268e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80174de:	f89a 4000 	ldrb.w	r4, [sl]
 80174e2:	26ae      	movs	r6, #174	; 0xae
 80174e4:	fb01 b404 	mla	r4, r1, r4, fp
 80174e8:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 80174ec:	fb06 2303 	mla	r3, r6, r3, r2
 80174f0:	33c8      	adds	r3, #200	; 0xc8
 80174f2:	f824 5013 	strh.w	r5, [r4, r3, lsl #1]
 80174f6:	e7ae      	b.n	8017456 <DrawLowSpectrum+0x26a6>
 80174f8:	4d06      	ldr	r5, [pc, #24]	; (8017514 <DrawLowSpectrum+0x2764>)
	if(display.cuemode == 1) {
 80174fa:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80174fc:	2134      	movs	r1, #52	; 0x34
 80174fe:	f04f 0ecf 	mov.w	lr, #207	; 0xcf
 8017502:	f105 0844 	add.w	r8, r5, #68	; 0x44
 8017506:	f44f 4078 	mov.w	r0, #63488	; 0xf800
 801750a:	f04f 09ce 	mov.w	r9, #206	; 0xce
 801750e:	e0bb      	b.n	8017688 <DrawLowSpectrum+0x28d8>
 8017510:	080265a2 	.word	0x080265a2
 8017514:	080259de 	.word	0x080259de
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017518:	f89a 7000 	ldrb.w	r7, [sl]
 801751c:	fb01 b707 	mla	r7, r1, r7, fp
 8017520:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017524:	fb0e 2404 	mla	r4, lr, r4, r2
 8017528:	3456      	adds	r4, #86	; 0x56
 801752a:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801752e:	f013 0602 	ands.w	r6, r3, #2
 8017532:	f040 80be 	bne.w	80176b2 <DrawLowSpectrum+0x2902>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017536:	f89a 7000 	ldrb.w	r7, [sl]
 801753a:	fb01 b707 	mla	r7, r1, r7, fp
 801753e:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017542:	fb09 2404 	mla	r4, r9, r4, r2
 8017546:	3456      	adds	r4, #86	; 0x56
 8017548:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801754c:	f013 0604 	ands.w	r6, r3, #4
 8017550:	f040 80be 	bne.w	80176d0 <DrawLowSpectrum+0x2920>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017554:	f89a 7000 	ldrb.w	r7, [sl]
 8017558:	f04f 0ccd 	mov.w	ip, #205	; 0xcd
 801755c:	fb01 b707 	mla	r7, r1, r7, fp
 8017560:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017564:	fb0c 2404 	mla	r4, ip, r4, r2
 8017568:	3456      	adds	r4, #86	; 0x56
 801756a:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801756e:	f013 0608 	ands.w	r6, r3, #8
 8017572:	f040 80bd 	bne.w	80176f0 <DrawLowSpectrum+0x2940>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017576:	f89a 7000 	ldrb.w	r7, [sl]
 801757a:	f04f 0ccc 	mov.w	ip, #204	; 0xcc
 801757e:	fb01 b707 	mla	r7, r1, r7, fp
 8017582:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017586:	fb0c 2404 	mla	r4, ip, r4, r2
 801758a:	3456      	adds	r4, #86	; 0x56
 801758c:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017590:	f013 0610 	ands.w	r6, r3, #16
 8017594:	f040 80bc 	bne.w	8017710 <DrawLowSpectrum+0x2960>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017598:	f89a 7000 	ldrb.w	r7, [sl]
 801759c:	f04f 0ccb 	mov.w	ip, #203	; 0xcb
 80175a0:	fb01 b707 	mla	r7, r1, r7, fp
 80175a4:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80175a8:	fb0c 2404 	mla	r4, ip, r4, r2
 80175ac:	3456      	adds	r4, #86	; 0x56
 80175ae:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80175b2:	f013 0620 	ands.w	r6, r3, #32
 80175b6:	f040 80bb 	bne.w	8017730 <DrawLowSpectrum+0x2980>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80175ba:	f89a 7000 	ldrb.w	r7, [sl]
 80175be:	f04f 0cca 	mov.w	ip, #202	; 0xca
 80175c2:	fb01 b707 	mla	r7, r1, r7, fp
 80175c6:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80175ca:	fb0c 2404 	mla	r4, ip, r4, r2
 80175ce:	3456      	adds	r4, #86	; 0x56
 80175d0:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80175d4:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 80175d8:	f040 80ba 	bne.w	8017750 <DrawLowSpectrum+0x29a0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80175dc:	f89a 7000 	ldrb.w	r7, [sl]
 80175e0:	f04f 0cc9 	mov.w	ip, #201	; 0xc9
 80175e4:	fb01 b707 	mla	r7, r1, r7, fp
 80175e8:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80175ec:	fb0c 2404 	mla	r4, ip, r4, r2
 80175f0:	3456      	adds	r4, #86	; 0x56
 80175f2:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80175f6:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 80175fa:	f040 80b9 	bne.w	8017770 <DrawLowSpectrum+0x29c0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80175fe:	f89a 7000 	ldrb.w	r7, [sl]
 8017602:	f04f 0cc8 	mov.w	ip, #200	; 0xc8
 8017606:	fb01 b707 	mla	r7, r1, r7, fp
 801760a:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801760c:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 801760e:	fb0c 2404 	mla	r4, ip, r4, r2
 8017612:	3456      	adds	r4, #86	; 0x56
 8017614:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017618:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 801761c:	f040 80b8 	bne.w	8017790 <DrawLowSpectrum+0x29e0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017620:	f89a 7000 	ldrb.w	r7, [sl]
 8017624:	f04f 0cc7 	mov.w	ip, #199	; 0xc7
 8017628:	fb01 b707 	mla	r7, r1, r7, fp
 801762c:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 801762e:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 8017630:	fb0c 2404 	mla	r4, ip, r4, r2
 8017634:	3456      	adds	r4, #86	; 0x56
 8017636:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801763a:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 801763e:	f040 80b7 	bne.w	80177b0 <DrawLowSpectrum+0x2a00>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017642:	f89a 7000 	ldrb.w	r7, [sl]
 8017646:	f04f 0cc6 	mov.w	ip, #198	; 0xc6
			if(((element[i] >> k) & 1) == 1) {
 801764a:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801764e:	fb01 b707 	mla	r7, r1, r7, fp
 8017652:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 8017654:	6dff      	ldr	r7, [r7, #92]	; 0x5c
 8017656:	fb0c 2404 	mla	r4, ip, r4, r2
 801765a:	f104 0456 	add.w	r4, r4, #86	; 0x56
 801765e:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017662:	f040 80b6 	bne.w	80177d2 <DrawLowSpectrum+0x2a22>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017666:	f89a 6000 	ldrb.w	r6, [sl]
 801766a:	27c5      	movs	r7, #197	; 0xc5
 801766c:	fb01 b606 	mla	r6, r1, r6, fp
 8017670:	6e34      	ldr	r4, [r6, #96]	; 0x60
 8017672:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 8017674:	fb07 2404 	mla	r4, r7, r4, r2
 8017678:	3456      	adds	r4, #86	; 0x56
 801767a:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 801767e:	45a8      	cmp	r8, r5
 8017680:	f102 0201 	add.w	r2, r2, #1
 8017684:	f43e a98c 	beq.w	80159a0 <DrawLowSpectrum+0xbf0>
			if(((element[i] >> k) & 1) == 1) {
 8017688:	f835 3f02 	ldrh.w	r3, [r5, #2]!
 801768c:	f013 0601 	ands.w	r6, r3, #1
 8017690:	f43f af42 	beq.w	8017518 <DrawLowSpectrum+0x2768>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017694:	f89a 6000 	ldrb.w	r6, [sl]
 8017698:	fb01 b606 	mla	r6, r1, r6, fp
 801769c:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80176a0:	fb0e 2404 	mla	r4, lr, r4, r2
 80176a4:	3456      	adds	r4, #86	; 0x56
 80176a6:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80176aa:	f013 0602 	ands.w	r6, r3, #2
 80176ae:	f43f af42 	beq.w	8017536 <DrawLowSpectrum+0x2786>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80176b2:	f89a 6000 	ldrb.w	r6, [sl]
 80176b6:	fb01 b606 	mla	r6, r1, r6, fp
 80176ba:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80176be:	fb09 2404 	mla	r4, r9, r4, r2
 80176c2:	3456      	adds	r4, #86	; 0x56
 80176c4:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80176c8:	f013 0604 	ands.w	r6, r3, #4
 80176cc:	f43f af42 	beq.w	8017554 <DrawLowSpectrum+0x27a4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80176d0:	f89a 6000 	ldrb.w	r6, [sl]
 80176d4:	27cd      	movs	r7, #205	; 0xcd
 80176d6:	fb01 b606 	mla	r6, r1, r6, fp
 80176da:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80176de:	fb07 2404 	mla	r4, r7, r4, r2
 80176e2:	3456      	adds	r4, #86	; 0x56
 80176e4:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80176e8:	f013 0608 	ands.w	r6, r3, #8
 80176ec:	f43f af43 	beq.w	8017576 <DrawLowSpectrum+0x27c6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80176f0:	f89a 6000 	ldrb.w	r6, [sl]
 80176f4:	27cc      	movs	r7, #204	; 0xcc
 80176f6:	fb01 b606 	mla	r6, r1, r6, fp
 80176fa:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80176fe:	fb07 2404 	mla	r4, r7, r4, r2
 8017702:	3456      	adds	r4, #86	; 0x56
 8017704:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017708:	f013 0610 	ands.w	r6, r3, #16
 801770c:	f43f af44 	beq.w	8017598 <DrawLowSpectrum+0x27e8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017710:	f89a 6000 	ldrb.w	r6, [sl]
 8017714:	27cb      	movs	r7, #203	; 0xcb
 8017716:	fb01 b606 	mla	r6, r1, r6, fp
 801771a:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801771e:	fb07 2404 	mla	r4, r7, r4, r2
 8017722:	3456      	adds	r4, #86	; 0x56
 8017724:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017728:	f013 0620 	ands.w	r6, r3, #32
 801772c:	f43f af45 	beq.w	80175ba <DrawLowSpectrum+0x280a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017730:	f89a 6000 	ldrb.w	r6, [sl]
 8017734:	27ca      	movs	r7, #202	; 0xca
 8017736:	fb01 b606 	mla	r6, r1, r6, fp
 801773a:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801773e:	fb07 2404 	mla	r4, r7, r4, r2
 8017742:	3456      	adds	r4, #86	; 0x56
 8017744:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017748:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 801774c:	f43f af46 	beq.w	80175dc <DrawLowSpectrum+0x282c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017750:	f89a 6000 	ldrb.w	r6, [sl]
 8017754:	27c9      	movs	r7, #201	; 0xc9
 8017756:	fb01 b606 	mla	r6, r1, r6, fp
 801775a:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801775e:	fb07 2404 	mla	r4, r7, r4, r2
 8017762:	3456      	adds	r4, #86	; 0x56
 8017764:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017768:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 801776c:	f43f af47 	beq.w	80175fe <DrawLowSpectrum+0x284e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017770:	f89a 6000 	ldrb.w	r6, [sl]
 8017774:	27c8      	movs	r7, #200	; 0xc8
 8017776:	fb01 b606 	mla	r6, r1, r6, fp
 801777a:	6e34      	ldr	r4, [r6, #96]	; 0x60
 801777c:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 801777e:	fb07 2404 	mla	r4, r7, r4, r2
 8017782:	3456      	adds	r4, #86	; 0x56
 8017784:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017788:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 801778c:	f43f af48 	beq.w	8017620 <DrawLowSpectrum+0x2870>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017790:	f89a 6000 	ldrb.w	r6, [sl]
 8017794:	27c7      	movs	r7, #199	; 0xc7
 8017796:	fb01 b606 	mla	r6, r1, r6, fp
 801779a:	6e34      	ldr	r4, [r6, #96]	; 0x60
 801779c:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 801779e:	fb07 2404 	mla	r4, r7, r4, r2
 80177a2:	3456      	adds	r4, #86	; 0x56
 80177a4:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80177a8:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 80177ac:	f43f af49 	beq.w	8017642 <DrawLowSpectrum+0x2892>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80177b0:	f89a 6000 	ldrb.w	r6, [sl]
 80177b4:	27c6      	movs	r7, #198	; 0xc6
			if(((element[i] >> k) & 1) == 1) {
 80177b6:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80177ba:	fb01 b606 	mla	r6, r1, r6, fp
 80177be:	6e34      	ldr	r4, [r6, #96]	; 0x60
 80177c0:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 80177c2:	fb07 2404 	mla	r4, r7, r4, r2
 80177c6:	f104 0456 	add.w	r4, r4, #86	; 0x56
 80177ca:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80177ce:	f43f af4a 	beq.w	8017666 <DrawLowSpectrum+0x28b6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80177d2:	f89a 4000 	ldrb.w	r4, [sl]
 80177d6:	26c5      	movs	r6, #197	; 0xc5
 80177d8:	fb01 b404 	mla	r4, r1, r4, fp
 80177dc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80177de:	6de4      	ldr	r4, [r4, #92]	; 0x5c
 80177e0:	fb06 2303 	mla	r3, r6, r3, r2
 80177e4:	3356      	adds	r3, #86	; 0x56
 80177e6:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
 80177ea:	e748      	b.n	801767e <DrawLowSpectrum+0x28ce>
 80177ec:	4d05      	ldr	r5, [pc, #20]	; (8017804 <DrawLowSpectrum+0x2a54>)
	if(display.loop == 1) {
 80177ee:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80177f0:	2134      	movs	r1, #52	; 0x34
 80177f2:	f04f 0ec7 	mov.w	lr, #199	; 0xc7
 80177f6:	f105 082c 	add.w	r8, r5, #44	; 0x2c
 80177fa:	f44f 60fc 	mov.w	r0, #2016	; 0x7e0
 80177fe:	f04f 09c6 	mov.w	r9, #198	; 0xc6
 8017802:	e0c8      	b.n	8017996 <DrawLowSpectrum+0x2be6>
 8017804:	08026382 	.word	0x08026382
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017808:	f89a 7000 	ldrb.w	r7, [sl]
 801780c:	fb01 b707 	mla	r7, r1, r7, fp
 8017810:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017814:	fb0e 2404 	mla	r4, lr, r4, r2
 8017818:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 801781c:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017820:	f013 0602 	ands.w	r6, r3, #2
 8017824:	f040 80cd 	bne.w	80179c2 <DrawLowSpectrum+0x2c12>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017828:	f89a 7000 	ldrb.w	r7, [sl]
 801782c:	fb01 b707 	mla	r7, r1, r7, fp
 8017830:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017834:	fb09 2404 	mla	r4, r9, r4, r2
 8017838:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 801783c:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017840:	f013 0604 	ands.w	r6, r3, #4
 8017844:	f040 80cd 	bne.w	80179e2 <DrawLowSpectrum+0x2c32>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017848:	f89a 7000 	ldrb.w	r7, [sl]
 801784c:	f04f 0cc5 	mov.w	ip, #197	; 0xc5
 8017850:	fb01 b707 	mla	r7, r1, r7, fp
 8017854:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017858:	fb0c 2404 	mla	r4, ip, r4, r2
 801785c:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017860:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017864:	f013 0608 	ands.w	r6, r3, #8
 8017868:	f040 80cc 	bne.w	8017a04 <DrawLowSpectrum+0x2c54>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801786c:	f89a 7000 	ldrb.w	r7, [sl]
 8017870:	f04f 0cc4 	mov.w	ip, #196	; 0xc4
 8017874:	fb01 b707 	mla	r7, r1, r7, fp
 8017878:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 801787c:	fb0c 2404 	mla	r4, ip, r4, r2
 8017880:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017884:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017888:	f013 0610 	ands.w	r6, r3, #16
 801788c:	f040 80cb 	bne.w	8017a26 <DrawLowSpectrum+0x2c76>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017890:	f89a 7000 	ldrb.w	r7, [sl]
 8017894:	fb01 b707 	mla	r7, r1, r7, fp
 8017898:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 801789c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80178a0:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 80178a4:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80178a8:	4414      	add	r4, r2
 80178aa:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80178ae:	f013 0620 	ands.w	r6, r3, #32
 80178b2:	f040 80cb 	bne.w	8017a4c <DrawLowSpectrum+0x2c9c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80178b6:	f89a 7000 	ldrb.w	r7, [sl]
 80178ba:	f04f 0cc2 	mov.w	ip, #194	; 0xc2
 80178be:	fb01 b707 	mla	r7, r1, r7, fp
 80178c2:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80178c6:	fb0c 2404 	mla	r4, ip, r4, r2
 80178ca:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80178ce:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80178d2:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 80178d6:	f040 80ca 	bne.w	8017a6e <DrawLowSpectrum+0x2cbe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80178da:	f89a 7000 	ldrb.w	r7, [sl]
 80178de:	fb01 b707 	mla	r7, r1, r7, fp
 80178e2:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 80178e6:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
 80178ea:	eb04 148c 	add.w	r4, r4, ip, lsl #6
 80178ee:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80178f2:	4414      	add	r4, r2
 80178f4:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80178f8:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 80178fc:	f040 80ca 	bne.w	8017a94 <DrawLowSpectrum+0x2ce4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017900:	f89a 7000 	ldrb.w	r7, [sl]
 8017904:	fb01 b707 	mla	r7, r1, r7, fp
 8017908:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 801790c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8017910:	eb02 1484 	add.w	r4, r2, r4, lsl #6
 8017914:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017918:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801791c:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 8017920:	f040 80ca 	bne.w	8017ab8 <DrawLowSpectrum+0x2d08>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017924:	f89a 7000 	ldrb.w	r7, [sl]
 8017928:	fb01 b707 	mla	r7, r1, r7, fp
 801792c:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 8017930:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
 8017934:	ebc4 148c 	rsb	r4, r4, ip, lsl #6
 8017938:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 801793c:	4414      	add	r4, r2
 801793e:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017942:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 8017946:	f040 80ca 	bne.w	8017ade <DrawLowSpectrum+0x2d2e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801794a:	f89a 7000 	ldrb.w	r7, [sl]
 801794e:	f04f 0cbe 	mov.w	ip, #190	; 0xbe
			if(((element[i] >> k) & 1) == 1) {
 8017952:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017956:	fb01 b707 	mla	r7, r1, r7, fp
 801795a:	e9d7 7417 	ldrd	r7, r4, [r7, #92]	; 0x5c
 801795e:	fb0c 2404 	mla	r4, ip, r4, r2
 8017962:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017966:	f827 6014 	strh.w	r6, [r7, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801796a:	f040 80c9 	bne.w	8017b00 <DrawLowSpectrum+0x2d50>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801796e:	f89a 6000 	ldrb.w	r6, [sl]
	while(i < width) {
 8017972:	45a8      	cmp	r8, r5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017974:	fb01 b606 	mla	r6, r1, r6, fp
 8017978:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801797c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8017980:	ebc4 1484 	rsb	r4, r4, r4, lsl #6
 8017984:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017988:	4414      	add	r4, r2
	while(i < width) {
 801798a:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801798e:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
	while(i < width) {
 8017992:	f000 80c9 	beq.w	8017b28 <DrawLowSpectrum+0x2d78>
			if(((element[i] >> k) & 1) == 1) {
 8017996:	f835 3f02 	ldrh.w	r3, [r5, #2]!
 801799a:	f013 0601 	ands.w	r6, r3, #1
 801799e:	f43f af33 	beq.w	8017808 <DrawLowSpectrum+0x2a58>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80179a2:	f89a 6000 	ldrb.w	r6, [sl]
 80179a6:	fb01 b606 	mla	r6, r1, r6, fp
 80179aa:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80179ae:	fb0e 2404 	mla	r4, lr, r4, r2
 80179b2:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80179b6:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80179ba:	f013 0602 	ands.w	r6, r3, #2
 80179be:	f43f af33 	beq.w	8017828 <DrawLowSpectrum+0x2a78>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80179c2:	f89a 6000 	ldrb.w	r6, [sl]
 80179c6:	fb01 b606 	mla	r6, r1, r6, fp
 80179ca:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80179ce:	fb09 2404 	mla	r4, r9, r4, r2
 80179d2:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80179d6:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80179da:	f013 0604 	ands.w	r6, r3, #4
 80179de:	f43f af33 	beq.w	8017848 <DrawLowSpectrum+0x2a98>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80179e2:	f89a 6000 	ldrb.w	r6, [sl]
 80179e6:	27c5      	movs	r7, #197	; 0xc5
 80179e8:	fb01 b606 	mla	r6, r1, r6, fp
 80179ec:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80179f0:	fb07 2404 	mla	r4, r7, r4, r2
 80179f4:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 80179f8:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80179fc:	f013 0608 	ands.w	r6, r3, #8
 8017a00:	f43f af34 	beq.w	801786c <DrawLowSpectrum+0x2abc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017a04:	f89a 6000 	ldrb.w	r6, [sl]
 8017a08:	27c4      	movs	r7, #196	; 0xc4
 8017a0a:	fb01 b606 	mla	r6, r1, r6, fp
 8017a0e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017a12:	fb07 2404 	mla	r4, r7, r4, r2
 8017a16:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017a1a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017a1e:	f013 0610 	ands.w	r6, r3, #16
 8017a22:	f43f af35 	beq.w	8017890 <DrawLowSpectrum+0x2ae0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017a26:	f89a 6000 	ldrb.w	r6, [sl]
 8017a2a:	fb01 b606 	mla	r6, r1, r6, fp
 8017a2e:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017a32:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8017a36:	eb04 1484 	add.w	r4, r4, r4, lsl #6
 8017a3a:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017a3e:	4414      	add	r4, r2
 8017a40:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017a44:	f013 0620 	ands.w	r6, r3, #32
 8017a48:	f43f af35 	beq.w	80178b6 <DrawLowSpectrum+0x2b06>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017a4c:	f89a 6000 	ldrb.w	r6, [sl]
 8017a50:	27c2      	movs	r7, #194	; 0xc2
 8017a52:	fb01 b606 	mla	r6, r1, r6, fp
 8017a56:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017a5a:	fb07 2404 	mla	r4, r7, r4, r2
 8017a5e:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017a62:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017a66:	f013 0640 	ands.w	r6, r3, #64	; 0x40
 8017a6a:	f43f af36 	beq.w	80178da <DrawLowSpectrum+0x2b2a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017a6e:	f89a 6000 	ldrb.w	r6, [sl]
 8017a72:	fb01 b606 	mla	r6, r1, r6, fp
 8017a76:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017a7a:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8017a7e:	eb04 1487 	add.w	r4, r4, r7, lsl #6
 8017a82:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017a86:	4414      	add	r4, r2
 8017a88:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017a8c:	f013 0680 	ands.w	r6, r3, #128	; 0x80
 8017a90:	f43f af36 	beq.w	8017900 <DrawLowSpectrum+0x2b50>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017a94:	f89a 6000 	ldrb.w	r6, [sl]
 8017a98:	fb01 b606 	mla	r6, r1, r6, fp
 8017a9c:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017aa0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8017aa4:	eb02 1484 	add.w	r4, r2, r4, lsl #6
 8017aa8:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017aac:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017ab0:	f413 7680 	ands.w	r6, r3, #256	; 0x100
 8017ab4:	f43f af36 	beq.w	8017924 <DrawLowSpectrum+0x2b74>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ab8:	f89a 6000 	ldrb.w	r6, [sl]
 8017abc:	fb01 b606 	mla	r6, r1, r6, fp
 8017ac0:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017ac4:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8017ac8:	ebc4 1487 	rsb	r4, r4, r7, lsl #6
 8017acc:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017ad0:	4414      	add	r4, r2
 8017ad2:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017ad6:	f413 7600 	ands.w	r6, r3, #512	; 0x200
 8017ada:	f43f af36 	beq.w	801794a <DrawLowSpectrum+0x2b9a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ade:	f89a 6000 	ldrb.w	r6, [sl]
 8017ae2:	27be      	movs	r7, #190	; 0xbe
			if(((element[i] >> k) & 1) == 1) {
 8017ae4:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ae8:	fb01 b606 	mla	r6, r1, r6, fp
 8017aec:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017af0:	fb07 2404 	mla	r4, r7, r4, r2
 8017af4:	f504 7487 	add.w	r4, r4, #270	; 0x10e
 8017af8:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017afc:	f43f af37 	beq.w	801796e <DrawLowSpectrum+0x2bbe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017b00:	f89a 4000 	ldrb.w	r4, [sl]
	while(i < width) {
 8017b04:	45a8      	cmp	r8, r5
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017b06:	fb01 b404 	mla	r4, r1, r4, fp
 8017b0a:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 8017b0e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8017b12:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 8017b16:	f503 7387 	add.w	r3, r3, #270	; 0x10e
 8017b1a:	4413      	add	r3, r2
	while(i < width) {
 8017b1c:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017b20:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
	while(i < width) {
 8017b24:	f47f af37 	bne.w	8017996 <DrawLowSpectrum+0x2be6>
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b28:	4b4c      	ldr	r3, [pc, #304]	; (8017c5c <DrawLowSpectrum+0x2eac>)
		VLine(40+start_pos, 220, 40, 0x0000FF00);
 8017b2a:	21dc      	movs	r1, #220	; 0xdc
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017b2c:	2634      	movs	r6, #52	; 0x34
 8017b2e:	f04f 09dc 	mov.w	r9, #220	; 0xdc
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b32:	f8d3 2a88 	ldr.w	r2, [r3, #2696]	; 0xa88
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b36:	f603 238c 	addw	r3, r3, #2700	; 0xa8c
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017b3a:	f44f 67fc 	mov.w	r7, #2016	; 0x7e0
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b3e:	ed93 6a00 	vldr	s12, [r3]
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b42:	ee07 2a90 	vmov	s15, r2
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b46:	4b46      	ldr	r3, [pc, #280]	; (8017c60 <DrawLowSpectrum+0x2eb0>)
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b48:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8017b4c:	9203      	str	r2, [sp, #12]
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b4e:	edd3 6a02 	vldr	s13, [r3, #8]
 8017b52:	eeb8 6a46 	vcvt.f32.u32	s12, s12
				(float)display.loopend/rekordbox.spectrum_size;
 8017b56:	ed93 7a03 	vldr	s14, [r3, #12]
		VLine(40+start_pos, 220, 40, 0x0000FF00);
 8017b5a:	2228      	movs	r2, #40	; 0x28
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b5c:	eef8 6a66 	vcvt.f32.u32	s13, s13
				(float)display.loopend/rekordbox.spectrum_size;
 8017b60:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b64:	ee66 6aa7 	vmul.f32	s13, s13, s15
		uint16_t end_pos = rekordbox.lowp_spectrum_size*
 8017b68:	ee27 7a27 	vmul.f32	s14, s14, s15
				(float)display.loopstart/rekordbox.spectrum_size;
 8017b6c:	eec6 7a86 	vdiv.f32	s15, s13, s12
				(float)display.loopend/rekordbox.spectrum_size;
 8017b70:	eec7 6a06 	vdiv.f32	s13, s14, s12
		uint16_t start_pos = rekordbox.lowp_spectrum_size*
 8017b74:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8017b78:	ee17 3a90 	vmov	r3, s15
 8017b7c:	b29d      	uxth	r5, r3
		uint16_t end_pos = rekordbox.lowp_spectrum_size*
 8017b7e:	eebc 7ae6 	vcvt.u32.f32	s14, s13
		VLine(40+start_pos, 220, 40, 0x0000FF00);
 8017b82:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 8017b86:	18a8      	adds	r0, r5, r2
		Pixel(41+start_pos, 220, 0x0000FF00);
 8017b88:	3529      	adds	r5, #41	; 0x29
		uint16_t end_pos = rekordbox.lowp_spectrum_size*
 8017b8a:	ee17 4a10 	vmov	r4, s14
		VLine(40+start_pos, 220, 40, 0x0000FF00);
 8017b8e:	b280      	uxth	r0, r0
 8017b90:	f7fc fcaa 	bl	80144e8 <VLine>
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017b94:	f89a 3000 	ldrb.w	r3, [sl]
 8017b98:	b2ad      	uxth	r5, r5
 8017b9a:	fb06 b303 	mla	r3, r6, r3, fp
		uint16_t end_pos = rekordbox.lowp_spectrum_size*
 8017b9e:	b2a4      	uxth	r4, r4
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017ba0:	e9d3 1217 	ldrd	r1, r2, [r3, #92]	; 0x5c
		VLine(40+end_pos, 220, 40, 0x0000FF00);
 8017ba4:	f104 0028 	add.w	r0, r4, #40	; 0x28
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017ba8:	fb09 5302 	mla	r3, r9, r2, r5
		VLine(40+end_pos, 220, 40, 0x0000FF00);
 8017bac:	2228      	movs	r2, #40	; 0x28
 8017bae:	b280      	uxth	r0, r0
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017bb0:	f821 7013 	strh.w	r7, [r1, r3, lsl #1]
		VLine(40+end_pos, 220, 40, 0x0000FF00);
 8017bb4:	f44f 437f 	mov.w	r3, #65280	; 0xff00
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017bb8:	f89a e000 	ldrb.w	lr, [sl]
		VLine(40+end_pos, 220, 40, 0x0000FF00);
 8017bbc:	4649      	mov	r1, r9
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017bbe:	fb06 be0e 	mla	lr, r6, lr, fp
 8017bc2:	e9de ec17 	ldrd	lr, ip, [lr, #92]	; 0x5c
 8017bc6:	eb0c 18cc 	add.w	r8, ip, ip, lsl #7
 8017bca:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
 8017bce:	4465      	add	r5, ip
 8017bd0:	f82e 7015 	strh.w	r7, [lr, r5, lsl #1]
		VLine(40+end_pos, 220, 40, 0x0000FF00);
 8017bd4:	f7fc fc88 	bl	80144e8 <VLine>
		Pixel(39+end_pos, 220, 0x0000FF00);
 8017bd8:	f104 0327 	add.w	r3, r4, #39	; 0x27
	*(__IO uint16_t*) (hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*hltdc.LayerCfg[ActiveLayer].ImageWidth + Xpos))) = Color_Convertion(color);
 8017bdc:	b299      	uxth	r1, r3
 8017bde:	f89a 3000 	ldrb.w	r3, [sl]
 8017be2:	fb06 b303 	mla	r3, r6, r3, fp
 8017be6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8017be8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8017bea:	fb09 1202 	mla	r2, r9, r2, r1
 8017bee:	f823 7012 	strh.w	r7, [r3, r2, lsl #1]
 8017bf2:	f89a 3000 	ldrb.w	r3, [sl]
 8017bf6:	fb06 b303 	mla	r3, r6, r3, fp
 8017bfa:	e9d3 0217 	ldrd	r0, r2, [r3, #92]	; 0x5c
 8017bfe:	eb02 13c2 	add.w	r3, r2, r2, lsl #7
 8017c02:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8017c06:	440b      	add	r3, r1
 8017c08:	f820 7013 	strh.w	r7, [r0, r3, lsl #1]
}
 8017c0c:	f7fe ba97 	b.w	801613e <DrawLowSpectrum+0x138e>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8017c10:	ebc6 1186 	rsb	r1, r6, r6, lsl #6
		Rectangle(file_pos+40, 253, 400-file_pos, 3, 0x00FFFFFF);
 8017c14:	f107 0228 	add.w	r2, r7, #40	; 0x28
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8017c18:	4623      	mov	r3, r4
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8017c1a:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8017c1e:	fa11 f282 	uxtah	r2, r1, r2
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8017c22:	2103      	movs	r1, #3
 8017c24:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 8017c28:	480e      	ldr	r0, [pc, #56]	; (8017c64 <DrawLowSpectrum+0x2eb4>)
 8017c2a:	9100      	str	r1, [sp, #0]
 8017c2c:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8017c30:	f7e9 ff46 	bl	8001ac0 <HAL_DMA2D_Start>
 8017c34:	2800      	cmp	r0, #0
 8017c36:	f47d aa55 	bne.w	80150e4 <DrawLowSpectrum+0x334>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8017c3a:	2164      	movs	r1, #100	; 0x64
 8017c3c:	4809      	ldr	r0, [pc, #36]	; (8017c64 <DrawLowSpectrum+0x2eb4>)
 8017c3e:	f7e9 ffb5 	bl	8001bac <HAL_DMA2D_PollForTransfer>
}
 8017c42:	f7fd ba4f 	b.w	80150e4 <DrawLowSpectrum+0x334>
 8017c46:	f8df c020 	ldr.w	ip, [pc, #32]	; 8017c68 <DrawLowSpectrum+0x2eb8>
	else if(display.pitchmode == 2) {
 8017c4a:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017c4c:	2134      	movs	r1, #52	; 0x34
 8017c4e:	f44f 4478 	mov.w	r4, #63488	; 0xf800
 8017c52:	f10c 0e44 	add.w	lr, ip, #68	; 0x44
 8017c56:	f04f 09fa 	mov.w	r9, #250	; 0xfa
 8017c5a:	e0a8      	b.n	8017dae <DrawLowSpectrum+0x2ffe>
 8017c5c:	200174f0 	.word	0x200174f0
 8017c60:	20000c70 	.word	0x20000c70
 8017c64:	20000c94 	.word	0x20000c94
 8017c68:	0802647e 	.word	0x0802647e
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017c6c:	f89a 6000 	ldrb.w	r6, [sl]
 8017c70:	fb01 b606 	mla	r6, r1, r6, fp
 8017c74:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017c78:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8017c7c:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8017c80:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017c84:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017c88:	f013 0502 	ands.w	r5, r3, #2
 8017c8c:	f040 80a7 	bne.w	8017dde <DrawLowSpectrum+0x302e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017c90:	f89a 6000 	ldrb.w	r6, [sl]
 8017c94:	fb01 b606 	mla	r6, r1, r6, fp
 8017c98:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017c9c:	ebc0 1780 	rsb	r7, r0, r0, lsl #6
 8017ca0:	ebc0 0087 	rsb	r0, r0, r7, lsl #2
 8017ca4:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017ca8:	4410      	add	r0, r2
 8017caa:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017cae:	f013 0504 	ands.w	r5, r3, #4
 8017cb2:	f040 80a7 	bne.w	8017e04 <DrawLowSpectrum+0x3054>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017cb6:	f89a 6000 	ldrb.w	r6, [sl]
 8017cba:	fb01 b606 	mla	r6, r1, r6, fp
 8017cbe:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017cc2:	fb09 2000 	mla	r0, r9, r0, r2
 8017cc6:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017cca:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017cce:	f013 0508 	ands.w	r5, r3, #8
 8017cd2:	f040 80a7 	bne.w	8017e24 <DrawLowSpectrum+0x3074>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017cd6:	f89a 6000 	ldrb.w	r6, [sl]
 8017cda:	fb01 b606 	mla	r6, r1, r6, fp
 8017cde:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017ce2:	ebc0 1740 	rsb	r7, r0, r0, lsl #5
 8017ce6:	eb00 00c7 	add.w	r0, r0, r7, lsl #3
 8017cea:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017cee:	4410      	add	r0, r2
 8017cf0:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017cf4:	f013 0510 	ands.w	r5, r3, #16
 8017cf8:	f040 80a7 	bne.w	8017e4a <DrawLowSpectrum+0x309a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017cfc:	f89a 6000 	ldrb.w	r6, [sl]
 8017d00:	fb01 b606 	mla	r6, r1, r6, fp
 8017d04:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017d08:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 8017d0c:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 8017d10:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017d14:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017d18:	f013 0520 	ands.w	r5, r3, #32
 8017d1c:	f040 80a7 	bne.w	8017e6e <DrawLowSpectrum+0x30be>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d20:	f89a 6000 	ldrb.w	r6, [sl]
 8017d24:	fb01 b606 	mla	r6, r1, r6, fp
 8017d28:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017d2c:	ebc0 1740 	rsb	r7, r0, r0, lsl #5
 8017d30:	ebc0 00c7 	rsb	r0, r0, r7, lsl #3
 8017d34:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017d38:	4410      	add	r0, r2
 8017d3a:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017d3e:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8017d42:	f040 80a7 	bne.w	8017e94 <DrawLowSpectrum+0x30e4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d46:	f89a 6000 	ldrb.w	r6, [sl]
 8017d4a:	27f6      	movs	r7, #246	; 0xf6
 8017d4c:	fb01 b606 	mla	r6, r1, r6, fp
 8017d50:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017d54:	fb07 2000 	mla	r0, r7, r0, r2
 8017d58:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017d5c:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017d60:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 8017d64:	f040 80a7 	bne.w	8017eb6 <DrawLowSpectrum+0x3106>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d68:	f89a 6000 	ldrb.w	r6, [sl]
 8017d6c:	27f5      	movs	r7, #245	; 0xf5
			if(((element[i] >> k) & 1) == 1) {
 8017d6e:	f413 7380 	ands.w	r3, r3, #256	; 0x100
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d72:	fb01 b606 	mla	r6, r1, r6, fp
 8017d76:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8017d7a:	fb07 2000 	mla	r0, r7, r0, r2
 8017d7e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017d82:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017d86:	f040 80a7 	bne.w	8017ed8 <DrawLowSpectrum+0x3128>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d8a:	f89a 5000 	ldrb.w	r5, [sl]
 8017d8e:	26f4      	movs	r6, #244	; 0xf4
	while(i < width) {
 8017d90:	45e6      	cmp	lr, ip
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017d92:	fb01 b505 	mla	r5, r1, r5, fp
 8017d96:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017d9a:	fb06 2000 	mla	r0, r6, r0, r2
	while(i < width) {
 8017d9e:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017da2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017da6:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
	while(i < width) {
 8017daa:	f000 80a7 	beq.w	8017efc <DrawLowSpectrum+0x314c>
			if(((element[i] >> k) & 1) == 1) {
 8017dae:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
 8017db2:	f013 0501 	ands.w	r5, r3, #1
 8017db6:	f43f af59 	beq.w	8017c6c <DrawLowSpectrum+0x2ebc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017dba:	f89a 5000 	ldrb.w	r5, [sl]
 8017dbe:	fb01 b505 	mla	r5, r1, r5, fp
 8017dc2:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017dc6:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8017dca:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8017dce:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017dd2:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017dd6:	f013 0502 	ands.w	r5, r3, #2
 8017dda:	f43f af59 	beq.w	8017c90 <DrawLowSpectrum+0x2ee0>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017dde:	f89a 5000 	ldrb.w	r5, [sl]
 8017de2:	fb01 b505 	mla	r5, r1, r5, fp
 8017de6:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017dea:	ebc0 1680 	rsb	r6, r0, r0, lsl #6
 8017dee:	ebc0 0086 	rsb	r0, r0, r6, lsl #2
 8017df2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017df6:	4410      	add	r0, r2
 8017df8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017dfc:	f013 0504 	ands.w	r5, r3, #4
 8017e00:	f43f af59 	beq.w	8017cb6 <DrawLowSpectrum+0x2f06>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017e04:	f89a 5000 	ldrb.w	r5, [sl]
 8017e08:	fb01 b505 	mla	r5, r1, r5, fp
 8017e0c:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017e10:	fb09 2000 	mla	r0, r9, r0, r2
 8017e14:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017e18:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017e1c:	f013 0508 	ands.w	r5, r3, #8
 8017e20:	f43f af59 	beq.w	8017cd6 <DrawLowSpectrum+0x2f26>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017e24:	f89a 5000 	ldrb.w	r5, [sl]
 8017e28:	fb01 b505 	mla	r5, r1, r5, fp
 8017e2c:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017e30:	ebc0 1640 	rsb	r6, r0, r0, lsl #5
 8017e34:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8017e38:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017e3c:	4410      	add	r0, r2
 8017e3e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017e42:	f013 0510 	ands.w	r5, r3, #16
 8017e46:	f43f af59 	beq.w	8017cfc <DrawLowSpectrum+0x2f4c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017e4a:	f89a 5000 	ldrb.w	r5, [sl]
 8017e4e:	fb01 b505 	mla	r5, r1, r5, fp
 8017e52:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017e56:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 8017e5a:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 8017e5e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017e62:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017e66:	f013 0520 	ands.w	r5, r3, #32
 8017e6a:	f43f af59 	beq.w	8017d20 <DrawLowSpectrum+0x2f70>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017e6e:	f89a 5000 	ldrb.w	r5, [sl]
 8017e72:	fb01 b505 	mla	r5, r1, r5, fp
 8017e76:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017e7a:	ebc0 1640 	rsb	r6, r0, r0, lsl #5
 8017e7e:	ebc0 00c6 	rsb	r0, r0, r6, lsl #3
 8017e82:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017e86:	4410      	add	r0, r2
 8017e88:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017e8c:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8017e90:	f43f af59 	beq.w	8017d46 <DrawLowSpectrum+0x2f96>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017e94:	f89a 5000 	ldrb.w	r5, [sl]
 8017e98:	26f6      	movs	r6, #246	; 0xf6
 8017e9a:	fb01 b505 	mla	r5, r1, r5, fp
 8017e9e:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017ea2:	fb06 2000 	mla	r0, r6, r0, r2
 8017ea6:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017eaa:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017eae:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 8017eb2:	f43f af59 	beq.w	8017d68 <DrawLowSpectrum+0x2fb8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017eb6:	f89a 5000 	ldrb.w	r5, [sl]
 8017eba:	26f5      	movs	r6, #245	; 0xf5
			if(((element[i] >> k) & 1) == 1) {
 8017ebc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ec0:	fb01 b505 	mla	r5, r1, r5, fp
 8017ec4:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8017ec8:	fb06 2000 	mla	r0, r6, r0, r2
 8017ecc:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8017ed0:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8017ed4:	f43f af59 	beq.w	8017d8a <DrawLowSpectrum+0x2fda>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ed8:	f89a 0000 	ldrb.w	r0, [sl]
 8017edc:	25f4      	movs	r5, #244	; 0xf4
	while(i < width) {
 8017ede:	45e6      	cmp	lr, ip
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ee0:	fb01 b000 	mla	r0, r1, r0, fp
 8017ee4:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 8017ee8:	fb05 2303 	mla	r3, r5, r3, r2
	while(i < width) {
 8017eec:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017ef0:	f203 13bd 	addw	r3, r3, #445	; 0x1bd
 8017ef4:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
	while(i < width) {
 8017ef8:	f47f af59 	bne.w	8017dae <DrawLowSpectrum+0x2ffe>
		if(percent / 1000 > 0) {
 8017efc:	9b03      	ldr	r3, [sp, #12]
 8017efe:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8017f02:	f080 83e9 	bcs.w	80186d8 <DrawLowSpectrum+0x3928>
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 8017f06:	4cdc      	ldr	r4, [pc, #880]	; (8018278 <DrawLowSpectrum+0x34c8>)
 8017f08:	fba4 3403 	umull	r3, r4, r4, r3
 8017f0c:	0964      	lsrs	r4, r4, #5
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 8017f0e:	4ddb      	ldr	r5, [pc, #876]	; (801827c <DrawLowSpectrum+0x34cc>)
 8017f10:	f06f 497f 	mvn.w	r9, #4278190080	; 0xff000000
 8017f14:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 8017f18:	22ba      	movs	r2, #186	; 0xba
 8017f1a:	fba5 3004 	umull	r3, r0, r5, r4
 8017f1e:	230a      	movs	r3, #10
 8017f20:	f8cd 9000 	str.w	r9, [sp]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f24:	f64f 77ff 	movw	r7, #65535	; 0xffff
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 8017f28:	08c0      	lsrs	r0, r0, #3
 8017f2a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8017f2e:	eba4 0040 	sub.w	r0, r4, r0, lsl #1
 8017f32:	b2c0      	uxtb	r0, r0
 8017f34:	f7fc fb64 	bl	8014600 <DrawDigit>
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f38:	9b03      	ldr	r3, [sp, #12]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f3a:	f04f 0ccc 	mov.w	ip, #204	; 0xcc
 8017f3e:	f04f 0ecb 	mov.w	lr, #203	; 0xcb
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f42:	fba5 3203 	umull	r3, r2, r5, r3
 8017f46:	08d2      	lsrs	r2, r2, #3
 8017f48:	fba5 1302 	umull	r1, r3, r5, r2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f4c:	2534      	movs	r5, #52	; 0x34
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f4e:	f240 1159 	movw	r1, #345	; 0x159
 8017f52:	08db      	lsrs	r3, r3, #3
 8017f54:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8017f58:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f5c:	f89a 2000 	ldrb.w	r2, [sl]
 8017f60:	fb05 b202 	mla	r2, r5, r2, fp
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f64:	b2d8      	uxtb	r0, r3
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f66:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8017f6a:	fb0c f303 	mul.w	r3, ip, r3
 8017f6e:	f203 1355 	addw	r3, r3, #341	; 0x155
 8017f72:	f822 7013 	strh.w	r7, [r2, r3, lsl #1]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f76:	230a      	movs	r3, #10
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f78:	f89a 6000 	ldrb.w	r6, [sl]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017f7c:	22ba      	movs	r2, #186	; 0xba
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017f7e:	fb05 b606 	mla	r6, r5, r6, fp
 8017f82:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 8017f86:	fb0e f404 	mul.w	r4, lr, r4
 8017f8a:	f204 1455 	addw	r4, r4, #341	; 0x155
 8017f8e:	f826 7014 	strh.w	r7, [r6, r4, lsl #1]
 8017f92:	f89a 6000 	ldrb.w	r6, [sl]
 8017f96:	fb05 b606 	mla	r6, r5, r6, fp
 8017f9a:	6e34      	ldr	r4, [r6, #96]	; 0x60
 8017f9c:	6df6      	ldr	r6, [r6, #92]	; 0x5c
 8017f9e:	fb0c f404 	mul.w	r4, ip, r4
 8017fa2:	f504 74ab 	add.w	r4, r4, #342	; 0x156
 8017fa6:	f826 7014 	strh.w	r7, [r6, r4, lsl #1]
 8017faa:	f89a 4000 	ldrb.w	r4, [sl]
 8017fae:	fb05 b504 	mla	r5, r5, r4, fp
 8017fb2:	6e2c      	ldr	r4, [r5, #96]	; 0x60
 8017fb4:	6ded      	ldr	r5, [r5, #92]	; 0x5c
 8017fb6:	fb0e f404 	mul.w	r4, lr, r4
 8017fba:	f504 74ab 	add.w	r4, r4, #342	; 0x156
 8017fbe:	f825 7014 	strh.w	r7, [r5, r4, lsl #1]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8017fc2:	f8cd 9000 	str.w	r9, [sp]
 8017fc6:	f7fc fb1b 	bl	8014600 <DrawDigit>
		DrawDigit((percent % 2) * 5, 360, 186, 10, 0x00FFFFFF);
 8017fca:	f008 0001 	and.w	r0, r8, #1
 8017fce:	230a      	movs	r3, #10
 8017fd0:	22ba      	movs	r2, #186	; 0xba
 8017fd2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8017fd6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8017fda:	f8cd 9000 	str.w	r9, [sp]
 8017fde:	f7fc fb0f 	bl	8014600 <DrawDigit>
 8017fe2:	f7fd bb80 	b.w	80156e6 <DrawLowSpectrum+0x936>
 8017fe6:	f8df c298 	ldr.w	ip, [pc, #664]	; 8018280 <DrawLowSpectrum+0x34d0>
	else if(display.pitchmode == 1) {
 8017fea:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8017fec:	2134      	movs	r1, #52	; 0x34
 8017fee:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8017ff2:	f10c 0e44 	add.w	lr, ip, #68	; 0x44
 8017ff6:	f04f 09ee 	mov.w	r9, #238	; 0xee
 8017ffa:	e09d      	b.n	8018138 <DrawLowSpectrum+0x3388>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8017ffc:	f89a 6000 	ldrb.w	r6, [sl]
 8018000:	fb01 b606 	mla	r6, r1, r6, fp
 8018004:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8018008:	ebc0 1700 	rsb	r7, r0, r0, lsl #4
 801800c:	eb00 1007 	add.w	r0, r0, r7, lsl #4
 8018010:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018014:	4410      	add	r0, r2
 8018016:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801801a:	f013 0502 	ands.w	r5, r3, #2
 801801e:	f040 80a4 	bne.w	801816a <DrawLowSpectrum+0x33ba>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018022:	f89a 6000 	ldrb.w	r6, [sl]
 8018026:	fb01 b606 	mla	r6, r1, r6, fp
 801802a:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801802e:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8018032:	eb02 1000 	add.w	r0, r2, r0, lsl #4
 8018036:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801803a:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801803e:	f013 0504 	ands.w	r5, r3, #4
 8018042:	f040 80a4 	bne.w	801818e <DrawLowSpectrum+0x33de>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018046:	f89a 6000 	ldrb.w	r6, [sl]
 801804a:	fb01 b606 	mla	r6, r1, r6, fp
 801804e:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8018052:	ebc0 1700 	rsb	r7, r0, r0, lsl #4
 8018056:	ebc0 1007 	rsb	r0, r0, r7, lsl #4
 801805a:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801805e:	4410      	add	r0, r2
 8018060:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018064:	f013 0508 	ands.w	r5, r3, #8
 8018068:	f040 80a4 	bne.w	80181b4 <DrawLowSpectrum+0x3404>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801806c:	f89a 6000 	ldrb.w	r6, [sl]
 8018070:	fb01 b606 	mla	r6, r1, r6, fp
 8018074:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8018078:	fb09 2000 	mla	r0, r9, r0, r2
 801807c:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018080:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018084:	f013 0510 	ands.w	r5, r3, #16
 8018088:	f040 80a4 	bne.w	80181d4 <DrawLowSpectrum+0x3424>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801808c:	f89a 6000 	ldrb.w	r6, [sl]
 8018090:	27ed      	movs	r7, #237	; 0xed
 8018092:	fb01 b606 	mla	r6, r1, r6, fp
 8018096:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 801809a:	fb07 2000 	mla	r0, r7, r0, r2
 801809e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80180a2:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80180a6:	f013 0520 	ands.w	r5, r3, #32
 80180aa:	f040 80a4 	bne.w	80181f6 <DrawLowSpectrum+0x3446>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80180ae:	f89a 6000 	ldrb.w	r6, [sl]
 80180b2:	27ec      	movs	r7, #236	; 0xec
 80180b4:	fb01 b606 	mla	r6, r1, r6, fp
 80180b8:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80180bc:	fb07 2000 	mla	r0, r7, r0, r2
 80180c0:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80180c4:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80180c8:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 80180cc:	f040 80a4 	bne.w	8018218 <DrawLowSpectrum+0x3468>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80180d0:	f89a 6000 	ldrb.w	r6, [sl]
 80180d4:	27eb      	movs	r7, #235	; 0xeb
 80180d6:	fb01 b606 	mla	r6, r1, r6, fp
 80180da:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 80180de:	fb07 2000 	mla	r0, r7, r0, r2
 80180e2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80180e6:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80180ea:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 80180ee:	f040 80a4 	bne.w	801823a <DrawLowSpectrum+0x348a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80180f2:	f89a 6000 	ldrb.w	r6, [sl]
 80180f6:	27ea      	movs	r7, #234	; 0xea
			if(((element[i] >> k) & 1) == 1) {
 80180f8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80180fc:	fb01 b606 	mla	r6, r1, r6, fp
 8018100:	e9d6 6017 	ldrd	r6, r0, [r6, #92]	; 0x5c
 8018104:	fb07 2000 	mla	r0, r7, r0, r2
 8018108:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801810c:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018110:	f040 80a4 	bne.w	801825c <DrawLowSpectrum+0x34ac>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018114:	f89a 5000 	ldrb.w	r5, [sl]
 8018118:	26e9      	movs	r6, #233	; 0xe9
 801811a:	fb01 b505 	mla	r5, r1, r5, fp
 801811e:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018122:	fb06 2000 	mla	r0, r6, r0, r2
 8018126:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801812a:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
	while(i < width) {
 801812e:	45e6      	cmp	lr, ip
 8018130:	f102 0201 	add.w	r2, r2, #1
 8018134:	f43f aee2 	beq.w	8017efc <DrawLowSpectrum+0x314c>
			if(((element[i] >> k) & 1) == 1) {
 8018138:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
 801813c:	f013 0501 	ands.w	r5, r3, #1
 8018140:	f43f af5c 	beq.w	8017ffc <DrawLowSpectrum+0x324c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018144:	f89a 5000 	ldrb.w	r5, [sl]
 8018148:	fb01 b505 	mla	r5, r1, r5, fp
 801814c:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018150:	ebc0 1600 	rsb	r6, r0, r0, lsl #4
 8018154:	eb00 1006 	add.w	r0, r0, r6, lsl #4
 8018158:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801815c:	4410      	add	r0, r2
 801815e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018162:	f013 0502 	ands.w	r5, r3, #2
 8018166:	f43f af5c 	beq.w	8018022 <DrawLowSpectrum+0x3272>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801816a:	f89a 5000 	ldrb.w	r5, [sl]
 801816e:	fb01 b505 	mla	r5, r1, r5, fp
 8018172:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018176:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 801817a:	eb02 1000 	add.w	r0, r2, r0, lsl #4
 801817e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018182:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018186:	f013 0504 	ands.w	r5, r3, #4
 801818a:	f43f af5c 	beq.w	8018046 <DrawLowSpectrum+0x3296>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801818e:	f89a 5000 	ldrb.w	r5, [sl]
 8018192:	fb01 b505 	mla	r5, r1, r5, fp
 8018196:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 801819a:	ebc0 1600 	rsb	r6, r0, r0, lsl #4
 801819e:	ebc0 1006 	rsb	r0, r0, r6, lsl #4
 80181a2:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80181a6:	4410      	add	r0, r2
 80181a8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80181ac:	f013 0508 	ands.w	r5, r3, #8
 80181b0:	f43f af5c 	beq.w	801806c <DrawLowSpectrum+0x32bc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80181b4:	f89a 5000 	ldrb.w	r5, [sl]
 80181b8:	fb01 b505 	mla	r5, r1, r5, fp
 80181bc:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80181c0:	fb09 2000 	mla	r0, r9, r0, r2
 80181c4:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80181c8:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80181cc:	f013 0510 	ands.w	r5, r3, #16
 80181d0:	f43f af5c 	beq.w	801808c <DrawLowSpectrum+0x32dc>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80181d4:	f89a 5000 	ldrb.w	r5, [sl]
 80181d8:	26ed      	movs	r6, #237	; 0xed
 80181da:	fb01 b505 	mla	r5, r1, r5, fp
 80181de:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80181e2:	fb06 2000 	mla	r0, r6, r0, r2
 80181e6:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80181ea:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80181ee:	f013 0520 	ands.w	r5, r3, #32
 80181f2:	f43f af5c 	beq.w	80180ae <DrawLowSpectrum+0x32fe>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80181f6:	f89a 5000 	ldrb.w	r5, [sl]
 80181fa:	26ec      	movs	r6, #236	; 0xec
 80181fc:	fb01 b505 	mla	r5, r1, r5, fp
 8018200:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018204:	fb06 2000 	mla	r0, r6, r0, r2
 8018208:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801820c:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018210:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8018214:	f43f af5c 	beq.w	80180d0 <DrawLowSpectrum+0x3320>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018218:	f89a 5000 	ldrb.w	r5, [sl]
 801821c:	26eb      	movs	r6, #235	; 0xeb
 801821e:	fb01 b505 	mla	r5, r1, r5, fp
 8018222:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018226:	fb06 2000 	mla	r0, r6, r0, r2
 801822a:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801822e:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018232:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 8018236:	f43f af5c 	beq.w	80180f2 <DrawLowSpectrum+0x3342>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801823a:	f89a 5000 	ldrb.w	r5, [sl]
 801823e:	26ea      	movs	r6, #234	; 0xea
			if(((element[i] >> k) & 1) == 1) {
 8018240:	f413 7380 	ands.w	r3, r3, #256	; 0x100
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018244:	fb01 b505 	mla	r5, r1, r5, fp
 8018248:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 801824c:	fb06 2000 	mla	r0, r6, r0, r2
 8018250:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018254:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018258:	f43f af5c 	beq.w	8018114 <DrawLowSpectrum+0x3364>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801825c:	f89a 0000 	ldrb.w	r0, [sl]
 8018260:	25e9      	movs	r5, #233	; 0xe9
 8018262:	fb01 b000 	mla	r0, r1, r0, fp
 8018266:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 801826a:	fb05 2303 	mla	r3, r5, r3, r2
 801826e:	f203 13bd 	addw	r3, r3, #445	; 0x1bd
 8018272:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
 8018276:	e75a      	b.n	801812e <DrawLowSpectrum+0x337e>
 8018278:	51eb851f 	.word	0x51eb851f
 801827c:	cccccccd 	.word	0xcccccccd
 8018280:	080264c2 	.word	0x080264c2
			DrawDigit(percent / 10000, 315, 186, 10, 0x00FFFFFF);
 8018284:	4613      	mov	r3, r2
 8018286:	48d1      	ldr	r0, [pc, #836]	; (80185cc <DrawLowSpectrum+0x381c>)
 8018288:	22ba      	movs	r2, #186	; 0xba
 801828a:	f240 113b 	movw	r1, #315	; 0x13b
 801828e:	fba0 3003 	umull	r3, r0, r0, r3
 8018292:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8018296:	0b40      	lsrs	r0, r0, #13
 8018298:	9300      	str	r3, [sp, #0]
 801829a:	230a      	movs	r3, #10
 801829c:	f7fc f9b0 	bl	8014600 <DrawDigit>
			DrawDigit(((percent / 100) % 100) / 10, 330, 186, 10, 0x00FFFFFF);
 80182a0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80182a4:	4aca      	ldr	r2, [pc, #808]	; (80185d0 <DrawLowSpectrum+0x3820>)
 80182a6:	2064      	movs	r0, #100	; 0x64
 80182a8:	49ca      	ldr	r1, [pc, #808]	; (80185d4 <DrawLowSpectrum+0x3824>)
 80182aa:	9300      	str	r3, [sp, #0]
 80182ac:	9b03      	ldr	r3, [sp, #12]
 80182ae:	fba2 4303 	umull	r4, r3, r2, r3
 80182b2:	095b      	lsrs	r3, r3, #5
 80182b4:	fba2 4203 	umull	r4, r2, r2, r3
 80182b8:	0954      	lsrs	r4, r2, #5
 80182ba:	22ba      	movs	r2, #186	; 0xba
 80182bc:	fb00 3314 	mls	r3, r0, r4, r3
 80182c0:	b29c      	uxth	r4, r3
 80182c2:	fba1 3104 	umull	r3, r1, r1, r4
 80182c6:	230a      	movs	r3, #10
 80182c8:	f3c1 00c7 	ubfx	r0, r1, #3, #8
 80182cc:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 80182d0:	f7fc f996 	bl	8014600 <DrawDigit>
 80182d4:	f7fe be4e 	b.w	8016f74 <DrawLowSpectrum+0x21c4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80182d8:	f89a 4000 	ldrb.w	r4, [sl]
 80182dc:	fb01 b404 	mla	r4, r1, r4, fp
 80182e0:	e9d4 4317 	ldrd	r4, r3, [r4, #92]	; 0x5c
 80182e4:	fb08 2303 	mla	r3, r8, r3, r2
 80182e8:	3301      	adds	r3, #1
 80182ea:	f824 0013 	strh.w	r0, [r4, r3, lsl #1]
 80182ee:	f7fe bc3f 	b.w	8016b70 <DrawLowSpectrum+0x1dc0>
 80182f2:	f89a 6000 	ldrb.w	r6, [sl]
 80182f6:	fb01 b606 	mla	r6, r1, r6, fp
 80182fa:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 80182fe:	ebc4 1784 	rsb	r7, r4, r4, lsl #6
 8018302:	ebc4 0487 	rsb	r4, r4, r7, lsl #2
 8018306:	3401      	adds	r4, #1
 8018308:	4414      	add	r4, r2
 801830a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 801830e:	f7fe bc20 	b.w	8016b52 <DrawLowSpectrum+0x1da2>
 8018312:	f89a 6000 	ldrb.w	r6, [sl]
 8018316:	fb01 b606 	mla	r6, r1, r6, fp
 801831a:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801831e:	ebc4 1484 	rsb	r4, r4, r4, lsl #6
 8018322:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8018326:	3401      	adds	r4, #1
 8018328:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 801832c:	f7fe bbff 	b.w	8016b2e <DrawLowSpectrum+0x1d7e>
 8018330:	f89a 6000 	ldrb.w	r6, [sl]
 8018334:	fb01 b606 	mla	r6, r1, r6, fp
 8018338:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801833c:	ebc4 1784 	rsb	r7, r4, r4, lsl #6
 8018340:	eb04 0487 	add.w	r4, r4, r7, lsl #2
 8018344:	3401      	adds	r4, #1
 8018346:	4414      	add	r4, r2
 8018348:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 801834c:	f7fe bbde 	b.w	8016b0c <DrawLowSpectrum+0x1d5c>
 8018350:	f89a 6000 	ldrb.w	r6, [sl]
 8018354:	fb01 b606 	mla	r6, r1, r6, fp
 8018358:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801835c:	ebc4 14c4 	rsb	r4, r4, r4, lsl #7
 8018360:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8018364:	3401      	adds	r4, #1
 8018366:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 801836a:	f7fe bbbd 	b.w	8016ae8 <DrawLowSpectrum+0x1d38>
 801836e:	f89a 6000 	ldrb.w	r6, [sl]
 8018372:	fb01 b606 	mla	r6, r1, r6, fp
 8018376:	e9d6 6417 	ldrd	r6, r4, [r6, #92]	; 0x5c
 801837a:	ebc4 2404 	rsb	r4, r4, r4, lsl #8
 801837e:	3401      	adds	r4, #1
 8018380:	4414      	add	r4, r2
 8018382:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 8018386:	f7fe bb9e 	b.w	8016ac6 <DrawLowSpectrum+0x1d16>
 801838a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 801838e:	f7fe bb8a 	b.w	8016aa6 <DrawLowSpectrum+0x1cf6>
 8018392:	f8df c244 	ldr.w	ip, [pc, #580]	; 80185d8 <DrawLowSpectrum+0x3828>
	else if(display.pitchmode == 3) {
 8018396:	2200      	movs	r2, #0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018398:	2134      	movs	r1, #52	; 0x34
 801839a:	f44f 67fc 	mov.w	r7, #2016	; 0x7e0
 801839e:	f10c 0e44 	add.w	lr, ip, #68	; 0x44
 80183a2:	f44f 7883 	mov.w	r8, #262	; 0x106
 80183a6:	e09a      	b.n	80184de <DrawLowSpectrum+0x372e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80183a8:	f89a 5000 	ldrb.w	r5, [sl]
 80183ac:	fb01 b505 	mla	r5, r1, r5, fp
 80183b0:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80183b4:	eb00 1640 	add.w	r6, r0, r0, lsl #5
 80183b8:	ebc0 00c6 	rsb	r0, r0, r6, lsl #3
 80183bc:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80183c0:	4410      	add	r0, r2
 80183c2:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80183c6:	f89a 4000 	ldrb.w	r4, [sl]
			if(((element[i] >> k) & 1) == 1) {
 80183ca:	f013 0502 	ands.w	r5, r3, #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80183ce:	fb01 b404 	mla	r4, r1, r4, fp
 80183d2:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 80183d6:	fb08 2000 	mla	r0, r8, r0, r2
 80183da:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
			if(((element[i] >> k) & 1) == 1) {
 80183de:	f040 80f1 	bne.w	80185c4 <DrawLowSpectrum+0x3814>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80183e2:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80183e6:	f013 0404 	ands.w	r4, r3, #4
 80183ea:	f040 80db 	bne.w	80185a4 <DrawLowSpectrum+0x37f4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80183ee:	f89a 5000 	ldrb.w	r5, [sl]
 80183f2:	fb01 b505 	mla	r5, r1, r5, fp
 80183f6:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 80183fa:	eb00 1680 	add.w	r6, r0, r0, lsl #6
 80183fe:	eb00 0086 	add.w	r0, r0, r6, lsl #2
 8018402:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018406:	4410      	add	r0, r2
 8018408:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 801840c:	f013 0408 	ands.w	r4, r3, #8
 8018410:	f040 80b9 	bne.w	8018586 <DrawLowSpectrum+0x37d6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018414:	f89a 5000 	ldrb.w	r5, [sl]
 8018418:	fb01 b505 	mla	r5, r1, r5, fp
 801841c:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018420:	eb00 1080 	add.w	r0, r0, r0, lsl #6
 8018424:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8018428:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801842c:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018430:	f013 0410 	ands.w	r4, r3, #16
 8018434:	f040 8097 	bne.w	8018566 <DrawLowSpectrum+0x37b6>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018438:	f89a 5000 	ldrb.w	r5, [sl]
 801843c:	fb01 b505 	mla	r5, r1, r5, fp
 8018440:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018444:	eb00 16c0 	add.w	r6, r0, r0, lsl #7
 8018448:	eb00 0046 	add.w	r0, r0, r6, lsl #1
 801844c:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018450:	4410      	add	r0, r2
 8018452:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018456:	f013 0420 	ands.w	r4, r3, #32
 801845a:	d175      	bne.n	8018548 <DrawLowSpectrum+0x3798>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801845c:	f89a 5000 	ldrb.w	r5, [sl]
 8018460:	fb01 b505 	mla	r5, r1, r5, fp
 8018464:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 8018468:	eb00 10c0 	add.w	r0, r0, r0, lsl #7
 801846c:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8018470:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018474:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018478:	f013 0440 	ands.w	r4, r3, #64	; 0x40
 801847c:	d156      	bne.n	801852c <DrawLowSpectrum+0x377c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 801847e:	f89a 5000 	ldrb.w	r5, [sl]
 8018482:	fb01 b505 	mla	r5, r1, r5, fp
 8018486:	e9d5 5017 	ldrd	r5, r0, [r5, #92]	; 0x5c
 801848a:	eb00 2000 	add.w	r0, r0, r0, lsl #8
 801848e:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018492:	4410      	add	r0, r2
 8018494:	f825 4010 	strh.w	r4, [r5, r0, lsl #1]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018498:	f89a 4000 	ldrb.w	r4, [sl]
			if(((element[i] >> k) & 1) == 1) {
 801849c:	f013 0580 	ands.w	r5, r3, #128	; 0x80
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80184a0:	fb01 b404 	mla	r4, r1, r4, fp
 80184a4:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 80184a8:	eb02 2000 	add.w	r0, r2, r0, lsl #8
 80184ac:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
			if(((element[i] >> k) & 1) == 1) {
 80184b0:	d139      	bne.n	8018526 <DrawLowSpectrum+0x3776>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80184b2:	f824 5010 	strh.w	r5, [r4, r0, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 80184b6:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 80184ba:	d126      	bne.n	801850a <DrawLowSpectrum+0x375a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 80184bc:	f89a 4000 	ldrb.w	r4, [sl]
 80184c0:	fb01 b404 	mla	r4, r1, r4, fp
 80184c4:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 80184c8:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
 80184cc:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80184d0:	4410      	add	r0, r2
 80184d2:	f824 3010 	strh.w	r3, [r4, r0, lsl #1]
	while(i < width) {
 80184d6:	45e6      	cmp	lr, ip
 80184d8:	f102 0201 	add.w	r2, r2, #1
 80184dc:	d07e      	beq.n	80185dc <DrawLowSpectrum+0x382c>
			if(((element[i] >> k) & 1) == 1) {
 80184de:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
 80184e2:	f013 0401 	ands.w	r4, r3, #1
 80184e6:	f43f af5f 	beq.w	80183a8 <DrawLowSpectrum+0x35f8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80184ea:	f89a 4000 	ldrb.w	r4, [sl]
 80184ee:	fb01 b404 	mla	r4, r1, r4, fp
 80184f2:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 80184f6:	eb00 1540 	add.w	r5, r0, r0, lsl #5
 80184fa:	ebc0 00c5 	rsb	r0, r0, r5, lsl #3
 80184fe:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018502:	4410      	add	r0, r2
 8018504:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 8018508:	e75d      	b.n	80183c6 <DrawLowSpectrum+0x3616>
 801850a:	f89a 0000 	ldrb.w	r0, [sl]
 801850e:	fb01 b000 	mla	r0, r1, r0, fp
 8018512:	e9d0 0317 	ldrd	r0, r3, [r0, #92]	; 0x5c
 8018516:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 801851a:	f203 13bd 	addw	r3, r3, #445	; 0x1bd
 801851e:	4413      	add	r3, r2
 8018520:	f820 7013 	strh.w	r7, [r0, r3, lsl #1]
 8018524:	e7d7      	b.n	80184d6 <DrawLowSpectrum+0x3726>
 8018526:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 801852a:	e7c4      	b.n	80184b6 <DrawLowSpectrum+0x3706>
 801852c:	f89a 4000 	ldrb.w	r4, [sl]
 8018530:	fb01 b404 	mla	r4, r1, r4, fp
 8018534:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8018538:	eb00 2000 	add.w	r0, r0, r0, lsl #8
 801853c:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018540:	4410      	add	r0, r2
 8018542:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 8018546:	e7a7      	b.n	8018498 <DrawLowSpectrum+0x36e8>
 8018548:	f89a 4000 	ldrb.w	r4, [sl]
 801854c:	fb01 b404 	mla	r4, r1, r4, fp
 8018550:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8018554:	eb00 10c0 	add.w	r0, r0, r0, lsl #7
 8018558:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 801855c:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 8018560:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 8018564:	e788      	b.n	8018478 <DrawLowSpectrum+0x36c8>
 8018566:	f89a 4000 	ldrb.w	r4, [sl]
 801856a:	fb01 b404 	mla	r4, r1, r4, fp
 801856e:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8018572:	eb00 15c0 	add.w	r5, r0, r0, lsl #7
 8018576:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 801857a:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801857e:	4410      	add	r0, r2
 8018580:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 8018584:	e767      	b.n	8018456 <DrawLowSpectrum+0x36a6>
 8018586:	f89a 4000 	ldrb.w	r4, [sl]
 801858a:	fb01 b404 	mla	r4, r1, r4, fp
 801858e:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 8018592:	eb00 1080 	add.w	r0, r0, r0, lsl #6
 8018596:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 801859a:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 801859e:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 80185a2:	e745      	b.n	8018430 <DrawLowSpectrum+0x3680>
 80185a4:	f89a 4000 	ldrb.w	r4, [sl]
 80185a8:	fb01 b404 	mla	r4, r1, r4, fp
 80185ac:	e9d4 4017 	ldrd	r4, r0, [r4, #92]	; 0x5c
 80185b0:	eb00 1580 	add.w	r5, r0, r0, lsl #6
 80185b4:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 80185b8:	f200 10bd 	addw	r0, r0, #445	; 0x1bd
 80185bc:	4410      	add	r0, r2
 80185be:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 80185c2:	e723      	b.n	801840c <DrawLowSpectrum+0x365c>
 80185c4:	f824 7010 	strh.w	r7, [r4, r0, lsl #1]
 80185c8:	e70d      	b.n	80183e6 <DrawLowSpectrum+0x3636>
 80185ca:	bf00      	nop
 80185cc:	d1b71759 	.word	0xd1b71759
 80185d0:	51eb851f 	.word	0x51eb851f
 80185d4:	cccccccd 	.word	0xcccccccd
 80185d8:	08026506 	.word	0x08026506
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 80185dc:	9e03      	ldr	r6, [sp, #12]
 80185de:	2164      	movs	r1, #100	; 0x64
 80185e0:	4a4b      	ldr	r2, [pc, #300]	; (8018710 <DrawLowSpectrum+0x3960>)
 80185e2:	f06f 487f 	mvn.w	r8, #4278190080	; 0xff000000
 80185e6:	4c4b      	ldr	r4, [pc, #300]	; (8018714 <DrawLowSpectrum+0x3964>)
 80185e8:	fba2 0306 	umull	r0, r3, r2, r6
 80185ec:	f8cd 8000 	str.w	r8, [sp]
 80185f0:	095b      	lsrs	r3, r3, #5
 80185f2:	fba2 0203 	umull	r0, r2, r2, r3
 80185f6:	0950      	lsrs	r0, r2, #5
 80185f8:	22ba      	movs	r2, #186	; 0xba
 80185fa:	fb01 3310 	mls	r3, r1, r0, r3
 80185fe:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 8018602:	b298      	uxth	r0, r3
 8018604:	230a      	movs	r3, #10
 8018606:	fba4 7500 	umull	r7, r5, r4, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801860a:	f64f 77ff 	movw	r7, #65535	; 0xffff
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 801860e:	08ed      	lsrs	r5, r5, #3
 8018610:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8018614:	eba0 0045 	sub.w	r0, r0, r5, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018618:	2534      	movs	r5, #52	; 0x34
		DrawDigit(((percent / 100) % 100) % 10, 330, 186, 10, 0x00FFFFFF);
 801861a:	b2c0      	uxtb	r0, r0
 801861c:	f7fb fff0 	bl	8014600 <DrawDigit>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018620:	f89a 2000 	ldrb.w	r2, [sl]
 8018624:	f04f 0ccc 	mov.w	ip, #204	; 0xcc
 8018628:	f04f 0ecb 	mov.w	lr, #203	; 0xcb
 801862c:	fb05 b202 	mla	r2, r5, r2, fp
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018630:	9603      	str	r6, [sp, #12]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018632:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8018636:	fb0c f303 	mul.w	r3, ip, r3
 801863a:	f203 1355 	addw	r3, r3, #341	; 0x155
 801863e:	f822 7013 	strh.w	r7, [r2, r3, lsl #1]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018642:	22ba      	movs	r2, #186	; 0xba
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018644:	f89a 0000 	ldrb.w	r0, [sl]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018648:	fba4 3906 	umull	r3, r9, r4, r6
 801864c:	230a      	movs	r3, #10
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801864e:	fb05 b000 	mla	r0, r5, r0, fp
 8018652:	e9d0 0117 	ldrd	r0, r1, [r0, #92]	; 0x5c
 8018656:	fb0e f101 	mul.w	r1, lr, r1
 801865a:	f201 1155 	addw	r1, r1, #341	; 0x155
 801865e:	f820 7011 	strh.w	r7, [r0, r1, lsl #1]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018662:	ea4f 01d9 	mov.w	r1, r9, lsr #3
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018666:	f89a 6000 	ldrb.w	r6, [sl]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 801866a:	fba4 4001 	umull	r4, r0, r4, r1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801866e:	fb05 b606 	mla	r6, r5, r6, fp
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018672:	08c0      	lsrs	r0, r0, #3
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018674:	6df4      	ldr	r4, [r6, #92]	; 0x5c
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018676:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801867a:	eba1 0040 	sub.w	r0, r1, r0, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801867e:	6e31      	ldr	r1, [r6, #96]	; 0x60
 8018680:	fb0c f101 	mul.w	r1, ip, r1
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018684:	b2c0      	uxtb	r0, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018686:	f501 71ab 	add.w	r1, r1, #342	; 0x156
 801868a:	f824 7011 	strh.w	r7, [r4, r1, lsl #1]
 801868e:	f89a 1000 	ldrb.w	r1, [sl]
 8018692:	fb05 b501 	mla	r5, r5, r1, fp
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 8018696:	f240 1159 	movw	r1, #345	; 0x159
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 801869a:	6e2c      	ldr	r4, [r5, #96]	; 0x60
 801869c:	6ded      	ldr	r5, [r5, #92]	; 0x5c
 801869e:	fb0e f404 	mul.w	r4, lr, r4
 80186a2:	f504 74ab 	add.w	r4, r4, #342	; 0x156
 80186a6:	f825 7014 	strh.w	r7, [r5, r4, lsl #1]
		DrawDigit((percent / 10) % 10, 345, 186, 10, 0x00FFFFFF);
 80186aa:	f8cd 8000 	str.w	r8, [sp]
 80186ae:	f7fb ffa7 	bl	8014600 <DrawDigit>
		DrawDigit((percent % 5) * 2, 360, 186, 10, 0x00FFFFFF);
 80186b2:	9e03      	ldr	r6, [sp, #12]
 80186b4:	ea4f 0099 	mov.w	r0, r9, lsr #2
 80186b8:	230a      	movs	r3, #10
 80186ba:	22ba      	movs	r2, #186	; 0xba
 80186bc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80186c0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80186c4:	f8cd 8000 	str.w	r8, [sp]
 80186c8:	1a30      	subs	r0, r6, r0
 80186ca:	0040      	lsls	r0, r0, #1
 80186cc:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
 80186d0:	f7fb ff96 	bl	8014600 <DrawDigit>
 80186d4:	f7fd b807 	b.w	80156e6 <DrawLowSpectrum+0x936>
			DrawDigit(((percent / 100) % 100) / 10, 315, 186, 10, 0x00FFFFFF);
 80186d8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80186dc:	4a0c      	ldr	r2, [pc, #48]	; (8018710 <DrawLowSpectrum+0x3960>)
 80186de:	2064      	movs	r0, #100	; 0x64
 80186e0:	490c      	ldr	r1, [pc, #48]	; (8018714 <DrawLowSpectrum+0x3964>)
 80186e2:	9300      	str	r3, [sp, #0]
 80186e4:	9b03      	ldr	r3, [sp, #12]
 80186e6:	fba2 4303 	umull	r4, r3, r2, r3
 80186ea:	095b      	lsrs	r3, r3, #5
 80186ec:	fba2 4203 	umull	r4, r2, r2, r3
 80186f0:	0954      	lsrs	r4, r2, #5
 80186f2:	22ba      	movs	r2, #186	; 0xba
 80186f4:	fb00 3314 	mls	r3, r0, r4, r3
 80186f8:	b29c      	uxth	r4, r3
 80186fa:	fba1 3104 	umull	r3, r1, r1, r4
 80186fe:	230a      	movs	r3, #10
 8018700:	f3c1 00c7 	ubfx	r0, r1, #3, #8
 8018704:	f240 113b 	movw	r1, #315	; 0x13b
 8018708:	f7fb ff7a 	bl	8014600 <DrawDigit>
 801870c:	f7ff bbff 	b.w	8017f0e <DrawLowSpectrum+0x315e>
 8018710:	51eb851f 	.word	0x51eb851f
 8018714:	cccccccd 	.word	0xcccccccd

08018718 <DrawSpectrum>:
{
 8018718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801871c:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
	uint8_t spectrum_frame[480] = {0};
 8018720:	2100      	movs	r1, #0
 8018722:	f44f 72ee 	mov.w	r2, #476	; 0x1dc
	if(position != file_pos_wide) {
 8018726:	4da7      	ldr	r5, [pc, #668]	; (80189c4 <DrawSpectrum+0x2ac>)
{
 8018728:	af02      	add	r7, sp, #8
	uint8_t spectrum_frame[480] = {0};
 801872a:	f107 0024 	add.w	r0, r7, #36	; 0x24
 801872e:	6239      	str	r1, [r7, #32]
 8018730:	f007 fcd4 	bl	80200dc <memset>
	uint32_t new_cues[rekordbox.cues];
 8018734:	4ba4      	ldr	r3, [pc, #656]	; (80189c8 <DrawSpectrum+0x2b0>)
	if(position != file_pos_wide) {
 8018736:	6829      	ldr	r1, [r5, #0]
	uint32_t new_cues[rekordbox.cues];
 8018738:	f8d3 6b94 	ldr.w	r6, [r3, #2964]	; 0xb94
	if(position != file_pos_wide) {
 801873c:	4ba3      	ldr	r3, [pc, #652]	; (80189cc <DrawSpectrum+0x2b4>)
	uint32_t new_cues[rekordbox.cues];
 801873e:	00b0      	lsls	r0, r6, #2
	if(position != file_pos_wide) {
 8018740:	681a      	ldr	r2, [r3, #0]
	uint32_t new_cues[rekordbox.cues];
 8018742:	1dc3      	adds	r3, r0, #7
	if(position != file_pos_wide) {
 8018744:	4291      	cmp	r1, r2
	uint32_t new_cues[rekordbox.cues];
 8018746:	f023 0307 	bic.w	r3, r3, #7
 801874a:	ebad 0d03 	sub.w	sp, sp, r3
 801874e:	ab02      	add	r3, sp, #8
 8018750:	61fb      	str	r3, [r7, #28]
	if(position != file_pos_wide) {
 8018752:	f000 8093 	beq.w	801887c <DrawSpectrum+0x164>
		if(stretch > 1) {
 8018756:	f8df a298 	ldr.w	sl, [pc, #664]	; 80189f0 <DrawSpectrum+0x2d8>
 801875a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		position = file_pos_wide;
 801875e:	602a      	str	r2, [r5, #0]
		if(stretch > 1) {
 8018760:	edda 7a00 	vldr	s15, [sl]
 8018764:	eef4 7ac7 	vcmpe.f32	s15, s14
 8018768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801876c:	f340 808a 	ble.w	8018884 <DrawSpectrum+0x16c>
			while((position % (int32_t)(stretch)) != (check % (int32_t)(stretch))) {
 8018770:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8018774:	4c96      	ldr	r4, [pc, #600]	; (80189d0 <DrawSpectrum+0x2b8>)
 8018776:	ee17 1a10 	vmov	r1, s14
 801877a:	e002      	b.n	8018782 <DrawSpectrum+0x6a>
				position++;
 801877c:	682b      	ldr	r3, [r5, #0]
 801877e:	3301      	adds	r3, #1
 8018780:	602b      	str	r3, [r5, #0]
			while((position % (int32_t)(stretch)) != (check % (int32_t)(stretch))) {
 8018782:	682a      	ldr	r2, [r5, #0]
 8018784:	6823      	ldr	r3, [r4, #0]
 8018786:	fb92 fcf1 	sdiv	ip, r2, r1
 801878a:	fb01 221c 	mls	r2, r1, ip, r2
 801878e:	fb93 fcf1 	sdiv	ip, r3, r1
 8018792:	fb01 331c 	mls	r3, r1, ip, r3
 8018796:	429a      	cmp	r2, r3
 8018798:	d1f0      	bne.n	801877c <DrawSpectrum+0x64>
	for(k = 0; k < rekordbox.cues; k++) {
 801879a:	2e00      	cmp	r6, #0
 801879c:	dc75      	bgt.n	801888a <DrawSpectrum+0x172>
 801879e:	f107 0820 	add.w	r8, r7, #32
 80187a2:	f06f 00ef 	mvn.w	r0, #239	; 0xef
 80187a6:	f507 7600 	add.w	r6, r7, #512	; 0x200
			spectrum_frame[i] = *(__IO uint8_t*)(WAVE_BUFFER+check);
 80187aa:	f8df c248 	ldr.w	ip, [pc, #584]	; 80189f4 <DrawSpectrum+0x2dc>
 80187ae:	eba0 0008 	sub.w	r0, r0, r8
			while(check < rekordbox.cue_start_position[k]) {
 80187b2:	4641      	mov	r1, r8
		check = position + (int32_t)((i-240)*stretch);
 80187b4:	1842      	adds	r2, r0, r1
 80187b6:	682b      	ldr	r3, [r5, #0]
 80187b8:	ee07 2a10 	vmov	s14, r2
 80187bc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80187c0:	ee27 7a27 	vmul.f32	s14, s14, s15
 80187c4:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80187c8:	ee17 2a10 	vmov	r2, s14
 80187cc:	441a      	add	r2, r3
 80187ce:	6022      	str	r2, [r4, #0]
		if(check > 0) {
 80187d0:	6823      	ldr	r3, [r4, #0]
 80187d2:	2b00      	cmp	r3, #0
 80187d4:	dd03      	ble.n	80187de <DrawSpectrum+0xc6>
			spectrum_frame[i] = *(__IO uint8_t*)(WAVE_BUFFER+check);
 80187d6:	6823      	ldr	r3, [r4, #0]
 80187d8:	f813 300c 	ldrb.w	r3, [r3, ip]
 80187dc:	700b      	strb	r3, [r1, #0]
	for(i = 0; i < 480; i++) {
 80187de:	3101      	adds	r1, #1
 80187e0:	428e      	cmp	r6, r1
 80187e2:	d1e7      	bne.n	80187b4 <DrawSpectrum+0x9c>
	for(i = 0; i < 480; i++)
 80187e4:	2600      	movs	r6, #0
			if(display.loop == 1) {
 80187e6:	f8df 9210 	ldr.w	r9, [pc, #528]	; 80189f8 <DrawSpectrum+0x2e0>
			color |= 0x000000FF;
 80187ea:	f8df b210 	ldr.w	fp, [pc, #528]	; 80189fc <DrawSpectrum+0x2e4>
 80187ee:	e01c      	b.n	801882a <DrawSpectrum+0x112>
			color = spectrum_frame[i] & 0xE0; // read color data - first 3 bits
 80187f0:	f898 1000 	ldrb.w	r1, [r8]
 80187f4:	f001 03e0 	and.w	r3, r1, #224	; 0xe0
 80187f8:	f001 011f 	and.w	r1, r1, #31
			color <<= 8;
 80187fc:	ea4f 2e03 	mov.w	lr, r3, lsl #8
			height = spectrum_frame[i] & 0x1F; //read height data - last 5 bits
 8018800:	4b74      	ldr	r3, [pc, #464]	; (80189d4 <DrawSpectrum+0x2bc>)
			VLine(i, 120-height, height*2, color);
 8018802:	f1c1 0c78 	rsb	ip, r1, #120	; 0x78
 8018806:	004a      	lsls	r2, r1, #1
			height = spectrum_frame[i] & 0x1F; //read height data - last 5 bits
 8018808:	6019      	str	r1, [r3, #0]
			color |= 0x000000FF;
 801880a:	f04e 03ff 	orr.w	r3, lr, #255	; 0xff
			VLine(i, 120-height, height*2, color);
 801880e:	fa1f f18c 	uxth.w	r1, ip
			color |= 0x000000FF;
 8018812:	f8cb 3000 	str.w	r3, [fp]
			VLine(i, 120-height, height*2, color);
 8018816:	f7fb fe67 	bl	80144e8 <VLine>
		check = position + (int32_t)((i-240)*stretch);
 801881a:	edda 7a00 	vldr	s15, [sl]
	for(i = 0; i < 480; i++)
 801881e:	3601      	adds	r6, #1
 8018820:	f108 0801 	add.w	r8, r8, #1
 8018824:	f5b6 7ff0 	cmp.w	r6, #480	; 0x1e0
 8018828:	d06a      	beq.n	8018900 <DrawSpectrum+0x1e8>
		check = position + (int32_t)((i-240)*stretch);
 801882a:	f1a6 02f0 	sub.w	r2, r6, #240	; 0xf0
 801882e:	682b      	ldr	r3, [r5, #0]
 8018830:	ee07 2a10 	vmov	s14, r2
 8018834:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8018838:	ee27 7a27 	vmul.f32	s14, s14, s15
 801883c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8018840:	ee17 2a10 	vmov	r2, s14
 8018844:	441a      	add	r2, r3
 8018846:	6022      	str	r2, [r4, #0]
		if(check > 0) {
 8018848:	6823      	ldr	r3, [r4, #0]
 801884a:	2b00      	cmp	r3, #0
 801884c:	dde7      	ble.n	801881e <DrawSpectrum+0x106>
			if(display.loop == 1) {
 801884e:	f899 3010 	ldrb.w	r3, [r9, #16]
 8018852:	b2b0      	uxth	r0, r6
 8018854:	2b01      	cmp	r3, #1
 8018856:	d1cb      	bne.n	80187f0 <DrawSpectrum+0xd8>
				if((check >= display.loopstart) && (check <= display.loopend)) {
 8018858:	6823      	ldr	r3, [r4, #0]
 801885a:	f8d9 2008 	ldr.w	r2, [r9, #8]
 801885e:	429a      	cmp	r2, r3
 8018860:	d8c6      	bhi.n	80187f0 <DrawSpectrum+0xd8>
 8018862:	6823      	ldr	r3, [r4, #0]
 8018864:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8018868:	429a      	cmp	r2, r3
 801886a:	d3c1      	bcc.n	80187f0 <DrawSpectrum+0xd8>
					VLine(i, 75, 90, 0x008F8F8F);
 801886c:	4b5a      	ldr	r3, [pc, #360]	; (80189d8 <DrawSpectrum+0x2c0>)
 801886e:	225a      	movs	r2, #90	; 0x5a
 8018870:	214b      	movs	r1, #75	; 0x4b
 8018872:	61b8      	str	r0, [r7, #24]
 8018874:	f7fb fe38 	bl	80144e8 <VLine>
 8018878:	69b8      	ldr	r0, [r7, #24]
 801887a:	e7b9      	b.n	80187f0 <DrawSpectrum+0xd8>
		check = position + (int32_t)((i-240)*stretch);
 801887c:	f8df a170 	ldr.w	sl, [pc, #368]	; 80189f0 <DrawSpectrum+0x2d8>
 8018880:	edda 7a00 	vldr	s15, [sl]
	for(k = 0; k < rekordbox.cues; k++) {
 8018884:	2e00      	cmp	r6, #0
 8018886:	4c52      	ldr	r4, [pc, #328]	; (80189d0 <DrawSpectrum+0x2b8>)
 8018888:	dd89      	ble.n	801879e <DrawSpectrum+0x86>
		check = position + (int32_t)((i-240)*stretch);
 801888a:	ed9f 7a54 	vldr	s14, [pc, #336]	; 80189dc <DrawSpectrum+0x2c4>
 801888e:	3804      	subs	r0, #4
 8018890:	69fb      	ldr	r3, [r7, #28]
		new_cues[k] = 0;
 8018892:	f04f 0800 	mov.w	r8, #0
		check = position + (int32_t)((i-240)*stretch);
 8018896:	ee27 7a87 	vmul.f32	s14, s15, s14
 801889a:	4e51      	ldr	r6, [pc, #324]	; (80189e0 <DrawSpectrum+0x2c8>)
 801889c:	eb03 0c00 	add.w	ip, r3, r0
 80188a0:	1f18      	subs	r0, r3, #4
 80188a2:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80188a6:	ee17 ea10 	vmov	lr, s14
 80188aa:	e002      	b.n	80188b2 <DrawSpectrum+0x19a>
	for(k = 0; k < rekordbox.cues; k++) {
 80188ac:	4584      	cmp	ip, r0
 80188ae:	f43f af76 	beq.w	801879e <DrawSpectrum+0x86>
		check = position + (int32_t)((i-240)*stretch);
 80188b2:	682b      	ldr	r3, [r5, #0]
		if(check < rekordbox.cue_start_position[k]) {
 80188b4:	f856 1f04 	ldr.w	r1, [r6, #4]!
		check = position + (int32_t)((i-240)*stretch);
 80188b8:	4473      	add	r3, lr
		new_cues[k] = 0;
 80188ba:	f840 8f04 	str.w	r8, [r0, #4]!
		check = position + (int32_t)((i-240)*stretch);
 80188be:	6023      	str	r3, [r4, #0]
		if(check < rekordbox.cue_start_position[k]) {
 80188c0:	6823      	ldr	r3, [r4, #0]
 80188c2:	4299      	cmp	r1, r3
 80188c4:	ddf2      	ble.n	80188ac <DrawSpectrum+0x194>
			while(check < rekordbox.cue_start_position[k]) {
 80188c6:	6823      	ldr	r3, [r4, #0]
 80188c8:	4299      	cmp	r1, r3
 80188ca:	dd13      	ble.n	80188f4 <DrawSpectrum+0x1dc>
 80188cc:	f06f 02ee 	mvn.w	r2, #238	; 0xee
				check = position + (int32_t)((i-240)*stretch);
 80188d0:	ee07 2a10 	vmov	s14, r2
 80188d4:	682b      	ldr	r3, [r5, #0]
 80188d6:	3201      	adds	r2, #1
 80188d8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80188dc:	ee27 7a27 	vmul.f32	s14, s14, s15
 80188e0:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80188e4:	ee17 9a10 	vmov	r9, s14
 80188e8:	4499      	add	r9, r3
 80188ea:	f8c4 9000 	str.w	r9, [r4]
			while(check < rekordbox.cue_start_position[k]) {
 80188ee:	6823      	ldr	r3, [r4, #0]
 80188f0:	4299      	cmp	r1, r3
 80188f2:	dced      	bgt.n	80188d0 <DrawSpectrum+0x1b8>
			if(new_cues[k] != check) new_cues[k] = check;
 80188f4:	6823      	ldr	r3, [r4, #0]
 80188f6:	2b00      	cmp	r3, #0
 80188f8:	d0d8      	beq.n	80188ac <DrawSpectrum+0x194>
 80188fa:	6823      	ldr	r3, [r4, #0]
 80188fc:	6003      	str	r3, [r0, #0]
 80188fe:	e7d5      	b.n	80188ac <DrawSpectrum+0x194>
 8018900:	f06f 090a 	mvn.w	r9, #10
 8018904:	f04f 0801 	mov.w	r8, #1
 8018908:	2600      	movs	r6, #0
 801890a:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 8018a00 <DrawSpectrum+0x2e8>
 801890e:	e00a      	b.n	8018926 <DrawSpectrum+0x20e>
	for(i = 0; i < 480; i++)
 8018910:	f5b8 7ff0 	cmp.w	r8, #480	; 0x1e0
 8018914:	f000 80f9 	beq.w	8018b0a <DrawSpectrum+0x3f2>
		check = position + (int32_t)((i-240)*stretch);
 8018918:	edda 7a00 	vldr	s15, [sl]
 801891c:	3601      	adds	r6, #1
 801891e:	f108 0801 	add.w	r8, r8, #1
 8018922:	f109 0901 	add.w	r9, r9, #1
 8018926:	f1a6 03f0 	sub.w	r3, r6, #240	; 0xf0
 801892a:	ee07 3a10 	vmov	s14, r3
 801892e:	682b      	ldr	r3, [r5, #0]
 8018930:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8018934:	ee67 7a27 	vmul.f32	s15, s14, s15
 8018938:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801893c:	ee17 2a90 	vmov	r2, s15
 8018940:	441a      	add	r2, r3
 8018942:	6022      	str	r2, [r4, #0]
		if(check > 0) {
 8018944:	6823      	ldr	r3, [r4, #0]
 8018946:	2b00      	cmp	r3, #0
 8018948:	dde2      	ble.n	8018910 <DrawSpectrum+0x1f8>
			if(first_beat <= rekordbox.timezones) {
 801894a:	4b26      	ldr	r3, [pc, #152]	; (80189e4 <DrawSpectrum+0x2cc>)
 801894c:	f8db 2500 	ldr.w	r2, [fp, #1280]	; 0x500
 8018950:	681b      	ldr	r3, [r3, #0]
 8018952:	429a      	cmp	r2, r3
 8018954:	d326      	bcc.n	80189a4 <DrawSpectrum+0x28c>
				if(check >= (int32_t)(rekordbox.timeindex[first_beat]*150/1000)) {
 8018956:	f503 62be 	add.w	r2, r3, #1520	; 0x5f0
 801895a:	2196      	movs	r1, #150	; 0x96
 801895c:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 8018960:	6852      	ldr	r2, [r2, #4]
 8018962:	fb01 f202 	mul.w	r2, r1, r2
 8018966:	4920      	ldr	r1, [pc, #128]	; (80189e8 <DrawSpectrum+0x2d0>)
 8018968:	fba1 1202 	umull	r1, r2, r1, r2
 801896c:	6821      	ldr	r1, [r4, #0]
 801896e:	ebb1 1f92 	cmp.w	r1, r2, lsr #6
 8018972:	db17      	blt.n	80189a4 <DrawSpectrum+0x28c>
					if(rekordbox.phase[first_beat] == 1) {
 8018974:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 8018978:	b2b0      	uxth	r0, r6
 801897a:	f8b3 3e64 	ldrh.w	r3, [r3, #3684]	; 0xe64
 801897e:	2b01      	cmp	r3, #1
 8018980:	f000 80b6 	beq.w	8018af0 <DrawSpectrum+0x3d8>
						VLine(i, 75, 4, 0x00FFFFFF);
 8018984:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8018988:	214b      	movs	r1, #75	; 0x4b
 801898a:	61b8      	str	r0, [r7, #24]
 801898c:	f7fb fc70 	bl	8014270 <VLine.constprop.0>
						VLine(i, 161, 4, 0x00FFFFFF);
 8018990:	69b8      	ldr	r0, [r7, #24]
 8018992:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8018996:	21a1      	movs	r1, #161	; 0xa1
 8018998:	f7fb fc6a 	bl	8014270 <VLine.constprop.0>
					first_beat++;
 801899c:	4a11      	ldr	r2, [pc, #68]	; (80189e4 <DrawSpectrum+0x2cc>)
 801899e:	6813      	ldr	r3, [r2, #0]
 80189a0:	3301      	adds	r3, #1
 80189a2:	6013      	str	r3, [r2, #0]
			if(rekordbox.state == 1) {
 80189a4:	4b11      	ldr	r3, [pc, #68]	; (80189ec <DrawSpectrum+0x2d4>)
 80189a6:	f893 33d4 	ldrb.w	r3, [r3, #980]	; 0x3d4
 80189aa:	2b01      	cmp	r3, #1
 80189ac:	d067      	beq.n	8018a7e <DrawSpectrum+0x366>
			for(int k = 1; k < rekordbox.cues; k++) {
 80189ae:	4b06      	ldr	r3, [pc, #24]	; (80189c8 <DrawSpectrum+0x2b0>)
 80189b0:	f8d3 1b94 	ldr.w	r1, [r3, #2964]	; 0xb94
 80189b4:	2901      	cmp	r1, #1
 80189b6:	ddab      	ble.n	8018910 <DrawSpectrum+0x1f8>
 80189b8:	69fa      	ldr	r2, [r7, #28]
 80189ba:	2301      	movs	r3, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 80189bc:	f44f 4e78 	mov.w	lr, #63488	; 0xf800
 80189c0:	e023      	b.n	8018a0a <DrawSpectrum+0x2f2>
 80189c2:	bf00      	nop
 80189c4:	20000c90 	.word	0x20000c90
 80189c8:	200174f0 	.word	0x200174f0
 80189cc:	2000ec8c 	.word	0x2000ec8c
 80189d0:	20000c68 	.word	0x20000c68
 80189d4:	20000c88 	.word	0x20000c88
 80189d8:	008f8f8f 	.word	0x008f8f8f
 80189dc:	c3700000 	.word	0xc3700000
 80189e0:	20018534 	.word	0x20018534
 80189e4:	20000c84 	.word	0x20000c84
 80189e8:	10624dd3 	.word	0x10624dd3
 80189ec:	200184f0 	.word	0x200184f0
 80189f0:	20000028 	.word	0x20000028
 80189f4:	c0100000 	.word	0xc0100000
 80189f8:	20000c70 	.word	0x20000c70
 80189fc:	20000c6c 	.word	0x20000c6c
 8018a00:	200154f0 	.word	0x200154f0
			for(int k = 1; k < rekordbox.cues; k++) {
 8018a04:	3301      	adds	r3, #1
 8018a06:	4299      	cmp	r1, r3
 8018a08:	dd82      	ble.n	8018910 <DrawSpectrum+0x1f8>
				if(check == new_cues[k]) {
 8018a0a:	6820      	ldr	r0, [r4, #0]
 8018a0c:	f852 cf04 	ldr.w	ip, [r2, #4]!
 8018a10:	4584      	cmp	ip, r0
 8018a12:	d1f7      	bne.n	8018a04 <DrawSpectrum+0x2ec>
					if((i > 10) && (i < 472))
 8018a14:	f5b9 7fe6 	cmp.w	r9, #460	; 0x1cc
 8018a18:	d8f4      	bhi.n	8018a04 <DrawSpectrum+0x2ec>
 8018a1a:	2000      	movs	r0, #0
 8018a1c:	f8c7 9018 	str.w	r9, [r7, #24]
 8018a20:	6178      	str	r0, [r7, #20]
 8018a22:	e9c7 3102 	strd	r3, r1, [r7, #8]
			if(((element[i] >> k) & 1) == 1) {
 8018a26:	4b7b      	ldr	r3, [pc, #492]	; (8018c14 <DrawSpectrum+0x4fc>)
 8018a28:	6979      	ldr	r1, [r7, #20]
 8018a2a:	607a      	str	r2, [r7, #4]
 8018a2c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8018a30:	613b      	str	r3, [r7, #16]
 8018a32:	2348      	movs	r3, #72	; 0x48
 8018a34:	f1c3 0148 	rsb	r1, r3, #72	; 0x48
 8018a38:	6938      	ldr	r0, [r7, #16]
 8018a3a:	fa40 f101 	asr.w	r1, r0, r1
 8018a3e:	f011 0101 	ands.w	r1, r1, #1
 8018a42:	f000 82fa 	beq.w	801903a <DrawSpectrum+0x922>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018a46:	4974      	ldr	r1, [pc, #464]	; (8018c18 <DrawSpectrum+0x500>)
 8018a48:	2234      	movs	r2, #52	; 0x34
 8018a4a:	4874      	ldr	r0, [pc, #464]	; (8018c1c <DrawSpectrum+0x504>)
 8018a4c:	7809      	ldrb	r1, [r1, #0]
 8018a4e:	fb02 0101 	mla	r1, r2, r1, r0
 8018a52:	69ba      	ldr	r2, [r7, #24]
 8018a54:	e9d1 1017 	ldrd	r1, r0, [r1, #92]	; 0x5c
 8018a58:	fb00 2003 	mla	r0, r0, r3, r2
 8018a5c:	f821 e010 	strh.w	lr, [r1, r0, lsl #1]
		while(k < height) {
 8018a60:	3b01      	subs	r3, #1
 8018a62:	2b43      	cmp	r3, #67	; 0x43
 8018a64:	d1e6      	bne.n	8018a34 <DrawSpectrum+0x31c>
	while(i < width) {
 8018a66:	697b      	ldr	r3, [r7, #20]
 8018a68:	69b9      	ldr	r1, [r7, #24]
 8018a6a:	3301      	adds	r3, #1
 8018a6c:	687a      	ldr	r2, [r7, #4]
 8018a6e:	3101      	adds	r1, #1
 8018a70:	2b0f      	cmp	r3, #15
 8018a72:	617b      	str	r3, [r7, #20]
 8018a74:	61b9      	str	r1, [r7, #24]
 8018a76:	d1d6      	bne.n	8018a26 <DrawSpectrum+0x30e>
 8018a78:	e9d7 3102 	ldrd	r3, r1, [r7, #8]
 8018a7c:	e7c2      	b.n	8018a04 <DrawSpectrum+0x2ec>
				if(check == new_cues[0]) {
 8018a7e:	69fa      	ldr	r2, [r7, #28]
 8018a80:	6823      	ldr	r3, [r4, #0]
 8018a82:	6812      	ldr	r2, [r2, #0]
 8018a84:	429a      	cmp	r2, r3
 8018a86:	d192      	bne.n	80189ae <DrawSpectrum+0x296>
					if((i > 10) && (i < 472))
 8018a88:	f5b9 7fe6 	cmp.w	r9, #460	; 0x1cc
 8018a8c:	d88f      	bhi.n	80189ae <DrawSpectrum+0x296>
 8018a8e:	46ce      	mov	lr, r9
 8018a90:	f04f 0c00 	mov.w	ip, #0
			if(((element[i] >> k) & 1) == 1) {
 8018a94:	4b5f      	ldr	r3, [pc, #380]	; (8018c14 <DrawSpectrum+0x4fc>)
 8018a96:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
 8018a9a:	61bb      	str	r3, [r7, #24]
 8018a9c:	2348      	movs	r3, #72	; 0x48
 8018a9e:	f1c3 0248 	rsb	r2, r3, #72	; 0x48
 8018aa2:	69b9      	ldr	r1, [r7, #24]
 8018aa4:	fa41 f202 	asr.w	r2, r1, r2
 8018aa8:	f012 0201 	ands.w	r2, r2, #1
 8018aac:	617a      	str	r2, [r7, #20]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018aae:	4a5a      	ldr	r2, [pc, #360]	; (8018c18 <DrawSpectrum+0x500>)
 8018ab0:	7812      	ldrb	r2, [r2, #0]
			if(((element[i] >> k) & 1) == 1) {
 8018ab2:	f000 82b6 	beq.w	8019022 <DrawSpectrum+0x90a>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018ab6:	4959      	ldr	r1, [pc, #356]	; (8018c1c <DrawSpectrum+0x504>)
 8018ab8:	2034      	movs	r0, #52	; 0x34
 8018aba:	fb00 1202 	mla	r2, r0, r2, r1
 8018abe:	e9d2 0117 	ldrd	r0, r1, [r2, #92]	; 0x5c
 8018ac2:	fb01 e203 	mla	r2, r1, r3, lr
 8018ac6:	f64f 71e0 	movw	r1, #65504	; 0xffe0
 8018aca:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
		while(k < height) {
 8018ace:	3b01      	subs	r3, #1
 8018ad0:	2b43      	cmp	r3, #67	; 0x43
 8018ad2:	d1e4      	bne.n	8018a9e <DrawSpectrum+0x386>
	while(i < width) {
 8018ad4:	f10c 0c01 	add.w	ip, ip, #1
 8018ad8:	f10e 0e01 	add.w	lr, lr, #1
 8018adc:	f1bc 0f0f 	cmp.w	ip, #15
 8018ae0:	d1d8      	bne.n	8018a94 <DrawSpectrum+0x37c>
			for(int k = 1; k < rekordbox.cues; k++) {
 8018ae2:	4b4f      	ldr	r3, [pc, #316]	; (8018c20 <DrawSpectrum+0x508>)
 8018ae4:	f8d3 1b94 	ldr.w	r1, [r3, #2964]	; 0xb94
 8018ae8:	2901      	cmp	r1, #1
 8018aea:	f73f af65 	bgt.w	80189b8 <DrawSpectrum+0x2a0>
 8018aee:	e713      	b.n	8018918 <DrawSpectrum+0x200>
						VLine(i, 75, 4, 0x00FF0000);
 8018af0:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
 8018af4:	214b      	movs	r1, #75	; 0x4b
 8018af6:	61b8      	str	r0, [r7, #24]
 8018af8:	f7fb fbba 	bl	8014270 <VLine.constprop.0>
						VLine(i, 161, 4, 0x00FF0000);
 8018afc:	69b8      	ldr	r0, [r7, #24]
 8018afe:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
 8018b02:	21a1      	movs	r1, #161	; 0xa1
 8018b04:	f7fb fbb4 	bl	8014270 <VLine.constprop.0>
 8018b08:	e748      	b.n	801899c <DrawSpectrum+0x284>
	VLine(239, 75, 90, 0x00FFFFFF);
 8018b0a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8018b0e:	225a      	movs	r2, #90	; 0x5a
 8018b10:	214b      	movs	r1, #75	; 0x4b
 8018b12:	20ef      	movs	r0, #239	; 0xef
 8018b14:	f7fb fce8 	bl	80144e8 <VLine>
	VLine(240, 75, 90, 0x00FFFFFF);
 8018b18:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8018b1c:	225a      	movs	r2, #90	; 0x5a
 8018b1e:	214b      	movs	r1, #75	; 0x4b
 8018b20:	20f0      	movs	r0, #240	; 0xf0
	bar = (beat + rekordbox.beat_grid_offset) / 4;
 8018b22:	4e40      	ldr	r6, [pc, #256]	; (8018c24 <DrawSpectrum+0x50c>)
	VLine(240, 75, 90, 0x00FFFFFF);
 8018b24:	f7fb fce0 	bl	80144e8 <VLine>
	bar = (beat + rekordbox.beat_grid_offset) / 4;
 8018b28:	4b3d      	ldr	r3, [pc, #244]	; (8018c20 <DrawSpectrum+0x508>)
 8018b2a:	6832      	ldr	r2, [r6, #0]
 8018b2c:	f893 3a84 	ldrb.w	r3, [r3, #2692]	; 0xa84
 8018b30:	4c3d      	ldr	r4, [pc, #244]	; (8018c28 <DrawSpectrum+0x510>)
 8018b32:	4413      	add	r3, r2
 8018b34:	2b00      	cmp	r3, #0
 8018b36:	461a      	mov	r2, r3
 8018b38:	bfb8      	it	lt
 8018b3a:	1cda      	addlt	r2, r3, #3
	if(bar / 100 > 0) {
 8018b3c:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
	bar = (beat + rekordbox.beat_grid_offset) / 4;
 8018b40:	ea4f 02a2 	mov.w	r2, r2, asr #2
 8018b44:	6022      	str	r2, [r4, #0]
	if(bar / 100 > 0) {
 8018b46:	f280 821d 	bge.w	8018f84 <DrawSpectrum+0x86c>
	else if(bar / 10 > 0) DrawDigit(bar / 10, 314, 51, 7, 0x000000FF);
 8018b4a:	2b27      	cmp	r3, #39	; 0x27
 8018b4c:	f300 8203 	bgt.w	8018f56 <DrawSpectrum+0x83e>
	DrawDigit(bar % 10, 323, 51, 7, 0x000000FF);
 8018b50:	4936      	ldr	r1, [pc, #216]	; (8018c2c <DrawSpectrum+0x514>)
 8018b52:	f04f 08ff 	mov.w	r8, #255	; 0xff
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018b56:	2434      	movs	r4, #52	; 0x34
 8018b58:	251f      	movs	r5, #31
	DrawDigit(bar % 10, 323, 51, 7, 0x000000FF);
 8018b5a:	fb81 3102 	smull	r3, r1, r1, r2
 8018b5e:	17d3      	asrs	r3, r2, #31
 8018b60:	f8cd 8000 	str.w	r8, [sp]
 8018b64:	ebc3 03a1 	rsb	r3, r3, r1, asr #2
 8018b68:	f240 1143 	movw	r1, #323	; 0x143
 8018b6c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8018b70:	eba2 0243 	sub.w	r2, r2, r3, lsl #1
 8018b74:	2307      	movs	r3, #7
 8018b76:	b2d0      	uxtb	r0, r2
 8018b78:	2233      	movs	r2, #51	; 0x33
 8018b7a:	f7fb fd41 	bl	8014600 <DrawDigit>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018b7e:	4926      	ldr	r1, [pc, #152]	; (8018c18 <DrawSpectrum+0x500>)
 8018b80:	4826      	ldr	r0, [pc, #152]	; (8018c1c <DrawSpectrum+0x504>)
 8018b82:	780a      	ldrb	r2, [r1, #0]
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018b84:	6833      	ldr	r3, [r6, #0]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018b86:	fb04 0202 	mla	r2, r4, r2, r0
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018b8a:	eb0b 0c43 	add.w	ip, fp, r3, lsl #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018b8e:	e9d2 2317 	ldrd	r2, r3, [r2, #92]	; 0x5c
 8018b92:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 8018b96:	f503 73a6 	add.w	r3, r3, #332	; 0x14c
 8018b9a:	f822 5013 	strh.w	r5, [r2, r3, lsl #1]
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018b9e:	2233      	movs	r2, #51	; 0x33
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018ba0:	f891 e000 	ldrb.w	lr, [r1]
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018ba4:	2307      	movs	r3, #7
 8018ba6:	f44f 71a8 	mov.w	r1, #336	; 0x150
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018baa:	fb04 0e0e 	mla	lr, r4, lr, r0
 8018bae:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 8018bb2:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 8018bb6:	0040      	lsls	r0, r0, #1
 8018bb8:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
 8018bbc:	f82e 5010 	strh.w	r5, [lr, r0, lsl #1]
 8018bc0:	4815      	ldr	r0, [pc, #84]	; (8018c18 <DrawSpectrum+0x500>)
 8018bc2:	f890 e000 	ldrb.w	lr, [r0]
 8018bc6:	4815      	ldr	r0, [pc, #84]	; (8018c1c <DrawSpectrum+0x504>)
 8018bc8:	fb04 0e0e 	mla	lr, r4, lr, r0
 8018bcc:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 8018bd0:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8018bd4:	f200 104d 	addw	r0, r0, #333	; 0x14d
 8018bd8:	f82e 5010 	strh.w	r5, [lr, r0, lsl #1]
 8018bdc:	480e      	ldr	r0, [pc, #56]	; (8018c18 <DrawSpectrum+0x500>)
 8018bde:	f890 e000 	ldrb.w	lr, [r0]
 8018be2:	480e      	ldr	r0, [pc, #56]	; (8018c1c <DrawSpectrum+0x504>)
 8018be4:	fb04 0e0e 	mla	lr, r4, lr, r0
 8018be8:	e9de e017 	ldrd	lr, r0, [lr, #92]	; 0x5c
 8018bec:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 8018bf0:	0040      	lsls	r0, r0, #1
 8018bf2:	f200 104d 	addw	r0, r0, #333	; 0x14d
 8018bf6:	f82e 5010 	strh.w	r5, [lr, r0, lsl #1]
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018bfa:	f8cd 8000 	str.w	r8, [sp]
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018bfe:	f04f 083a 	mov.w	r8, #58	; 0x3a
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018c02:	f89c 0e64 	ldrb.w	r0, [ip, #3684]	; 0xe64
 8018c06:	f7fb fcfb 	bl	8014600 <DrawDigit>
	while(i < width) {
 8018c0a:	4809      	ldr	r0, [pc, #36]	; (8018c30 <DrawSpectrum+0x518>)
	DrawDigit(rekordbox.phase[beat], 336, 51, 7, 0x000000FF);
 8018c0c:	2200      	movs	r2, #0
 8018c0e:	f100 0e26 	add.w	lr, r0, #38	; 0x26
 8018c12:	e080      	b.n	8018d16 <DrawSpectrum+0x5fe>
 8018c14:	08026364 	.word	0x08026364
 8018c18:	20000e2c 	.word	0x20000e2c
 8018c1c:	20000d84 	.word	0x20000d84
 8018c20:	200174f0 	.word	0x200174f0
 8018c24:	20000c64 	.word	0x20000c64
 8018c28:	20000c60 	.word	0x20000c60
 8018c2c:	66666667 	.word	0x66666667
 8018c30:	08025a22 	.word	0x08025a22
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018c34:	f891 9000 	ldrb.w	r9, [r1]
 8018c38:	49cf      	ldr	r1, [pc, #828]	; (8018f78 <DrawSpectrum+0x860>)
 8018c3a:	fb04 1909 	mla	r9, r4, r9, r1
 8018c3e:	e9d9 9117 	ldrd	r9, r1, [r9, #92]	; 0x5c
 8018c42:	ebc1 1181 	rsb	r1, r1, r1, lsl #6
 8018c46:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018c4a:	4411      	add	r1, r2
 8018c4c:	f829 c011 	strh.w	ip, [r9, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018c50:	f013 0c02 	ands.w	ip, r3, #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018c54:	49c9      	ldr	r1, [pc, #804]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018c56:	d176      	bne.n	8018d46 <DrawSpectrum+0x62e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018c58:	f891 9000 	ldrb.w	r9, [r1]
 8018c5c:	49c6      	ldr	r1, [pc, #792]	; (8018f78 <DrawSpectrum+0x860>)
 8018c5e:	fb04 1909 	mla	r9, r4, r9, r1
 8018c62:	e9d9 9117 	ldrd	r9, r1, [r9, #92]	; 0x5c
 8018c66:	ebc1 1141 	rsb	r1, r1, r1, lsl #5
 8018c6a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8018c6e:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018c72:	f829 c011 	strh.w	ip, [r9, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018c76:	f013 0c04 	ands.w	ip, r3, #4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018c7a:	49c0      	ldr	r1, [pc, #768]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018c7c:	d176      	bne.n	8018d6c <DrawSpectrum+0x654>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018c7e:	f891 9000 	ldrb.w	r9, [r1]
 8018c82:	49bd      	ldr	r1, [pc, #756]	; (8018f78 <DrawSpectrum+0x860>)
 8018c84:	fb04 1909 	mla	r9, r4, r9, r1
 8018c88:	e9d9 9117 	ldrd	r9, r1, [r9, #92]	; 0x5c
 8018c8c:	ebc1 1a01 	rsb	sl, r1, r1, lsl #4
 8018c90:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8018c94:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018c98:	4411      	add	r1, r2
 8018c9a:	f829 c011 	strh.w	ip, [r9, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018c9e:	f013 0c08 	ands.w	ip, r3, #8
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018ca2:	49b6      	ldr	r1, [pc, #728]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018ca4:	d176      	bne.n	8018d94 <DrawSpectrum+0x67c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018ca6:	f891 9000 	ldrb.w	r9, [r1]
 8018caa:	49b3      	ldr	r1, [pc, #716]	; (8018f78 <DrawSpectrum+0x860>)
 8018cac:	fb04 1909 	mla	r9, r4, r9, r1
 8018cb0:	e9d9 9117 	ldrd	r9, r1, [r9, #92]	; 0x5c
 8018cb4:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8018cb8:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8018cbc:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018cc0:	f829 c011 	strh.w	ip, [r9, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018cc4:	f013 0c10 	ands.w	ip, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018cc8:	49ac      	ldr	r1, [pc, #688]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018cca:	d176      	bne.n	8018dba <DrawSpectrum+0x6a2>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018ccc:	f891 9000 	ldrb.w	r9, [r1]
			if(((element[i] >> k) & 1) == 1) {
 8018cd0:	f013 0320 	ands.w	r3, r3, #32
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018cd4:	49a8      	ldr	r1, [pc, #672]	; (8018f78 <DrawSpectrum+0x860>)
 8018cd6:	fb04 1909 	mla	r9, r4, r9, r1
 8018cda:	e9d9 9117 	ldrd	r9, r1, [r9, #92]	; 0x5c
 8018cde:	ebc1 1a01 	rsb	sl, r1, r1, lsl #4
 8018ce2:	ebc1 018a 	rsb	r1, r1, sl, lsl #2
 8018ce6:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018cea:	4411      	add	r1, r2
 8018cec:	f829 c011 	strh.w	ip, [r9, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018cf0:	d176      	bne.n	8018de0 <DrawSpectrum+0x6c8>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018cf2:	49a2      	ldr	r1, [pc, #648]	; (8018f7c <DrawSpectrum+0x864>)
	while(i < width) {
 8018cf4:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018cf6:	f891 c000 	ldrb.w	ip, [r1]
 8018cfa:	499f      	ldr	r1, [pc, #636]	; (8018f78 <DrawSpectrum+0x860>)
 8018cfc:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018d00:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018d04:	fb08 2101 	mla	r1, r8, r1, r2
	while(i < width) {
 8018d08:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8018d0c:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018d10:	f82c 3011 	strh.w	r3, [ip, r1, lsl #1]
	while(i < width) {
 8018d14:	d075      	beq.n	8018e02 <DrawSpectrum+0x6ea>
			if(((element[i] >> k) & 1) == 1) {
 8018d16:	f830 3f02 	ldrh.w	r3, [r0, #2]!
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d1a:	4998      	ldr	r1, [pc, #608]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018d1c:	f013 0c01 	ands.w	ip, r3, #1
 8018d20:	d088      	beq.n	8018c34 <DrawSpectrum+0x51c>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d22:	f891 c000 	ldrb.w	ip, [r1]
 8018d26:	4994      	ldr	r1, [pc, #592]	; (8018f78 <DrawSpectrum+0x860>)
 8018d28:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018d2c:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018d30:	ebc1 1181 	rsb	r1, r1, r1, lsl #6
 8018d34:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018d38:	4411      	add	r1, r2
 8018d3a:	f82c 5011 	strh.w	r5, [ip, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018d3e:	f013 0c02 	ands.w	ip, r3, #2
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d42:	498e      	ldr	r1, [pc, #568]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018d44:	d088      	beq.n	8018c58 <DrawSpectrum+0x540>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d46:	f891 c000 	ldrb.w	ip, [r1]
 8018d4a:	498b      	ldr	r1, [pc, #556]	; (8018f78 <DrawSpectrum+0x860>)
 8018d4c:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018d50:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018d54:	ebc1 1141 	rsb	r1, r1, r1, lsl #5
 8018d58:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8018d5c:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018d60:	f82c 5011 	strh.w	r5, [ip, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018d64:	f013 0c04 	ands.w	ip, r3, #4
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d68:	4984      	ldr	r1, [pc, #528]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018d6a:	d088      	beq.n	8018c7e <DrawSpectrum+0x566>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d6c:	f891 c000 	ldrb.w	ip, [r1]
 8018d70:	4981      	ldr	r1, [pc, #516]	; (8018f78 <DrawSpectrum+0x860>)
 8018d72:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018d76:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018d7a:	ebc1 1901 	rsb	r9, r1, r1, lsl #4
 8018d7e:	eb01 0189 	add.w	r1, r1, r9, lsl #2
 8018d82:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018d86:	4411      	add	r1, r2
 8018d88:	f82c 5011 	strh.w	r5, [ip, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018d8c:	f013 0c08 	ands.w	ip, r3, #8
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d90:	497a      	ldr	r1, [pc, #488]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018d92:	d088      	beq.n	8018ca6 <DrawSpectrum+0x58e>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018d94:	f891 c000 	ldrb.w	ip, [r1]
 8018d98:	4977      	ldr	r1, [pc, #476]	; (8018f78 <DrawSpectrum+0x860>)
 8018d9a:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018d9e:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018da2:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8018da6:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8018daa:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018dae:	f82c 5011 	strh.w	r5, [ip, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018db2:	f013 0c10 	ands.w	ip, r3, #16
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018db6:	4971      	ldr	r1, [pc, #452]	; (8018f7c <DrawSpectrum+0x864>)
			if(((element[i] >> k) & 1) == 1) {
 8018db8:	d088      	beq.n	8018ccc <DrawSpectrum+0x5b4>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018dba:	f891 c000 	ldrb.w	ip, [r1]
			if(((element[i] >> k) & 1) == 1) {
 8018dbe:	f013 0320 	ands.w	r3, r3, #32
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018dc2:	496d      	ldr	r1, [pc, #436]	; (8018f78 <DrawSpectrum+0x860>)
 8018dc4:	fb04 1c0c 	mla	ip, r4, ip, r1
 8018dc8:	e9dc c117 	ldrd	ip, r1, [ip, #92]	; 0x5c
 8018dcc:	ebc1 1901 	rsb	r9, r1, r1, lsl #4
 8018dd0:	ebc1 0189 	rsb	r1, r1, r9, lsl #2
 8018dd4:	f501 71ae 	add.w	r1, r1, #348	; 0x15c
 8018dd8:	4411      	add	r1, r2
 8018dda:	f82c 5011 	strh.w	r5, [ip, r1, lsl #1]
			if(((element[i] >> k) & 1) == 1) {
 8018dde:	d088      	beq.n	8018cf2 <DrawSpectrum+0x5da>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018de0:	4b66      	ldr	r3, [pc, #408]	; (8018f7c <DrawSpectrum+0x864>)
	while(i < width) {
 8018de2:	4586      	cmp	lr, r0
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018de4:	7819      	ldrb	r1, [r3, #0]
 8018de6:	4b64      	ldr	r3, [pc, #400]	; (8018f78 <DrawSpectrum+0x860>)
 8018de8:	fb04 3101 	mla	r1, r4, r1, r3
 8018dec:	e9d1 1317 	ldrd	r1, r3, [r1, #92]	; 0x5c
 8018df0:	fb08 2303 	mla	r3, r8, r3, r2
	while(i < width) {
 8018df4:	f102 0201 	add.w	r2, r2, #1
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(color);
 8018df8:	f503 73ae 	add.w	r3, r3, #348	; 0x15c
 8018dfc:	f821 5013 	strh.w	r5, [r1, r3, lsl #1]
	while(i < width) {
 8018e00:	d189      	bne.n	8018d16 <DrawSpectrum+0x5fe>
	VLine(171, 54, 9, 0x000000FF);
 8018e02:	23ff      	movs	r3, #255	; 0xff
 8018e04:	2209      	movs	r2, #9
 8018e06:	2136      	movs	r1, #54	; 0x36
 8018e08:	20ab      	movs	r0, #171	; 0xab
 8018e0a:	f7fb fb6d 	bl	80144e8 <VLine>
	HLine(172, 54, 28, 0x000000FF);
 8018e0e:	23ff      	movs	r3, #255	; 0xff
 8018e10:	221c      	movs	r2, #28
 8018e12:	2136      	movs	r1, #54	; 0x36
 8018e14:	20ac      	movs	r0, #172	; 0xac
 8018e16:	f7fb fbad 	bl	8014574 <HLine>
	HLine(172, 62, 28, 0x000000FF);
 8018e1a:	23ff      	movs	r3, #255	; 0xff
 8018e1c:	221c      	movs	r2, #28
 8018e1e:	213e      	movs	r1, #62	; 0x3e
 8018e20:	20ac      	movs	r0, #172	; 0xac
 8018e22:	f7fb fba7 	bl	8014574 <HLine>
	VLine(200, 54, 9, 0x000000FF);
 8018e26:	23ff      	movs	r3, #255	; 0xff
 8018e28:	2209      	movs	r2, #9
 8018e2a:	2136      	movs	r1, #54	; 0x36
 8018e2c:	20c8      	movs	r0, #200	; 0xc8
 8018e2e:	f7fb fb5b 	bl	80144e8 <VLine>
	VLine(201, 57, 3, 0x000000FF);
 8018e32:	23ff      	movs	r3, #255	; 0xff
 8018e34:	2203      	movs	r2, #3
 8018e36:	2139      	movs	r1, #57	; 0x39
 8018e38:	20c9      	movs	r0, #201	; 0xc9
 8018e3a:	f7fb fb55 	bl	80144e8 <VLine>
	VLine(202, 57, 3, 0x000000FF);
 8018e3e:	23ff      	movs	r3, #255	; 0xff
 8018e40:	2203      	movs	r2, #3
 8018e42:	2139      	movs	r1, #57	; 0x39
 8018e44:	20ca      	movs	r0, #202	; 0xca
 8018e46:	f7fb fb4f 	bl	80144e8 <VLine>
	VLine(203, 57, 3, 0x000000FF);
 8018e4a:	23ff      	movs	r3, #255	; 0xff
 8018e4c:	2203      	movs	r2, #3
 8018e4e:	2139      	movs	r1, #57	; 0x39
 8018e50:	20cb      	movs	r0, #203	; 0xcb
 8018e52:	f7fb fb49 	bl	80144e8 <VLine>
	VLine(204, 54, 9, 0x000000FF);
 8018e56:	23ff      	movs	r3, #255	; 0xff
 8018e58:	2209      	movs	r2, #9
 8018e5a:	2136      	movs	r1, #54	; 0x36
 8018e5c:	20cc      	movs	r0, #204	; 0xcc
 8018e5e:	f7fb fb43 	bl	80144e8 <VLine>
	HLine(205, 54, 28, 0x000000FF);
 8018e62:	23ff      	movs	r3, #255	; 0xff
 8018e64:	221c      	movs	r2, #28
 8018e66:	2136      	movs	r1, #54	; 0x36
 8018e68:	20cd      	movs	r0, #205	; 0xcd
 8018e6a:	f7fb fb83 	bl	8014574 <HLine>
	HLine(205, 62, 28, 0x000000FF);
 8018e6e:	23ff      	movs	r3, #255	; 0xff
 8018e70:	221c      	movs	r2, #28
 8018e72:	213e      	movs	r1, #62	; 0x3e
 8018e74:	20cd      	movs	r0, #205	; 0xcd
 8018e76:	f7fb fb7d 	bl	8014574 <HLine>
	VLine(233, 54, 9, 0x000000FF);
 8018e7a:	23ff      	movs	r3, #255	; 0xff
 8018e7c:	2209      	movs	r2, #9
 8018e7e:	2136      	movs	r1, #54	; 0x36
 8018e80:	20e9      	movs	r0, #233	; 0xe9
 8018e82:	f7fb fb31 	bl	80144e8 <VLine>
	VLine(234, 57, 3, 0x000000FF);
 8018e86:	23ff      	movs	r3, #255	; 0xff
 8018e88:	2203      	movs	r2, #3
 8018e8a:	2139      	movs	r1, #57	; 0x39
 8018e8c:	20ea      	movs	r0, #234	; 0xea
 8018e8e:	f7fb fb2b 	bl	80144e8 <VLine>
	VLine(235, 57, 3, 0x000000FF);
 8018e92:	23ff      	movs	r3, #255	; 0xff
 8018e94:	2203      	movs	r2, #3
 8018e96:	2139      	movs	r1, #57	; 0x39
 8018e98:	20eb      	movs	r0, #235	; 0xeb
 8018e9a:	f7fb fb25 	bl	80144e8 <VLine>
	VLine(236, 57, 3, 0x000000FF);
 8018e9e:	23ff      	movs	r3, #255	; 0xff
 8018ea0:	2203      	movs	r2, #3
 8018ea2:	2139      	movs	r1, #57	; 0x39
 8018ea4:	20ec      	movs	r0, #236	; 0xec
 8018ea6:	f7fb fb1f 	bl	80144e8 <VLine>
	VLine(237, 54, 9, 0x000000FF);
 8018eaa:	23ff      	movs	r3, #255	; 0xff
 8018eac:	2209      	movs	r2, #9
 8018eae:	2136      	movs	r1, #54	; 0x36
 8018eb0:	20ed      	movs	r0, #237	; 0xed
 8018eb2:	f7fb fb19 	bl	80144e8 <VLine>
	HLine(238, 54, 28, 0x000000FF);
 8018eb6:	23ff      	movs	r3, #255	; 0xff
 8018eb8:	221c      	movs	r2, #28
 8018eba:	2136      	movs	r1, #54	; 0x36
 8018ebc:	20ee      	movs	r0, #238	; 0xee
 8018ebe:	f7fb fb59 	bl	8014574 <HLine>
	HLine(238, 62, 28, 0x000000FF);
 8018ec2:	23ff      	movs	r3, #255	; 0xff
 8018ec4:	221c      	movs	r2, #28
 8018ec6:	213e      	movs	r1, #62	; 0x3e
 8018ec8:	20ee      	movs	r0, #238	; 0xee
 8018eca:	f7fb fb53 	bl	8014574 <HLine>
	VLine(266, 54, 9, 0x000000FF);
 8018ece:	23ff      	movs	r3, #255	; 0xff
 8018ed0:	2209      	movs	r2, #9
 8018ed2:	2136      	movs	r1, #54	; 0x36
 8018ed4:	f44f 7085 	mov.w	r0, #266	; 0x10a
 8018ed8:	f7fb fb06 	bl	80144e8 <VLine>
	VLine(267, 57, 3, 0x000000FF);
 8018edc:	23ff      	movs	r3, #255	; 0xff
 8018ede:	2203      	movs	r2, #3
 8018ee0:	2139      	movs	r1, #57	; 0x39
 8018ee2:	f240 100b 	movw	r0, #267	; 0x10b
 8018ee6:	f7fb faff 	bl	80144e8 <VLine>
	VLine(268, 57, 3, 0x000000FF);
 8018eea:	23ff      	movs	r3, #255	; 0xff
 8018eec:	2203      	movs	r2, #3
 8018eee:	2139      	movs	r1, #57	; 0x39
 8018ef0:	f44f 7086 	mov.w	r0, #268	; 0x10c
 8018ef4:	f7fb faf8 	bl	80144e8 <VLine>
	VLine(269, 57, 3, 0x000000FF);
 8018ef8:	23ff      	movs	r3, #255	; 0xff
 8018efa:	2203      	movs	r2, #3
 8018efc:	2139      	movs	r1, #57	; 0x39
 8018efe:	f240 100d 	movw	r0, #269	; 0x10d
 8018f02:	f7fb faf1 	bl	80144e8 <VLine>
	VLine(270, 54, 9, 0x000000FF);
 8018f06:	23ff      	movs	r3, #255	; 0xff
 8018f08:	2209      	movs	r2, #9
 8018f0a:	2136      	movs	r1, #54	; 0x36
 8018f0c:	f44f 7087 	mov.w	r0, #270	; 0x10e
 8018f10:	f7fb faea 	bl	80144e8 <VLine>
	HLine(271, 54, 28, 0x000000FF);
 8018f14:	23ff      	movs	r3, #255	; 0xff
 8018f16:	221c      	movs	r2, #28
 8018f18:	2136      	movs	r1, #54	; 0x36
 8018f1a:	f240 100f 	movw	r0, #271	; 0x10f
 8018f1e:	f7fb fb29 	bl	8014574 <HLine>
	HLine(271, 62, 28, 0x000000FF);
 8018f22:	23ff      	movs	r3, #255	; 0xff
 8018f24:	221c      	movs	r2, #28
 8018f26:	213e      	movs	r1, #62	; 0x3e
 8018f28:	f240 100f 	movw	r0, #271	; 0x10f
 8018f2c:	f7fb fb22 	bl	8014574 <HLine>
	VLine(299, 54, 9, 0x000000FF);
 8018f30:	23ff      	movs	r3, #255	; 0xff
 8018f32:	2209      	movs	r2, #9
 8018f34:	2136      	movs	r1, #54	; 0x36
 8018f36:	f240 102b 	movw	r0, #299	; 0x12b
 8018f3a:	f7fb fad5 	bl	80144e8 <VLine>
	if(rekordbox.phase[beat] > 0) Rectangle(172 + (rekordbox.phase[beat] - 1) * 33, 55, 28, 7, 0x000000FF);
 8018f3e:	6833      	ldr	r3, [r6, #0]
 8018f40:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 8018f44:	f8b3 4e64 	ldrh.w	r4, [r3, #3684]	; 0xe64
 8018f48:	2c00      	cmp	r4, #0
 8018f4a:	d13f      	bne.n	8018fcc <DrawSpectrum+0x8b4>
}
 8018f4c:	f507 7701 	add.w	r7, r7, #516	; 0x204
 8018f50:	46bd      	mov	sp, r7
 8018f52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	else if(bar / 10 > 0) DrawDigit(bar / 10, 314, 51, 7, 0x000000FF);
 8018f56:	480a      	ldr	r0, [pc, #40]	; (8018f80 <DrawSpectrum+0x868>)
 8018f58:	fb80 2003 	smull	r2, r0, r0, r3
 8018f5c:	17db      	asrs	r3, r3, #31
 8018f5e:	ebc3 1020 	rsb	r0, r3, r0, asr #4
 8018f62:	23ff      	movs	r3, #255	; 0xff
 8018f64:	b2c0      	uxtb	r0, r0
 8018f66:	9300      	str	r3, [sp, #0]
 8018f68:	2233      	movs	r2, #51	; 0x33
 8018f6a:	2307      	movs	r3, #7
 8018f6c:	f44f 719d 	mov.w	r1, #314	; 0x13a
 8018f70:	f7fb fb46 	bl	8014600 <DrawDigit>
	DrawDigit(bar % 10, 323, 51, 7, 0x000000FF);
 8018f74:	6822      	ldr	r2, [r4, #0]
 8018f76:	e5eb      	b.n	8018b50 <DrawSpectrum+0x438>
 8018f78:	20000d84 	.word	0x20000d84
 8018f7c:	20000e2c 	.word	0x20000e2c
 8018f80:	66666667 	.word	0x66666667
		DrawDigit(bar / 100, 305, 51, 7, 0x000000FF);
 8018f84:	4d34      	ldr	r5, [pc, #208]	; (8019058 <DrawSpectrum+0x940>)
 8018f86:	17da      	asrs	r2, r3, #31
 8018f88:	f04f 08ff 	mov.w	r8, #255	; 0xff
 8018f8c:	fb85 1303 	smull	r1, r3, r5, r3
 8018f90:	f240 1131 	movw	r1, #305	; 0x131
 8018f94:	f8cd 8000 	str.w	r8, [sp]
 8018f98:	ebc2 13e3 	rsb	r3, r2, r3, asr #7
 8018f9c:	2233      	movs	r2, #51	; 0x33
 8018f9e:	b2d8      	uxtb	r0, r3
 8018fa0:	2307      	movs	r3, #7
 8018fa2:	f7fb fb2d 	bl	8014600 <DrawDigit>
		DrawDigit(bar % 100 / 10 , 314, 51, 7, 0x000000FF);
 8018fa6:	f8cd 8000 	str.w	r8, [sp]
 8018faa:	6823      	ldr	r3, [r4, #0]
 8018fac:	482b      	ldr	r0, [pc, #172]	; (801905c <DrawSpectrum+0x944>)
 8018fae:	fb85 2503 	smull	r2, r5, r5, r3
 8018fb2:	17da      	asrs	r2, r3, #31
 8018fb4:	ebc2 1565 	rsb	r5, r2, r5, asr #5
 8018fb8:	2264      	movs	r2, #100	; 0x64
 8018fba:	fb02 3315 	mls	r3, r2, r5, r3
 8018fbe:	fb80 2003 	smull	r2, r0, r0, r3
 8018fc2:	17db      	asrs	r3, r3, #31
 8018fc4:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
 8018fc8:	b2c0      	uxtb	r0, r0
 8018fca:	e7cd      	b.n	8018f68 <DrawSpectrum+0x850>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8018fcc:	4b24      	ldr	r3, [pc, #144]	; (8019060 <DrawSpectrum+0x948>)
 8018fce:	2234      	movs	r2, #52	; 0x34
 8018fd0:	4924      	ldr	r1, [pc, #144]	; (8019064 <DrawSpectrum+0x94c>)
 8018fd2:	781b      	ldrb	r3, [r3, #0]
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8018fd4:	4d24      	ldr	r5, [pc, #144]	; (8019068 <DrawSpectrum+0x950>)
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8018fd6:	fb02 1303 	mla	r3, r2, r3, r1
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8018fda:	4628      	mov	r0, r5
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8018fdc:	e9d3 8617 	ldrd	r8, r6, [r3, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8018fe0:	f1a6 031c 	sub.w	r3, r6, #28
 8018fe4:	60eb      	str	r3, [r5, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8018fe6:	f7e8 fd15 	bl	8001a14 <HAL_DMA2D_Init>
 8018fea:	2800      	cmp	r0, #0
 8018fec:	d1ae      	bne.n	8018f4c <DrawSpectrum+0x834>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8018fee:	ebc6 01c6 	rsb	r1, r6, r6, lsl #3
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8018ff2:	2307      	movs	r3, #7
	if(rekordbox.phase[beat] > 0) Rectangle(172 + (rekordbox.phase[beat] - 1) * 33, 55, 28, 7, 0x000000FF);
 8018ff4:	eb04 1444 	add.w	r4, r4, r4, lsl #5
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8018ff8:	4628      	mov	r0, r5
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8018ffa:	ebc6 06c1 	rsb	r6, r6, r1, lsl #3
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8018ffe:	9300      	str	r3, [sp, #0]
	if(rekordbox.phase[beat] > 0) Rectangle(172 + (rekordbox.phase[beat] - 1) * 33, 55, 28, 7, 0x000000FF);
 8019000:	f104 028b 	add.w	r2, r4, #139	; 0x8b
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019004:	231c      	movs	r3, #28
 8019006:	21ff      	movs	r1, #255	; 0xff
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019008:	fa16 f282 	uxtah	r2, r6, r2
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 801900c:	eb08 0242 	add.w	r2, r8, r2, lsl #1
 8019010:	f7e8 fd56 	bl	8001ac0 <HAL_DMA2D_Start>
 8019014:	2800      	cmp	r0, #0
 8019016:	d199      	bne.n	8018f4c <DrawSpectrum+0x834>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8019018:	2164      	movs	r1, #100	; 0x64
 801901a:	4628      	mov	r0, r5
 801901c:	f7e8 fdc6 	bl	8001bac <HAL_DMA2D_PollForTransfer>
}
 8019020:	e794      	b.n	8018f4c <DrawSpectrum+0x834>
				*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((ypos - k) * hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = 0;
 8019022:	4810      	ldr	r0, [pc, #64]	; (8019064 <DrawSpectrum+0x94c>)
 8019024:	2134      	movs	r1, #52	; 0x34
 8019026:	fb01 0202 	mla	r2, r1, r2, r0
 801902a:	6979      	ldr	r1, [r7, #20]
 801902c:	e9d2 2017 	ldrd	r2, r0, [r2, #92]	; 0x5c
 8019030:	fb00 e003 	mla	r0, r0, r3, lr
 8019034:	f822 1010 	strh.w	r1, [r2, r0, lsl #1]
 8019038:	e549      	b.n	8018ace <DrawSpectrum+0x3b6>
 801903a:	4a09      	ldr	r2, [pc, #36]	; (8019060 <DrawSpectrum+0x948>)
 801903c:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8019040:	7810      	ldrb	r0, [r2, #0]
 8019042:	4a08      	ldr	r2, [pc, #32]	; (8019064 <DrawSpectrum+0x94c>)
 8019044:	fb0c 2000 	mla	r0, ip, r0, r2
 8019048:	69ba      	ldr	r2, [r7, #24]
 801904a:	e9d0 0c17 	ldrd	r0, ip, [r0, #92]	; 0x5c
 801904e:	fb0c 2c03 	mla	ip, ip, r3, r2
 8019052:	f820 101c 	strh.w	r1, [r0, ip, lsl #1]
 8019056:	e503      	b.n	8018a60 <DrawSpectrum+0x348>
 8019058:	51eb851f 	.word	0x51eb851f
 801905c:	66666667 	.word	0x66666667
 8019060:	20000e2c 	.word	0x20000e2c
 8019064:	20000d84 	.word	0x20000d84
 8019068:	20000c94 	.word	0x20000c94

0801906c <DrawString>:
{
 801906c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019070:	b089      	sub	sp, #36	; 0x24
	hdma2d.Init.Mode = DMA2D_R2M;
 8019072:	4d91      	ldr	r5, [pc, #580]	; (80192b8 <DrawString+0x24c>)
{
 8019074:	4616      	mov	r6, r2
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8019076:	f44f 3240 	mov.w	r2, #196608	; 0x30000
{
 801907a:	9307      	str	r3, [sp, #28]
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 801907c:	2302      	movs	r3, #2
{
 801907e:	4604      	mov	r4, r0
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8019080:	4628      	mov	r0, r5
{
 8019082:	4688      	mov	r8, r1
 8019084:	9f12      	ldr	r7, [sp, #72]	; 0x48
	hdma2d.Init.OutputOffset = Xpos;
 8019086:	60e9      	str	r1, [r5, #12]
	hdma2d.Init.ColorMode = DMA2D_RGB565;
 8019088:	e9c5 2301 	strd	r2, r3, [r5, #4]
	hdma2d.Instance = DMA2D;
 801908c:	4b8b      	ldr	r3, [pc, #556]	; (80192bc <DrawString+0x250>)
 801908e:	602b      	str	r3, [r5, #0]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8019090:	f7e8 fcc0 	bl	8001a14 <HAL_DMA2D_Init>
 8019094:	2800      	cmp	r0, #0
 8019096:	f000 80e6 	beq.w	8019266 <DrawString+0x1fa>
	int xpos = Xpos + 5;
 801909a:	f108 0305 	add.w	r3, r8, #5
	Ypos -= 4;
 801909e:	3e04      	subs	r6, #4
	while(str[l] != 0) {
 80190a0:	7822      	ldrb	r2, [r4, #0]
	int xpos = Xpos + 5;
 80190a2:	9302      	str	r3, [sp, #8]
	Ypos -= 4;
 80190a4:	b2b3      	uxth	r3, r6
 80190a6:	9303      	str	r3, [sp, #12]
	while(str[l] != 0) {
 80190a8:	2a00      	cmp	r2, #0
 80190aa:	f000 80d5 	beq.w	8019258 <DrawString+0x1ec>
	uint16_t out_color = ((red & 0xF8) << 8) | ((green & 0xFC) << 3) | (blue >> 3);
 80190ae:	0a3b      	lsrs	r3, r7, #8
 80190b0:	4e83      	ldr	r6, [pc, #524]	; (80192c0 <DrawString+0x254>)
 80190b2:	0979      	lsrs	r1, r7, #5
 80190b4:	f3c7 07c4 	ubfx	r7, r7, #3, #5
 80190b8:	f403 4378 	and.w	r3, r3, #63488	; 0xf800
 80190bc:	4d81      	ldr	r5, [pc, #516]	; (80192c4 <DrawString+0x258>)
 80190be:	f401 61fc 	and.w	r1, r1, #2016	; 0x7e0
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 80190c2:	2034      	movs	r0, #52	; 0x34
 80190c4:	f8df 9204 	ldr.w	r9, [pc, #516]	; 80192cc <DrawString+0x260>
	uint16_t out_color = ((red & 0xF8) << 8) | ((green & 0xFC) << 3) | (blue >> 3);
 80190c8:	430b      	orrs	r3, r1
 80190ca:	433b      	orrs	r3, r7
 80190cc:	4f7e      	ldr	r7, [pc, #504]	; (80192c8 <DrawString+0x25c>)
 80190ce:	9304      	str	r3, [sp, #16]
 80190d0:	e00b      	b.n	80190ea <DrawString+0x7e>
		if(str[l] > 191) {
 80190d2:	2abf      	cmp	r2, #191	; 0xbf
 80190d4:	d860      	bhi.n	8019198 <DrawString+0x12c>
		if(str[l] == 32) {
 80190d6:	2a20      	cmp	r2, #32
 80190d8:	d102      	bne.n	80190e0 <DrawString+0x74>
			xpos += 5;
 80190da:	9b02      	ldr	r3, [sp, #8]
 80190dc:	3305      	adds	r3, #5
 80190de:	9302      	str	r3, [sp, #8]
	while(str[l] != 0) {
 80190e0:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 80190e4:	2a00      	cmp	r2, #0
 80190e6:	f000 80b7 	beq.w	8019258 <DrawString+0x1ec>
		if((str[l] > 32) && (str[l] < 128)) {
 80190ea:	f1a2 0321 	sub.w	r3, r2, #33	; 0x21
 80190ee:	b2d9      	uxtb	r1, r3
 80190f0:	295e      	cmp	r1, #94	; 0x5e
 80190f2:	d8ee      	bhi.n	80190d2 <DrawString+0x66>
 80190f4:	9902      	ldr	r1, [sp, #8]
 80190f6:	f04f 0e01 	mov.w	lr, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80190fa:	f8bd 801c 	ldrh.w	r8, [sp, #28]
 80190fe:	4692      	mov	sl, r2
 8019100:	3901      	subs	r1, #1
 8019102:	9106      	str	r1, [sp, #24]
 8019104:	e013      	b.n	801912e <DrawString+0xc2>
				if(font[(str[l]-33)*12+i] == 0) {
 8019106:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801910a:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 801910e:	f837 101c 	ldrh.w	r1, [r7, ip, lsl #1]
 8019112:	b931      	cbnz	r1, 8019122 <DrawString+0xb6>
					if(font[(str[l]-33)*12+i+1] == 0) {
 8019114:	f10c 0c01 	add.w	ip, ip, #1
 8019118:	f837 101c 	ldrh.w	r1, [r7, ip, lsl #1]
 801911c:	2900      	cmp	r1, #0
 801911e:	f000 809e 	beq.w	801925e <DrawString+0x1f2>
			while(i < 12);
 8019122:	f10e 0e01 	add.w	lr, lr, #1
 8019126:	f1be 0f0d 	cmp.w	lr, #13
 801912a:	f000 808e 	beq.w	801924a <DrawString+0x1de>
				if(xpos < 470) {
 801912e:	9a02      	ldr	r2, [sp, #8]
 8019130:	f10e 3cff 	add.w	ip, lr, #4294967295
 8019134:	f5b2 7feb 	cmp.w	r2, #470	; 0x1d6
 8019138:	dae5      	bge.n	8019106 <DrawString+0x9a>
 801913a:	9a06      	ldr	r2, [sp, #24]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801913c:	f8cd e014 	str.w	lr, [sp, #20]
 8019140:	eb02 0a0e 	add.w	sl, r2, lr
 8019144:	9903      	ldr	r1, [sp, #12]
 8019146:	2200      	movs	r2, #0
 8019148:	f8dd e010 	ldr.w	lr, [sp, #16]
 801914c:	e007      	b.n	801915e <DrawString+0xf2>
					while(k < 13) {
 801914e:	3201      	adds	r2, #1
 8019150:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019152:	f823 801b 	strh.w	r8, [r3, fp, lsl #1]
					while(k < 13) {
 8019156:	2a0d      	cmp	r2, #13
 8019158:	d018      	beq.n	801918c <DrawString+0x120>
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 801915a:	7823      	ldrb	r3, [r4, #0]
 801915c:	3b21      	subs	r3, #33	; 0x21
 801915e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8019162:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 8019166:	f837 3013 	ldrh.w	r3, [r7, r3, lsl #1]
 801916a:	4113      	asrs	r3, r2
 801916c:	f013 0f01 	tst.w	r3, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019170:	7833      	ldrb	r3, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019172:	fb00 5303 	mla	r3, r0, r3, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019176:	e9d3 3b17 	ldrd	r3, fp, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801917a:	fb0b ab01 	mla	fp, fp, r1, sl
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 801917e:	d1e6      	bne.n	801914e <DrawString+0xe2>
					while(k < 13) {
 8019180:	3201      	adds	r2, #1
 8019182:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019184:	f823 e01b 	strh.w	lr, [r3, fp, lsl #1]
					while(k < 13) {
 8019188:	2a0d      	cmp	r2, #13
 801918a:	d1e6      	bne.n	801915a <DrawString+0xee>
				if(font[(str[l]-33)*12+i] == 0) {
 801918c:	7823      	ldrb	r3, [r4, #0]
 801918e:	f8dd e014 	ldr.w	lr, [sp, #20]
 8019192:	469a      	mov	sl, r3
 8019194:	3b21      	subs	r3, #33	; 0x21
 8019196:	e7b6      	b.n	8019106 <DrawString+0x9a>
 8019198:	9902      	ldr	r1, [sp, #8]
 801919a:	f04f 0e01 	mov.w	lr, #1
 801919e:	f1a2 03c0 	sub.w	r3, r2, #192	; 0xc0
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80191a2:	f8bd a01c 	ldrh.w	sl, [sp, #28]
 80191a6:	3901      	subs	r1, #1
 80191a8:	4690      	mov	r8, r2
 80191aa:	9106      	str	r1, [sp, #24]
 80191ac:	e011      	b.n	80191d2 <DrawString+0x166>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 80191ae:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80191b2:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 80191b6:	f839 101c 	ldrh.w	r1, [r9, ip, lsl #1]
 80191ba:	b929      	cbnz	r1, 80191c8 <DrawString+0x15c>
					if(ru_font[(str[l]-192)*12+i+1] == 0) {
 80191bc:	f10c 0c01 	add.w	ip, ip, #1
 80191c0:	f839 101c 	ldrh.w	r1, [r9, ip, lsl #1]
 80191c4:	2900      	cmp	r1, #0
 80191c6:	d04c      	beq.n	8019262 <DrawString+0x1f6>
			while(i < 12);
 80191c8:	f10e 0e01 	add.w	lr, lr, #1
 80191cc:	f1be 0f0d 	cmp.w	lr, #13
 80191d0:	d034      	beq.n	801923c <DrawString+0x1d0>
				if(xpos < 470) {
 80191d2:	9a02      	ldr	r2, [sp, #8]
 80191d4:	f10e 3cff 	add.w	ip, lr, #4294967295
 80191d8:	f5b2 7feb 	cmp.w	r2, #470	; 0x1d6
 80191dc:	dae7      	bge.n	80191ae <DrawString+0x142>
 80191de:	9a06      	ldr	r2, [sp, #24]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80191e0:	f8cd e014 	str.w	lr, [sp, #20]
 80191e4:	eb02 080e 	add.w	r8, r2, lr
 80191e8:	9903      	ldr	r1, [sp, #12]
 80191ea:	2200      	movs	r2, #0
 80191ec:	f8dd e010 	ldr.w	lr, [sp, #16]
 80191f0:	e007      	b.n	8019202 <DrawString+0x196>
					while(k < 13) {
 80191f2:	3201      	adds	r2, #1
 80191f4:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80191f6:	f823 a01b 	strh.w	sl, [r3, fp, lsl #1]
					while(k < 13) {
 80191fa:	2a0d      	cmp	r2, #13
 80191fc:	d018      	beq.n	8019230 <DrawString+0x1c4>
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 80191fe:	7823      	ldrb	r3, [r4, #0]
 8019200:	3bc0      	subs	r3, #192	; 0xc0
 8019202:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8019206:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 801920a:	f839 3013 	ldrh.w	r3, [r9, r3, lsl #1]
 801920e:	4113      	asrs	r3, r2
 8019210:	f013 0f01 	tst.w	r3, #1
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019214:	7833      	ldrb	r3, [r6, #0]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019216:	fb00 5303 	mla	r3, r0, r3, r5
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801921a:	e9d3 3b17 	ldrd	r3, fp, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801921e:	fb0b 8b01 	mla	fp, fp, r1, r8
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 8019222:	d1e6      	bne.n	80191f2 <DrawString+0x186>
					while(k < 13) {
 8019224:	3201      	adds	r2, #1
 8019226:	3901      	subs	r1, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019228:	f823 e01b 	strh.w	lr, [r3, fp, lsl #1]
					while(k < 13) {
 801922c:	2a0d      	cmp	r2, #13
 801922e:	d1e6      	bne.n	80191fe <DrawString+0x192>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 8019230:	7823      	ldrb	r3, [r4, #0]
 8019232:	f8dd e014 	ldr.w	lr, [sp, #20]
 8019236:	4698      	mov	r8, r3
 8019238:	3bc0      	subs	r3, #192	; 0xc0
 801923a:	e7b8      	b.n	80191ae <DrawString+0x142>
 801923c:	4642      	mov	r2, r8
 801923e:	f04f 0e0c 	mov.w	lr, #12
			xpos += i;
 8019242:	9b02      	ldr	r3, [sp, #8]
 8019244:	4473      	add	r3, lr
 8019246:	9302      	str	r3, [sp, #8]
 8019248:	e745      	b.n	80190d6 <DrawString+0x6a>
 801924a:	4652      	mov	r2, sl
 801924c:	f04f 0e0c 	mov.w	lr, #12
			xpos += i;
 8019250:	9b02      	ldr	r3, [sp, #8]
 8019252:	4473      	add	r3, lr
 8019254:	9302      	str	r3, [sp, #8]
 8019256:	e73c      	b.n	80190d2 <DrawString+0x66>
}
 8019258:	b009      	add	sp, #36	; 0x24
 801925a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						i++;
 801925e:	4652      	mov	r2, sl
						break;
 8019260:	e7f6      	b.n	8019250 <DrawString+0x1e4>
						i++;
 8019262:	4642      	mov	r2, r8
						break;
 8019264:	e7ed      	b.n	8019242 <DrawString+0x1d6>
		if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK)
 8019266:	f8df 9058 	ldr.w	r9, [pc, #88]	; 80192c0 <DrawString+0x254>
 801926a:	4628      	mov	r0, r5
 801926c:	f899 1000 	ldrb.w	r1, [r9]
 8019270:	f7e8 fd32 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 8019274:	2800      	cmp	r0, #0
 8019276:	f47f af10 	bne.w	801909a <DrawString+0x2e>
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 801927a:	f899 1000 	ldrb.w	r1, [r9]
 801927e:	2034      	movs	r0, #52	; 0x34
 8019280:	f1a6 0314 	sub.w	r3, r6, #20
 8019284:	4a0f      	ldr	r2, [pc, #60]	; (80192c4 <DrawString+0x258>)
 8019286:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801928a:	fb00 2201 	mla	r2, r0, r1, r2
 801928e:	4639      	mov	r1, r7
 8019290:	4628      	mov	r0, r5
 8019292:	eb08 1343 	add.w	r3, r8, r3, lsl #5
 8019296:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8019298:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801929c:	2314      	movs	r3, #20
 801929e:	9300      	str	r3, [sp, #0]
 80192a0:	f5c8 73f0 	rsb	r3, r8, #480	; 0x1e0
 80192a4:	f7e8 fc0c 	bl	8001ac0 <HAL_DMA2D_Start>
 80192a8:	2800      	cmp	r0, #0
 80192aa:	f47f aef6 	bne.w	801909a <DrawString+0x2e>
				HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80192ae:	4628      	mov	r0, r5
 80192b0:	210a      	movs	r1, #10
 80192b2:	f7e8 fc7b 	bl	8001bac <HAL_DMA2D_PollForTransfer>
 80192b6:	e6f0      	b.n	801909a <DrawString+0x2e>
 80192b8:	20000c94 	.word	0x20000c94
 80192bc:	4002b000 	.word	0x4002b000
 80192c0:	20000e2c 	.word	0x20000e2c
 80192c4:	20000d84 	.word	0x20000d84
 80192c8:	08025abc 	.word	0x08025abc
 80192cc:	08026650 	.word	0x08026650

080192d0 <DrawMenu>:
	if(menu_mode == 0) {
 80192d0:	4b7f      	ldr	r3, [pc, #508]	; (80194d0 <DrawMenu+0x200>)
{
 80192d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if(menu_mode == 0) {
 80192d6:	f993 4000 	ldrsb.w	r4, [r3]
{
 80192da:	b0c9      	sub	sp, #292	; 0x124
	if(menu_mode == 0) {
 80192dc:	2c00      	cmp	r4, #0
 80192de:	d069      	beq.n	80193b4 <DrawMenu+0xe4>
	else if(menu_mode == 1) {
 80192e0:	2c01      	cmp	r4, #1
 80192e2:	d008      	beq.n	80192f6 <DrawMenu+0x26>
	else if(menu_mode == 2) {
 80192e4:	2c02      	cmp	r4, #2
 80192e6:	f000 8111 	beq.w	801950c <DrawMenu+0x23c>
	else if(menu_mode == 3) {
 80192ea:	2c03      	cmp	r4, #3
 80192ec:	f000 820f 	beq.w	801970e <DrawMenu+0x43e>
}
 80192f0:	b049      	add	sp, #292	; 0x124
 80192f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(Total_tracks > 7) {
 80192f6:	f8df 8208 	ldr.w	r8, [pc, #520]	; 8019500 <DrawMenu+0x230>
 80192fa:	f8b8 3000 	ldrh.w	r3, [r8]
 80192fe:	2b07      	cmp	r3, #7
 8019300:	d86a      	bhi.n	80193d8 <DrawMenu+0x108>
 8019302:	f8df a200 	ldr.w	sl, [pc, #512]	; 8019504 <DrawMenu+0x234>
		DrawString(" [FILES]", 0, 20, 0x00FFFFFF, 0x000000FF);
 8019306:	2400      	movs	r4, #0
 8019308:	2214      	movs	r2, #20
 801930a:	2100      	movs	r1, #0
 801930c:	4871      	ldr	r0, [pc, #452]	; (80194d4 <DrawMenu+0x204>)
 801930e:	2529      	movs	r5, #41	; 0x29
	uint32_t backcolor = 0;
 8019310:	4626      	mov	r6, r4
 8019312:	af08      	add	r7, sp, #32
 8019314:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8019508 <DrawMenu+0x238>
				backcolor += 0x00202020;
 8019318:	f8df b1e0 	ldr.w	fp, [pc, #480]	; 80194fc <DrawMenu+0x22c>
		DrawString(" [FILES]", 0, 20, 0x00FFFFFF, 0x000000FF);
 801931c:	f7fa fd6a 	bl	8013df4 <DrawString.constprop.1>
		while(21+20*(i+1) < 165) {
 8019320:	e027      	b.n	8019372 <DrawMenu+0xa2>
			else if(i == String_number) {
 8019322:	4a6d      	ldr	r2, [pc, #436]	; (80194d8 <DrawMenu+0x208>)
 8019324:	7812      	ldrb	r2, [r2, #0]
 8019326:	42a2      	cmp	r2, r4
 8019328:	f000 80b7 	beq.w	801949a <DrawMenu+0x1ca>
				if(i == Mark_number) {
 801932c:	4a6b      	ldr	r2, [pc, #428]	; (80194dc <DrawMenu+0x20c>)
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 801932e:	4423      	add	r3, r4
 8019330:	4638      	mov	r0, r7
				if(i == Mark_number) {
 8019332:	7812      	ldrb	r2, [r2, #0]
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 8019334:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
				if(i == Mark_number) {
 8019338:	42a2      	cmp	r2, r4
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 801933a:	4a69      	ldr	r2, [pc, #420]	; (80194e0 <DrawMenu+0x210>)
 801933c:	eb02 0103 	add.w	r1, r2, r3
				if(i == Mark_number) {
 8019340:	f000 80a5 	beq.w	801948e <DrawMenu+0x1be>
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00FFFFFF, backcolor);
 8019344:	f007 f826 	bl	8020394 <strcat>
 8019348:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801934c:	462a      	mov	r2, r5
 801934e:	210b      	movs	r1, #11
 8019350:	9600      	str	r6, [sp, #0]
 8019352:	f7ff fe8b 	bl	801906c <DrawString>
				backcolor += 0x00202020;
 8019356:	445e      	add	r6, fp
				if(backcolor > 0x00404040) backcolor = 0;
 8019358:	4b62      	ldr	r3, [pc, #392]	; (80194e4 <DrawMenu+0x214>)
 801935a:	429e      	cmp	r6, r3
 801935c:	d900      	bls.n	8019360 <DrawMenu+0x90>
 801935e:	2600      	movs	r6, #0
			if(i >= Total_tracks) break;
 8019360:	3401      	adds	r4, #1
 8019362:	f8b8 3000 	ldrh.w	r3, [r8]
 8019366:	42a3      	cmp	r3, r4
 8019368:	ddc2      	ble.n	80192f0 <DrawMenu+0x20>
		while(21+20*(i+1) < 165) {
 801936a:	3514      	adds	r5, #20
 801936c:	2c07      	cmp	r4, #7
 801936e:	b2ad      	uxth	r5, r5
 8019370:	d0be      	beq.n	80192f0 <DrawMenu+0x20>
			char string[255] = "{ ";
 8019372:	f242 037b 	movw	r3, #8315	; 0x207b
 8019376:	22fb      	movs	r2, #251	; 0xfb
 8019378:	2100      	movs	r1, #0
 801937a:	a809      	add	r0, sp, #36	; 0x24
 801937c:	603b      	str	r3, [r7, #0]
 801937e:	f006 fead 	bl	80200dc <memset>
			if(i == Track_number - str_increment) {
 8019382:	f8da 3000 	ldr.w	r3, [sl]
 8019386:	f8d9 2000 	ldr.w	r2, [r9]
 801938a:	1ad2      	subs	r2, r2, r3
 801938c:	42a2      	cmp	r2, r4
 801938e:	d1c8      	bne.n	8019322 <DrawMenu+0x52>
				if(i == Mark_number) {
 8019390:	4a52      	ldr	r2, [pc, #328]	; (80194dc <DrawMenu+0x20c>)
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 8019392:	4423      	add	r3, r4
 8019394:	4638      	mov	r0, r7
				if(i == Mark_number) {
 8019396:	7812      	ldrb	r2, [r2, #0]
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 8019398:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
				if(i == Mark_number) {
 801939c:	42a2      	cmp	r2, r4
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 801939e:	4a50      	ldr	r2, [pc, #320]	; (80194e0 <DrawMenu+0x210>)
 80193a0:	eb02 0103 	add.w	r1, r2, r3
				if(i == Mark_number) {
 80193a4:	d073      	beq.n	801948e <DrawMenu+0x1be>
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00FFFFFF, 0x000000FF);
 80193a6:	f006 fff5 	bl	8020394 <strcat>
 80193aa:	462a      	mov	r2, r5
 80193ac:	210b      	movs	r1, #11
 80193ae:	f7fa fd21 	bl	8013df4 <DrawString.constprop.1>
 80193b2:	e7d0      	b.n	8019356 <DrawMenu+0x86>
		char string[255] = " { ";
 80193b4:	4b4c      	ldr	r3, [pc, #304]	; (80194e8 <DrawMenu+0x218>)
 80193b6:	22fb      	movs	r2, #251	; 0xfb
 80193b8:	4621      	mov	r1, r4
 80193ba:	a809      	add	r0, sp, #36	; 0x24
 80193bc:	9308      	str	r3, [sp, #32]
 80193be:	f006 fe8d 	bl	80200dc <memset>
		DrawString(strcat(string, rekordbox.file), 0, 20, 0x00FFFFFF, 0x000000FF);
 80193c2:	494a      	ldr	r1, [pc, #296]	; (80194ec <DrawMenu+0x21c>)
 80193c4:	a808      	add	r0, sp, #32
 80193c6:	f006 ffe5 	bl	8020394 <strcat>
 80193ca:	2214      	movs	r2, #20
 80193cc:	4621      	mov	r1, r4
 80193ce:	f7fa fd11 	bl	8013df4 <DrawString.constprop.1>
}
 80193d2:	b049      	add	sp, #292	; 0x124
 80193d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 80193d8:	ee07 3a90 	vmov	s15, r3
 80193dc:	ed9f 6a44 	vldr	s12, [pc, #272]	; 80194f0 <DrawMenu+0x220>
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 80193e0:	ed9f 7a44 	vldr	s14, [pc, #272]	; 80194f4 <DrawMenu+0x224>
			VLine(1, 21, 140, 0x00FFFFFF);
 80193e4:	4620      	mov	r0, r4
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 80193e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 80193ea:	f8df a118 	ldr.w	sl, [pc, #280]	; 8019504 <DrawMenu+0x234>
			VLine(1, 21, 140, 0x00FFFFFF);
 80193ee:	2115      	movs	r1, #21
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 80193f0:	eec7 6a27 	vdiv.f32	s13, s14, s15
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 80193f4:	ee86 7a27 	vdiv.f32	s14, s12, s15
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 80193f8:	edda 7a00 	vldr	s15, [sl]
 80193fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8019400:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8019404:	eefc 7ae7 	vcvt.u32.f32	s15, s15
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 8019408:	eebc 7ac7 	vcvt.u32.f32	s14, s14
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 801940c:	ee17 2a90 	vmov	r2, s15
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 8019410:	ee17 3a10 	vmov	r3, s14
			uint16_t step_scroll = (140/(float)Total_tracks)*(float)str_increment;
 8019414:	b294      	uxth	r4, r2
			VLine(1, 21, 140, 0x00FFFFFF);
 8019416:	228c      	movs	r2, #140	; 0x8c
			uint16_t scroll_lenght = (140/(float)Total_tracks)*7;
 8019418:	b29d      	uxth	r5, r3
			VLine(3, 22+step_scroll, scroll_lenght-2, 0x00FFFFFF);
 801941a:	f104 0616 	add.w	r6, r4, #22
			VLine(1, 21, 140, 0x00FFFFFF);
 801941e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019422:	2d05      	cmp	r5, #5
			VLine(3, 22+step_scroll, scroll_lenght-2, 0x00FFFFFF);
 8019424:	b2b6      	uxth	r6, r6
 8019426:	bf38      	it	cc
 8019428:	2505      	movcc	r5, #5
			VLine(1, 21, 140, 0x00FFFFFF);
 801942a:	f7fb f85d 	bl	80144e8 <VLine>
			VLine(3, 22+step_scroll, scroll_lenght-2, 0x00FFFFFF);
 801942e:	4631      	mov	r1, r6
 8019430:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019434:	1eaf      	subs	r7, r5, #2
 8019436:	2003      	movs	r0, #3
 8019438:	b2bf      	uxth	r7, r7
 801943a:	463a      	mov	r2, r7
 801943c:	f7fb f854 	bl	80144e8 <VLine>
			VLine(4, 21+step_scroll, scroll_lenght, 0x00FFFFFF);
 8019440:	f104 0115 	add.w	r1, r4, #21
 8019444:	462a      	mov	r2, r5
 8019446:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801944a:	b289      	uxth	r1, r1
 801944c:	2004      	movs	r0, #4
 801944e:	9103      	str	r1, [sp, #12]
 8019450:	f7fb f84a 	bl	80144e8 <VLine>
			VLine(5, 21+step_scroll, scroll_lenght, 0x00FFFFFF);
 8019454:	462a      	mov	r2, r5
 8019456:	9903      	ldr	r1, [sp, #12]
 8019458:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801945c:	2005      	movs	r0, #5
 801945e:	f7fb f843 	bl	80144e8 <VLine>
			VLine(6, 21+step_scroll, scroll_lenght, 0x00FFFFFF);
 8019462:	462a      	mov	r2, r5
 8019464:	9903      	ldr	r1, [sp, #12]
 8019466:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801946a:	2006      	movs	r0, #6
 801946c:	f7fb f83c 	bl	80144e8 <VLine>
			VLine(7, 22+step_scroll, scroll_lenght-2, 0x00FFFFFF);
 8019470:	463a      	mov	r2, r7
 8019472:	4631      	mov	r1, r6
 8019474:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019478:	2007      	movs	r0, #7
 801947a:	f7fb f835 	bl	80144e8 <VLine>
			VLine(9, 21, 140, 0x00FFFFFF);
 801947e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019482:	228c      	movs	r2, #140	; 0x8c
 8019484:	2115      	movs	r1, #21
 8019486:	2009      	movs	r0, #9
 8019488:	f7fb f82e 	bl	80144e8 <VLine>
 801948c:	e73b      	b.n	8019306 <DrawMenu+0x36>
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11, 21+20*(i+1), 0x00000000, 0x00FFFFFF);
 801948e:	f006 ff81 	bl	8020394 <strcat>
 8019492:	4629      	mov	r1, r5
 8019494:	f7fa fdce 	bl	8014034 <DrawString.constprop.2>
 8019498:	e75d      	b.n	8019356 <DrawMenu+0x86>
				if(str_offset > 10) {
 801949a:	4a17      	ldr	r2, [pc, #92]	; (80194f8 <DrawMenu+0x228>)
 801949c:	6812      	ldr	r2, [r2, #0]
 801949e:	2a0a      	cmp	r2, #10
 80194a0:	f77f af44 	ble.w	801932c <DrawMenu+0x5c>
					DrawString(strcat(string, (char*)TrackTable[i+str_increment]), 11 + str_offset, 21+20*(i+1), 0x00FFFFFF, 0x00008F00);
 80194a4:	4423      	add	r3, r4
 80194a6:	9203      	str	r2, [sp, #12]
 80194a8:	4a0d      	ldr	r2, [pc, #52]	; (80194e0 <DrawMenu+0x210>)
 80194aa:	4638      	mov	r0, r7
 80194ac:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 80194b0:	18d1      	adds	r1, r2, r3
 80194b2:	f006 ff6f 	bl	8020394 <strcat>
 80194b6:	9a03      	ldr	r2, [sp, #12]
 80194b8:	f44f 430f 	mov.w	r3, #36608	; 0x8f00
 80194bc:	320b      	adds	r2, #11
 80194be:	9300      	str	r3, [sp, #0]
 80194c0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80194c4:	b291      	uxth	r1, r2
 80194c6:	462a      	mov	r2, r5
 80194c8:	f7ff fdd0 	bl	801906c <DrawString>
 80194cc:	e743      	b.n	8019356 <DrawMenu+0x86>
 80194ce:	bf00      	nop
 80194d0:	20000c8c 	.word	0x20000c8c
 80194d4:	0802595c 	.word	0x0802595c
 80194d8:	2000006c 	.word	0x2000006c
 80194dc:	20000064 	.word	0x20000064
 80194e0:	20008660 	.word	0x20008660
 80194e4:	00404040 	.word	0x00404040
 80194e8:	00207b20 	.word	0x00207b20
 80194ec:	200158ec 	.word	0x200158ec
 80194f0:	44750000 	.word	0x44750000
 80194f4:	430c0000 	.word	0x430c0000
 80194f8:	20018b78 	.word	0x20018b78
 80194fc:	00202020 	.word	0x00202020
 8019500:	200022c0 	.word	0x200022c0
 8019504:	20018b74 	.word	0x20018b74
 8019508:	2000e9fc 	.word	0x2000e9fc
		char stri[50] = {0};
 801950c:	2400      	movs	r4, #0
 801950e:	af08      	add	r7, sp, #32
		DrawString(" [SETTINGS]", 0, 20, 0x00FFFFFF, 0x000000FF);
 8019510:	2214      	movs	r2, #20
 8019512:	48b8      	ldr	r0, [pc, #736]	; (80197f4 <DrawMenu+0x524>)
 8019514:	4621      	mov	r1, r4
		sprintf(stri, "%s %d %s", " Volume", volume, "%");
 8019516:	4eb8      	ldr	r6, [pc, #736]	; (80197f8 <DrawMenu+0x528>)
 8019518:	4db8      	ldr	r5, [pc, #736]	; (80197fc <DrawMenu+0x52c>)
		DrawString(" [SETTINGS]", 0, 20, 0x00FFFFFF, 0x000000FF);
 801951a:	f7fa fc6b 	bl	8013df4 <DrawString.constprop.1>
		char stri[50] = {0};
 801951e:	4621      	mov	r1, r4
 8019520:	222e      	movs	r2, #46	; 0x2e
 8019522:	603c      	str	r4, [r7, #0]
 8019524:	a809      	add	r0, sp, #36	; 0x24
 8019526:	f006 fdd9 	bl	80200dc <memset>
		sprintf(stri, "%s %d %s", " Volume", volume, "%");
 801952a:	7833      	ldrb	r3, [r6, #0]
 801952c:	4ab4      	ldr	r2, [pc, #720]	; (8019800 <DrawMenu+0x530>)
 801952e:	4638      	mov	r0, r7
 8019530:	49b4      	ldr	r1, [pc, #720]	; (8019804 <DrawMenu+0x534>)
 8019532:	9500      	str	r5, [sp, #0]
 8019534:	f006 ff0e 	bl	8020354 <siprintf>
		DrawString(stri, 0, 40, 0x00FFFFFF, backcolor);
 8019538:	4bb3      	ldr	r3, [pc, #716]	; (8019808 <DrawMenu+0x538>)
 801953a:	4621      	mov	r1, r4
 801953c:	2228      	movs	r2, #40	; 0x28
 801953e:	4638      	mov	r0, r7
 8019540:	9300      	str	r3, [sp, #0]
 8019542:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019546:	f7ff fd91 	bl	801906c <DrawString>
		VLine(40, 41, 18, 0x00FFFFFF);
 801954a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801954e:	2212      	movs	r2, #18
 8019550:	2129      	movs	r1, #41	; 0x29
 8019552:	2028      	movs	r0, #40	; 0x28
 8019554:	f7fa ffc8 	bl	80144e8 <VLine>
		VLine(440, 41, 18, 0x00FFFFFF);
 8019558:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801955c:	2212      	movs	r2, #18
 801955e:	2129      	movs	r1, #41	; 0x29
 8019560:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
 8019564:	f7fa ffc0 	bl	80144e8 <VLine>
		HLine(40, 41, 400, 0x00FFFFFF);
 8019568:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801956c:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8019570:	2129      	movs	r1, #41	; 0x29
 8019572:	2028      	movs	r0, #40	; 0x28
 8019574:	f7fa fffe 	bl	8014574 <HLine>
		HLine(40, 59, 401, 0x00FFFFFF);
 8019578:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801957c:	f240 1291 	movw	r2, #401	; 0x191
 8019580:	213b      	movs	r1, #59	; 0x3b
 8019582:	2028      	movs	r0, #40	; 0x28
 8019584:	f7fa fff6 	bl	8014574 <HLine>
		uint32_t vol_pos = (float)volume/100*400;
 8019588:	7833      	ldrb	r3, [r6, #0]
 801958a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 801958e:	ee07 3a90 	vmov	s15, r3
 8019592:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8019596:	ee67 7a87 	vmul.f32	s15, s15, s14
 801959a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801959e:	ee17 4a90 	vmov	r4, s15
		if(vol_pos != 0) Rectangle(40, 42, vol_pos, 17, 0x00FFFFFF);
 80195a2:	2c00      	cmp	r4, #0
 80195a4:	f040 8250 	bne.w	8019a48 <DrawMenu+0x778>
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195a8:	4b98      	ldr	r3, [pc, #608]	; (801980c <DrawMenu+0x53c>)
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195aa:	4638      	mov	r0, r7
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195ac:	ed9f 7a98 	vldr	s14, [pc, #608]	; 8019810 <DrawMenu+0x540>
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195b0:	9500      	str	r5, [sp, #0]
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195b2:	edd3 7a00 	vldr	s15, [r3]
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195b6:	4a97      	ldr	r2, [pc, #604]	; (8019814 <DrawMenu+0x544>)
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195b8:	ee67 7a87 	vmul.f32	s15, s15, s14
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195bc:	4991      	ldr	r1, [pc, #580]	; (8019804 <DrawMenu+0x534>)
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195c2:	ee17 3a90 	vmov	r3, s15
		uint32_t jogsens_pos = jog_sensitivity * 10000;
 80195c6:	ee17 4a90 	vmov	r4, s15
		sprintf(stri, "%s %d %s", " Jog sensitivity", (int)jogsens_pos, "%");
 80195ca:	f006 fec3 	bl	8020354 <siprintf>
		DrawString(stri, 0, 80, 0x00FFFFFF, backcolor);
 80195ce:	4a92      	ldr	r2, [pc, #584]	; (8019818 <DrawMenu+0x548>)
 80195d0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80195d4:	2100      	movs	r1, #0
 80195d6:	4638      	mov	r0, r7
 80195d8:	9200      	str	r2, [sp, #0]
 80195da:	2250      	movs	r2, #80	; 0x50
 80195dc:	f7ff fd46 	bl	801906c <DrawString>
		VLine(40, 81, 18, 0x00FFFFFF);
 80195e0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80195e4:	2212      	movs	r2, #18
 80195e6:	2151      	movs	r1, #81	; 0x51
 80195e8:	2028      	movs	r0, #40	; 0x28
 80195ea:	f7fa ff7d 	bl	80144e8 <VLine>
		VLine(440, 81, 18, 0x00FFFFFF);
 80195ee:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80195f2:	2212      	movs	r2, #18
 80195f4:	2151      	movs	r1, #81	; 0x51
 80195f6:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
 80195fa:	f7fa ff75 	bl	80144e8 <VLine>
		HLine(40, 81, 400, 0x00FFFFFF);
 80195fe:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019602:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8019606:	2151      	movs	r1, #81	; 0x51
 8019608:	2028      	movs	r0, #40	; 0x28
 801960a:	f7fa ffb3 	bl	8014574 <HLine>
		HLine(40, 99, 401, 0x00FFFFFF);
 801960e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019612:	f240 1291 	movw	r2, #401	; 0x191
 8019616:	2163      	movs	r1, #99	; 0x63
 8019618:	2028      	movs	r0, #40	; 0x28
 801961a:	f7fa ffab 	bl	8014574 <HLine>
		if(jogsens_pos != 0) Rectangle(40, 82, jogsens_pos, 17, 0x00FFFFFF);
 801961e:	00a4      	lsls	r4, r4, #2
 8019620:	f040 81e7 	bne.w	80199f2 <DrawMenu+0x722>
		sprintf(stri, "%s %d %s", " Auto cue sensitivity", (int)((float)acue_sensitivity/250*100), "%");
 8019624:	4c7d      	ldr	r4, [pc, #500]	; (801981c <DrawMenu+0x54c>)
 8019626:	4638      	mov	r0, r7
 8019628:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 8019820 <DrawMenu+0x550>
 801962c:	7823      	ldrb	r3, [r4, #0]
 801962e:	4a7d      	ldr	r2, [pc, #500]	; (8019824 <DrawMenu+0x554>)
 8019630:	ee07 3a90 	vmov	s15, r3
 8019634:	4973      	ldr	r1, [pc, #460]	; (8019804 <DrawMenu+0x534>)
 8019636:	9500      	str	r5, [sp, #0]
 8019638:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801963c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019640:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019644:	ee17 3a90 	vmov	r3, s15
 8019648:	f006 fe84 	bl	8020354 <siprintf>
		DrawString(stri, 0, 120, 0x00FFFFFF, backcolor);
 801964c:	4976      	ldr	r1, [pc, #472]	; (8019828 <DrawMenu+0x558>)
 801964e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019652:	2278      	movs	r2, #120	; 0x78
 8019654:	4638      	mov	r0, r7
 8019656:	9100      	str	r1, [sp, #0]
 8019658:	2100      	movs	r1, #0
 801965a:	f7ff fd07 	bl	801906c <DrawString>
		VLine(40, 121, 18, 0x00FFFFFF);
 801965e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019662:	2212      	movs	r2, #18
 8019664:	2179      	movs	r1, #121	; 0x79
 8019666:	2028      	movs	r0, #40	; 0x28
 8019668:	f7fa ff3e 	bl	80144e8 <VLine>
		VLine(440, 121, 18, 0x00FFFFFF);
 801966c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019670:	2212      	movs	r2, #18
 8019672:	2179      	movs	r1, #121	; 0x79
 8019674:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
 8019678:	f7fa ff36 	bl	80144e8 <VLine>
		HLine(40, 121, 400, 0x00FFFFFF);
 801967c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019680:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8019684:	2179      	movs	r1, #121	; 0x79
 8019686:	2028      	movs	r0, #40	; 0x28
 8019688:	f7fa ff74 	bl	8014574 <HLine>
		HLine(40, 139, 401, 0x00FFFFFF);
 801968c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019690:	f240 1291 	movw	r2, #401	; 0x191
 8019694:	218b      	movs	r1, #139	; 0x8b
 8019696:	2028      	movs	r0, #40	; 0x28
 8019698:	f7fa ff6c 	bl	8014574 <HLine>
		uint32_t acu_pos = (float)acue_sensitivity/250*400;
 801969c:	7823      	ldrb	r3, [r4, #0]
 801969e:	ed9f 7a63 	vldr	s14, [pc, #396]	; 801982c <DrawMenu+0x55c>
 80196a2:	ee07 3a90 	vmov	s15, r3
 80196a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80196aa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80196ae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80196b2:	ee17 4a90 	vmov	r4, s15
		if(acu_pos != 0) Rectangle(40, 122, acu_pos, 17, 0x00FFFFFF);
 80196b6:	2c00      	cmp	r4, #0
 80196b8:	f43f ae1a 	beq.w	80192f0 <DrawMenu+0x20>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196bc:	485c      	ldr	r0, [pc, #368]	; (8019830 <DrawMenu+0x560>)
 80196be:	2134      	movs	r1, #52	; 0x34
 80196c0:	4a5c      	ldr	r2, [pc, #368]	; (8019834 <DrawMenu+0x564>)
 80196c2:	b2a4      	uxth	r4, r4
 80196c4:	7803      	ldrb	r3, [r0, #0]
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 80196c6:	4e5c      	ldr	r6, [pc, #368]	; (8019838 <DrawMenu+0x568>)
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196c8:	fb01 2303 	mla	r3, r1, r3, r2
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80196cc:	4630      	mov	r0, r6
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196ce:	e9d3 7517 	ldrd	r7, r5, [r3, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 80196d2:	1b2b      	subs	r3, r5, r4
 80196d4:	60f3      	str	r3, [r6, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 80196d6:	f7e8 f99d 	bl	8001a14 <HAL_DMA2D_Init>
 80196da:	2800      	cmp	r0, #0
 80196dc:	f47f ae08 	bne.w	80192f0 <DrawMenu+0x20>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196e0:	227a      	movs	r2, #122	; 0x7a
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 80196e2:	2111      	movs	r1, #17
 80196e4:	4623      	mov	r3, r4
 80196e6:	4630      	mov	r0, r6
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196e8:	fb02 f505 	mul.w	r5, r2, r5
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 80196ec:	9100      	str	r1, [sp, #0]
 80196ee:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80196f2:	f105 0228 	add.w	r2, r5, #40	; 0x28
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 80196f6:	eb07 0242 	add.w	r2, r7, r2, lsl #1
 80196fa:	f7e8 f9e1 	bl	8001ac0 <HAL_DMA2D_Start>
 80196fe:	2800      	cmp	r0, #0
 8019700:	f47f adf6 	bne.w	80192f0 <DrawMenu+0x20>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8019704:	2164      	movs	r1, #100	; 0x64
 8019706:	4630      	mov	r0, r6
 8019708:	f7e8 fa50 	bl	8001bac <HAL_DMA2D_PollForTransfer>
}
 801970c:	e5f0      	b.n	80192f0 <DrawMenu+0x20>
		DrawString("ERROR! INSERT SD CARD or USB storage!", 0, 20, 0x00FFFFFF, 0x00FF0000);
 801970e:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8019712:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8019716:	2214      	movs	r2, #20
 8019718:	2100      	movs	r1, #0
 801971a:	9000      	str	r0, [sp, #0]
 801971c:	4847      	ldr	r0, [pc, #284]	; (801983c <DrawMenu+0x56c>)
 801971e:	f7ff fca5 	bl	801906c <DrawString>
		while (i<DebugLines){
 8019722:	4b47      	ldr	r3, [pc, #284]	; (8019840 <DrawMenu+0x570>)
 8019724:	781b      	ldrb	r3, [r3, #0]
 8019726:	2b00      	cmp	r3, #0
 8019728:	f43f ade2 	beq.w	80192f0 <DrawMenu+0x20>
 801972c:	4b45      	ldr	r3, [pc, #276]	; (8019844 <DrawMenu+0x574>)
		if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK)
 801972e:	f8df b100 	ldr.w	fp, [pc, #256]	; 8019830 <DrawMenu+0x560>
 8019732:	9306      	str	r3, [sp, #24]
		while (i<DebugLines){
 8019734:	2325      	movs	r3, #37	; 0x25
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 8019736:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 8019834 <DrawMenu+0x564>
		while (i<DebugLines){
 801973a:	9304      	str	r3, [sp, #16]
		uint32_t i=0;
 801973c:	2300      	movs	r3, #0
 801973e:	9307      	str	r3, [sp, #28]
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 8019740:	9b07      	ldr	r3, [sp, #28]
	hdma2d.Init.OutputOffset = Xpos;
 8019742:	250a      	movs	r5, #10
	hdma2d.Init.Mode = DMA2D_R2M;
 8019744:	4a3c      	ldr	r2, [pc, #240]	; (8019838 <DrawMenu+0x568>)
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 8019746:	3301      	adds	r3, #1
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8019748:	4610      	mov	r0, r2
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 801974a:	9307      	str	r3, [sp, #28]
	hdma2d.Init.Mode = DMA2D_R2M;
 801974c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8019750:	6053      	str	r3, [r2, #4]
	hdma2d.Init.OutputOffset = Xpos;
 8019752:	2302      	movs	r3, #2
 8019754:	e9c2 3502 	strd	r3, r5, [r2, #8]
	hdma2d.Instance = DMA2D;
 8019758:	4b3b      	ldr	r3, [pc, #236]	; (8019848 <DrawMenu+0x578>)
 801975a:	6013      	str	r3, [r2, #0]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 801975c:	f7e8 f95a 	bl	8001a14 <HAL_DMA2D_Init>
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 8019760:	9c06      	ldr	r4, [sp, #24]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK)
 8019762:	2800      	cmp	r0, #0
 8019764:	f000 811e 	beq.w	80199a4 <DrawMenu+0x6d4>
	while(str[l] != 0) {
 8019768:	9b06      	ldr	r3, [sp, #24]
 801976a:	781b      	ldrb	r3, [r3, #0]
 801976c:	2b00      	cmp	r3, #0
 801976e:	f000 8108 	beq.w	8019982 <DrawMenu+0x6b2>
	int xpos = Xpos + 5;
 8019772:	220f      	movs	r2, #15
 8019774:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 801984c <DrawMenu+0x57c>
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019778:	2534      	movs	r5, #52	; 0x34
 801977a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8019850 <DrawMenu+0x580>
	int xpos = Xpos + 5;
 801977e:	9203      	str	r2, [sp, #12]
 8019780:	e00c      	b.n	801979c <DrawMenu+0x4cc>
		if(str[l] > 191) {
 8019782:	2bbf      	cmp	r3, #191	; 0xbf
 8019784:	f200 8097 	bhi.w	80198b6 <DrawMenu+0x5e6>
		if(str[l] == 32) {
 8019788:	2b20      	cmp	r3, #32
 801978a:	d102      	bne.n	8019792 <DrawMenu+0x4c2>
			xpos += 5;
 801978c:	9b03      	ldr	r3, [sp, #12]
 801978e:	3305      	adds	r3, #5
 8019790:	9303      	str	r3, [sp, #12]
	while(str[l] != 0) {
 8019792:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8019796:	2b00      	cmp	r3, #0
 8019798:	f000 80f3 	beq.w	8019982 <DrawMenu+0x6b2>
		if((str[l] > 32) && (str[l] < 128)) {
 801979c:	f1a3 0021 	sub.w	r0, r3, #33	; 0x21
 80197a0:	b2c2      	uxtb	r2, r0
 80197a2:	2a5e      	cmp	r2, #94	; 0x5e
 80197a4:	d8ed      	bhi.n	8019782 <DrawMenu+0x4b2>
 80197a6:	9a03      	ldr	r2, [sp, #12]
 80197a8:	f04f 0c01 	mov.w	ip, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80197ac:	4619      	mov	r1, r3
 80197ae:	3a01      	subs	r2, #1
 80197b0:	9205      	str	r2, [sp, #20]
 80197b2:	e012      	b.n	80197da <DrawMenu+0x50a>
				if(font[(str[l]-33)*12+i] == 0) {
 80197b4:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80197b8:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80197bc:	f838 2016 	ldrh.w	r2, [r8, r6, lsl #1]
 80197c0:	b92a      	cbnz	r2, 80197ce <DrawMenu+0x4fe>
					if(font[(str[l]-33)*12+i+1] == 0) {
 80197c2:	3601      	adds	r6, #1
 80197c4:	f838 2016 	ldrh.w	r2, [r8, r6, lsl #1]
 80197c8:	2a00      	cmp	r2, #0
 80197ca:	f000 80e9 	beq.w	80199a0 <DrawMenu+0x6d0>
			while(i < 12);
 80197ce:	f10c 0c01 	add.w	ip, ip, #1
 80197d2:	f1bc 0f0d 	cmp.w	ip, #13
 80197d6:	f000 80cd 	beq.w	8019974 <DrawMenu+0x6a4>
				if(xpos < 470) {
 80197da:	9b03      	ldr	r3, [sp, #12]
 80197dc:	f10c 36ff 	add.w	r6, ip, #4294967295
 80197e0:	f5b3 7feb 	cmp.w	r3, #470	; 0x1d6
 80197e4:	dae6      	bge.n	80197b4 <DrawMenu+0x4e4>
 80197e6:	9b05      	ldr	r3, [sp, #20]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80197e8:	2200      	movs	r2, #0
 80197ea:	f8bd 1010 	ldrh.w	r1, [sp, #16]
 80197ee:	eb03 0e0c 	add.w	lr, r3, ip
 80197f2:	e042      	b.n	801987a <DrawMenu+0x5aa>
 80197f4:	08025968 	.word	0x08025968
 80197f8:	2000005c 	.word	0x2000005c
 80197fc:	08025988 	.word	0x08025988
 8019800:	08025974 	.word	0x08025974
 8019804:	0802597c 	.word	0x0802597c
 8019808:	00202020 	.word	0x00202020
 801980c:	20000070 	.word	0x20000070
 8019810:	461c4000 	.word	0x461c4000
 8019814:	0802598c 	.word	0x0802598c
 8019818:	00404040 	.word	0x00404040
 801981c:	20000054 	.word	0x20000054
 8019820:	3ecccccd 	.word	0x3ecccccd
 8019824:	080259a0 	.word	0x080259a0
 8019828:	00606060 	.word	0x00606060
 801982c:	3fcccccd 	.word	0x3fcccccd
 8019830:	20000e2c 	.word	0x20000e2c
 8019834:	20000d84 	.word	0x20000d84
 8019838:	20000c94 	.word	0x20000c94
 801983c:	080259b8 	.word	0x080259b8
 8019840:	200007ac 	.word	0x200007ac
 8019844:	200007b0 	.word	0x200007b0
 8019848:	4002b000 	.word	0x4002b000
 801984c:	08025abc 	.word	0x08025abc
 8019850:	08026650 	.word	0x08026650
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019854:	f89b 3000 	ldrb.w	r3, [fp]
					while(k < 13) {
 8019858:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801985a:	fb05 a303 	mla	r3, r5, r3, sl
					while(k < 13) {
 801985e:	2a0d      	cmp	r2, #13
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019860:	e9d3 7017 	ldrd	r7, r0, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019864:	fb00 e301 	mla	r3, r0, r1, lr
 8019868:	f04f 30ff 	mov.w	r0, #4294967295
					while(k < 13) {
 801986c:	f101 31ff 	add.w	r1, r1, #4294967295
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019870:	f827 0013 	strh.w	r0, [r7, r3, lsl #1]
					while(k < 13) {
 8019874:	d01a      	beq.n	80198ac <DrawMenu+0x5dc>
						if(((font[(str[l]-33)*12+i] >> k) & 1) == 1) {
 8019876:	7820      	ldrb	r0, [r4, #0]
 8019878:	3821      	subs	r0, #33	; 0x21
 801987a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801987e:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8019882:	f838 3010 	ldrh.w	r3, [r8, r0, lsl #1]
 8019886:	4113      	asrs	r3, r2
 8019888:	f013 0301 	ands.w	r3, r3, #1
 801988c:	d1e2      	bne.n	8019854 <DrawMenu+0x584>
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801988e:	f89b 0000 	ldrb.w	r0, [fp]
					while(k < 13) {
 8019892:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019894:	fb05 a000 	mla	r0, r5, r0, sl
					while(k < 13) {
 8019898:	2a0d      	cmp	r2, #13
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801989a:	e9d0 0717 	ldrd	r0, r7, [r0, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 801989e:	fb07 e701 	mla	r7, r7, r1, lr
					while(k < 13) {
 80198a2:	f101 31ff 	add.w	r1, r1, #4294967295
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 80198a6:	f820 3017 	strh.w	r3, [r0, r7, lsl #1]
					while(k < 13) {
 80198aa:	d1e4      	bne.n	8019876 <DrawMenu+0x5a6>
				if(font[(str[l]-33)*12+i] == 0) {
 80198ac:	7823      	ldrb	r3, [r4, #0]
 80198ae:	4619      	mov	r1, r3
 80198b0:	f1a3 0021 	sub.w	r0, r3, #33	; 0x21
 80198b4:	e77e      	b.n	80197b4 <DrawMenu+0x4e4>
 80198b6:	9a03      	ldr	r2, [sp, #12]
 80198b8:	f04f 0c01 	mov.w	ip, #1
 80198bc:	f1a3 00c0 	sub.w	r0, r3, #192	; 0xc0
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80198c0:	4619      	mov	r1, r3
 80198c2:	3a01      	subs	r2, #1
 80198c4:	9205      	str	r2, [sp, #20]
 80198c6:	e010      	b.n	80198ea <DrawMenu+0x61a>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 80198c8:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80198cc:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80198d0:	f839 2016 	ldrh.w	r2, [r9, r6, lsl #1]
 80198d4:	b922      	cbnz	r2, 80198e0 <DrawMenu+0x610>
					if(ru_font[(str[l]-192)*12+i+1] == 0) {
 80198d6:	3601      	adds	r6, #1
 80198d8:	f839 2016 	ldrh.w	r2, [r9, r6, lsl #1]
 80198dc:	2a00      	cmp	r2, #0
 80198de:	d05d      	beq.n	801999c <DrawMenu+0x6cc>
			while(i < 12);
 80198e0:	f10c 0c01 	add.w	ip, ip, #1
 80198e4:	f1bc 0f0d 	cmp.w	ip, #13
 80198e8:	d03d      	beq.n	8019966 <DrawMenu+0x696>
				if(xpos < 470) {
 80198ea:	9b03      	ldr	r3, [sp, #12]
 80198ec:	f10c 36ff 	add.w	r6, ip, #4294967295
 80198f0:	f5b3 7feb 	cmp.w	r3, #470	; 0x1d6
 80198f4:	dae8      	bge.n	80198c8 <DrawMenu+0x5f8>
 80198f6:	9b05      	ldr	r3, [sp, #20]
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 80198f8:	2200      	movs	r2, #0
 80198fa:	f8bd 1010 	ldrh.w	r1, [sp, #16]
 80198fe:	eb03 0e0c 	add.w	lr, r3, ip
 8019902:	e012      	b.n	801992a <DrawMenu+0x65a>
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019904:	f89b 3000 	ldrb.w	r3, [fp]
					while(k < 13) {
 8019908:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 801990a:	fb05 a303 	mla	r3, r5, r3, sl
					while(k < 13) {
 801990e:	2a0d      	cmp	r2, #13
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 8019910:	e9d3 7017 	ldrd	r7, r0, [r3, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019914:	fb00 e301 	mla	r3, r0, r1, lr
 8019918:	f04f 30ff 	mov.w	r0, #4294967295
					while(k < 13) {
 801991c:	f101 31ff 	add.w	r1, r1, #4294967295
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = color;
 8019920:	f827 0013 	strh.w	r0, [r7, r3, lsl #1]
					while(k < 13) {
 8019924:	d01a      	beq.n	801995c <DrawMenu+0x68c>
						if(((ru_font[(str[l]-192)*12+i] >> k) & 1) == 1) {
 8019926:	7820      	ldrb	r0, [r4, #0]
 8019928:	38c0      	subs	r0, #192	; 0xc0
 801992a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801992e:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8019932:	f839 3010 	ldrh.w	r3, [r9, r0, lsl #1]
 8019936:	4113      	asrs	r3, r2
 8019938:	f013 0301 	ands.w	r3, r3, #1
 801993c:	d1e2      	bne.n	8019904 <DrawMenu+0x634>
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801993e:	f89b 0000 	ldrb.w	r0, [fp]
					while(k < 13) {
 8019942:	3201      	adds	r2, #1
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019944:	fb05 a000 	mla	r0, r5, r0, sl
					while(k < 13) {
 8019948:	2a0d      	cmp	r2, #13
							*(__IO uint16_t*)(hltdc.LayerCfg[ActiveLayer].FBStartAdress + (2 * ((Ypos - k)
 801994a:	e9d0 0717 	ldrd	r0, r7, [r0, #92]	; 0x5c
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 801994e:	fb07 e701 	mla	r7, r7, r1, lr
					while(k < 13) {
 8019952:	f101 31ff 	add.w	r1, r1, #4294967295
									* hltdc.LayerCfg[ActiveLayer].ImageWidth + xpos + i))) = Color_Convertion(fontcolor);
 8019956:	f820 3017 	strh.w	r3, [r0, r7, lsl #1]
					while(k < 13) {
 801995a:	d1e4      	bne.n	8019926 <DrawMenu+0x656>
				if(ru_font[(str[l]-192)*12+i] == 0) {
 801995c:	7823      	ldrb	r3, [r4, #0]
 801995e:	4619      	mov	r1, r3
 8019960:	f1a3 00c0 	sub.w	r0, r3, #192	; 0xc0
 8019964:	e7b0      	b.n	80198c8 <DrawMenu+0x5f8>
 8019966:	460b      	mov	r3, r1
 8019968:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 801996c:	9a03      	ldr	r2, [sp, #12]
 801996e:	4462      	add	r2, ip
 8019970:	9203      	str	r2, [sp, #12]
 8019972:	e709      	b.n	8019788 <DrawMenu+0x4b8>
 8019974:	460b      	mov	r3, r1
 8019976:	f04f 0c0c 	mov.w	ip, #12
			xpos += i;
 801997a:	9a03      	ldr	r2, [sp, #12]
 801997c:	4462      	add	r2, ip
 801997e:	9203      	str	r2, [sp, #12]
 8019980:	e6ff      	b.n	8019782 <DrawMenu+0x4b2>
		while (i<DebugLines){
 8019982:	9b06      	ldr	r3, [sp, #24]
 8019984:	9a07      	ldr	r2, [sp, #28]
 8019986:	3350      	adds	r3, #80	; 0x50
 8019988:	9306      	str	r3, [sp, #24]
 801998a:	9b04      	ldr	r3, [sp, #16]
 801998c:	3314      	adds	r3, #20
 801998e:	9304      	str	r3, [sp, #16]
 8019990:	4b43      	ldr	r3, [pc, #268]	; (8019aa0 <DrawMenu+0x7d0>)
 8019992:	781b      	ldrb	r3, [r3, #0]
 8019994:	429a      	cmp	r2, r3
 8019996:	f4ff aed3 	bcc.w	8019740 <DrawMenu+0x470>
 801999a:	e4a9      	b.n	80192f0 <DrawMenu+0x20>
						i++;
 801999c:	460b      	mov	r3, r1
						break;
 801999e:	e7e5      	b.n	801996c <DrawMenu+0x69c>
						i++;
 80199a0:	460b      	mov	r3, r1
						break;
 80199a2:	e7ea      	b.n	801997a <DrawMenu+0x6aa>
		if(HAL_DMA2D_ConfigLayer(&hdma2d, ActiveLayer) == HAL_OK)
 80199a4:	f89b 1000 	ldrb.w	r1, [fp]
 80199a8:	483e      	ldr	r0, [pc, #248]	; (8019aa4 <DrawMenu+0x7d4>)
 80199aa:	f7e8 f995 	bl	8001cd8 <HAL_DMA2D_ConfigLayer>
 80199ae:	2800      	cmp	r0, #0
 80199b0:	f47f aeda 	bne.w	8019768 <DrawMenu+0x498>
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 80199b4:	9b04      	ldr	r3, [sp, #16]
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 80199b6:	4601      	mov	r1, r0
 80199b8:	f89b 2000 	ldrb.w	r2, [fp]
 80199bc:	2034      	movs	r0, #52	; 0x34
			DrawString(DebugText[i], 10, 21+20*(i+1), 0x00FFFFFF, backcolor); ///
 80199be:	3304      	adds	r3, #4
			if (HAL_DMA2D_Start(&hdma2d, fontcolor, hltdc.LayerCfg[ActiveLayer].FBStartAdress + 2*(480*(Ypos-20)+Xpos),
 80199c0:	fb00 a202 	mla	r2, r0, r2, sl
 80199c4:	4837      	ldr	r0, [pc, #220]	; (8019aa4 <DrawMenu+0x7d4>)
 80199c6:	b29b      	uxth	r3, r3
 80199c8:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 80199ca:	3b14      	subs	r3, #20
 80199cc:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 80199d0:	019b      	lsls	r3, r3, #6
 80199d2:	3314      	adds	r3, #20
 80199d4:	441a      	add	r2, r3
 80199d6:	2314      	movs	r3, #20
 80199d8:	9300      	str	r3, [sp, #0]
 80199da:	f44f 73eb 	mov.w	r3, #470	; 0x1d6
 80199de:	f7e8 f86f 	bl	8001ac0 <HAL_DMA2D_Start>
 80199e2:	2800      	cmp	r0, #0
 80199e4:	f47f aec0 	bne.w	8019768 <DrawMenu+0x498>
				HAL_DMA2D_PollForTransfer(&hdma2d, 10);
 80199e8:	4629      	mov	r1, r5
 80199ea:	482e      	ldr	r0, [pc, #184]	; (8019aa4 <DrawMenu+0x7d4>)
 80199ec:	f7e8 f8de 	bl	8001bac <HAL_DMA2D_PollForTransfer>
 80199f0:	e6ba      	b.n	8019768 <DrawMenu+0x498>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 80199f2:	4a2d      	ldr	r2, [pc, #180]	; (8019aa8 <DrawMenu+0x7d8>)
 80199f4:	2134      	movs	r1, #52	; 0x34
 80199f6:	4b2d      	ldr	r3, [pc, #180]	; (8019aac <DrawMenu+0x7dc>)
 80199f8:	b2a4      	uxth	r4, r4
 80199fa:	7812      	ldrb	r2, [r2, #0]
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 80199fc:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8019aa4 <DrawMenu+0x7d4>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a00:	fb01 3302 	mla	r3, r1, r2, r3
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8019a04:	4640      	mov	r0, r8
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a06:	e9d3 9617 	ldrd	r9, r6, [r3, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8019a0a:	1b33      	subs	r3, r6, r4
 8019a0c:	f8c8 300c 	str.w	r3, [r8, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8019a10:	f7e8 f800 	bl	8001a14 <HAL_DMA2D_Init>
 8019a14:	2800      	cmp	r0, #0
 8019a16:	f47f ae05 	bne.w	8019624 <DrawMenu+0x354>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a1a:	2252      	movs	r2, #82	; 0x52
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a1c:	2111      	movs	r1, #17
 8019a1e:	4623      	mov	r3, r4
 8019a20:	4640      	mov	r0, r8
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a22:	fb02 f606 	mul.w	r6, r2, r6
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a26:	9100      	str	r1, [sp, #0]
 8019a28:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a2c:	f106 0228 	add.w	r2, r6, #40	; 0x28
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a30:	eb09 0242 	add.w	r2, r9, r2, lsl #1
 8019a34:	f7e8 f844 	bl	8001ac0 <HAL_DMA2D_Start>
 8019a38:	2800      	cmp	r0, #0
 8019a3a:	f47f adf3 	bne.w	8019624 <DrawMenu+0x354>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8019a3e:	2164      	movs	r1, #100	; 0x64
 8019a40:	4640      	mov	r0, r8
 8019a42:	f7e8 f8b3 	bl	8001bac <HAL_DMA2D_PollForTransfer>
}
 8019a46:	e5ed      	b.n	8019624 <DrawMenu+0x354>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a48:	4917      	ldr	r1, [pc, #92]	; (8019aa8 <DrawMenu+0x7d8>)
 8019a4a:	b2a4      	uxth	r4, r4
 8019a4c:	4a17      	ldr	r2, [pc, #92]	; (8019aac <DrawMenu+0x7dc>)
 8019a4e:	780b      	ldrb	r3, [r1, #0]
 8019a50:	2134      	movs	r1, #52	; 0x34
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8019a52:	f8df 8050 	ldr.w	r8, [pc, #80]	; 8019aa4 <DrawMenu+0x7d4>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a56:	fb01 2303 	mla	r3, r1, r3, r2
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8019a5a:	4640      	mov	r0, r8
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a5c:	e9d3 9617 	ldrd	r9, r6, [r3, #92]	; 0x5c
	hdma2d.Init.OutputOffset = hltdc.LayerCfg[ActiveLayer].ImageWidth - Xsize;
 8019a60:	1b33      	subs	r3, r6, r4
 8019a62:	f8c8 300c 	str.w	r3, [r8, #12]
	if(HAL_DMA2D_Init(&hdma2d) == HAL_OK) {
 8019a66:	f7e7 ffd5 	bl	8001a14 <HAL_DMA2D_Init>
 8019a6a:	2800      	cmp	r0, #0
 8019a6c:	f47f ad9c 	bne.w	80195a8 <DrawMenu+0x2d8>
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a70:	222a      	movs	r2, #42	; 0x2a
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a72:	2111      	movs	r1, #17
 8019a74:	4623      	mov	r3, r4
 8019a76:	4640      	mov	r0, r8
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a78:	fb02 f606 	mul.w	r6, r2, r6
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a7c:	9100      	str	r1, [sp, #0]
 8019a7e:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
	uint32_t xpos = hltdc.LayerCfg[ActiveLayer].FBStartAdress+2*(hltdc.LayerCfg[ActiveLayer].ImageWidth*Ypos+Xpos);
 8019a82:	f106 0228 	add.w	r2, r6, #40	; 0x28
		if (HAL_DMA2D_Start(&hdma2d, color, xpos, Xsize, Ysize) == HAL_OK) {
 8019a86:	eb09 0242 	add.w	r2, r9, r2, lsl #1
 8019a8a:	f7e8 f819 	bl	8001ac0 <HAL_DMA2D_Start>
 8019a8e:	2800      	cmp	r0, #0
 8019a90:	f47f ad8a 	bne.w	80195a8 <DrawMenu+0x2d8>
			HAL_DMA2D_PollForTransfer(&hdma2d, 100);
 8019a94:	2164      	movs	r1, #100	; 0x64
 8019a96:	4640      	mov	r0, r8
 8019a98:	f7e8 f888 	bl	8001bac <HAL_DMA2D_PollForTransfer>
}
 8019a9c:	e584      	b.n	80195a8 <DrawMenu+0x2d8>
 8019a9e:	bf00      	nop
 8019aa0:	200007ac 	.word	0x200007ac
 8019aa4:	20000c94 	.word	0x20000c94
 8019aa8:	20000e2c 	.word	0x20000e2c
 8019aac:	20000d84 	.word	0x20000d84

08019ab0 <dbgAddText>:
{
 8019ab0:	b538      	push	{r3, r4, r5, lr}
	if (DebugLines < MAXDEBUG){
 8019ab2:	4d0b      	ldr	r5, [pc, #44]	; (8019ae0 <dbgAddText+0x30>)
 8019ab4:	782c      	ldrb	r4, [r5, #0]
 8019ab6:	2c0e      	cmp	r4, #14
 8019ab8:	d903      	bls.n	8019ac2 <dbgAddText+0x12>
}
 8019aba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	DrawMenu();
 8019abe:	f7ff bc07 	b.w	80192d0 <DrawMenu>
		strcpy(DebugText[DebugLines],text+'\0');
 8019ac2:	4b08      	ldr	r3, [pc, #32]	; (8019ae4 <dbgAddText+0x34>)
 8019ac4:	eb04 0284 	add.w	r2, r4, r4, lsl #2
		DebugLines++;
 8019ac8:	3401      	adds	r4, #1
		strcpy(DebugText[DebugLines],text+'\0');
 8019aca:	4601      	mov	r1, r0
 8019acc:	eb03 1002 	add.w	r0, r3, r2, lsl #4
 8019ad0:	f006 fc6f 	bl	80203b2 <strcpy>
		DebugLines++;
 8019ad4:	702c      	strb	r4, [r5, #0]
}
 8019ad6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	DrawMenu();
 8019ada:	f7ff bbf9 	b.w	80192d0 <DrawMenu>
 8019ade:	bf00      	nop
 8019ae0:	200007ac 	.word	0x200007ac
 8019ae4:	200007b0 	.word	0x200007b0

08019ae8 <QuantizePosition>:

// snaps file position on the spectra to the nearest beat
uint32_t QuantizePosition(int beat_offset) {
	uint32_t quantized_pos = file_pos_wide;
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019ae8:	4a1c      	ldr	r2, [pc, #112]	; (8019b5c <QuantizePosition+0x74>)
 8019aea:	f04f 0c96 	mov.w	ip, #150	; 0x96
	uint32_t quantized_pos = file_pos_wide;
 8019aee:	4b1c      	ldr	r3, [pc, #112]	; (8019b60 <QuantizePosition+0x78>)
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019af0:	6812      	ldr	r2, [r2, #0]
uint32_t QuantizePosition(int beat_offset) {
 8019af2:	b570      	push	{r4, r5, r6, lr}
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019af4:	f202 51f1 	addw	r1, r2, #1521	; 0x5f1
	uint32_t quantized_pos = file_pos_wide;
 8019af8:	681e      	ldr	r6, [r3, #0]
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019afa:	4d1a      	ldr	r5, [pc, #104]	; (8019b64 <QuantizePosition+0x7c>)
 8019afc:	f502 63be 	add.w	r3, r2, #1520	; 0x5f0
 8019b00:	4c19      	ldr	r4, [pc, #100]	; (8019b68 <QuantizePosition+0x80>)
 8019b02:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019b06:	eb05 0181 	add.w	r1, r5, r1, lsl #2
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019b0a:	685b      	ldr	r3, [r3, #4]
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019b0c:	6849      	ldr	r1, [r1, #4]
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019b0e:	fb0c f303 	mul.w	r3, ip, r3
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019b12:	fb0c f101 	mul.w	r1, ip, r1
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019b16:	fba4 e303 	umull	lr, r3, r4, r3
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019b1a:	fba4 e101 	umull	lr, r1, r4, r1
	int32_t time1 = file_pos_wide - rekordbox.timeindex[beat]*150/1000;
 8019b1e:	eba6 1393 	sub.w	r3, r6, r3, lsr #6
	int32_t time2 = rekordbox.timeindex[beat+1]*150/1000 - file_pos_wide;
 8019b22:	ebc6 1191 	rsb	r1, r6, r1, lsr #6
	if(time1 > time2) {
 8019b26:	428b      	cmp	r3, r1
 8019b28:	dd0b      	ble.n	8019b42 <QuantizePosition+0x5a>
		quantized_pos = rekordbox.timeindex[beat+beat_offset+1]*150/1000;							;
 8019b2a:	4410      	add	r0, r2
 8019b2c:	f200 50f1 	addw	r0, r0, #1521	; 0x5f1
 8019b30:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 8019b34:	6868      	ldr	r0, [r5, #4]
 8019b36:	fb0c f000 	mul.w	r0, ip, r0
 8019b3a:	fba4 3000 	umull	r3, r0, r4, r0
 8019b3e:	0980      	lsrs	r0, r0, #6
	}
	else {
		quantized_pos = rekordbox.timeindex[beat+beat_offset]*150/1000;
	}
	return quantized_pos;
}
 8019b40:	bd70      	pop	{r4, r5, r6, pc}
		quantized_pos = rekordbox.timeindex[beat+beat_offset]*150/1000;
 8019b42:	4402      	add	r2, r0
 8019b44:	f502 62be 	add.w	r2, r2, #1520	; 0x5f0
 8019b48:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 8019b4c:	6850      	ldr	r0, [r2, #4]
 8019b4e:	fb0c f000 	mul.w	r0, ip, r0
 8019b52:	fba4 3000 	umull	r3, r0, r4, r0
 8019b56:	0980      	lsrs	r0, r0, #6
}
 8019b58:	bd70      	pop	{r4, r5, r6, pc}
 8019b5a:	bf00      	nop
 8019b5c:	20000c64 	.word	0x20000c64
 8019b60:	2000ec8c 	.word	0x2000ec8c
 8019b64:	200154f0 	.word	0x200154f0
 8019b68:	10624dd3 	.word	0x10624dd3

08019b6c <MX_DMA_Init>:
  */
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8019b6c:	4b0b      	ldr	r3, [pc, #44]	; (8019b9c <MX_DMA_Init+0x30>)

  /* DMA interrupt init */
  /* DMA2_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 0, 0);
 8019b6e:	2200      	movs	r2, #0
 8019b70:	203c      	movs	r0, #60	; 0x3c
 8019b72:	4611      	mov	r1, r2
{
 8019b74:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
 8019b76:	6b1c      	ldr	r4, [r3, #48]	; 0x30
{
 8019b78:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
 8019b7a:	f444 0480 	orr.w	r4, r4, #4194304	; 0x400000
 8019b7e:	631c      	str	r4, [r3, #48]	; 0x30
 8019b80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019b82:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8019b86:	9301      	str	r3, [sp, #4]
 8019b88:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 0, 0);
 8019b8a:	f7e7 faa7 	bl	80010dc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 8019b8e:	203c      	movs	r0, #60	; 0x3c

}
 8019b90:	b002      	add	sp, #8
 8019b92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 8019b96:	f7e7 baeb 	b.w	8001170 <HAL_NVIC_EnableIRQ>
 8019b9a:	bf00      	nop
 8019b9c:	40023800 	.word	0x40023800

08019ba0 <MX_DMA2D_Init>:

DMA2D_HandleTypeDef hdma2d;

/* DMA2D init function */
void MX_DMA2D_Init(void)
{
 8019ba0:	b510      	push	{r4, lr}
  /* USER CODE END DMA2D_Init 0 */

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
 8019ba2:	4808      	ldr	r0, [pc, #32]	; (8019bc4 <MX_DMA2D_Init+0x24>)
  hdma2d.Init.Mode = DMA2D_R2M;
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
  hdma2d.Init.OutputOffset = 0;
 8019ba4:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8019ba8:	4907      	ldr	r1, [pc, #28]	; (8019bc8 <MX_DMA2D_Init+0x28>)
 8019baa:	2302      	movs	r3, #2
 8019bac:	2400      	movs	r4, #0
 8019bae:	e880 001e 	stmia.w	r0, {r1, r2, r3, r4}
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 8019bb2:	f7e7 ff2f 	bl	8001a14 <HAL_DMA2D_Init>
 8019bb6:	b900      	cbnz	r0, 8019bba <MX_DMA2D_Init+0x1a>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
 8019bb8:	bd10      	pop	{r4, pc}
 8019bba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 8019bbe:	f001 b96f 	b.w	801aea0 <Error_Handler>
 8019bc2:	bf00      	nop
 8019bc4:	20000c94 	.word	0x20000c94
 8019bc8:	4002b000 	.word	0x4002b000

08019bcc <HAL_DMA2D_MspInit>:

void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* dma2dHandle)
{

  if(dma2dHandle->Instance==DMA2D)
 8019bcc:	4b0d      	ldr	r3, [pc, #52]	; (8019c04 <HAL_DMA2D_MspInit+0x38>)
 8019bce:	6802      	ldr	r2, [r0, #0]
 8019bd0:	429a      	cmp	r2, r3
 8019bd2:	d000      	beq.n	8019bd6 <HAL_DMA2D_MspInit+0xa>
 8019bd4:	4770      	bx	lr
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */
	__HAL_DMA2D_ENABLE_IT(&hdma2d, DMA2D_IT_TC);
 8019bd6:	4a0c      	ldr	r2, [pc, #48]	; (8019c08 <HAL_DMA2D_MspInit+0x3c>)
	__HAL_DMA2D_CLEAR_FLAG(&hdma2d, DMA2D_IT_TC);
 8019bd8:	f44f 7000 	mov.w	r0, #512	; 0x200
  /* USER CODE END DMA2D_MspInit 0 */
    /* DMA2D clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8019bdc:	f5a3 43f0 	sub.w	r3, r3, #30720	; 0x7800
{
 8019be0:	b082      	sub	sp, #8
	__HAL_DMA2D_ENABLE_IT(&hdma2d, DMA2D_IT_TC);
 8019be2:	6812      	ldr	r2, [r2, #0]
 8019be4:	6811      	ldr	r1, [r2, #0]
 8019be6:	4301      	orrs	r1, r0
 8019be8:	6011      	str	r1, [r2, #0]
	__HAL_DMA2D_CLEAR_FLAG(&hdma2d, DMA2D_IT_TC);
 8019bea:	6090      	str	r0, [r2, #8]
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8019bec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8019bee:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8019bf2:	631a      	str	r2, [r3, #48]	; 0x30
 8019bf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019bf6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8019bfa:	9301      	str	r3, [sp, #4]
 8019bfc:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }
}
 8019bfe:	b002      	add	sp, #8
 8019c00:	4770      	bx	lr
 8019c02:	bf00      	nop
 8019c04:	4002b000 	.word	0x4002b000
 8019c08:	20000c94 	.word	0x20000c94

08019c0c <MX_FATFS_Init>:
#include "ff.h"

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 8019c0c:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  //retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
  /*## FatFS: Link the USBH driver ###########################*/
  retUSBH = FATFS_LinkDriver(&USBH_Driver, USBHPath);
 8019c0e:	4903      	ldr	r1, [pc, #12]	; (8019c1c <MX_FATFS_Init+0x10>)
 8019c10:	4803      	ldr	r0, [pc, #12]	; (8019c20 <MX_FATFS_Init+0x14>)
 8019c12:	f7f2 fe93 	bl	800c93c <FATFS_LinkDriver>
 8019c16:	4b03      	ldr	r3, [pc, #12]	; (8019c24 <MX_FATFS_Init+0x18>)
 8019c18:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
 8019c1a:	bd08      	pop	{r3, pc}
 8019c1c:	20000cd8 	.word	0x20000cd8
 8019c20:	08026f9c 	.word	0x08026f9c
 8019c24:	20000cdc 	.word	0x20000cdc

08019c28 <BSP_PlatformIsDetected>:
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8019c28:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8019c2c:	4803      	ldr	r0, [pc, #12]	; (8019c3c <BSP_PlatformIsDetected+0x14>)
uint8_t	BSP_PlatformIsDetected(void) {
 8019c2e:	b508      	push	{r3, lr}
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8019c30:	f7e8 fa78 	bl	8002124 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
    /* USER CODE END 1 */
    return status;
}
 8019c34:	fab0 f080 	clz	r0, r0
 8019c38:	0940      	lsrs	r0, r0, #5
 8019c3a:	bd08      	pop	{r3, pc}
 8019c3c:	40020800 	.word	0x40020800

08019c40 <SDRAM_Init>:
/* USER CODE BEGIN 0 */
FMC_SDRAM_CommandTypeDef command;
HAL_StatusTypeDef hal_stat;

void SDRAM_Init(void)
{
 8019c40:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
	__IO uint32_t tmpmrd = 0;
 8019c44:	2300      	movs	r3, #0
{
 8019c46:	b082      	sub	sp, #8
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c48:	4c2c      	ldr	r4, [pc, #176]	; (8019cfc <SDRAM_Init+0xbc>)
 8019c4a:	2201      	movs	r2, #1
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
	command.AutoRefreshNumber = 1;
	command.ModeRegisterDefinition = 0;
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c4c:	4d2c      	ldr	r5, [pc, #176]	; (8019d00 <SDRAM_Init+0xc0>)
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c4e:	f04f 0801 	mov.w	r8, #1
	__IO uint32_t tmpmrd = 0;
 8019c52:	9301      	str	r3, [sp, #4]
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c54:	2310      	movs	r3, #16
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c56:	4e2b      	ldr	r6, [pc, #172]	; (8019d04 <SDRAM_Init+0xc4>)
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c58:	f04f 0900 	mov.w	r9, #0
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c5c:	4621      	mov	r1, r4
 8019c5e:	4628      	mov	r0, r5
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c60:	e9c4 2300 	strd	r2, r3, [r4]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c64:	f64f 72ff 	movw	r2, #65535	; 0xffff
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8019c68:	e9c4 8902 	strd	r8, r9, [r4, #8]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c6c:	f7ec f84a 	bl	8005d04 <HAL_SDRAM_SendCommand>
 8019c70:	7030      	strb	r0, [r6, #0]
	HAL_Delay(1);
 8019c72:	2001      	movs	r0, #1
 8019c74:	f7e7 fa02 	bl	800107c <HAL_Delay>

	command.CommandMode = FMC_SDRAM_CMD_PALL;
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
	command.AutoRefreshNumber = 1;
	command.ModeRegisterDefinition = 0;
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c78:	4621      	mov	r1, r4
 8019c7a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8019c7e:	4628      	mov	r0, r5
	command.CommandMode = FMC_SDRAM_CMD_PALL;
 8019c80:	e9c4 8902 	strd	r8, r9, [r4, #8]
 8019c84:	f04f 0802 	mov.w	r8, #2
 8019c88:	f04f 0910 	mov.w	r9, #16
 8019c8c:	e9c4 8900 	strd	r8, r9, [r4]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c90:	f7ec f838 	bl	8005d04 <HAL_SDRAM_SendCommand>
 8019c94:	4603      	mov	r3, r0
	HAL_Delay(1);
 8019c96:	2001      	movs	r0, #1
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019c98:	7033      	strb	r3, [r6, #0]
	HAL_Delay(1);
 8019c9a:	f7e7 f9ef 	bl	800107c <HAL_Delay>

	command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8019c9e:	2203      	movs	r2, #3
 8019ca0:	2310      	movs	r3, #16
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
	command.AutoRefreshNumber = 8;
	command.ModeRegisterDefinition = 0;
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019ca2:	4621      	mov	r1, r4
 8019ca4:	4628      	mov	r0, r5
	command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8019ca6:	e9c4 2300 	strd	r2, r3, [r4]
 8019caa:	2300      	movs	r3, #0
 8019cac:	2208      	movs	r2, #8
 8019cae:	e9c4 2302 	strd	r2, r3, [r4, #8]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cb2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8019cb6:	f7ec f825 	bl	8005d04 <HAL_SDRAM_SendCommand>
 8019cba:	4603      	mov	r3, r0
	HAL_Delay(1);
 8019cbc:	2001      	movs	r0, #1
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cbe:	7033      	strb	r3, [r6, #0]
	HAL_Delay(1);
 8019cc0:	f7e7 f9dc 	bl	800107c <HAL_Delay>

	tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 |
 8019cc4:	f44f 7308 	mov.w	r3, #544	; 0x220
		  SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL |
		  SDRAM_MODEREG_CAS_LATENCY_2 |
		  SDRAM_MODEREG_OPERATING_MODE_STANDARD |
		  SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
	command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 8019cc8:	2204      	movs	r2, #4
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
	command.AutoRefreshNumber = 1;
	command.ModeRegisterDefinition = tmpmrd;
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cca:	4621      	mov	r1, r4
 8019ccc:	4628      	mov	r0, r5
	tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 |
 8019cce:	9301      	str	r3, [sp, #4]
	command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 8019cd0:	2310      	movs	r3, #16
 8019cd2:	e9c4 2300 	strd	r2, r3, [r4]
	command.ModeRegisterDefinition = tmpmrd;
 8019cd6:	9a01      	ldr	r2, [sp, #4]
	command.AutoRefreshNumber = 1;
 8019cd8:	2301      	movs	r3, #1
	command.ModeRegisterDefinition = tmpmrd;
 8019cda:	60e2      	str	r2, [r4, #12]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cdc:	f64f 72ff 	movw	r2, #65535	; 0xffff
	command.AutoRefreshNumber = 1;
 8019ce0:	60a3      	str	r3, [r4, #8]
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019ce2:	f7ec f80f 	bl	8005d04 <HAL_SDRAM_SendCommand>
	HAL_SDRAM_ProgramRefreshRate(&hsdram1, REFRESH_COUNT);
 8019ce6:	f240 6103 	movw	r1, #1539	; 0x603
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cea:	4603      	mov	r3, r0
	HAL_SDRAM_ProgramRefreshRate(&hsdram1, REFRESH_COUNT);
 8019cec:	4628      	mov	r0, r5
	hal_stat = HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
 8019cee:	7033      	strb	r3, [r6, #0]
}
 8019cf0:	b002      	add	sp, #8
 8019cf2:	e8bd 4370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, lr}
	HAL_SDRAM_ProgramRefreshRate(&hsdram1, REFRESH_COUNT);
 8019cf6:	f7ec b81d 	b.w	8005d34 <HAL_SDRAM_ProgramRefreshRate>
 8019cfa:	bf00      	nop
 8019cfc:	20000ce8 	.word	0x20000ce8
 8019d00:	20000cfc 	.word	0x20000cfc
 8019d04:	20000cf8 	.word	0x20000cf8

08019d08 <MX_FMC_Init>:

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8019d08:	4817      	ldr	r0, [pc, #92]	; (8019d68 <MX_FMC_Init+0x60>)
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8019d0a:	2300      	movs	r3, #0
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
 8019d0c:	2204      	movs	r2, #4
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8019d0e:	4917      	ldr	r1, [pc, #92]	; (8019d6c <MX_FMC_Init+0x64>)
{
 8019d10:	b510      	push	{r4, lr}
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8019d12:	2410      	movs	r4, #16
{
 8019d14:	b088      	sub	sp, #32
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_2;
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8019d16:	6283      	str	r3, [r0, #40]	; 0x28
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
 8019d18:	e9c0 3202 	strd	r3, r2, [r0, #8]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 8019d1c:	f44f 6200 	mov.w	r2, #2048	; 0x800
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8019d20:	e9c0 1300 	strd	r1, r3, [r0]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_2;
 8019d24:	e9c0 4304 	strd	r4, r3, [r0, #16]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 8019d28:	e9c0 3207 	strd	r3, r2, [r0, #28]
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
 8019d2c:	2202      	movs	r2, #2
 8019d2e:	2306      	movs	r3, #6
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8019d30:	f44f 7180 	mov.w	r1, #256	; 0x100
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8019d34:	f44f 5480 	mov.w	r4, #4096	; 0x1000
  SdramTiming.LoadToActiveDelay = 2;
 8019d38:	e9cd 2300 	strd	r2, r3, [sp]
 8019d3c:	2204      	movs	r2, #4
 8019d3e:	2306      	movs	r3, #6
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8019d40:	6181      	str	r1, [r0, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;
 8019d42:	2102      	movs	r1, #2
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8019d44:	6244      	str	r4, [r0, #36]	; 0x24
  SdramTiming.RCDDelay = 2;
 8019d46:	9106      	str	r1, [sp, #24]

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8019d48:	4669      	mov	r1, sp
  SdramTiming.LoadToActiveDelay = 2;
 8019d4a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8019d4e:	2202      	movs	r2, #2
 8019d50:	2302      	movs	r3, #2
 8019d52:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8019d56:	f7eb ffb3 	bl	8005cc0 <HAL_SDRAM_Init>
 8019d5a:	b908      	cbnz	r0, 8019d60 <MX_FMC_Init+0x58>
  }

  /* USER CODE BEGIN FMC_Init 2 */

  /* USER CODE END FMC_Init 2 */
}
 8019d5c:	b008      	add	sp, #32
 8019d5e:	bd10      	pop	{r4, pc}
    Error_Handler( );
 8019d60:	f001 f89e 	bl	801aea0 <Error_Handler>
}
 8019d64:	b008      	add	sp, #32
 8019d66:	bd10      	pop	{r4, pc}
 8019d68:	20000cfc 	.word	0x20000cfc
 8019d6c:	a0000140 	.word	0xa0000140

08019d70 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
 8019d70:	4b2e      	ldr	r3, [pc, #184]	; (8019e2c <HAL_SDRAM_MspInit+0xbc>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8019d72:	2100      	movs	r1, #0
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 8019d74:	b5d0      	push	{r4, r6, r7, lr}
  if (FMC_Initialized) {
 8019d76:	681a      	ldr	r2, [r3, #0]
void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 8019d78:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8019d7a:	9104      	str	r1, [sp, #16]
  if (FMC_Initialized) {
 8019d7c:	2a00      	cmp	r2, #0
 8019d7e:	d152      	bne.n	8019e26 <HAL_SDRAM_MspInit+0xb6>
  __HAL_RCC_FMC_CLK_ENABLE();
 8019d80:	4a2b      	ldr	r2, [pc, #172]	; (8019e30 <HAL_SDRAM_MspInit+0xc0>)
  FMC_Initialized = 1;
 8019d82:	2101      	movs	r1, #1
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_0|GPIO_PIN_8|GPIO_PIN_9
 8019d84:	f64f 7083 	movw	r0, #65411	; 0xff83
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019d88:	240c      	movs	r4, #12
  FMC_Initialized = 1;
 8019d8a:	6019      	str	r1, [r3, #0]
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_1|GPIO_PIN_0
 8019d8c:	2600      	movs	r6, #0
  __HAL_RCC_FMC_CLK_ENABLE();
 8019d8e:	6b93      	ldr	r3, [r2, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_1|GPIO_PIN_0
 8019d90:	2703      	movs	r7, #3
  __HAL_RCC_FMC_CLK_ENABLE();
 8019d92:	430b      	orrs	r3, r1
 8019d94:	6393      	str	r3, [r2, #56]	; 0x38
 8019d96:	6b93      	ldr	r3, [r2, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019d98:	9406      	str	r4, [sp, #24]
  __HAL_RCC_FMC_CLK_ENABLE();
 8019d9a:	400b      	ands	r3, r1
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_0|GPIO_PIN_8|GPIO_PIN_9
 8019d9c:	2102      	movs	r1, #2
  __HAL_RCC_FMC_CLK_ENABLE();
 8019d9e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8019da0:	2303      	movs	r3, #3
  __HAL_RCC_FMC_CLK_ENABLE();
 8019da2:	9a01      	ldr	r2, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8019da4:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_0|GPIO_PIN_8|GPIO_PIN_9
 8019da6:	e9cd 0102 	strd	r0, r1, [sp, #8]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8019daa:	a902      	add	r1, sp, #8
 8019dac:	4821      	ldr	r0, [pc, #132]	; (8019e34 <HAL_SDRAM_MspInit+0xc4>)
 8019dae:	f7e8 f81d 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_1|GPIO_PIN_0
 8019db2:	f248 1213 	movw	r2, #33043	; 0x8113
 8019db6:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8019db8:	a902      	add	r1, sp, #8
 8019dba:	481f      	ldr	r0, [pc, #124]	; (8019e38 <HAL_SDRAM_MspInit+0xc8>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019dbc:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_1|GPIO_PIN_0
 8019dbe:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8019dc2:	e9cd 6704 	strd	r6, r7, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8019dc6:	f7e8 f811 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_10
 8019dca:	f24c 7203 	movw	r2, #50947	; 0xc703
 8019dce:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8019dd0:	a902      	add	r1, sp, #8
 8019dd2:	481a      	ldr	r0, [pc, #104]	; (8019e3c <HAL_SDRAM_MspInit+0xcc>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019dd4:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_10
 8019dd6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8019dda:	e9cd 6704 	strd	r6, r7, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8019dde:	f7e8 f805 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 8019de2:	f64f 023f 	movw	r2, #63551	; 0xf83f
 8019de6:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8019de8:	a902      	add	r1, sp, #8
 8019dea:	4815      	ldr	r0, [pc, #84]	; (8019e40 <HAL_SDRAM_MspInit+0xd0>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019dec:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 8019dee:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8019df2:	e9cd 6704 	strd	r6, r7, [sp, #16]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8019df6:	f7e7 fff9 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_3;
 8019dfa:	2228      	movs	r2, #40	; 0x28
 8019dfc:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8019dfe:	a902      	add	r1, sp, #8
 8019e00:	4810      	ldr	r0, [pc, #64]	; (8019e44 <HAL_SDRAM_MspInit+0xd4>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019e02:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_3;
 8019e04:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8019e08:	e9cd 6704 	strd	r6, r7, [sp, #16]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8019e0c:	f7e7 ffee 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8019e10:	2208      	movs	r2, #8
 8019e12:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8019e14:	a902      	add	r1, sp, #8
 8019e16:	480c      	ldr	r0, [pc, #48]	; (8019e48 <HAL_SDRAM_MspInit+0xd8>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8019e18:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8019e1a:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8019e1e:	e9cd 2302 	strd	r2, r3, [sp, #8]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8019e22:	f7e7 ffe3 	bl	8001dec <HAL_GPIO_Init>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 8019e26:	b008      	add	sp, #32
 8019e28:	bdd0      	pop	{r4, r6, r7, pc}
 8019e2a:	bf00      	nop
 8019e2c:	20000ce0 	.word	0x20000ce0
 8019e30:	40023800 	.word	0x40023800
 8019e34:	40021000 	.word	0x40021000
 8019e38:	40021800 	.word	0x40021800
 8019e3c:	40020c00 	.word	0x40020c00
 8019e40:	40021400 	.word	0x40021400
 8019e44:	40021c00 	.word	0x40021c00
 8019e48:	40020800 	.word	0x40020800

08019e4c <ft5336_Reset>:
  */
void ft5336_Reset(uint16_t DeviceAddr)
{
  /* Do nothing */
  /* No software reset sequence available in FT5336 IC */
}
 8019e4c:	4770      	bx	lr
 8019e4e:	bf00      	nop

08019e50 <ft5336_TS_ITStatus>:
  */
uint8_t ft5336_TS_ITStatus(uint16_t DeviceAddr)
{
  /* Always return 0 as feature not applicable to FT5336 */
  return 0;
}
 8019e50:	2000      	movs	r0, #0
 8019e52:	4770      	bx	lr

08019e54 <ft5336_Init>:
{
 8019e54:	b510      	push	{r4, lr}
  * @param  None.
  * @retval : I2C initialization status.
  */
static uint8_t ft5336_Get_I2C_InitializedStatus(void)
{
  return(ft5336_handle.i2cInitialized);
 8019e56:	4c06      	ldr	r4, [pc, #24]	; (8019e70 <ft5336_Init+0x1c>)
  TS_IO_Delay(200);
 8019e58:	20c8      	movs	r0, #200	; 0xc8
 8019e5a:	f003 facf 	bl	801d3fc <TS_IO_Delay>
  * @param  None.
  * @retval : None.
  */
static void ft5336_I2C_InitializeIfRequired(void)
{
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 8019e5e:	7823      	ldrb	r3, [r4, #0]
 8019e60:	b103      	cbz	r3, 8019e64 <ft5336_Init+0x10>
}
 8019e62:	bd10      	pop	{r4, pc}
  {
    /* Initialize TS IO BUS layer (I2C) */
    TS_IO_Init();
 8019e64:	f003 fa94 	bl	801d390 <TS_IO_Init>

    /* Set state to initialized */
    ft5336_handle.i2cInitialized = FT5336_I2C_INITIALIZED;
 8019e68:	2301      	movs	r3, #1
 8019e6a:	7023      	strb	r3, [r4, #0]
}
 8019e6c:	bd10      	pop	{r4, pc}
 8019e6e:	bf00      	nop
 8019e70:	20000d34 	.word	0x20000d34

08019e74 <ft5336_ReadID>:
{
 8019e74:	b530      	push	{r4, r5, lr}
  return(ft5336_handle.i2cInitialized);
 8019e76:	4c11      	ldr	r4, [pc, #68]	; (8019ebc <ft5336_ReadID+0x48>)
{
 8019e78:	b083      	sub	sp, #12
  volatile uint8_t ucReadId = 0;
 8019e7a:	2200      	movs	r2, #0
{
 8019e7c:	4605      	mov	r5, r0
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 8019e7e:	7823      	ldrb	r3, [r4, #0]
  volatile uint8_t ucReadId = 0;
 8019e80:	f88d 2007 	strb.w	r2, [sp, #7]
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 8019e84:	b1a3      	cbz	r3, 8019eb0 <ft5336_ReadID+0x3c>
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 8019e86:	b2ed      	uxtb	r5, r5
 8019e88:	2400      	movs	r4, #0
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8019e8a:	3401      	adds	r4, #1
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 8019e8c:	21a8      	movs	r1, #168	; 0xa8
 8019e8e:	4628      	mov	r0, r5
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8019e90:	b2e4      	uxtb	r4, r4
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 8019e92:	f003 fa9b 	bl	801d3cc <TS_IO_Read>
 8019e96:	f88d 0007 	strb.w	r0, [sp, #7]
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8019e9a:	2c02      	cmp	r4, #2
    if(ucReadId == FT5336_ID_VALUE)
 8019e9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019ea0:	b2db      	uxtb	r3, r3
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8019ea2:	d801      	bhi.n	8019ea8 <ft5336_ReadID+0x34>
 8019ea4:	2b51      	cmp	r3, #81	; 0x51
 8019ea6:	d1f0      	bne.n	8019e8a <ft5336_ReadID+0x16>
  return (ucReadId);
 8019ea8:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8019eac:	b003      	add	sp, #12
 8019eae:	bd30      	pop	{r4, r5, pc}
    TS_IO_Init();
 8019eb0:	f003 fa6e 	bl	801d390 <TS_IO_Init>
    ft5336_handle.i2cInitialized = FT5336_I2C_INITIALIZED;
 8019eb4:	2301      	movs	r3, #1
 8019eb6:	7023      	strb	r3, [r4, #0]
 8019eb8:	e7e5      	b.n	8019e86 <ft5336_ReadID+0x12>
 8019eba:	bf00      	nop
 8019ebc:	20000d34 	.word	0x20000d34

08019ec0 <ft5336_TS_DetectTouch>:
{
 8019ec0:	b510      	push	{r4, lr}
  volatile uint8_t nbTouch = 0;
 8019ec2:	2400      	movs	r4, #0
{
 8019ec4:	b082      	sub	sp, #8
  nbTouch = TS_IO_Read(DeviceAddr, FT5336_TD_STAT_REG);
 8019ec6:	2102      	movs	r1, #2
 8019ec8:	b2c0      	uxtb	r0, r0
  volatile uint8_t nbTouch = 0;
 8019eca:	f88d 4007 	strb.w	r4, [sp, #7]
  nbTouch = TS_IO_Read(DeviceAddr, FT5336_TD_STAT_REG);
 8019ece:	f003 fa7d 	bl	801d3cc <TS_IO_Read>
 8019ed2:	f88d 0007 	strb.w	r0, [sp, #7]
  nbTouch &= FT5336_TD_STAT_MASK;
 8019ed6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019eda:	f003 030f 	and.w	r3, r3, #15
 8019ede:	f88d 3007 	strb.w	r3, [sp, #7]
  if(nbTouch > FT5336_MAX_DETECTABLE_TOUCH)
 8019ee2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019ee6:	2b05      	cmp	r3, #5
 8019ee8:	d901      	bls.n	8019eee <ft5336_TS_DetectTouch+0x2e>
    nbTouch = 0;
 8019eea:	f88d 4007 	strb.w	r4, [sp, #7]
  ft5336_handle.currActiveTouchNb = nbTouch;
 8019eee:	f89d 1007 	ldrb.w	r1, [sp, #7]
  ft5336_handle.currActiveTouchIdx = 0;
 8019ef2:	2200      	movs	r2, #0
  ft5336_handle.currActiveTouchNb = nbTouch;
 8019ef4:	4b03      	ldr	r3, [pc, #12]	; (8019f04 <ft5336_TS_DetectTouch+0x44>)
  return(nbTouch);
 8019ef6:	f89d 0007 	ldrb.w	r0, [sp, #7]
  ft5336_handle.currActiveTouchNb = nbTouch;
 8019efa:	7059      	strb	r1, [r3, #1]
  ft5336_handle.currActiveTouchIdx = 0;
 8019efc:	709a      	strb	r2, [r3, #2]
}
 8019efe:	b002      	add	sp, #8
 8019f00:	bd10      	pop	{r4, pc}
 8019f02:	bf00      	nop
 8019f04:	20000d34 	.word	0x20000d34

08019f08 <ft5336_TS_GetXY>:
{
 8019f08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8019f0c:	4d2d      	ldr	r5, [pc, #180]	; (8019fc4 <ft5336_TS_GetXY+0xbc>)
{
 8019f0e:	4616      	mov	r6, r2
 8019f10:	b083      	sub	sp, #12
  volatile uint8_t ucReadData = 0;
 8019f12:	f04f 0900 	mov.w	r9, #0
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8019f16:	78ab      	ldrb	r3, [r5, #2]
 8019f18:	786a      	ldrb	r2, [r5, #1]
  volatile uint8_t ucReadData = 0;
 8019f1a:	f88d 9007 	strb.w	r9, [sp, #7]
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8019f1e:	429a      	cmp	r2, r3
 8019f20:	d949      	bls.n	8019fb6 <ft5336_TS_GetXY+0xae>
 8019f22:	2b09      	cmp	r3, #9
 8019f24:	4688      	mov	r8, r1
    switch(ft5336_handle.currActiveTouchIdx)
 8019f26:	d849      	bhi.n	8019fbc <ft5336_TS_GetXY+0xb4>
 8019f28:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8019f2c:	005b      	lsls	r3, r3, #1
 8019f2e:	b2db      	uxtb	r3, r3
 8019f30:	1d19      	adds	r1, r3, #4
 8019f32:	f103 0a03 	add.w	sl, r3, #3
 8019f36:	f103 0b06 	add.w	fp, r3, #6
 8019f3a:	3305      	adds	r3, #5
 8019f3c:	b2c9      	uxtb	r1, r1
 8019f3e:	fa5f fa8a 	uxtb.w	sl, sl
 8019f42:	fa5f fb8b 	uxtb.w	fp, fp
 8019f46:	fa5f f983 	uxtb.w	r9, r3
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 8019f4a:	b2c4      	uxtb	r4, r0
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8019f4c:	4f1e      	ldr	r7, [pc, #120]	; (8019fc8 <ft5336_TS_GetXY+0xc0>)
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 8019f4e:	4620      	mov	r0, r4
 8019f50:	f003 fa3c 	bl	801d3cc <TS_IO_Read>
 8019f54:	f88d 0007 	strb.w	r0, [sp, #7]
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8019f58:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8019f5c:	4651      	mov	r1, sl
 8019f5e:	4620      	mov	r0, r4
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8019f60:	803b      	strh	r3, [r7, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8019f62:	f003 fa33 	bl	801d3cc <TS_IO_Read>
 8019f66:	f88d 0007 	strb.w	r0, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8019f6a:	4659      	mov	r1, fp
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8019f6c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8019f70:	4620      	mov	r0, r4
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8019f72:	883b      	ldrh	r3, [r7, #0]
 8019f74:	0212      	lsls	r2, r2, #8
 8019f76:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
 8019f7a:	431a      	orrs	r2, r3
    *X = coord;
 8019f7c:	f8a8 2000 	strh.w	r2, [r8]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8019f80:	803a      	strh	r2, [r7, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8019f82:	f003 fa23 	bl	801d3cc <TS_IO_Read>
 8019f86:	4603      	mov	r3, r0
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYHigh);
 8019f88:	4649      	mov	r1, r9
 8019f8a:	4620      	mov	r0, r4
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8019f8c:	f88d 3007 	strb.w	r3, [sp, #7]
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8019f90:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019f94:	803b      	strh	r3, [r7, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYHigh);
 8019f96:	f003 fa19 	bl	801d3cc <TS_IO_Read>
 8019f9a:	f88d 0007 	strb.w	r0, [sp, #7]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8019f9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019fa2:	883a      	ldrh	r2, [r7, #0]
 8019fa4:	021b      	lsls	r3, r3, #8
 8019fa6:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8019faa:	4313      	orrs	r3, r2
    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 8019fac:	78aa      	ldrb	r2, [r5, #2]
 8019fae:	3201      	adds	r2, #1
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8019fb0:	803b      	strh	r3, [r7, #0]
    *Y = coord;
 8019fb2:	8033      	strh	r3, [r6, #0]
    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 8019fb4:	70aa      	strb	r2, [r5, #2]
}
 8019fb6:	b003      	add	sp, #12
 8019fb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8019fbc:	46cb      	mov	fp, r9
 8019fbe:	46ca      	mov	sl, r9
 8019fc0:	4649      	mov	r1, r9
 8019fc2:	e7c2      	b.n	8019f4a <ft5336_TS_GetXY+0x42>
 8019fc4:	20000d34 	.word	0x20000d34
 8019fc8:	20000d30 	.word	0x20000d30

08019fcc <ft5336_TS_EnableIT>:
   TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 8019fcc:	2201      	movs	r2, #1
 8019fce:	21a4      	movs	r1, #164	; 0xa4
 8019fd0:	b2c0      	uxtb	r0, r0
 8019fd2:	f003 b9e3 	b.w	801d39c <TS_IO_Write>
 8019fd6:	bf00      	nop

08019fd8 <ft5336_TS_Start>:
  TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 8019fd8:	2200      	movs	r2, #0
 8019fda:	21a4      	movs	r1, #164	; 0xa4
 8019fdc:	b2c0      	uxtb	r0, r0
 8019fde:	f003 b9dd 	b.w	801d39c <TS_IO_Write>
 8019fe2:	bf00      	nop

08019fe4 <ft5336_TS_ClearIT>:
 8019fe4:	4770      	bx	lr
 8019fe6:	bf00      	nop

08019fe8 <ft5336_TS_DisableIT>:
 8019fe8:	2200      	movs	r2, #0
 8019fea:	21a4      	movs	r1, #164	; 0xa4
 8019fec:	b2c0      	uxtb	r0, r0
 8019fee:	f003 b9d5 	b.w	801d39c <TS_IO_Write>
 8019ff2:	bf00      	nop

08019ff4 <ft5336_TS_GetGestureID>:
{
 8019ff4:	b510      	push	{r4, lr}
  volatile uint8_t ucReadData = 0;
 8019ff6:	2300      	movs	r3, #0
{
 8019ff8:	b082      	sub	sp, #8
 8019ffa:	460c      	mov	r4, r1
  ucReadData = TS_IO_Read(DeviceAddr, FT5336_GEST_ID_REG);
 8019ffc:	b2c0      	uxtb	r0, r0
 8019ffe:	2101      	movs	r1, #1
  volatile uint8_t ucReadData = 0;
 801a000:	f88d 3007 	strb.w	r3, [sp, #7]
  ucReadData = TS_IO_Read(DeviceAddr, FT5336_GEST_ID_REG);
 801a004:	f003 f9e2 	bl	801d3cc <TS_IO_Read>
 801a008:	f88d 0007 	strb.w	r0, [sp, #7]
  * pGestureId = ucReadData;
 801a00c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a010:	6023      	str	r3, [r4, #0]
}
 801a012:	b002      	add	sp, #8
 801a014:	bd10      	pop	{r4, pc}
 801a016:	bf00      	nop

0801a018 <ft5336_TS_GetTouchInfo>:
{
 801a018:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a01c:	461c      	mov	r4, r3
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 801a01e:	4b22      	ldr	r3, [pc, #136]	; (801a0a8 <ft5336_TS_GetTouchInfo+0x90>)
{
 801a020:	b082      	sub	sp, #8
  volatile uint8_t ucReadData = 0;
 801a022:	f04f 0c00 	mov.w	ip, #0
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 801a026:	785b      	ldrb	r3, [r3, #1]
  volatile uint8_t ucReadData = 0;
 801a028:	f88d c007 	strb.w	ip, [sp, #7]
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 801a02c:	428b      	cmp	r3, r1
 801a02e:	d934      	bls.n	801a09a <ft5336_TS_GetTouchInfo+0x82>
 801a030:	2909      	cmp	r1, #9
 801a032:	4616      	mov	r6, r2
    switch(touchIdx)
 801a034:	d834      	bhi.n	801a0a0 <ft5336_TS_GetTouchInfo+0x88>
 801a036:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801a03a:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 801a03e:	fa5f fc8c 	uxtb.w	ip, ip
 801a042:	f10c 0103 	add.w	r1, ip, #3
 801a046:	f10c 0807 	add.w	r8, ip, #7
 801a04a:	f10c 0c08 	add.w	ip, ip, #8
 801a04e:	b2c9      	uxtb	r1, r1
 801a050:	fa5f f888 	uxtb.w	r8, r8
 801a054:	fa5f f58c 	uxtb.w	r5, ip
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 801a058:	b2c7      	uxtb	r7, r0
 801a05a:	4638      	mov	r0, r7
 801a05c:	f003 f9b6 	bl	801d3cc <TS_IO_Read>
 801a060:	f88d 0007 	strb.w	r0, [sp, #7]
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 801a064:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 801a068:	4641      	mov	r1, r8
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 801a06a:	9a08      	ldr	r2, [sp, #32]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 801a06c:	4638      	mov	r0, r7
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 801a06e:	099b      	lsrs	r3, r3, #6
 801a070:	6013      	str	r3, [r2, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 801a072:	f003 f9ab 	bl	801d3cc <TS_IO_Read>
 801a076:	4603      	mov	r3, r0
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPMisc);
 801a078:	4629      	mov	r1, r5
 801a07a:	4638      	mov	r0, r7
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 801a07c:	f88d 3007 	strb.w	r3, [sp, #7]
    * pWeight = (ucReadData & FT5336_TOUCH_WEIGHT_MASK) >> FT5336_TOUCH_WEIGHT_SHIFT;
 801a080:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a084:	6033      	str	r3, [r6, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPMisc);
 801a086:	f003 f9a1 	bl	801d3cc <TS_IO_Read>
 801a08a:	f88d 0007 	strb.w	r0, [sp, #7]
    * pArea = (ucReadData & FT5336_TOUCH_AREA_MASK) >> FT5336_TOUCH_AREA_SHIFT;
 801a08e:	f89d 2007 	ldrb.w	r2, [sp, #7]
 801a092:	0912      	lsrs	r2, r2, #4
 801a094:	f002 0204 	and.w	r2, r2, #4
 801a098:	6022      	str	r2, [r4, #0]
}
 801a09a:	b002      	add	sp, #8
 801a09c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 801a0a0:	4665      	mov	r5, ip
 801a0a2:	46e0      	mov	r8, ip
 801a0a4:	4661      	mov	r1, ip
 801a0a6:	e7d7      	b.n	801a058 <ft5336_TS_GetTouchInfo+0x40>
 801a0a8:	20000d34 	.word	0x20000d34

0801a0ac <MX_GPIO_Init>:
        * EXTI
        * Free pins are configured automatically as Analog (this feature is enabled through
        * the Code Generation settings)
*/
void MX_GPIO_Init(void)
{
 801a0ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 801a0b0:	4ba0      	ldr	r3, [pc, #640]	; (801a334 <MX_GPIO_Init+0x288>)
{
 801a0b2:	b092      	sub	sp, #72	; 0x48
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a0b4:	2400      	movs	r4, #0
  __HAL_RCC_GPIOK_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(FS_PowerSwitchOn_GPIO_Port, FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 801a0b6:	4ea0      	ldr	r6, [pc, #640]	; (801a338 <MX_GPIO_Init+0x28c>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
 801a0b8:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 801a364 <MX_GPIO_Init+0x2b8>
  HAL_GPIO_WritePin(FS_PowerSwitchOn_GPIO_Port, FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 801a0bc:	2120      	movs	r1, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a0be:	9410      	str	r4, [sp, #64]	; 0x40
  HAL_GPIO_WritePin(FS_PowerSwitchOn_GPIO_Port, FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 801a0c0:	4630      	mov	r0, r6

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);
 801a0c2:	4d9e      	ldr	r5, [pc, #632]	; (801a33c <MX_GPIO_Init+0x290>)
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SD_DETECT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 801a0c4:	2701      	movs	r7, #1
  HAL_GPIO_Init(SD_DETECT_GPIO_Port, &GPIO_InitStruct);
 801a0c6:	f8df a2a0 	ldr.w	sl, [pc, #672]	; 801a368 <MX_GPIO_Init+0x2bc>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
 801a0ca:	f04f 0902 	mov.w	r9, #2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a0ce:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
 801a0d2:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  __HAL_RCC_GPIOE_CLK_ENABLE();
 801a0d6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a0d8:	f042 0210 	orr.w	r2, r2, #16
 801a0dc:	631a      	str	r2, [r3, #48]	; 0x30
 801a0de:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a0e0:	f002 0210 	and.w	r2, r2, #16
 801a0e4:	9201      	str	r2, [sp, #4]
 801a0e6:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 801a0e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a0ea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801a0ee:	631a      	str	r2, [r3, #48]	; 0x30
 801a0f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a0f2:	f002 0240 	and.w	r2, r2, #64	; 0x40
 801a0f6:	9202      	str	r2, [sp, #8]
 801a0f8:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 801a0fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a0fc:	f042 0202 	orr.w	r2, r2, #2
 801a100:	631a      	str	r2, [r3, #48]	; 0x30
 801a102:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a104:	f002 0202 	and.w	r2, r2, #2
 801a108:	9203      	str	r2, [sp, #12]
 801a10a:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 801a10c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a10e:	f042 0208 	orr.w	r2, r2, #8
 801a112:	631a      	str	r2, [r3, #48]	; 0x30
 801a114:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a116:	f002 0208 	and.w	r2, r2, #8
 801a11a:	9204      	str	r2, [sp, #16]
 801a11c:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 801a11e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a120:	f042 0204 	orr.w	r2, r2, #4
 801a124:	631a      	str	r2, [r3, #48]	; 0x30
 801a126:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a128:	f002 0204 	and.w	r2, r2, #4
 801a12c:	9205      	str	r2, [sp, #20]
 801a12e:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 801a130:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a132:	f042 0201 	orr.w	r2, r2, #1
 801a136:	631a      	str	r2, [r3, #48]	; 0x30
 801a138:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a13a:	f002 0201 	and.w	r2, r2, #1
 801a13e:	9206      	str	r2, [sp, #24]
 801a140:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 801a142:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a144:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 801a148:	631a      	str	r2, [r3, #48]	; 0x30
 801a14a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a14c:	f402 7200 	and.w	r2, r2, #512	; 0x200
 801a150:	9207      	str	r2, [sp, #28]
 801a152:	9a07      	ldr	r2, [sp, #28]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 801a154:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a156:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 801a15a:	631a      	str	r2, [r3, #48]	; 0x30
 801a15c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a15e:	f402 7280 	and.w	r2, r2, #256	; 0x100
 801a162:	9208      	str	r2, [sp, #32]
 801a164:	9a08      	ldr	r2, [sp, #32]
  __HAL_RCC_GPIOK_CLK_ENABLE();
 801a166:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a168:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 801a16c:	631a      	str	r2, [r3, #48]	; 0x30
 801a16e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a170:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 801a174:	9209      	str	r2, [sp, #36]	; 0x24
 801a176:	9a09      	ldr	r2, [sp, #36]	; 0x24
  __HAL_RCC_GPIOF_CLK_ENABLE();
 801a178:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a17a:	f042 0220 	orr.w	r2, r2, #32
 801a17e:	631a      	str	r2, [r3, #48]	; 0x30
 801a180:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a182:	f002 0220 	and.w	r2, r2, #32
 801a186:	920a      	str	r2, [sp, #40]	; 0x28
 801a188:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  __HAL_RCC_GPIOH_CLK_ENABLE();
 801a18a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a18c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801a190:	631a      	str	r2, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(FS_PowerSwitchOn_GPIO_Port, FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 801a192:	4622      	mov	r2, r4
  __HAL_RCC_GPIOH_CLK_ENABLE();
 801a194:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a196:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801a19a:	930b      	str	r3, [sp, #44]	; 0x2c
 801a19c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  HAL_GPIO_WritePin(FS_PowerSwitchOn_GPIO_Port, FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 801a19e:	f7e7 ffd3 	bl	8002148 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
 801a1a2:	4640      	mov	r0, r8
 801a1a4:	2201      	movs	r2, #1
 801a1a6:	2108      	movs	r1, #8
 801a1a8:	f7e7 ffce 	bl	8002148 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);
 801a1ac:	4628      	mov	r0, r5
 801a1ae:	2201      	movs	r2, #1
 801a1b0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801a1b4:	f7e7 ffc8 	bl	8002148 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6;
 801a1b8:	226c      	movs	r2, #108	; 0x6c
 801a1ba:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801a1bc:	a90c      	add	r1, sp, #48	; 0x30
 801a1be:	4860      	ldr	r0, [pc, #384]	; (801a340 <MX_GPIO_Init+0x294>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a1c0:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6;
 801a1c2:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801a1c6:	f7e7 fe11 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_11|GPIO_PIN_10
 801a1ca:	f646 62ec 	movw	r2, #28396	; 0x6eec
 801a1ce:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801a1d0:	a90c      	add	r1, sp, #48	; 0x30
 801a1d2:	485c      	ldr	r0, [pc, #368]	; (801a344 <MX_GPIO_Init+0x298>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a1d4:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_11|GPIO_PIN_10
 801a1d6:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801a1da:	f7e7 fe07 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_4|GPIO_PIN_3|GPIO_PIN_9
 801a1de:	f44f 7277 	mov.w	r2, #988	; 0x3dc
 801a1e2:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801a1e4:	a90c      	add	r1, sp, #48	; 0x30
 801a1e6:	4858      	ldr	r0, [pc, #352]	; (801a348 <MX_GPIO_Init+0x29c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a1e8:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_4|GPIO_PIN_3|GPIO_PIN_9
 801a1ea:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801a1ee:	f7e7 fdfd 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_3|GPIO_PIN_4
 801a1f2:	f643 02d8 	movw	r2, #14552	; 0x38d8
 801a1f6:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801a1f8:	a90c      	add	r1, sp, #48	; 0x30
 801a1fa:	4630      	mov	r0, r6
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a1fc:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_3|GPIO_PIN_4
 801a1fe:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801a202:	f7e7 fdf3 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_10|GPIO_PIN_9|GPIO_PIN_8
 801a206:	f248 72d7 	movw	r2, #34775	; 0x87d7
 801a20a:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801a20c:	a90c      	add	r1, sp, #48	; 0x30
 801a20e:	484f      	ldr	r0, [pc, #316]	; (801a34c <MX_GPIO_Init+0x2a0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a210:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_10|GPIO_PIN_9|GPIO_PIN_8
 801a212:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801a216:	f7e7 fde9 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 801a21a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801a21e:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801a220:	a90c      	add	r1, sp, #48	; 0x30
 801a222:	484b      	ldr	r0, [pc, #300]	; (801a350 <MX_GPIO_Init+0x2a4>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a224:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 801a226:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801a22a:	f7e7 fddf 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_3;
 801a22e:	f44f 7284 	mov.w	r2, #264	; 0x108
 801a232:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a234:	a90c      	add	r1, sp, #48	; 0x30
 801a236:	4628      	mov	r0, r5
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a238:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_3;
 801a23a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a23e:	f7e7 fdd5 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FS_PowerSwitchOn_Pin;
 801a242:	2220      	movs	r2, #32
 801a244:	2301      	movs	r3, #1
  HAL_GPIO_Init(FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 801a246:	4630      	mov	r0, r6
 801a248:	a90c      	add	r1, sp, #48	; 0x30
  GPIO_InitStruct.Pin = FS_PowerSwitchOn_Pin;
 801a24a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801a24e:	2200      	movs	r2, #0
 801a250:	2300      	movs	r3, #0
 801a252:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  HAL_GPIO_Init(FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 801a256:	f7e7 fdc9 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = KBD_INT_Pin|LCD_INT_Pin;
 801a25a:	f242 0204 	movw	r2, #8196	; 0x2004
 801a25e:	4b3d      	ldr	r3, [pc, #244]	; (801a354 <MX_GPIO_Init+0x2a8>)
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a260:	a90c      	add	r1, sp, #48	; 0x30
 801a262:	4628      	mov	r0, r5
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a264:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = KBD_INT_Pin|LCD_INT_Pin;
 801a266:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a26a:	f7e7 fdbf 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = SD_DETECT_Pin;
 801a26e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 801a272:	2300      	movs	r3, #0
  HAL_GPIO_Init(SD_DETECT_GPIO_Port, &GPIO_InitStruct);
 801a274:	a90c      	add	r1, sp, #48	; 0x30
 801a276:	4650      	mov	r0, sl
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 801a278:	970e      	str	r7, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = SD_DETECT_Pin;
 801a27a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(SD_DETECT_GPIO_Port, &GPIO_InitStruct);
 801a27e:	f7e7 fdb5 	bl	8001dec <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 801a282:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
 801a284:	2208      	movs	r2, #8
 801a286:	f04f 0800 	mov.w	r8, #0
 801a28a:	2301      	movs	r3, #1
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 801a28c:	a90c      	add	r1, sp, #48	; 0x30
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
 801a28e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801a292:	e9cd 890e 	strd	r8, r9, [sp, #56]	; 0x38
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 801a296:	f7e7 fda9 	bl	8001dec <HAL_GPIO_Init>

  /*Configure GPIO pins : PH15 PH13 PH14 PH2
                           PH12 PH9 PH11 PH6
                           PH10 */
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_2
 801a29a:	f64f 6244 	movw	r2, #65092	; 0xfe44
 801a29e:	2303      	movs	r3, #3
                          |GPIO_PIN_12|GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_6
                          |GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801a2a0:	a90c      	add	r1, sp, #48	; 0x30
 801a2a2:	482d      	ldr	r0, [pc, #180]	; (801a358 <MX_GPIO_Init+0x2ac>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a2a4:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_2
 801a2a6:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801a2aa:	f7e7 fd9f 	bl	8001dec <HAL_GPIO_Init>

  /*Configure GPIO pins : PC14 PC15 PC7 PC6
                           PC1 PC2 PC4 PC5 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_7|GPIO_PIN_6
 801a2ae:	f24c 02f6 	movw	r2, #49398	; 0xc0f6
 801a2b2:	2303      	movs	r3, #3
                          |GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801a2b4:	4650      	mov	r0, sl
 801a2b6:	a90c      	add	r1, sp, #48	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a2b8:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_7|GPIO_PIN_6
 801a2ba:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801a2be:	f7e7 fd95 	bl	8001dec <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LCD_DISP_Pin;
 801a2c2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801a2c6:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(LCD_DISP_GPIO_Port, &GPIO_InitStruct);
 801a2c8:	a90c      	add	r1, sp, #48	; 0x30
 801a2ca:	4628      	mov	r0, r5
  GPIO_InitStruct.Pin = LCD_DISP_Pin;
 801a2cc:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801a2d0:	e9cd 890e 	strd	r8, r9, [sp, #56]	; 0x38
  HAL_GPIO_Init(LCD_DISP_GPIO_Port, &GPIO_InitStruct);
 801a2d4:	f7e7 fd8a 	bl	8001dec <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SPI2_NSS_Pin;
 801a2d8:	2201      	movs	r2, #1
 801a2da:	4b20      	ldr	r3, [pc, #128]	; (801a35c <MX_GPIO_Init+0x2b0>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(SPI2_NSS_GPIO_Port, &GPIO_InitStruct);
 801a2dc:	a90c      	add	r1, sp, #48	; 0x30
 801a2de:	4628      	mov	r0, r5
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 801a2e0:	970e      	str	r7, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = SPI2_NSS_Pin;
 801a2e2:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(SPI2_NSS_GPIO_Port, &GPIO_InitStruct);
 801a2e6:	f7e7 fd81 	bl	8001dec <HAL_GPIO_Init>

  /*Configure GPIO pins : PF7 PF6 PF10 PF9
                           PF8 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_10|GPIO_PIN_9
 801a2ea:	2303      	movs	r3, #3
 801a2ec:	f44f 62f8 	mov.w	r2, #1984	; 0x7c0
                          |GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801a2f0:	a90c      	add	r1, sp, #48	; 0x30
 801a2f2:	481b      	ldr	r0, [pc, #108]	; (801a360 <MX_GPIO_Init+0x2b4>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801a2f4:	940e      	str	r4, [sp, #56]	; 0x38
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_10|GPIO_PIN_9
 801a2f6:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801a2fa:	f7e7 fd77 	bl	8001dec <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);
 801a2fe:	4622      	mov	r2, r4
 801a300:	2102      	movs	r1, #2
 801a302:	2006      	movs	r0, #6
 801a304:	f7e6 feea 	bl	80010dc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 801a308:	2006      	movs	r0, #6
 801a30a:	f7e6 ff31 	bl	8001170 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI2_IRQn, 2, 0);
 801a30e:	4622      	mov	r2, r4
 801a310:	2102      	movs	r1, #2
 801a312:	2008      	movs	r0, #8
 801a314:	f7e6 fee2 	bl	80010dc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 801a318:	2008      	movs	r0, #8
 801a31a:	f7e6 ff29 	bl	8001170 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 3, 0);
 801a31e:	4622      	mov	r2, r4
 801a320:	2103      	movs	r1, #3
 801a322:	2028      	movs	r0, #40	; 0x28
 801a324:	f7e6 feda 	bl	80010dc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 801a328:	2028      	movs	r0, #40	; 0x28
 801a32a:	f7e6 ff21 	bl	8001170 <HAL_NVIC_EnableIRQ>

}
 801a32e:	b012      	add	sp, #72	; 0x48
 801a330:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801a334:	40023800 	.word	0x40023800
 801a338:	40020c00 	.word	0x40020c00
 801a33c:	40022000 	.word	0x40022000
 801a340:	40021000 	.word	0x40021000
 801a344:	40021800 	.word	0x40021800
 801a348:	40020400 	.word	0x40020400
 801a34c:	40020000 	.word	0x40020000
 801a350:	40022400 	.word	0x40022400
 801a354:	10110000 	.word	0x10110000
 801a358:	40021c00 	.word	0x40021c00
 801a35c:	10210000 	.word	0x10210000
 801a360:	40021400 	.word	0x40021400
 801a364:	40022800 	.word	0x40022800
 801a368:	40020800 	.word	0x40020800

0801a36c <MX_I2C3_Init>:

I2C_HandleTypeDef hi2c3;

/* I2C3 init function */
void MX_I2C3_Init(void)
{
 801a36c:	b510      	push	{r4, lr}
  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
 801a36e:	4817      	ldr	r0, [pc, #92]	; (801a3cc <MX_I2C3_Init+0x60>)
  hi2c3.Init.Timing = 0x20303E5D;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801a370:	2300      	movs	r3, #0
 801a372:	4917      	ldr	r1, [pc, #92]	; (801a3d0 <MX_I2C3_Init+0x64>)
 801a374:	2401      	movs	r4, #1
 801a376:	4a17      	ldr	r2, [pc, #92]	; (801a3d4 <MX_I2C3_Init+0x68>)
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c3.Init.OwnAddress2 = 0;
  hi2c3.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 801a378:	6203      	str	r3, [r0, #32]
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801a37a:	e880 001e 	stmia.w	r0, {r1, r2, r3, r4}
  hi2c3.Init.OwnAddress2 = 0;
 801a37e:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 801a382:	e9c0 3306 	strd	r3, r3, [r0, #24]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 801a386:	f7e8 fe99 	bl	80030bc <HAL_I2C_Init>
 801a38a:	b950      	cbnz	r0, 801a3a2 <MX_I2C3_Init+0x36>
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801a38c:	2100      	movs	r1, #0
 801a38e:	480f      	ldr	r0, [pc, #60]	; (801a3cc <MX_I2C3_Init+0x60>)
 801a390:	f7e9 fa4c 	bl	800382c <HAL_I2CEx_ConfigAnalogFilter>
 801a394:	b968      	cbnz	r0, 801a3b2 <MX_I2C3_Init+0x46>
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 801a396:	2100      	movs	r1, #0
 801a398:	480c      	ldr	r0, [pc, #48]	; (801a3cc <MX_I2C3_Init+0x60>)
 801a39a:	f7e9 fa99 	bl	80038d0 <HAL_I2CEx_ConfigDigitalFilter>
 801a39e:	b980      	cbnz	r0, 801a3c2 <MX_I2C3_Init+0x56>
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}
 801a3a0:	bd10      	pop	{r4, pc}
    Error_Handler();
 801a3a2:	f000 fd7d 	bl	801aea0 <Error_Handler>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801a3a6:	2100      	movs	r1, #0
 801a3a8:	4808      	ldr	r0, [pc, #32]	; (801a3cc <MX_I2C3_Init+0x60>)
 801a3aa:	f7e9 fa3f 	bl	800382c <HAL_I2CEx_ConfigAnalogFilter>
 801a3ae:	2800      	cmp	r0, #0
 801a3b0:	d0f1      	beq.n	801a396 <MX_I2C3_Init+0x2a>
    Error_Handler();
 801a3b2:	f000 fd75 	bl	801aea0 <Error_Handler>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 801a3b6:	2100      	movs	r1, #0
 801a3b8:	4804      	ldr	r0, [pc, #16]	; (801a3cc <MX_I2C3_Init+0x60>)
 801a3ba:	f7e9 fa89 	bl	80038d0 <HAL_I2CEx_ConfigDigitalFilter>
 801a3be:	2800      	cmp	r0, #0
 801a3c0:	d0ee      	beq.n	801a3a0 <MX_I2C3_Init+0x34>
}
 801a3c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 801a3c6:	f000 bd6b 	b.w	801aea0 <Error_Handler>
 801a3ca:	bf00      	nop
 801a3cc:	20000d38 	.word	0x20000d38
 801a3d0:	40005c00 	.word	0x40005c00
 801a3d4:	20303e5d 	.word	0x20303e5d

0801a3d8 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 801a3d8:	b510      	push	{r4, lr}
 801a3da:	b0a8      	sub	sp, #160	; 0xa0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a3dc:	2100      	movs	r1, #0
{
 801a3de:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801a3e0:	2284      	movs	r2, #132	; 0x84
 801a3e2:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a3e4:	9106      	str	r1, [sp, #24]
 801a3e6:	e9cd 1102 	strd	r1, r1, [sp, #8]
 801a3ea:	e9cd 1104 	strd	r1, r1, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801a3ee:	f005 fe75 	bl	80200dc <memset>
  if(i2cHandle->Instance==I2C3)
 801a3f2:	4b1b      	ldr	r3, [pc, #108]	; (801a460 <HAL_I2C_MspInit+0x88>)
 801a3f4:	6822      	ldr	r2, [r4, #0]
 801a3f6:	429a      	cmp	r2, r3
 801a3f8:	d001      	beq.n	801a3fe <HAL_I2C_MspInit+0x26>
    __HAL_RCC_I2C3_CLK_ENABLE();
  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }
}
 801a3fa:	b028      	add	sp, #160	; 0xa0
 801a3fc:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 801a3fe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a402:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 801a404:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a406:	f7ea faa7 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
 801a40a:	bb10      	cbnz	r0, 801a452 <HAL_I2C_MspInit+0x7a>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801a40c:	4c15      	ldr	r4, [pc, #84]	; (801a464 <HAL_I2C_MspInit+0x8c>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 801a40e:	2204      	movs	r2, #4
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801a410:	a902      	add	r1, sp, #8
 801a412:	4815      	ldr	r0, [pc, #84]	; (801a468 <HAL_I2C_MspInit+0x90>)
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801a414:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a416:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801a41a:	6323      	str	r3, [r4, #48]	; 0x30
 801a41c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 801a41e:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
 801a420:	2201      	movs	r2, #1
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801a422:	f003 0380 	and.w	r3, r3, #128	; 0x80
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
 801a426:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 801a458 <HAL_I2C_MspInit+0x80>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801a42a:	9300      	str	r3, [sp, #0]
 801a42c:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
 801a42e:	2303      	movs	r3, #3
 801a430:	ed8d 7b02 	vstr	d7, [sp, #8]
 801a434:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801a438:	f7e7 fcd8 	bl	8001dec <HAL_GPIO_Init>
    __HAL_RCC_I2C3_CLK_ENABLE();
 801a43c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801a43e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 801a442:	6423      	str	r3, [r4, #64]	; 0x40
 801a444:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801a446:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 801a44a:	9301      	str	r3, [sp, #4]
 801a44c:	9b01      	ldr	r3, [sp, #4]
}
 801a44e:	b028      	add	sp, #160	; 0xa0
 801a450:	bd10      	pop	{r4, pc}
      Error_Handler();
 801a452:	f000 fd25 	bl	801aea0 <Error_Handler>
 801a456:	e7d9      	b.n	801a40c <HAL_I2C_MspInit+0x34>
 801a458:	00000180 	.word	0x00000180
 801a45c:	00000012 	.word	0x00000012
 801a460:	40005c00 	.word	0x40005c00
 801a464:	40023800 	.word	0x40023800
 801a468:	40021c00 	.word	0x40021c00

0801a46c <MX_LTDC_Init>:

LTDC_HandleTypeDef hltdc;

/* LTDC init function */
void MX_LTDC_Init(void)
{
 801a46c:	b510      	push	{r4, lr}
 801a46e:	b09a      	sub	sp, #104	; 0x68

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
 801a470:	2234      	movs	r2, #52	; 0x34
 801a472:	2100      	movs	r1, #0
 801a474:	4668      	mov	r0, sp
 801a476:	f005 fe31 	bl	80200dc <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
 801a47a:	2234      	movs	r2, #52	; 0x34
 801a47c:	2100      	movs	r1, #0
 801a47e:	eb0d 0002 	add.w	r0, sp, r2
 801a482:	f005 fe2b 	bl	80200dc <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
 801a486:	4836      	ldr	r0, [pc, #216]	; (801a560 <MX_LTDC_Init+0xf4>)
 801a488:	2300      	movs	r3, #0
 801a48a:	4a36      	ldr	r2, [pc, #216]	; (801a564 <MX_LTDC_Init+0xf8>)
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
  hltdc.Init.HorizontalSync = 0;
  hltdc.Init.VerticalSync = 9;
  hltdc.Init.AccumulatedHBP = 43;
  hltdc.Init.AccumulatedVBP = 29;
  hltdc.Init.AccumulatedActiveW = 523;
 801a48c:	f04f 0e1d 	mov.w	lr, #29
  hltdc.Init.AccumulatedActiveH = 301;
  hltdc.Init.TotalWidth = 531;
  hltdc.Init.TotalHeigh = 305;
  hltdc.Init.Backcolor.Blue = 0;
 801a490:	8683      	strh	r3, [r0, #52]	; 0x34
  hltdc.Init.Backcolor.Green = 0;
  hltdc.Init.Backcolor.Red = 0;
 801a492:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
  hltdc.Instance = LTDC;
 801a496:	e9c0 2300 	strd	r2, r3, [r0]
  hltdc.Init.VerticalSync = 9;
 801a49a:	2209      	movs	r2, #9
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 801a49c:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hltdc.Init.HorizontalSync = 0;
 801a4a0:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hltdc.Init.VerticalSync = 9;
 801a4a4:	6182      	str	r2, [r0, #24]
  hltdc.Init.AccumulatedActiveW = 523;
 801a4a6:	f240 230b 	movw	r3, #523	; 0x20b
  hltdc.Init.AccumulatedHBP = 43;
 801a4aa:	222b      	movs	r2, #43	; 0x2b
  hltdc.Init.AccumulatedActiveW = 523;
 801a4ac:	e9c0 e308 	strd	lr, r3, [r0, #32]
  hltdc.Init.AccumulatedHBP = 43;
 801a4b0:	61c2      	str	r2, [r0, #28]
  hltdc.Init.TotalWidth = 531;
 801a4b2:	f240 2313 	movw	r3, #531	; 0x213
 801a4b6:	f240 122d 	movw	r2, #301	; 0x12d
 801a4ba:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
  hltdc.Init.TotalHeigh = 305;
 801a4be:	f240 1331 	movw	r3, #305	; 0x131
 801a4c2:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 801a4c4:	f7e9 fae2 	bl	8003a8c <HAL_LTDC_Init>
 801a4c8:	2800      	cmp	r0, #0
 801a4ca:	d13e      	bne.n	801a54a <MX_LTDC_Init+0xde>
  {
    Error_Handler();
  }
  pLayerCfg.WindowX0 = 0;
 801a4cc:	2200      	movs	r2, #0
  pLayerCfg.WindowX1 = 480;
  pLayerCfg.WindowY0 = 0;
  pLayerCfg.WindowY1 = 272;
 801a4ce:	f44f 7388 	mov.w	r3, #272	; 0x110
  pLayerCfg.WindowX1 = 480;
 801a4d2:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
  pLayerCfg.Alpha = 0;
  pLayerCfg.Alpha0 = 0;
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 801a4d6:	f44f 6c80 	mov.w	ip, #1024	; 0x400
  pLayerCfg.FBStartAdress = 0;
  pLayerCfg.ImageWidth = 480;
  pLayerCfg.ImageHeight = 272;
 801a4da:	930b      	str	r3, [sp, #44]	; 0x2c
  pLayerCfg.Backcolor.Blue = 0;
  pLayerCfg.Backcolor.Green = 0;
  pLayerCfg.Backcolor.Red = 0;
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 801a4dc:	4669      	mov	r1, sp
  pLayerCfg.ImageWidth = 480;
 801a4de:	900a      	str	r0, [sp, #40]	; 0x28
  pLayerCfg.FBStartAdress = 0;
 801a4e0:	9209      	str	r2, [sp, #36]	; 0x24
  pLayerCfg.Backcolor.Blue = 0;
 801a4e2:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
  pLayerCfg.Backcolor.Red = 0;
 801a4e6:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
  pLayerCfg.WindowY1 = 272;
 801a4ea:	e9cd 2302 	strd	r2, r3, [sp, #8]
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 801a4ee:	2302      	movs	r3, #2
 801a4f0:	9304      	str	r3, [sp, #16]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 801a4f2:	2305      	movs	r3, #5
  pLayerCfg.WindowX1 = 480;
 801a4f4:	e9cd 2000 	strd	r2, r0, [sp]
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 801a4f8:	4819      	ldr	r0, [pc, #100]	; (801a560 <MX_LTDC_Init+0xf4>)
  pLayerCfg.Alpha0 = 0;
 801a4fa:	e9cd 2205 	strd	r2, r2, [sp, #20]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 801a4fe:	e9cd c307 	strd	ip, r3, [sp, #28]
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 801a502:	f7e9 fbb5 	bl	8003c70 <HAL_LTDC_ConfigLayer>
 801a506:	bb38      	cbnz	r0, 801a558 <MX_LTDC_Init+0xec>
  }
  pLayerCfg1.WindowX0 = 0;
  pLayerCfg1.WindowX1 = 480;
  pLayerCfg1.WindowY0 = 0;
  pLayerCfg1.WindowY1 = 272;
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 801a508:	2402      	movs	r4, #2
  pLayerCfg1.WindowX0 = 0;
 801a50a:	2300      	movs	r3, #0
  pLayerCfg1.WindowX1 = 480;
 801a50c:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
  pLayerCfg1.WindowY1 = 272;
 801a510:	f44f 7088 	mov.w	r0, #272	; 0x110
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 801a514:	9411      	str	r4, [sp, #68]	; 0x44
  pLayerCfg1.Alpha = 0;
  pLayerCfg1.Alpha0 = 0;
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 801a516:	f44f 6480 	mov.w	r4, #1024	; 0x400
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
  pLayerCfg1.FBStartAdress = 0;
  pLayerCfg1.ImageWidth = 480;
 801a51a:	9217      	str	r2, [sp, #92]	; 0x5c
  pLayerCfg1.ImageHeight = 272;
  pLayerCfg1.Backcolor.Blue = 0;
  pLayerCfg1.Backcolor.Green = 0;
  pLayerCfg1.Backcolor.Red = 0;
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
 801a51c:	a90d      	add	r1, sp, #52	; 0x34
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 801a51e:	9414      	str	r4, [sp, #80]	; 0x50
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 801a520:	2405      	movs	r4, #5
  pLayerCfg1.ImageHeight = 272;
 801a522:	9018      	str	r0, [sp, #96]	; 0x60
  pLayerCfg1.FBStartAdress = 0;
 801a524:	9316      	str	r3, [sp, #88]	; 0x58
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 801a526:	9415      	str	r4, [sp, #84]	; 0x54
  pLayerCfg1.Backcolor.Blue = 0;
 801a528:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
  pLayerCfg1.Backcolor.Red = 0;
 801a52c:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
  pLayerCfg1.WindowX1 = 480;
 801a530:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
  pLayerCfg1.WindowY1 = 272;
 801a534:	e9cd 300f 	strd	r3, r0, [sp, #60]	; 0x3c
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
 801a538:	2201      	movs	r2, #1
 801a53a:	4809      	ldr	r0, [pc, #36]	; (801a560 <MX_LTDC_Init+0xf4>)
  pLayerCfg1.Alpha0 = 0;
 801a53c:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
 801a540:	f7e9 fb96 	bl	8003c70 <HAL_LTDC_ConfigLayer>
 801a544:	b920      	cbnz	r0, 801a550 <MX_LTDC_Init+0xe4>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
 801a546:	b01a      	add	sp, #104	; 0x68
 801a548:	bd10      	pop	{r4, pc}
    Error_Handler();
 801a54a:	f000 fca9 	bl	801aea0 <Error_Handler>
 801a54e:	e7bd      	b.n	801a4cc <MX_LTDC_Init+0x60>
    Error_Handler();
 801a550:	f000 fca6 	bl	801aea0 <Error_Handler>
}
 801a554:	b01a      	add	sp, #104	; 0x68
 801a556:	bd10      	pop	{r4, pc}
    Error_Handler();
 801a558:	f000 fca2 	bl	801aea0 <Error_Handler>
 801a55c:	e7d4      	b.n	801a508 <MX_LTDC_Init+0x9c>
 801a55e:	bf00      	nop
 801a560:	20000d84 	.word	0x20000d84
 801a564:	40016800 	.word	0x40016800

0801a568 <HAL_LTDC_MspInit>:

void HAL_LTDC_MspInit(LTDC_HandleTypeDef* ltdcHandle)
{
 801a568:	b570      	push	{r4, r5, r6, lr}
 801a56a:	b0ae      	sub	sp, #184	; 0xb8

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a56c:	2100      	movs	r1, #0
{
 801a56e:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801a570:	2284      	movs	r2, #132	; 0x84
 801a572:	a80c      	add	r0, sp, #48	; 0x30
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801a574:	910a      	str	r1, [sp, #40]	; 0x28
 801a576:	e9cd 1106 	strd	r1, r1, [sp, #24]
 801a57a:	e9cd 1108 	strd	r1, r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801a57e:	f005 fdad 	bl	80200dc <memset>
  if(ltdcHandle->Instance==LTDC)
 801a582:	4b49      	ldr	r3, [pc, #292]	; (801a6a8 <HAL_LTDC_MspInit+0x140>)
 801a584:	6822      	ldr	r2, [r4, #0]
 801a586:	429a      	cmp	r2, r3
 801a588:	d001      	beq.n	801a58e <HAL_LTDC_MspInit+0x26>

  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }
}
 801a58a:	b02e      	add	sp, #184	; 0xb8
 801a58c:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
 801a58e:	2302      	movs	r3, #2
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 801a590:	2108      	movs	r1, #8
    PeriphClkInitStruct.PLLSAI.PLLSAIN = 240;
 801a592:	22f0      	movs	r2, #240	; 0xf0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a594:	a80c      	add	r0, sp, #48	; 0x30
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 801a596:	910c      	str	r1, [sp, #48]	; 0x30
    PeriphClkInitStruct.PLLSAI.PLLSAIR = 6;
 801a598:	2106      	movs	r1, #6
    PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV6;
 801a59a:	9314      	str	r3, [sp, #80]	; 0x50
    PeriphClkInitStruct.PLLSAI.PLLSAIR = 6;
 801a59c:	9113      	str	r1, [sp, #76]	; 0x4c
    PeriphClkInitStruct.PLLSAI.PLLSAIN = 240;
 801a59e:	e9cd 2311 	strd	r2, r3, [sp, #68]	; 0x44
    PeriphClkInitStruct.PLLSAIDivQ = 1;
 801a5a2:	2201      	movs	r2, #1
 801a5a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 801a5a8:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a5ac:	f7ea f9d4 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
 801a5b0:	2800      	cmp	r0, #0
 801a5b2:	d176      	bne.n	801a6a2 <HAL_LTDC_MspInit+0x13a>
    __HAL_RCC_LTDC_CLK_ENABLE();
 801a5b4:	4b3d      	ldr	r3, [pc, #244]	; (801a6ac <HAL_LTDC_MspInit+0x144>)
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801a5b6:	2010      	movs	r0, #16
 801a5b8:	2102      	movs	r1, #2
 801a5ba:	2400      	movs	r4, #0
    __HAL_RCC_LTDC_CLK_ENABLE();
 801a5bc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801a5be:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801a5c0:	260e      	movs	r6, #14
    __HAL_RCC_LTDC_CLK_ENABLE();
 801a5c2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 801a5c6:	645a      	str	r2, [r3, #68]	; 0x44
 801a5c8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801a5ca:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 801a5ce:	9200      	str	r2, [sp, #0]
 801a5d0:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 801a5d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a5d4:	f042 0210 	orr.w	r2, r2, #16
 801a5d8:	631a      	str	r2, [r3, #48]	; 0x30
 801a5da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a5dc:	f002 0210 	and.w	r2, r2, #16
 801a5e0:	9201      	str	r2, [sp, #4]
 801a5e2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 801a5e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a5e6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 801a5ea:	631a      	str	r2, [r3, #48]	; 0x30
 801a5ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a5ee:	f402 7200 	and.w	r2, r2, #512	; 0x200
 801a5f2:	9202      	str	r2, [sp, #8]
 801a5f4:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOK_CLK_ENABLE();
 801a5f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a5f8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 801a5fc:	631a      	str	r2, [r3, #48]	; 0x30
 801a5fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a600:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 801a604:	9203      	str	r2, [sp, #12]
 801a606:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 801a608:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a60a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801a60e:	631a      	str	r2, [r3, #48]	; 0x30
 801a610:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a612:	f002 0240 	and.w	r2, r2, #64	; 0x40
 801a616:	9204      	str	r2, [sp, #16]
 801a618:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 801a61a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a61c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 801a620:	631a      	str	r2, [r3, #48]	; 0x30
 801a622:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a624:	f403 7380 	and.w	r3, r3, #256	; 0x100
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801a628:	e9cd 0106 	strd	r0, r1, [sp, #24]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 801a62c:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801a62e:	a906      	add	r1, sp, #24
 801a630:	481f      	ldr	r0, [pc, #124]	; (801a6b0 <HAL_LTDC_MspInit+0x148>)
    __HAL_RCC_GPIOI_CLK_ENABLE();
 801a632:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801a634:	e9cd 4508 	strd	r4, r5, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801a638:	960a      	str	r6, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801a63a:	f7e7 fbd7 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_11
 801a63e:	f64e 72ff 	movw	r2, #61439	; 0xefff
 801a642:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801a644:	a906      	add	r1, sp, #24
 801a646:	481b      	ldr	r0, [pc, #108]	; (801a6b4 <HAL_LTDC_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801a648:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_11
 801a64a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 801a64e:	e9cd 4508 	strd	r4, r5, [sp, #32]
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801a652:	f7e7 fbcb 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_5|GPIO_PIN_4
 801a656:	22f7      	movs	r2, #247	; 0xf7
 801a658:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 801a65a:	a906      	add	r1, sp, #24
 801a65c:	4816      	ldr	r0, [pc, #88]	; (801a6b8 <HAL_LTDC_MspInit+0x150>)
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801a65e:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_5|GPIO_PIN_4
 801a660:	e9cd 2306 	strd	r2, r3, [sp, #24]
 801a664:	e9cd 4508 	strd	r4, r5, [sp, #32]
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 801a668:	f7e7 fbc0 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 801a66c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801a670:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801a672:	a906      	add	r1, sp, #24
 801a674:	4811      	ldr	r0, [pc, #68]	; (801a6bc <HAL_LTDC_MspInit+0x154>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 801a676:	e9cd 2306 	strd	r2, r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 801a67a:	2309      	movs	r3, #9
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 801a67c:	e9cd 4508 	strd	r4, r5, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 801a680:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801a682:	f7e7 fbb3 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_9|GPIO_PIN_15|GPIO_PIN_14;
 801a686:	f44f 4246 	mov.w	r2, #50688	; 0xc600
 801a68a:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a68c:	a906      	add	r1, sp, #24
 801a68e:	480c      	ldr	r0, [pc, #48]	; (801a6c0 <HAL_LTDC_MspInit+0x158>)
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801a690:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_9|GPIO_PIN_15|GPIO_PIN_14;
 801a692:	e9cd 4508 	strd	r4, r5, [sp, #32]
 801a696:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801a69a:	f7e7 fba7 	bl	8001dec <HAL_GPIO_Init>
}
 801a69e:	b02e      	add	sp, #184	; 0xb8
 801a6a0:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 801a6a2:	f000 fbfd 	bl	801aea0 <Error_Handler>
 801a6a6:	e785      	b.n	801a5b4 <HAL_LTDC_MspInit+0x4c>
 801a6a8:	40016800 	.word	0x40016800
 801a6ac:	40023800 	.word	0x40023800
 801a6b0:	40021000 	.word	0x40021000
 801a6b4:	40022400 	.word	0x40022400
 801a6b8:	40022800 	.word	0x40022800
 801a6bc:	40021800 	.word	0x40021800
 801a6c0:	40022000 	.word	0x40022000

0801a6c4 <BSP_LCD_DisplayOn>:
  * @retval None
  */
void BSP_LCD_DisplayOn(void)
{
  /* Display On */
  __HAL_LTDC_ENABLE(&hltdc);
 801a6c4:	4b09      	ldr	r3, [pc, #36]	; (801a6ec <BSP_LCD_DisplayOn+0x28>)
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);        /* Assert LCD_DISP pin */
 801a6c6:	2201      	movs	r2, #1
 801a6c8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801a6cc:	4808      	ldr	r0, [pc, #32]	; (801a6f0 <BSP_LCD_DisplayOn+0x2c>)
{
 801a6ce:	b510      	push	{r4, lr}
  __HAL_LTDC_ENABLE(&hltdc);
 801a6d0:	681c      	ldr	r4, [r3, #0]
 801a6d2:	69a3      	ldr	r3, [r4, #24]
 801a6d4:	4313      	orrs	r3, r2
 801a6d6:	61a3      	str	r3, [r4, #24]
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);        /* Assert LCD_DISP pin */
 801a6d8:	f7e7 fd36 	bl	8002148 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);  /* Assert LCD_BL_CTRL pin */
 801a6dc:	2201      	movs	r2, #1
 801a6de:	2108      	movs	r1, #8
 801a6e0:	4804      	ldr	r0, [pc, #16]	; (801a6f4 <BSP_LCD_DisplayOn+0x30>)
}
 801a6e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);  /* Assert LCD_BL_CTRL pin */
 801a6e6:	f7e7 bd2f 	b.w	8002148 <HAL_GPIO_WritePin>
 801a6ea:	bf00      	nop
 801a6ec:	20000d84 	.word	0x20000d84
 801a6f0:	40022000 	.word	0x40022000
 801a6f4:	40022800 	.word	0x40022800

0801a6f8 <find_file.constprop.0.isra.0>:
    	}
    }
    return res;
}

FRESULT find_file(uint16_t track_number)
 801a6f8:	b5f0      	push	{r4, r5, r6, r7, lr}
{
    DIR folder;
    TCHAR path[255] = {0};
    for(int i=0; i<255; i++) path[i] = ff_convert(TrackPaths[Track_number][i], 1);
 801a6fa:	2400      	movs	r4, #0
FRESULT find_file(uint16_t track_number)
 801a6fc:	f2ad 4d54 	subw	sp, sp, #1108	; 0x454
    TCHAR path[255] = {0};
 801a700:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801a704:	4f14      	ldr	r7, [pc, #80]	; (801a758 <find_file.constprop.0.isra.0+0x60>)
 801a706:	4621      	mov	r1, r4
 801a708:	a815      	add	r0, sp, #84	; 0x54
 801a70a:	ad14      	add	r5, sp, #80	; 0x50
 801a70c:	4e13      	ldr	r6, [pc, #76]	; (801a75c <find_file.constprop.0.isra.0+0x64>)
 801a70e:	f005 fce5 	bl	80200dc <memset>
    for(int i=0; i<255; i++) path[i] = ff_convert(TrackPaths[Track_number][i], 1);
 801a712:	6833      	ldr	r3, [r6, #0]
 801a714:	2101      	movs	r1, #1
 801a716:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 801a71a:	443b      	add	r3, r7
 801a71c:	5d18      	ldrb	r0, [r3, r4]
 801a71e:	440c      	add	r4, r1
 801a720:	f7f2 f938 	bl	800c994 <ff_convert>
 801a724:	f845 0f04 	str.w	r0, [r5, #4]!
 801a728:	2cff      	cmp	r4, #255	; 0xff
 801a72a:	d1f2      	bne.n	801a712 <find_file.constprop.0.isra.0+0x1a>
    wcscpy(new_path, path);
 801a72c:	a915      	add	r1, sp, #84	; 0x54
 801a72e:	480c      	ldr	r0, [pc, #48]	; (801a760 <find_file.constprop.0.isra.0+0x68>)
	res = f_opendir(&folder, new_path);
 801a730:	4c0c      	ldr	r4, [pc, #48]	; (801a764 <find_file.constprop.0.isra.0+0x6c>)
    wcscpy(new_path, path);
 801a732:	f005 fe56 	bl	80203e2 <wcscpy>
	res = f_opendir(&folder, new_path);
 801a736:	490a      	ldr	r1, [pc, #40]	; (801a760 <find_file.constprop.0.isra.0+0x68>)
 801a738:	4668      	mov	r0, sp
 801a73a:	f7f2 f867 	bl	800c80c <f_opendir>
 801a73e:	7020      	strb	r0, [r4, #0]
	if(res == FR_OK) {
 801a740:	b110      	cbz	r0, 801a748 <find_file.constprop.0.isra.0+0x50>
		res = f_readdir(&folder, &fno);
		if (!(fno.fattrib & AM_DIR)) {
		}
	}
    return res;
}
 801a742:	f20d 4d54 	addw	sp, sp, #1108	; 0x454
 801a746:	bdf0      	pop	{r4, r5, r6, r7, pc}
		res = f_readdir(&folder, &fno);
 801a748:	4907      	ldr	r1, [pc, #28]	; (801a768 <find_file.constprop.0.isra.0+0x70>)
 801a74a:	4668      	mov	r0, sp
 801a74c:	f7f2 f8ca 	bl	800c8e4 <f_readdir>
 801a750:	7020      	strb	r0, [r4, #0]
}
 801a752:	f20d 4d54 	addw	sp, sp, #1108	; 0x454
 801a756:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a758:	200022c4 	.word	0x200022c4
 801a75c:	2000e9fc 	.word	0x2000e9fc
 801a760:	2000f274 	.word	0x2000f274
 801a764:	2000fa6c 	.word	0x2000fa6c
 801a768:	2000ec90 	.word	0x2000ec90
 801a76c:	00000000 	.word	0x00000000

0801a770 <SystemClock_Config>:
{
 801a770:	b500      	push	{lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801a772:	2300      	movs	r3, #0
{
 801a774:	b0b7      	sub	sp, #220	; 0xdc
  __HAL_RCC_PWR_CLK_ENABLE();
 801a776:	4932      	ldr	r1, [pc, #200]	; (801a840 <SystemClock_Config+0xd0>)
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 801a778:	9302      	str	r3, [sp, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801a77a:	4a32      	ldr	r2, [pc, #200]	; (801a844 <SystemClock_Config+0xd4>)
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801a77c:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 801a780:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 801a784:	e9cd 3303 	strd	r3, r3, [sp, #12]
 801a788:	e9cd 3305 	strd	r3, r3, [sp, #20]
  __HAL_RCC_PWR_CLK_ENABLE();
 801a78c:	6c08      	ldr	r0, [r1, #64]	; 0x40
 801a78e:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 801a792:	6408      	str	r0, [r1, #64]	; 0x40
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801a794:	a808      	add	r0, sp, #32
  __HAL_RCC_PWR_CLK_ENABLE();
 801a796:	6c09      	ldr	r1, [r1, #64]	; 0x40
 801a798:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 801a79c:	9100      	str	r1, [sp, #0]
 801a79e:	9900      	ldr	r1, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801a7a0:	6811      	ldr	r1, [r2, #0]
 801a7a2:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 801a7a6:	6011      	str	r1, [r2, #0]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 801a7a8:	2102      	movs	r1, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801a7aa:	6812      	ldr	r2, [r2, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 801a7ac:	930b      	str	r3, [sp, #44]	; 0x2c
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801a7ae:	f402 4340 	and.w	r3, r2, #49152	; 0xc000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 801a7b2:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 801a7b6:	910e      	str	r1, [sp, #56]	; 0x38
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801a7b8:	9301      	str	r3, [sp, #4]
 801a7ba:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.PLL.PLLN = 400;//384;
 801a7bc:	f44f 73c8 	mov.w	r3, #400	; 0x190
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 801a7c0:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 25;
 801a7c2:	2219      	movs	r2, #25
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 801a7c4:	9112      	str	r1, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 8;
 801a7c6:	2108      	movs	r1, #8
  RCC_OscInitStruct.PLL.PLLN = 400;//384;
 801a7c8:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 801a7cc:	2201      	movs	r2, #1
 801a7ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLQ = 8;
 801a7d2:	9113      	str	r1, [sp, #76]	; 0x4c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 801a7d4:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801a7d8:	f7e9 fd12 	bl	8004200 <HAL_RCC_OscConfig>
 801a7dc:	b100      	cbz	r0, 801a7e0 <SystemClock_Config+0x70>
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
 801a7de:	e7fe      	b.n	801a7de <SystemClock_Config+0x6e>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 801a7e0:	f7e9 fcd4 	bl	800418c <HAL_PWREx_EnableOverDrive>
 801a7e4:	b100      	cbz	r0, 801a7e8 <SystemClock_Config+0x78>
  while(1)
 801a7e6:	e7fe      	b.n	801a7e6 <SystemClock_Config+0x76>
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 801a7e8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
 801a7ec:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
 801a7f0:	21c0      	movs	r1, #192	; 0xc0
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 4;
 801a7f2:	2204      	movs	r2, #4
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 801a7f4:	9334      	str	r3, [sp, #208]	; 0xd0
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV4;
 801a7f6:	2301      	movs	r3, #1
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
 801a7f8:	9015      	str	r0, [sp, #84]	; 0x54
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a7fa:	a815      	add	r0, sp, #84	; 0x54
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV4;
 801a7fc:	931d      	str	r3, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 4;
 801a7fe:	e9cd 121a 	strd	r1, r2, [sp, #104]	; 0x68
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801a802:	f7ea f8a9 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
 801a806:	b100      	cbz	r0, 801a80a <SystemClock_Config+0x9a>
  while(1)
 801a808:	e7fe      	b.n	801a808 <SystemClock_Config+0x98>
  RCC_ClkInitStruct.ClockType =
 801a80a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 801a80e:	2200      	movs	r2, #0
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 801a810:	a802      	add	r0, sp, #8
 801a812:	2106      	movs	r1, #6
  RCC_ClkInitStruct.ClockType =
 801a814:	ed9f 7b08 	vldr	d7, [pc, #32]	; 801a838 <SystemClock_Config+0xc8>
 801a818:	e9cd 2304 	strd	r2, r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 801a81c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  RCC_ClkInitStruct.ClockType =
 801a820:	ed8d 7b02 	vstr	d7, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 801a824:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 801a826:	f7e9 ff4d 	bl	80046c4 <HAL_RCC_ClockConfig>
 801a82a:	b910      	cbnz	r0, 801a832 <SystemClock_Config+0xc2>
}
 801a82c:	b037      	add	sp, #220	; 0xdc
 801a82e:	f85d fb04 	ldr.w	pc, [sp], #4
  while(1)
 801a832:	e7fe      	b.n	801a832 <SystemClock_Config+0xc2>
 801a834:	f3af 8000 	nop.w
 801a838:	0000000f 	.word	0x0000000f
 801a83c:	00000002 	.word	0x00000002
 801a840:	40023800 	.word	0x40023800
 801a844:	40007000 	.word	0x40007000

0801a848 <scan_files>:
{
 801a848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    UINT folders = 0;
 801a84c:	2600      	movs	r6, #0
{
 801a84e:	f2ad 4d5c 	subw	sp, sp, #1116	; 0x45c
    TCHAR relative_path[255] = {0};
 801a852:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801a856:	4d67      	ldr	r5, [pc, #412]	; (801a9f4 <scan_files+0x1ac>)
 801a858:	4631      	mov	r1, r6
 801a85a:	a817      	add	r0, sp, #92	; 0x5c
    	res = f_opendir(&folder, L"/PIONEER/USBANLZ");	/* Open the directory */
 801a85c:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 801aa1c <scan_files+0x1d4>
 801a860:	4c65      	ldr	r4, [pc, #404]	; (801a9f8 <scan_files+0x1b0>)
    	if ((res != FR_OK) || (fno.fname[0] == '\0') || (Total_tracks>=MAXTOTALTRACKS)) {
 801a862:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 801aa20 <scan_files+0x1d8>
    		for(i = 0; i < 255; i++) new_path[i] = 0;		//clr new_path
 801a866:	f8df a1bc 	ldr.w	sl, [pc, #444]	; 801aa24 <scan_files+0x1dc>
    TCHAR relative_path[255] = {0};
 801a86a:	f005 fc37 	bl	80200dc <memset>
    	res = f_opendir(&folder, L"/PIONEER/USBANLZ");	/* Open the directory */
 801a86e:	4649      	mov	r1, r9
 801a870:	a802      	add	r0, sp, #8
 801a872:	f7f1 ffcb 	bl	800c80c <f_opendir>
 801a876:	7028      	strb	r0, [r5, #0]
    	if (res != FR_OK) {
 801a878:	2800      	cmp	r0, #0
 801a87a:	f040 80b3 	bne.w	801a9e4 <scan_files+0x19c>
    	i = 0;
 801a87e:	4683      	mov	fp, r0
    		res = f_readdir(&folder, &fno);	/* Read a new, unknown directory item */
 801a880:	4621      	mov	r1, r4
 801a882:	a802      	add	r0, sp, #8
 801a884:	f7f2 f82e 	bl	800c8e4 <f_readdir>
    	}while(i++ < folders);
 801a888:	455e      	cmp	r6, fp
    		res = f_readdir(&folder, &fno);	/* Read a new, unknown directory item */
 801a88a:	7028      	strb	r0, [r5, #0]
    	}while(i++ < folders);
 801a88c:	f10b 0b01 	add.w	fp, fp, #1
 801a890:	d8f6      	bhi.n	801a880 <scan_files+0x38>
    	if ((res != FR_OK) || (fno.fname[0] == '\0') || (Total_tracks>=MAXTOTALTRACKS)) {
 801a892:	4607      	mov	r7, r0
 801a894:	2800      	cmp	r0, #0
 801a896:	f040 80a1 	bne.w	801a9dc <scan_files+0x194>
 801a89a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 801a89c:	2b00      	cmp	r3, #0
 801a89e:	f000 809d 	beq.w	801a9dc <scan_files+0x194>
 801a8a2:	f8b8 3000 	ldrh.w	r3, [r8]
 801a8a6:	2b63      	cmp	r3, #99	; 0x63
 801a8a8:	f200 8098 	bhi.w	801a9dc <scan_files+0x194>
    	if (fno.fattrib & AM_DIR) {	/* It is a directory */
 801a8ac:	7b23      	ldrb	r3, [r4, #12]
 801a8ae:	06da      	lsls	r2, r3, #27
 801a8b0:	d5dd      	bpl.n	801a86e <scan_files+0x26>
    		for(i = 0; i < 255; i++) new_path[i] = 0;		//clr new_path
 801a8b2:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801a8b6:	4601      	mov	r1, r0
 801a8b8:	4650      	mov	r0, sl
    		folders++;
 801a8ba:	3601      	adds	r6, #1
    		for(i = 0; i < 255; i++) new_path[i] = 0;		//clr new_path
 801a8bc:	f005 fc0e 	bl	80200dc <memset>
    		wcscpy(new_path, L"/PIONEER/USBANLZ/");
 801a8c0:	494e      	ldr	r1, [pc, #312]	; (801a9fc <scan_files+0x1b4>)
 801a8c2:	4650      	mov	r0, sl
 801a8c4:	f005 fd8d 	bl	80203e2 <wcscpy>
    		for(i = 0; i < 255; i++) relative_path[i] = 0;	//clr rel_path
 801a8c8:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801a8cc:	4639      	mov	r1, r7
 801a8ce:	a817      	add	r0, sp, #92	; 0x5c
 801a8d0:	f005 fc04 	bl	80200dc <memset>
    		wcscpy(relative_path, fno.fname);				//rel_path= [directory]
 801a8d4:	494a      	ldr	r1, [pc, #296]	; (801aa00 <scan_files+0x1b8>)
 801a8d6:	a817      	add	r0, sp, #92	; 0x5c
 801a8d8:	f005 fd83 	bl	80203e2 <wcscpy>
    		wcscat(new_path, relative_path);					//step in new_path=  /PIONEER/USBANLZ/ + [directory]
 801a8dc:	a917      	add	r1, sp, #92	; 0x5c
 801a8de:	4650      	mov	r0, sl
 801a8e0:	f005 fd6f 	bl	80203c2 <wcscat>
    		wcscpy(old_path, new_path);						//old_path=new_path
 801a8e4:	4651      	mov	r1, sl
 801a8e6:	4847      	ldr	r0, [pc, #284]	; (801aa04 <scan_files+0x1bc>)
 801a8e8:	f005 fd7b 	bl	80203e2 <wcscpy>
    		f_closedir(&folder);
 801a8ec:	a802      	add	r0, sp, #8
 801a8ee:	f7f1 ffe1 	bl	800c8b4 <f_closedir>
    			res = f_opendir(&folder, old_path);			//we have to go deeper
 801a8f2:	4944      	ldr	r1, [pc, #272]	; (801aa04 <scan_files+0x1bc>)
 801a8f4:	a802      	add	r0, sp, #8
 801a8f6:	f7f1 ff89 	bl	800c80c <f_opendir>
    			i = 0;
 801a8fa:	f04f 0b00 	mov.w	fp, #0
    			for(i = 0; i < 255; i++) new_path[i] = 0;	//clr new_path
 801a8fe:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801a902:	2100      	movs	r1, #0
    			res = f_opendir(&folder, old_path);			//we have to go deeper
 801a904:	7028      	strb	r0, [r5, #0]
    			for(i = 0; i < 255; i++) new_path[i] = 0;	//clr new_path
 801a906:	4650      	mov	r0, sl
 801a908:	f005 fbe8 	bl	80200dc <memset>
    			wcscpy(new_path, old_path);					//re-use new_path=  /PIONEER/USBANLZ/ + [directory]
 801a90c:	493d      	ldr	r1, [pc, #244]	; (801aa04 <scan_files+0x1bc>)
 801a90e:	4650      	mov	r0, sl
 801a910:	f005 fd67 	bl	80203e2 <wcscpy>
    				res = f_readdir(&folder, &fno);	/* Read a new directory item */
 801a914:	4621      	mov	r1, r4
 801a916:	a802      	add	r0, sp, #8
 801a918:	f7f1 ffe4 	bl	800c8e4 <f_readdir>
    			}while(i++ < subfolders);
 801a91c:	455f      	cmp	r7, fp
    				res = f_readdir(&folder, &fno);	/* Read a new directory item */
 801a91e:	7028      	strb	r0, [r5, #0]
    			}while(i++ < subfolders);
 801a920:	f10b 0b01 	add.w	fp, fp, #1
 801a924:	d8f6      	bhi.n	801a914 <scan_files+0xcc>
    			if ((res != FR_OK) || (fno.fname[0] == '\0') || (Total_tracks>=MAXTOTALTRACKS)) {
 801a926:	2800      	cmp	r0, #0
 801a928:	d160      	bne.n	801a9ec <scan_files+0x1a4>
 801a92a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 801a92c:	2b00      	cmp	r3, #0
 801a92e:	d05d      	beq.n	801a9ec <scan_files+0x1a4>
 801a930:	f8b8 3000 	ldrh.w	r3, [r8]
 801a934:	2b63      	cmp	r3, #99	; 0x63
 801a936:	d859      	bhi.n	801a9ec <scan_files+0x1a4>
    			if (fno.fattrib & AM_DIR) {	/* It is a directory */
 801a938:	7b23      	ldrb	r3, [r4, #12]
 801a93a:	06db      	lsls	r3, r3, #27
 801a93c:	d5d9      	bpl.n	801a8f2 <scan_files+0xaa>
    				wcscat(new_path, L"/");
 801a93e:	4932      	ldr	r1, [pc, #200]	; (801aa08 <scan_files+0x1c0>)
 801a940:	4650      	mov	r0, sl
 801a942:	f005 fd3e 	bl	80203c2 <wcscat>
    				wcscat(new_path, fno.fname);			// new_path=  /PIONEER/USBANLZ/ + [directory] + /[subdir]
 801a946:	492e      	ldr	r1, [pc, #184]	; (801aa00 <scan_files+0x1b8>)
 801a948:	4650      	mov	r0, sl
    				subfolders++;
 801a94a:	3701      	adds	r7, #1
    				wcscat(new_path, fno.fname);			// new_path=  /PIONEER/USBANLZ/ + [directory] + /[subdir]
 801a94c:	f005 fd39 	bl	80203c2 <wcscat>
    				f_closedir(&folder);
 801a950:	a802      	add	r0, sp, #8
 801a952:	f7f1 ffaf 	bl	800c8b4 <f_closedir>
    				res = f_opendir(&folder, new_path);		//one more level deeper
 801a956:	4651      	mov	r1, sl
 801a958:	a802      	add	r0, sp, #8
 801a95a:	f7f1 ff57 	bl	800c80c <f_opendir>
 801a95e:	7028      	strb	r0, [r5, #0]
    				if(res == FR_OK) {
 801a960:	2800      	cmp	r0, #0
 801a962:	d1c6      	bne.n	801a8f2 <scan_files+0xaa>
    					res = f_readdir(&folder, &fno);		//there should be files!
 801a964:	4621      	mov	r1, r4
 801a966:	a802      	add	r0, sp, #8
 801a968:	f7f1 ffbc 	bl	800c8e4 <f_readdir>
    					if (!(fno.fattrib & AM_DIR)) {
 801a96c:	7b23      	ldrb	r3, [r4, #12]
    					res = f_readdir(&folder, &fno);		//there should be files!
 801a96e:	7028      	strb	r0, [r5, #0]
    					if (!(fno.fattrib & AM_DIR)) {
 801a970:	f013 0310 	ands.w	r3, r3, #16
 801a974:	d1bd      	bne.n	801a8f2 <scan_files+0xaa>
    						for(i=0; i<255; i++) TrackPaths[Total_tracks][i] = ff_convert(new_path[i], 0);		//populate database
 801a976:	469b      	mov	fp, r3
 801a978:	4b24      	ldr	r3, [pc, #144]	; (801aa0c <scan_files+0x1c4>)
 801a97a:	9601      	str	r6, [sp, #4]
 801a97c:	461e      	mov	r6, r3
 801a97e:	2100      	movs	r1, #0
 801a980:	f856 0f04 	ldr.w	r0, [r6, #4]!
 801a984:	f7f2 f806 	bl	800c994 <ff_convert>
 801a988:	f8b8 2000 	ldrh.w	r2, [r8]
 801a98c:	4b20      	ldr	r3, [pc, #128]	; (801aa10 <scan_files+0x1c8>)
 801a98e:	ebc2 2202 	rsb	r2, r2, r2, lsl #8
 801a992:	441a      	add	r2, r3
 801a994:	f802 000b 	strb.w	r0, [r2, fp]
 801a998:	f10b 0b01 	add.w	fp, fp, #1
 801a99c:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 801a9a0:	d1ed      	bne.n	801a97e <scan_files+0x136>
    						wcscat(new_path, L"/");
 801a9a2:	4919      	ldr	r1, [pc, #100]	; (801aa08 <scan_files+0x1c0>)
 801a9a4:	4650      	mov	r0, sl
 801a9a6:	9e01      	ldr	r6, [sp, #4]
 801a9a8:	f005 fd0b 	bl	80203c2 <wcscat>
    						wcscat(new_path, fno.fname);			//one of the files --- does not matter -- all starts with the main header then the mediafile
 801a9ac:	4914      	ldr	r1, [pc, #80]	; (801aa00 <scan_files+0x1b8>)
 801a9ae:	4650      	mov	r0, sl
 801a9b0:	f005 fd07 	bl	80203c2 <wcscat>
    						if (GetFileName(new_path)==0)		//filename OK -- otherwise tracknumber overwritten with usable one (hopefully)
 801a9b4:	4650      	mov	r0, sl
 801a9b6:	f001 ff27 	bl	801c808 <GetFileName>
 801a9ba:	2800      	cmp	r0, #0
 801a9bc:	d196      	bne.n	801a8ec <scan_files+0xa4>
    							for(i = 0; i < 255; i++) TrackTable[Total_tracks][i] = rekordbox.file[i];
 801a9be:	465a      	mov	r2, fp
 801a9c0:	f8b8 b000 	ldrh.w	fp, [r8]
 801a9c4:	4813      	ldr	r0, [pc, #76]	; (801aa14 <scan_files+0x1cc>)
 801a9c6:	ebcb 230b 	rsb	r3, fp, fp, lsl #8
    							Total_tracks++;
 801a9ca:	f10b 0b01 	add.w	fp, fp, #1
    							for(i = 0; i < 255; i++) TrackTable[Total_tracks][i] = rekordbox.file[i];
 801a9ce:	4912      	ldr	r1, [pc, #72]	; (801aa18 <scan_files+0x1d0>)
 801a9d0:	4418      	add	r0, r3
 801a9d2:	f005 fb5b 	bl	802008c <memcpy>
    							Total_tracks++;
 801a9d6:	f8a8 b000 	strh.w	fp, [r8]
							f_closedir(&folder);
 801a9da:	e787      	b.n	801a8ec <scan_files+0xa4>
    		f_closedir(&folder);
 801a9dc:	a802      	add	r0, sp, #8
 801a9de:	f7f1 ff69 	bl	800c8b4 <f_closedir>
    return res;
 801a9e2:	7828      	ldrb	r0, [r5, #0]
}
 801a9e4:	f20d 4d5c 	addw	sp, sp, #1116	; 0x45c
 801a9e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    				f_closedir(&folder);
 801a9ec:	a802      	add	r0, sp, #8
 801a9ee:	f7f1 ff61 	bl	800c8b4 <f_closedir>
    				break;  /* Break on error or end of dir */
 801a9f2:	e73c      	b.n	801a86e <scan_files+0x26>
 801a9f4:	2000fa6c 	.word	0x2000fa6c
 801a9f8:	2000ec90 	.word	0x2000ec90
 801a9fc:	08026d28 	.word	0x08026d28
 801aa00:	2000ecd4 	.word	0x2000ecd4
 801aa04:	2000f670 	.word	0x2000f670
 801aa08:	08026d68 	.word	0x08026d68
 801aa0c:	2000f270 	.word	0x2000f270
 801aa10:	200022c4 	.word	0x200022c4
 801aa14:	20008660 	.word	0x20008660
 801aa18:	200158ec 	.word	0x200158ec
 801aa1c:	08026ce4 	.word	0x08026ce4
 801aa20:	200022c0 	.word	0x200022c0
 801aa24:	2000f274 	.word	0x2000f274

0801aa28 <main>:
{
 801aa28:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 801aa2c:	b085      	sub	sp, #20
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 801aa2e:	f240 1501 	movw	r5, #257	; 0x101
  HAL_MPU_Disable();
 801aa32:	f7e6 fbe1 	bl	80011f8 <HAL_MPU_Disable>
  MPU_InitStruct.BaseAddress = 0x00;
 801aa36:	2400      	movs	r4, #0
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801aa38:	2201      	movs	r2, #1
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 801aa3a:	f248 731f 	movw	r3, #34591	; 0x871f
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa3e:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x00;
 801aa40:	9401      	str	r4, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801aa42:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 801aa46:	9302      	str	r3, [sp, #8]
 801aa48:	9503      	str	r5, [sp, #12]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa4a:	f7e6 fbf3 	bl	8001234 <HAL_MPU_ConfigRegion>
  MPU_InitStruct.BaseAddress = 0xC0000000;
 801aa4e:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
  MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 801aa52:	4a90      	ldr	r2, [pc, #576]	; (801ac94 <main+0x26c>)
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa54:	4668      	mov	r0, sp
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801aa56:	f8ad 5000 	strh.w	r5, [sp]
  MPU_InitStruct.BaseAddress = 0xC0000000;
 801aa5a:	9301      	str	r3, [sp, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 801aa5c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 801aa60:	e9cd 2302 	strd	r2, r3, [sp, #8]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa64:	f7e6 fbe6 	bl	8001234 <HAL_MPU_ConfigRegion>
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801aa68:	f240 2301 	movw	r3, #513	; 0x201
  MPU_InitStruct.BaseAddress = 0xA0000000;
 801aa6c:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
  MPU_InitStruct.Size = MPU_REGION_SIZE_8KB;
 801aa70:	4a89      	ldr	r2, [pc, #548]	; (801ac98 <main+0x270>)
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801aa72:	f8ad 3000 	strh.w	r3, [sp]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa76:	4668      	mov	r0, sp
  MPU_InitStruct.Size = MPU_REGION_SIZE_8KB;
 801aa78:	4b88      	ldr	r3, [pc, #544]	; (801ac9c <main+0x274>)
  MPU_InitStruct.BaseAddress = 0xA0000000;
 801aa7a:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_8KB;
 801aa7c:	e9cd 2302 	strd	r2, r3, [sp, #8]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801aa80:	f7e6 fbd8 	bl	8001234 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 801aa84:	2004      	movs	r0, #4
 801aa86:	f7e6 fbc5 	bl	8001214 <HAL_MPU_Enable>
  __ASM volatile ("dsb 0xF":::"memory");
 801aa8a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801aa8e:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 801aa92:	4883      	ldr	r0, [pc, #524]	; (801aca0 <main+0x278>)
 801aa94:	f8c0 4250 	str.w	r4, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 801aa98:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801aa9c:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 801aaa0:	6943      	ldr	r3, [r0, #20]
 801aaa2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 801aaa6:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 801aaa8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801aaac:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 801aab0:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 801aab4:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 801aab8:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 801aabc:	f643 76e0 	movw	r6, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 801aac0:	f3c5 344e 	ubfx	r4, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 801aac4:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 801aac8:	0164      	lsls	r4, r4, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 801aaca:	ea04 0106 	and.w	r1, r4, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 801aace:	462b      	mov	r3, r5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 801aad0:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
      } while (ways-- != 0U);
 801aad4:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 801aad6:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 801aada:	1c5a      	adds	r2, r3, #1
 801aadc:	d1f8      	bne.n	801aad0 <main+0xa8>
    } while(sets-- != 0U);
 801aade:	3c20      	subs	r4, #32
 801aae0:	f114 0f20 	cmn.w	r4, #32
 801aae4:	d1f1      	bne.n	801aaca <main+0xa2>
 801aae6:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 801aaea:	6943      	ldr	r3, [r0, #20]
 801aaec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801aaf0:	6143      	str	r3, [r0, #20]
 801aaf2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801aaf6:	f3bf 8f6f 	isb	sy
  menu_mode=3;
 801aafa:	f8df 9208 	ldr.w	r9, [pc, #520]	; 801ad04 <main+0x2dc>
 801aafe:	2503      	movs	r5, #3
  HAL_Init();
 801ab00:	f7e6 fa98 	bl	8001034 <HAL_Init>
  HAL_LTDC_SetAlpha_NoReload(&hltdc, 0, ActiveLayer++);
 801ab04:	4c67      	ldr	r4, [pc, #412]	; (801aca4 <main+0x27c>)
  SystemClock_Config();
 801ab06:	f7ff fe33 	bl	801a770 <SystemClock_Config>
	  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801ab0a:	4f67      	ldr	r7, [pc, #412]	; (801aca8 <main+0x280>)
  MX_GPIO_Init();
 801ab0c:	f7ff face 	bl	801a0ac <MX_GPIO_Init>
	  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801ab10:	4e66      	ldr	r6, [pc, #408]	; (801acac <main+0x284>)
  MX_DMA_Init();
 801ab12:	f7ff f82b 	bl	8019b6c <MX_DMA_Init>
  MX_LTDC_Init();
 801ab16:	f7ff fca9 	bl	801a46c <MX_LTDC_Init>
  MX_FMC_Init();
 801ab1a:	f7ff f8f5 	bl	8019d08 <MX_FMC_Init>
  MX_SDMMC1_SD_Init();
 801ab1e:	f002 f80f 	bl	801cb40 <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
 801ab22:	f7ff f873 	bl	8019c0c <MX_FATFS_Init>
  MX_DMA2D_Init();
 801ab26:	f7ff f83b 	bl	8019ba0 <MX_DMA2D_Init>
  MX_SAI2_Init();
 801ab2a:	f001 ff51 	bl	801c9d0 <MX_SAI2_Init>
  MX_I2C3_Init();
 801ab2e:	f7ff fc1d 	bl	801a36c <MX_I2C3_Init>
  MX_TIM4_Init();
 801ab32:	f003 fc6d 	bl	801e410 <MX_TIM4_Init>
  MX_TIM6_Init();
 801ab36:	f003 fcdf 	bl	801e4f8 <MX_TIM6_Init>
  MX_TIM7_Init();
 801ab3a:	f003 fd07 	bl	801e54c <MX_TIM7_Init>
  MX_TIM8_Init();
 801ab3e:	f003 fd2f 	bl	801e5a0 <MX_TIM8_Init>
  MX_SPI2_Init();
 801ab42:	f002 f815 	bl	801cb70 <MX_SPI2_Init>
  MX_TIM5_Init();
 801ab46:	f003 fc9d 	bl	801e484 <MX_TIM5_Init>
  MX_TIM9_Init();
 801ab4a:	f003 fd6d 	bl	801e628 <MX_TIM9_Init>
  SDRAM_Init(); // MT48LC4M32B2B5-6A SDRAM initialization
 801ab4e:	f7ff f877 	bl	8019c40 <SDRAM_Init>
  HAL_LTDC_SetAddress(&hltdc, LCD_FB_START_ADDRESS_0, 0); // set layer 0 framebuffer address
 801ab52:	2200      	movs	r2, #0
 801ab54:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
 801ab58:	4855      	ldr	r0, [pc, #340]	; (801acb0 <main+0x288>)
  menu_mode=3;
 801ab5a:	f889 5000 	strb.w	r5, [r9]
  HAL_LTDC_SetAddress(&hltdc, LCD_FB_START_ADDRESS_0, 0); // set layer 0 framebuffer address
 801ab5e:	f7e9 f95d 	bl	8003e1c <HAL_LTDC_SetAddress>
  HAL_LTDC_SetAddress(&hltdc, LCD_FB_START_ADDRESS_1, 1); // set layer 1 framebuffer address
 801ab62:	2201      	movs	r2, #1
 801ab64:	4953      	ldr	r1, [pc, #332]	; (801acb4 <main+0x28c>)
 801ab66:	4852      	ldr	r0, [pc, #328]	; (801acb0 <main+0x288>)
 801ab68:	f7e9 f958 	bl	8003e1c <HAL_LTDC_SetAddress>
  ClearLayer(); // clear framebuffer 0
 801ab6c:	f7f9 fbc6 	bl	80142fc <ClearLayer>
  BSP_LCD_DisplayOn();
 801ab70:	f7ff fda8 	bl	801a6c4 <BSP_LCD_DisplayOn>
  MX_USB_HOST_Init();
 801ab74:	f003 fe6e 	bl	801e854 <MX_USB_HOST_Init>
  HAL_TIM_Base_Start_IT(&htim4); // start display refresh timer
 801ab78:	484f      	ldr	r0, [pc, #316]	; (801acb8 <main+0x290>)
 801ab7a:	f7eb fdf7 	bl	800676c <HAL_TIM_Base_Start_IT>
  HAL_LTDC_SetAlpha_NoReload(&hltdc, 0, ActiveLayer++);
 801ab7e:	7822      	ldrb	r2, [r4, #0]
 801ab80:	2100      	movs	r1, #0
 801ab82:	484b      	ldr	r0, [pc, #300]	; (801acb0 <main+0x288>)
 801ab84:	1c53      	adds	r3, r2, #1
 801ab86:	7023      	strb	r3, [r4, #0]
 801ab88:	f7e9 fa32 	bl	8003ff0 <HAL_LTDC_SetAlpha_NoReload>
  HAL_LTDC_SetAlpha_NoReload(&hltdc, 255, ActiveLayer--);
 801ab8c:	7822      	ldrb	r2, [r4, #0]
 801ab8e:	21ff      	movs	r1, #255	; 0xff
 801ab90:	4847      	ldr	r0, [pc, #284]	; (801acb0 <main+0x288>)
 801ab92:	1e53      	subs	r3, r2, #1
 801ab94:	7023      	strb	r3, [r4, #0]
 801ab96:	f7e9 fa2b 	bl	8003ff0 <HAL_LTDC_SetAlpha_NoReload>
  ChangeLayers();
 801ab9a:	f7f9 fbd9 	bl	8014350 <ChangeLayers>
  ClearLayer(); // clear framebuffer 1
 801ab9e:	4c47      	ldr	r4, [pc, #284]	; (801acbc <main+0x294>)
 801aba0:	f7f9 fbac 	bl	80142fc <ClearLayer>
  dbgAddText("pre init");
 801aba4:	4846      	ldr	r0, [pc, #280]	; (801acc0 <main+0x298>)
 801aba6:	f7fe ff83 	bl	8019ab0 <dbgAddText>
  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801abaa:	493f      	ldr	r1, [pc, #252]	; (801aca8 <main+0x280>)
 801abac:	483f      	ldr	r0, [pc, #252]	; (801acac <main+0x284>)
 801abae:	f003 fe8b 	bl	801e8c8 <MX_USB_HOST_Process>
  dbgAddText("host init");
 801abb2:	4844      	ldr	r0, [pc, #272]	; (801acc4 <main+0x29c>)
 801abb4:	f7fe ff7c 	bl	8019ab0 <dbgAddText>
  while(((BSP_SD_IsDetected() != SD_PRESENT))&&(Appli_FS_state != APPLICATION_READY)){   //&&(Appli_FS_state != APPLICATION_START))   {
 801abb8:	e00a      	b.n	801abd0 <main+0x1a8>
 801abba:	7823      	ldrb	r3, [r4, #0]
 801abbc:	2b02      	cmp	r3, #2
 801abbe:	d00b      	beq.n	801abd8 <main+0x1b0>
	  menu_mode = 3;
 801abc0:	f889 5000 	strb.w	r5, [r9]
	  BSP_LCD_DisplayOn();
 801abc4:	f7ff fd7e 	bl	801a6c4 <BSP_LCD_DisplayOn>
	  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801abc8:	4639      	mov	r1, r7
 801abca:	4630      	mov	r0, r6
 801abcc:	f003 fe7c 	bl	801e8c8 <MX_USB_HOST_Process>
  while(((BSP_SD_IsDetected() != SD_PRESENT))&&(Appli_FS_state != APPLICATION_READY)){   //&&(Appli_FS_state != APPLICATION_START))   {
 801abd0:	f7f9 f900 	bl	8013dd4 <BSP_SD_IsDetected>
 801abd4:	2801      	cmp	r0, #1
 801abd6:	d1f0      	bne.n	801abba <main+0x192>
  dbgAddText("post usb");
 801abd8:	483b      	ldr	r0, [pc, #236]	; (801acc8 <main+0x2a0>)
 801abda:	f7fe ff69 	bl	8019ab0 <dbgAddText>
  BSP_TS_Init(480, 272); // touchscreen initialization
 801abde:	f44f 7188 	mov.w	r1, #272	; 0x110
 801abe2:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
 801abe6:	f002 fa61 	bl	801d0ac <BSP_TS_Init>
  BSP_TS_ITClear();
 801abea:	f002 fbb7 	bl	801d35c <BSP_TS_ITClear>
  BSP_TS_ITConfig();
 801abee:	f002 fa87 	bl	801d100 <BSP_TS_ITConfig>
  if (BSP_SD_IsDetected() == SD_PRESENT){
 801abf2:	f7f9 f8ef 	bl	8013dd4 <BSP_SD_IsDetected>
 801abf6:	2801      	cmp	r0, #1
 801abf8:	f000 8115 	beq.w	801ae26 <main+0x3fe>
  else if ((Appli_FS_state != APPLICATION_READY)) //&& (Appli_FS_state != APPLICATION_START))   //shouldn't be true if it got here, but just to be safe  --- USB already mounts
 801abfc:	7823      	ldrb	r3, [r4, #0]
 801abfe:	2b02      	cmp	r3, #2
 801ac00:	d00c      	beq.n	801ac1c <main+0x1f4>
	  menu_mode = 3;
 801ac02:	2303      	movs	r3, #3
 801ac04:	f889 3000 	strb.w	r3, [r9]
	  BSP_LCD_DisplayOn();
 801ac08:	f7ff fd5c 	bl	801a6c4 <BSP_LCD_DisplayOn>
	  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801ac0c:	4827      	ldr	r0, [pc, #156]	; (801acac <main+0x284>)
 801ac0e:	4926      	ldr	r1, [pc, #152]	; (801aca8 <main+0x280>)
 801ac10:	f003 fe5a 	bl	801e8c8 <MX_USB_HOST_Process>
	  dbgAddText("usb halt");
 801ac14:	482d      	ldr	r0, [pc, #180]	; (801accc <main+0x2a4>)
 801ac16:	f7fe ff4b 	bl	8019ab0 <dbgAddText>
	  while(1);
 801ac1a:	e7fe      	b.n	801ac1a <main+0x1f2>
  	  f_mount(&USBHFatFs, (const TCHAR*)USBHPath, 0); // USB disk mount
 801ac1c:	2200      	movs	r2, #0
 801ac1e:	4922      	ldr	r1, [pc, #136]	; (801aca8 <main+0x280>)
 801ac20:	4822      	ldr	r0, [pc, #136]	; (801acac <main+0x284>)
 801ac22:	f7f1 f9cb 	bl	800bfbc <f_mount>
  hMP3Decoder = MP3InitDecoder(); // mp3 decoder initialization
 801ac26:	f7f1 ff11 	bl	800ca4c <MP3InitDecoder>
 801ac2a:	4b29      	ldr	r3, [pc, #164]	; (801acd0 <main+0x2a8>)
 801ac2c:	4602      	mov	r2, r0
  dbgAddText("pre scan");
 801ac2e:	4829      	ldr	r0, [pc, #164]	; (801acd4 <main+0x2ac>)
	  fr = 0;
 801ac30:	2700      	movs	r7, #0
 801ac32:	4c29      	ldr	r4, [pc, #164]	; (801acd8 <main+0x2b0>)
  hMP3Decoder = MP3InitDecoder(); // mp3 decoder initialization
 801ac34:	601a      	str	r2, [r3, #0]
  dbgAddText("pre scan");
 801ac36:	f7fe ff3b 	bl	8019ab0 <dbgAddText>
  scan_files(); // get total track number
 801ac3a:	f7ff fe05 	bl	801a848 <scan_files>
  dbgAddText("post scan");
 801ac3e:	4827      	ldr	r0, [pc, #156]	; (801acdc <main+0x2b4>)
 801ac40:	f7fe ff36 	bl	8019ab0 <dbgAddText>
  HAL_TIM_Base_Start_IT(&htim5); // start jog speed counting timer
 801ac44:	4826      	ldr	r0, [pc, #152]	; (801ace0 <main+0x2b8>)
 801ac46:	f7eb fd91 	bl	800676c <HAL_TIM_Base_Start_IT>
  HAL_SPI_TransmitReceive_IT(&hspi2, spi_tx, spi_rx, 4);
 801ac4a:	2304      	movs	r3, #4
 801ac4c:	4a25      	ldr	r2, [pc, #148]	; (801ace4 <main+0x2bc>)
 801ac4e:	f5a4 5b80 	sub.w	fp, r4, #4096	; 0x1000
 801ac52:	4925      	ldr	r1, [pc, #148]	; (801ace8 <main+0x2c0>)
 801ac54:	4825      	ldr	r0, [pc, #148]	; (801acec <main+0x2c4>)
 801ac56:	f7eb f9fd 	bl	8006054 <HAL_SPI_TransmitReceive_IT>
  BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_HEADPHONE, volume, (uint32_t)(AUDIO_FREQUENCY_22K)*(1 + trak.percent));
 801ac5a:	4a25      	ldr	r2, [pc, #148]	; (801acf0 <main+0x2c8>)
 801ac5c:	eddf 7a25 	vldr	s15, [pc, #148]	; 801acf4 <main+0x2cc>
 801ac60:	2002      	movs	r0, #2
 801ac62:	ed92 7a01 	vldr	s14, [r2, #4]
 801ac66:	4b24      	ldr	r3, [pc, #144]	; (801acf8 <main+0x2d0>)
 801ac68:	ee47 7a27 	vmla.f32	s15, s14, s15
 801ac6c:	4e23      	ldr	r6, [pc, #140]	; (801acfc <main+0x2d4>)
 801ac6e:	7819      	ldrb	r1, [r3, #0]
 801ac70:	f8df a094 	ldr.w	sl, [pc, #148]	; 801ad08 <main+0x2e0>
 801ac74:	4d22      	ldr	r5, [pc, #136]	; (801ad00 <main+0x2d8>)
	  res = f_open(&MyFile, rekordbox.filename, FA_READ);
 801ac76:	f8df 8094 	ldr.w	r8, [pc, #148]	; 801ad0c <main+0x2e4>
  BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_HEADPHONE, volume, (uint32_t)(AUDIO_FREQUENCY_22K)*(1 + trak.percent));
 801ac7a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ac7e:	ee17 2a90 	vmov	r2, s15
 801ac82:	f001 fff3 	bl	801cc6c <BSP_AUDIO_OUT_Init>
  BSP_AUDIO_OUT_SetVolume(0);
 801ac86:	4638      	mov	r0, r7
 801ac88:	f002 f8ca 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
  BSP_LCD_DisplayOn();
 801ac8c:	f7ff fd1a 	bl	801a6c4 <BSP_LCD_DisplayOn>
 801ac90:	e043      	b.n	801ad1a <main+0x2f2>
 801ac92:	bf00      	nop
 801ac94:	03000016 	.word	0x03000016
 801ac98:	0300000c 	.word	0x0300000c
 801ac9c:	01000101 	.word	0x01000101
 801aca0:	e000ed00 	.word	0xe000ed00
 801aca4:	20000e2c 	.word	0x20000e2c
 801aca8:	20000cd8 	.word	0x20000cd8
 801acac:	2000ea00 	.word	0x2000ea00
 801acb0:	20000d84 	.word	0x20000d84
 801acb4:	c0080000 	.word	0xc0080000
 801acb8:	20018b84 	.word	0x20018b84
 801acbc:	20018d04 	.word	0x20018d04
 801acc0:	08026d70 	.word	0x08026d70
 801acc4:	08026d7c 	.word	0x08026d7c
 801acc8:	08026d88 	.word	0x08026d88
 801accc:	08026da0 	.word	0x08026da0
 801acd0:	2000f0dc 	.word	0x2000f0dc
 801acd4:	08026dac 	.word	0x08026dac
 801acd8:	200184f0 	.word	0x200184f0
 801acdc:	08026db8 	.word	0x08026db8
 801ace0:	20018bc4 	.word	0x20018bc4
 801ace4:	2000fa74 	.word	0x2000fa74
 801ace8:	20000058 	.word	0x20000058
 801acec:	20018a40 	.word	0x20018a40
 801acf0:	2000fa7c 	.word	0x2000fa7c
 801acf4:	46ac4400 	.word	0x46ac4400
 801acf8:	2000005c 	.word	0x2000005c
 801acfc:	2000ec8c 	.word	0x2000ec8c
 801ad00:	2000e9fc 	.word	0x2000e9fc
 801ad04:	20000c8c 	.word	0x20000c8c
 801ad08:	20000c70 	.word	0x20000c70
 801ad0c:	20001e40 	.word	0x20001e40
	  if(Track_number >= Total_tracks) Track_number = 0;
 801ad10:	602f      	str	r7, [r5, #0]
	  MX_USB_HOST_Process(&USBHFatFs, (const TCHAR*)USBHPath);
 801ad12:	4949      	ldr	r1, [pc, #292]	; (801ae38 <main+0x410>)
 801ad14:	4849      	ldr	r0, [pc, #292]	; (801ae3c <main+0x414>)
 801ad16:	f003 fdd7 	bl	801e8c8 <MX_USB_HOST_Process>
	  find_file(Track_number);
 801ad1a:	f7ff fced 	bl	801a6f8 <find_file.constprop.0.isra.0>
	  fr = 0;
 801ad1e:	4b48      	ldr	r3, [pc, #288]	; (801ae40 <main+0x418>)
	  DecodeRekordboxFiles(new_path);
 801ad20:	4848      	ldr	r0, [pc, #288]	; (801ae44 <main+0x41c>)
	  fr = 0;
 801ad22:	801f      	strh	r7, [r3, #0]
	  sec = 0;
 801ad24:	4b48      	ldr	r3, [pc, #288]	; (801ae48 <main+0x420>)
	  file_pos_wide = 0;
 801ad26:	6037      	str	r7, [r6, #0]
	  sec = 0;
 801ad28:	701f      	strb	r7, [r3, #0]
	  min = 0;
 801ad2a:	4b48      	ldr	r3, [pc, #288]	; (801ae4c <main+0x424>)
	  rekordbox.state = 0;
 801ad2c:	f884 73d4 	strb.w	r7, [r4, #980]	; 0x3d4
	  min = 0;
 801ad30:	701f      	strb	r7, [r3, #0]
	  rfr = 0;
 801ad32:	4b47      	ldr	r3, [pc, #284]	; (801ae50 <main+0x428>)
	  display.loop = 0;
 801ad34:	f88a 7010 	strb.w	r7, [sl, #16]
	  rfr = 0;
 801ad38:	801f      	strh	r7, [r3, #0]
	  rsec = 0;
 801ad3a:	4b46      	ldr	r3, [pc, #280]	; (801ae54 <main+0x42c>)
	  rekordbox.currentcue = 0;
 801ad3c:	f8c4 73d0 	str.w	r7, [r4, #976]	; 0x3d0
	  rsec = 0;
 801ad40:	701f      	strb	r7, [r3, #0]
	  rmin = 0;
 801ad42:	4b45      	ldr	r3, [pc, #276]	; (801ae58 <main+0x430>)
 801ad44:	701f      	strb	r7, [r3, #0]
	  position = 0;
 801ad46:	4b45      	ldr	r3, [pc, #276]	; (801ae5c <main+0x434>)
 801ad48:	601f      	str	r7, [r3, #0]
	  if(display.cuemode == 1) rekordbox.autocue = 1;
 801ad4a:	f89a 3002 	ldrb.w	r3, [sl, #2]
 801ad4e:	f1a3 0301 	sub.w	r3, r3, #1
 801ad52:	fab3 f383 	clz	r3, r3
 801ad56:	095b      	lsrs	r3, r3, #5
 801ad58:	f884 33cc 	strb.w	r3, [r4, #972]	; 0x3cc
	  DecodeRekordboxFiles(new_path);
 801ad5c:	f000 fb8a 	bl	801b474 <DecodeRekordboxFiles>
	  bar = 0;
 801ad60:	4b3f      	ldr	r3, [pc, #252]	; (801ae60 <main+0x438>)
	  res = f_open(&MyFile, rekordbox.filename, FA_READ);
 801ad62:	2201      	movs	r2, #1
 801ad64:	493f      	ldr	r1, [pc, #252]	; (801ae64 <main+0x43c>)
 801ad66:	4640      	mov	r0, r8
	  bar = 0;
 801ad68:	601f      	str	r7, [r3, #0]
	  beat = 0;
 801ad6a:	4b3f      	ldr	r3, [pc, #252]	; (801ae68 <main+0x440>)
	  menu_mode = 0;
 801ad6c:	f889 7000 	strb.w	r7, [r9]
	  beat = 0;
 801ad70:	601f      	str	r7, [r3, #0]
	  res = f_open(&MyFile, rekordbox.filename, FA_READ);
 801ad72:	f7f1 f95d 	bl	800c030 <f_open>
 801ad76:	4b3d      	ldr	r3, [pc, #244]	; (801ae6c <main+0x444>)
 801ad78:	7018      	strb	r0, [r3, #0]
	  if(res == FR_OK)
 801ad7a:	2800      	cmp	r0, #0
 801ad7c:	d132      	bne.n	801ade4 <main+0x3bc>
		  trak.state = PLAYING;
 801ad7e:	4b3c      	ldr	r3, [pc, #240]	; (801ae70 <main+0x448>)
		  if(rekordbox.autocue == 2) spi_tx[2] &= ~(1 << 1);
 801ad80:	f894 23cc 	ldrb.w	r2, [r4, #972]	; 0x3cc
		  trak.state = PLAYING;
 801ad84:	701f      	strb	r7, [r3, #0]
		  if(rekordbox.autocue == 2) spi_tx[2] &= ~(1 << 1);
 801ad86:	2a02      	cmp	r2, #2
		  spi_tx[2] &= ~(1 << 0);
 801ad88:	4b3a      	ldr	r3, [pc, #232]	; (801ae74 <main+0x44c>)
 801ad8a:	789b      	ldrb	r3, [r3, #2]
		  if(rekordbox.autocue == 2) spi_tx[2] &= ~(1 << 1);
 801ad8c:	d048      	beq.n	801ae20 <main+0x3f8>
		  spi_tx[2] &= ~(1 << 0);
 801ad8e:	f023 0301 	bic.w	r3, r3, #1
		  else spi_tx[2] |= (1 << 1);
 801ad92:	f043 0302 	orr.w	r3, r3, #2
		  spi_tx[2] &= ~(1 << 3);
 801ad96:	f023 0308 	bic.w	r3, r3, #8
 801ad9a:	4a36      	ldr	r2, [pc, #216]	; (801ae74 <main+0x44c>)
		  if((strcmp(rekordbox.filetype, ".wav") == 0) || (strcmp(rekordbox.filetype, ".WAV") == 0)) {
 801ad9c:	4936      	ldr	r1, [pc, #216]	; (801ae78 <main+0x450>)
 801ad9e:	4837      	ldr	r0, [pc, #220]	; (801ae7c <main+0x454>)
		  spi_tx[2] &= ~(1 << 3);
 801ada0:	7093      	strb	r3, [r2, #2]
		  if((strcmp(rekordbox.filetype, ".wav") == 0) || (strcmp(rekordbox.filetype, ".WAV") == 0)) {
 801ada2:	f7e5 fa35 	bl	8000210 <strcmp>
 801ada6:	b120      	cbz	r0, 801adb2 <main+0x38a>
 801ada8:	4935      	ldr	r1, [pc, #212]	; (801ae80 <main+0x458>)
 801adaa:	4834      	ldr	r0, [pc, #208]	; (801ae7c <main+0x454>)
 801adac:	f7e5 fa30 	bl	8000210 <strcmp>
 801adb0:	b908      	cbnz	r0, 801adb6 <main+0x38e>
			  PlayWavFile();
 801adb2:	f004 fa15 	bl	801f1e0 <PlayWavFile>
		  if((strcmp(rekordbox.filetype, ".mp3") == 0) || (strcmp(rekordbox.filetype, ".MP3") == 0)) {
 801adb6:	4933      	ldr	r1, [pc, #204]	; (801ae84 <main+0x45c>)
 801adb8:	4830      	ldr	r0, [pc, #192]	; (801ae7c <main+0x454>)
 801adba:	f7e5 fa29 	bl	8000210 <strcmp>
 801adbe:	b120      	cbz	r0, 801adca <main+0x3a2>
 801adc0:	4931      	ldr	r1, [pc, #196]	; (801ae88 <main+0x460>)
 801adc2:	482e      	ldr	r0, [pc, #184]	; (801ae7c <main+0x454>)
 801adc4:	f7e5 fa24 	bl	8000210 <strcmp>
 801adc8:	b908      	cbnz	r0, 801adce <main+0x3a6>
			  PlayMp3File();
 801adca:	f000 f9c9 	bl	801b160 <PlayMp3File>
		  spi_tx[2] |= (1 << 3);
 801adce:	4a29      	ldr	r2, [pc, #164]	; (801ae74 <main+0x44c>)
		  BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 801add0:	2002      	movs	r0, #2
		  spi_tx[2] |= (1 << 3);
 801add2:	7893      	ldrb	r3, [r2, #2]
 801add4:	f043 0308 	orr.w	r3, r3, #8
 801add8:	7093      	strb	r3, [r2, #2]
		  trak.state = STOPPED;
 801adda:	2301      	movs	r3, #1
 801addc:	4a24      	ldr	r2, [pc, #144]	; (801ae70 <main+0x448>)
 801adde:	7013      	strb	r3, [r2, #0]
		  BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 801ade0:	f002 f802 	bl	801cde8 <BSP_AUDIO_OUT_Stop>
	  if(file_pos_wide >= rekordbox.spectrum_size) {
 801ade4:	f8db 2a8c 	ldr.w	r2, [fp, #2700]	; 0xa8c
 801ade8:	6833      	ldr	r3, [r6, #0]
 801adea:	429a      	cmp	r2, r3
 801adec:	d802      	bhi.n	801adf4 <main+0x3cc>
		  Track_number++;
 801adee:	682b      	ldr	r3, [r5, #0]
 801adf0:	3301      	adds	r3, #1
 801adf2:	602b      	str	r3, [r5, #0]
	  menu_mode = 4;
 801adf4:	2304      	movs	r3, #4
	  f_close(&MyFile);
 801adf6:	4640      	mov	r0, r8
	  file_pos_wide = 0;
 801adf8:	6037      	str	r7, [r6, #0]
	  menu_mode = 4;
 801adfa:	f889 3000 	strb.w	r3, [r9]
	  f_close(&MyFile);
 801adfe:	f7f1 fa8d 	bl	800c31c <f_close>
	  f_closedir(&dir);
 801ae02:	4822      	ldr	r0, [pc, #136]	; (801ae8c <main+0x464>)
 801ae04:	f7f1 fd56 	bl	800c8b4 <f_closedir>
	  if(Track_number >= Total_tracks) Track_number = 0;
 801ae08:	4b21      	ldr	r3, [pc, #132]	; (801ae90 <main+0x468>)
 801ae0a:	682a      	ldr	r2, [r5, #0]
 801ae0c:	881b      	ldrh	r3, [r3, #0]
 801ae0e:	4293      	cmp	r3, r2
 801ae10:	f77f af7e 	ble.w	801ad10 <main+0x2e8>
	  if(Track_number < 0) Track_number = Total_tracks - 1;
 801ae14:	2a00      	cmp	r2, #0
 801ae16:	f6bf af7c 	bge.w	801ad12 <main+0x2ea>
 801ae1a:	3b01      	subs	r3, #1
 801ae1c:	602b      	str	r3, [r5, #0]
 801ae1e:	e778      	b.n	801ad12 <main+0x2ea>
		  if(rekordbox.autocue == 2) spi_tx[2] &= ~(1 << 1);
 801ae20:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 801ae24:	e7b7      	b.n	801ad96 <main+0x36e>
	  dbgAddText("sd present");
 801ae26:	481b      	ldr	r0, [pc, #108]	; (801ae94 <main+0x46c>)
 801ae28:	f7fe fe42 	bl	8019ab0 <dbgAddText>
  	  f_mount(&SDFatFs, (const TCHAR*)SDPath, 0); // SD card disk mount
 801ae2c:	2200      	movs	r2, #0
 801ae2e:	491a      	ldr	r1, [pc, #104]	; (801ae98 <main+0x470>)
 801ae30:	481a      	ldr	r0, [pc, #104]	; (801ae9c <main+0x474>)
 801ae32:	f7f1 f8c3 	bl	800bfbc <f_mount>
 801ae36:	e6f6      	b.n	801ac26 <main+0x1fe>
 801ae38:	20000cd8 	.word	0x20000cd8
 801ae3c:	2000ea00 	.word	0x2000ea00
 801ae40:	2000f0d8 	.word	0x2000f0d8
 801ae44:	2000f274 	.word	0x2000f274
 801ae48:	2000fa72 	.word	0x2000fa72
 801ae4c:	2000f270 	.word	0x2000f270
 801ae50:	2000fa6e 	.word	0x2000fa6e
 801ae54:	2000fa71 	.word	0x2000fa71
 801ae58:	2000fa70 	.word	0x2000fa70
 801ae5c:	20000c90 	.word	0x20000c90
 801ae60:	20000c60 	.word	0x20000c60
 801ae64:	200154f0 	.word	0x200154f0
 801ae68:	20000c64 	.word	0x20000c64
 801ae6c:	2000fa6c 	.word	0x2000fa6c
 801ae70:	2000fa7c 	.word	0x2000fa7c
 801ae74:	20000058 	.word	0x20000058
 801ae78:	08026dc4 	.word	0x08026dc4
 801ae7c:	200159eb 	.word	0x200159eb
 801ae80:	08026dcc 	.word	0x08026dcc
 801ae84:	08026dd4 	.word	0x08026dd4
 801ae88:	08026ddc 	.word	0x08026ddc
 801ae8c:	2000ec38 	.word	0x2000ec38
 801ae90:	200022c0 	.word	0x200022c0
 801ae94:	08026d94 	.word	0x08026d94
 801ae98:	20000cd4 	.word	0x20000cd4
 801ae9c:	20002090 	.word	0x20002090

0801aea0 <Error_Handler>:
  while(1)
 801aea0:	e7fe      	b.n	801aea0 <Error_Handler>
 801aea2:	bf00      	nop

0801aea4 <assert_failed>:
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 801aea4:	4770      	bx	lr
 801aea6:	bf00      	nop

0801aea8 <Mp3ReadId3V2Text>:
/*
 * Taken from
 * http://www.mikrocontroller.net/topic/252319
 */
uint32_t Mp3ReadId3V2Text(FIL* pInFile, uint32_t unDataLen, char* pszBuffer, uint32_t unBufferSize)
{
 801aea8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801aeaa:	461c      	mov	r4, r3
 801aeac:	b083      	sub	sp, #12
	UINT unRead = 0;
 801aeae:	2300      	movs	r3, #0
{
 801aeb0:	460d      	mov	r5, r1
 801aeb2:	4617      	mov	r7, r2
	BYTE byEncoding = 0;
	if((f_read(pInFile, &byEncoding, 1, &unRead) == FR_OK) && (unRead == 1))
 801aeb4:	f10d 0103 	add.w	r1, sp, #3
	UINT unRead = 0;
 801aeb8:	9301      	str	r3, [sp, #4]
	if((f_read(pInFile, &byEncoding, 1, &unRead) == FR_OK) && (unRead == 1))
 801aeba:	2201      	movs	r2, #1
	BYTE byEncoding = 0;
 801aebc:	f88d 3003 	strb.w	r3, [sp, #3]
	if((f_read(pInFile, &byEncoding, 1, &unRead) == FR_OK) && (unRead == 1))
 801aec0:	ab01      	add	r3, sp, #4
{
 801aec2:	4606      	mov	r6, r0
	if((f_read(pInFile, &byEncoding, 1, &unRead) == FR_OK) && (unRead == 1))
 801aec4:	f7f1 f916 	bl	800c0f4 <f_read>
 801aec8:	b910      	cbnz	r0, 801aed0 <Mp3ReadId3V2Text+0x28>
 801aeca:	9b01      	ldr	r3, [sp, #4]
 801aecc:	2b01      	cmp	r3, #1
 801aece:	d002      	beq.n	801aed6 <Mp3ReadId3V2Text+0x2e>
			}
		}
	}
	else
	{
		return 1;
 801aed0:	2001      	movs	r0, #1
	}
	return 0;
}
 801aed2:	b003      	add	sp, #12
 801aed4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unDataLen--;
 801aed6:	3d01      	subs	r5, #1
		if(unDataLen <= (unBufferSize - 1))
 801aed8:	1e63      	subs	r3, r4, #1
 801aeda:	42ab      	cmp	r3, r5
 801aedc:	d30f      	bcc.n	801aefe <Mp3ReadId3V2Text+0x56>
			if((f_read(pInFile, pszBuffer, unDataLen, &unRead) == FR_OK) ||
 801aede:	ab01      	add	r3, sp, #4
 801aee0:	462a      	mov	r2, r5
 801aee2:	4630      	mov	r0, r6
 801aee4:	4639      	mov	r1, r7
 801aee6:	f7f1 f905 	bl	800c0f4 <f_read>
 801aeea:	b110      	cbz	r0, 801aef2 <Mp3ReadId3V2Text+0x4a>
 801aeec:	9b01      	ldr	r3, [sp, #4]
 801aeee:	42ab      	cmp	r3, r5
 801aef0:	d1ee      	bne.n	801aed0 <Mp3ReadId3V2Text+0x28>
				if(byEncoding == 0)
 801aef2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801aef6:	b97b      	cbnz	r3, 801af18 <Mp3ReadId3V2Text+0x70>
	return 0;
 801aef8:	4618      	mov	r0, r3
					pszBuffer[unDataLen] = 0;
 801aefa:	557b      	strb	r3, [r7, r5]
 801aefc:	e7e9      	b.n	801aed2 <Mp3ReadId3V2Text+0x2a>
			if(f_lseek(pInFile, f_tell(pInFile) + unDataLen) != FR_OK)
 801aefe:	e9d6 230e 	ldrd	r2, r3, [r6, #56]	; 0x38
 801af02:	4630      	mov	r0, r6
 801af04:	18aa      	adds	r2, r5, r2
 801af06:	f143 0300 	adc.w	r3, r3, #0
 801af0a:	f7f1 fa1f 	bl	800c34c <f_lseek>
 801af0e:	3800      	subs	r0, #0
 801af10:	bf18      	it	ne
 801af12:	2001      	movne	r0, #1
}
 801af14:	b003      	add	sp, #12
 801af16:	bdf0      	pop	{r4, r5, r6, r7, pc}
				else if(byEncoding == 1)
 801af18:	2b01      	cmp	r3, #1
 801af1a:	d001      	beq.n	801af20 <Mp3ReadId3V2Text+0x78>
	return 0;
 801af1c:	2000      	movs	r0, #0
 801af1e:	e7d8      	b.n	801aed2 <Mp3ReadId3V2Text+0x2a>
					if((unDataLen > 2) && (pszBuffer[0] == 0xFF) && (pszBuffer[1] == 0xFE))
 801af20:	2d02      	cmp	r5, #2
 801af22:	d902      	bls.n	801af2a <Mp3ReadId3V2Text+0x82>
 801af24:	783b      	ldrb	r3, [r7, #0]
 801af26:	2bff      	cmp	r3, #255	; 0xff
 801af28:	d011      	beq.n	801af4e <Mp3ReadId3V2Text+0xa6>
					for(; r < unDataLen; r += 2, w += 1)
 801af2a:	b165      	cbz	r5, 801af46 <Mp3ReadId3V2Text+0x9e>
 801af2c:	2200      	movs	r2, #0
 801af2e:	1e79      	subs	r1, r7, #1
						pszBuffer[w] = pszBuffer[r];
 801af30:	5cb8      	ldrb	r0, [r7, r2]
 801af32:	460b      	mov	r3, r1
					for(; r < unDataLen; r += 2, w += 1)
 801af34:	3202      	adds	r2, #2
 801af36:	3302      	adds	r3, #2
						pszBuffer[w] = pszBuffer[r];
 801af38:	f801 0f01 	strb.w	r0, [r1, #1]!
					for(; r < unDataLen; r += 2, w += 1)
 801af3c:	4295      	cmp	r5, r2
 801af3e:	eba3 0307 	sub.w	r3, r3, r7
 801af42:	d8f5      	bhi.n	801af30 <Mp3ReadId3V2Text+0x88>
					pszBuffer[w] = 0;
 801af44:	441f      	add	r7, r3
 801af46:	2300      	movs	r3, #0
	return 0;
 801af48:	4618      	mov	r0, r3
					pszBuffer[w] = 0;
 801af4a:	703b      	strb	r3, [r7, #0]
 801af4c:	e7c1      	b.n	801aed2 <Mp3ReadId3V2Text+0x2a>
					if((unDataLen > 2) && (pszBuffer[0] == 0xFF) && (pszBuffer[1] == 0xFE))
 801af4e:	787b      	ldrb	r3, [r7, #1]
 801af50:	2bfe      	cmp	r3, #254	; 0xfe
 801af52:	d1ea      	bne.n	801af2a <Mp3ReadId3V2Text+0x82>
						r = 2;
 801af54:	2202      	movs	r2, #2
 801af56:	e7ea      	b.n	801af2e <Mp3ReadId3V2Text+0x86>

0801af58 <Mp3ReadId3V2Tag>:
/*
 * Taken from
 * http://www.mikrocontroller.net/topic/252319
 */
uint32_t Mp3ReadId3V2Tag(FIL* pInFile, char* pszArtist, uint32_t unArtistSize, char* pszTitle, uint32_t unTitleSize)
{
 801af58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801af5c:	461d      	mov	r5, r3
 801af5e:	b08d      	sub	sp, #52	; 0x34
	pszArtist[0] = 0;
 801af60:	2300      	movs	r3, #0
{
 801af62:	460c      	mov	r4, r1
 801af64:	4617      	mov	r7, r2
	pszTitle[0] = 0;

	BYTE id3hd[10];
	UINT unRead = 0;
	// read ID3 tag header (10 bytes)
	if((f_read(pInFile, id3hd, 10, &unRead) != FR_OK) || (unRead != 10))
 801af66:	220a      	movs	r2, #10
	pszArtist[0] = 0;
 801af68:	700b      	strb	r3, [r1, #0]
	if((f_read(pInFile, id3hd, 10, &unRead) != FR_OK) || (unRead != 10))
 801af6a:	a906      	add	r1, sp, #24
	pszTitle[0] = 0;
 801af6c:	702b      	strb	r3, [r5, #0]
{
 801af6e:	4606      	mov	r6, r0
	UINT unRead = 0;
 801af70:	9303      	str	r3, [sp, #12]
	if((f_read(pInFile, id3hd, 10, &unRead) != FR_OK) || (unRead != 10))
 801af72:	ab03      	add	r3, sp, #12
 801af74:	f7f1 f8be 	bl	800c0f4 <f_read>
 801af78:	b910      	cbnz	r0, 801af80 <Mp3ReadId3V2Tag+0x28>
 801af7a:	9b03      	ldr	r3, [sp, #12]
 801af7c:	2b0a      	cmp	r3, #10
 801af7e:	d003      	beq.n	801af88 <Mp3ReadId3V2Tag+0x30>
	{
		return 1;
 801af80:	2001      	movs	r0, #1
			return 1;
		}
	}

	return 0;
}
 801af82:	b00d      	add	sp, #52	; 0x34
 801af84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if((unRead == 10) &&
 801af88:	f89d 2018 	ldrb.w	r2, [sp, #24]
		id3tagsize = 0;
 801af8c:	4b70      	ldr	r3, [pc, #448]	; (801b150 <Mp3ReadId3V2Tag+0x1f8>)
		if((unRead == 10) &&
 801af8e:	2a49      	cmp	r2, #73	; 0x49
		id3tagsize = 0;
 801af90:	6018      	str	r0, [r3, #0]
		if((unRead == 10) &&
 801af92:	d107      	bne.n	801afa4 <Mp3ReadId3V2Tag+0x4c>
				(id3hd[0] == 'I') &&
 801af94:	f89d 2019 	ldrb.w	r2, [sp, #25]
 801af98:	2a44      	cmp	r2, #68	; 0x44
 801af9a:	d103      	bne.n	801afa4 <Mp3ReadId3V2Tag+0x4c>
				(id3hd[1] == 'D') &&
 801af9c:	f89d 201a 	ldrb.w	r2, [sp, #26]
 801afa0:	2a33      	cmp	r2, #51	; 0x33
 801afa2:	d00a      	beq.n	801afba <Mp3ReadId3V2Tag+0x62>
 801afa4:	4602      	mov	r2, r0
 801afa6:	4603      	mov	r3, r0
		if(f_lseek(pInFile, unSkip) != FR_OK)
 801afa8:	4630      	mov	r0, r6
 801afaa:	f7f1 f9cf 	bl	800c34c <f_lseek>
 801afae:	3800      	subs	r0, #0
 801afb0:	bf18      	it	ne
 801afb2:	2001      	movne	r0, #1
}
 801afb4:	b00d      	add	sp, #52	; 0x34
 801afb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			unSkip = ((id3hd[6] & 0x7f) << 21) | ((id3hd[7] & 0x7f) << 14) | ((id3hd[8] & 0x7f) << 7) | (id3hd[9] & 0x7f);
 801afba:	f89d 201e 	ldrb.w	r2, [sp, #30]
				f_read(pInFile, exhd, 4, &unRead);
 801afbe:	f10d 0924 	add.w	r9, sp, #36	; 0x24
			unSkip = ((id3hd[6] & 0x7f) << 21) | ((id3hd[7] & 0x7f) << 14) | ((id3hd[8] & 0x7f) << 7) | (id3hd[9] & 0x7f);
 801afc2:	f89d 101f 	ldrb.w	r1, [sp, #31]
 801afc6:	0552      	lsls	r2, r2, #21
 801afc8:	0389      	lsls	r1, r1, #14
 801afca:	f002 627e 	and.w	r2, r2, #266338304	; 0xfe00000
 801afce:	f401 11fe 	and.w	r1, r1, #2080768	; 0x1fc000
 801afd2:	430a      	orrs	r2, r1
 801afd4:	f89d 1021 	ldrb.w	r1, [sp, #33]	; 0x21
 801afd8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 801afdc:	430a      	orrs	r2, r1
 801afde:	f89d 1020 	ldrb.w	r1, [sp, #32]
 801afe2:	01c9      	lsls	r1, r1, #7
 801afe4:	f401 517e 	and.w	r1, r1, #16256	; 0x3f80
 801afe8:	430a      	orrs	r2, r1
			id3tagsize = unSkip;
 801afea:	601a      	str	r2, [r3, #0]
			if(id3hd[5] & 0x40)
 801afec:	f89d 301d 	ldrb.w	r3, [sp, #29]
			unSkip = ((id3hd[6] & 0x7f) << 21) | ((id3hd[7] & 0x7f) << 14) | ((id3hd[8] & 0x7f) << 7) | (id3hd[9] & 0x7f);
 801aff0:	9201      	str	r2, [sp, #4]
			if(id3hd[5] & 0x40)
 801aff2:	065b      	lsls	r3, r3, #25
			uint8_t unVersion = id3hd[3];
 801aff4:	f89d 201b 	ldrb.w	r2, [sp, #27]
 801aff8:	9200      	str	r2, [sp, #0]
			if(id3hd[5] & 0x40)
 801affa:	d47f      	bmi.n	801b0fc <Mp3ReadId3V2Tag+0x1a4>
{
 801affc:	f04f 0a02 	mov.w	sl, #2
				if(strcmp(szFrameId, "TPE1") == 0)
 801b000:	f8df b158 	ldr.w	fp, [pc, #344]	; 801b15c <Mp3ReadId3V2Tag+0x204>
				if((f_read(pInFile, frhd, 10, &unRead) != FR_OK) || (unRead != 10))
 801b004:	ab03      	add	r3, sp, #12
 801b006:	220a      	movs	r2, #10
 801b008:	4649      	mov	r1, r9
 801b00a:	4630      	mov	r0, r6
 801b00c:	f7f1 f872 	bl	800c0f4 <f_read>
 801b010:	2800      	cmp	r0, #0
 801b012:	d1b5      	bne.n	801af80 <Mp3ReadId3V2Tag+0x28>
 801b014:	9b03      	ldr	r3, [sp, #12]
 801b016:	2b0a      	cmp	r3, #10
 801b018:	d1b2      	bne.n	801af80 <Mp3ReadId3V2Tag+0x28>
				if((frhd[0] == 0) || (strncmp(frhd, "3DI", 3) == 0))
 801b01a:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 801b01e:	2b00      	cmp	r3, #0
 801b020:	d03d      	beq.n	801b09e <Mp3ReadId3V2Tag+0x146>
 801b022:	f8b9 2000 	ldrh.w	r2, [r9]
 801b026:	f244 4333 	movw	r3, #17459	; 0x4433
 801b02a:	429a      	cmp	r2, r3
 801b02c:	d03a      	beq.n	801b0a4 <Mp3ReadId3V2Tag+0x14c>
				char szFrameId[5] = {0, 0, 0, 0, 0};
 801b02e:	4b49      	ldr	r3, [pc, #292]	; (801b154 <Mp3ReadId3V2Tag+0x1fc>)
 801b030:	e893 0003 	ldmia.w	r3, {r0, r1}
				memcpy(szFrameId, frhd, 4);
 801b034:	9b09      	ldr	r3, [sp, #36]	; 0x24
				char szFrameId[5] = {0, 0, 0, 0, 0};
 801b036:	f88d 1014 	strb.w	r1, [sp, #20]
				memcpy(szFrameId, frhd, 4);
 801b03a:	9304      	str	r3, [sp, #16]
					if(unVersion == 3)
 801b03c:	9b00      	ldr	r3, [sp, #0]
 801b03e:	2b03      	cmp	r3, #3
 801b040:	d035      	beq.n	801b0ae <Mp3ReadId3V2Tag+0x156>
					if(unVersion == 4)
 801b042:	2b04      	cmp	r3, #4
 801b044:	d157      	bne.n	801b0f6 <Mp3ReadId3V2Tag+0x19e>
						unFrameSize += frhd[i + 4] & 0x7F;
 801b046:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 801b04a:	f003 087f 	and.w	r8, r3, #127	; 0x7f
 801b04e:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 801b052:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801b056:	eb03 13c8 	add.w	r3, r3, r8, lsl #7
 801b05a:	f89d 802a 	ldrb.w	r8, [sp, #42]	; 0x2a
 801b05e:	f008 087f 	and.w	r8, r8, #127	; 0x7f
 801b062:	eb08 13c3 	add.w	r3, r8, r3, lsl #7
 801b066:	f89d 802b 	ldrb.w	r8, [sp, #43]	; 0x2b
 801b06a:	f008 087f 	and.w	r8, r8, #127	; 0x7f
 801b06e:	eb08 18c3 	add.w	r8, r8, r3, lsl #7
				if(strcmp(szFrameId, "TPE1") == 0)
 801b072:	4659      	mov	r1, fp
 801b074:	a804      	add	r0, sp, #16
 801b076:	f7e5 f8cb 	bl	8000210 <strcmp>
 801b07a:	b398      	cbz	r0, 801b0e4 <Mp3ReadId3V2Tag+0x18c>
				else if(strcmp(szFrameId, "TIT2") == 0)
 801b07c:	a804      	add	r0, sp, #16
 801b07e:	4936      	ldr	r1, [pc, #216]	; (801b158 <Mp3ReadId3V2Tag+0x200>)
 801b080:	f7e5 f8c6 	bl	8000210 <strcmp>
 801b084:	bb10      	cbnz	r0, 801b0cc <Mp3ReadId3V2Tag+0x174>
					if(Mp3ReadId3V2Text(pInFile, unFrameSize, pszTitle, unTitleSize) != 0)
 801b086:	4641      	mov	r1, r8
 801b088:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801b08a:	462a      	mov	r2, r5
 801b08c:	4630      	mov	r0, r6
 801b08e:	f7ff ff0b 	bl	801aea8 <Mp3ReadId3V2Text>
 801b092:	b920      	cbnz	r0, 801b09e <Mp3ReadId3V2Tag+0x146>
					nFramesToRead--;
 801b094:	f10a 3aff 	add.w	sl, sl, #4294967295
			while(nFramesToRead > 0)
 801b098:	f1ba 0f00 	cmp.w	sl, #0
 801b09c:	d1b2      	bne.n	801b004 <Mp3ReadId3V2Tag+0xac>
		if(f_lseek(pInFile, unSkip) != FR_OK)
 801b09e:	9a01      	ldr	r2, [sp, #4]
 801b0a0:	2300      	movs	r3, #0
 801b0a2:	e781      	b.n	801afa8 <Mp3ReadId3V2Tag+0x50>
				if((frhd[0] == 0) || (strncmp(frhd, "3DI", 3) == 0))
 801b0a4:	f899 3002 	ldrb.w	r3, [r9, #2]
 801b0a8:	2b49      	cmp	r3, #73	; 0x49
 801b0aa:	d1c0      	bne.n	801b02e <Mp3ReadId3V2Tag+0xd6>
 801b0ac:	e7f7      	b.n	801b09e <Mp3ReadId3V2Tag+0x146>
						unFrameSize += frhd[i + 4];
 801b0ae:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
 801b0b2:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 801b0b6:	eb03 2308 	add.w	r3, r3, r8, lsl #8
 801b0ba:	f89d 802a 	ldrb.w	r8, [sp, #42]	; 0x2a
 801b0be:	eb08 2303 	add.w	r3, r8, r3, lsl #8
 801b0c2:	f89d 802b 	ldrb.w	r8, [sp, #43]	; 0x2b
 801b0c6:	eb08 2803 	add.w	r8, r8, r3, lsl #8
					if(unVersion == 4)
 801b0ca:	e7d2      	b.n	801b072 <Mp3ReadId3V2Tag+0x11a>
					if(f_lseek(pInFile, f_tell(pInFile) + unFrameSize) != FR_OK)
 801b0cc:	6bb2      	ldr	r2, [r6, #56]	; 0x38
 801b0ce:	4630      	mov	r0, r6
 801b0d0:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 801b0d2:	eb18 0202 	adds.w	r2, r8, r2
 801b0d6:	f143 0300 	adc.w	r3, r3, #0
 801b0da:	f7f1 f937 	bl	800c34c <f_lseek>
 801b0de:	2800      	cmp	r0, #0
 801b0e0:	d090      	beq.n	801b004 <Mp3ReadId3V2Tag+0xac>
 801b0e2:	e74d      	b.n	801af80 <Mp3ReadId3V2Tag+0x28>
					if(Mp3ReadId3V2Text(pInFile, unFrameSize, pszArtist, unArtistSize) != 0)
 801b0e4:	4641      	mov	r1, r8
 801b0e6:	463b      	mov	r3, r7
 801b0e8:	4622      	mov	r2, r4
 801b0ea:	4630      	mov	r0, r6
 801b0ec:	f7ff fedc 	bl	801aea8 <Mp3ReadId3V2Text>
 801b0f0:	2800      	cmp	r0, #0
 801b0f2:	d0cf      	beq.n	801b094 <Mp3ReadId3V2Tag+0x13c>
 801b0f4:	e7d3      	b.n	801b09e <Mp3ReadId3V2Tag+0x146>
				uint32_t unFrameSize = 0;
 801b0f6:	f04f 0800 	mov.w	r8, #0
 801b0fa:	e7ba      	b.n	801b072 <Mp3ReadId3V2Tag+0x11a>
				f_read(pInFile, exhd, 4, &unRead);
 801b0fc:	ab03      	add	r3, sp, #12
 801b0fe:	2204      	movs	r2, #4
 801b100:	4630      	mov	r0, r6
 801b102:	4649      	mov	r1, r9
 801b104:	f7f0 fff6 	bl	800c0f4 <f_read>
				size_t unExHdrSkip = ((exhd[0] & 0x7f) << 21) | ((exhd[1] & 0x7f) << 14) | ((exhd[2] & 0x7f) << 7) | (exhd[3] & 0x7f);
 801b108:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 801b10c:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
				if(f_lseek(pInFile, f_tell(pInFile) + unExHdrSkip) != FR_OK)
 801b110:	4630      	mov	r0, r6
				size_t unExHdrSkip = ((exhd[0] & 0x7f) << 21) | ((exhd[1] & 0x7f) << 14) | ((exhd[2] & 0x7f) << 7) | (exhd[3] & 0x7f);
 801b112:	055b      	lsls	r3, r3, #21
 801b114:	0392      	lsls	r2, r2, #14
 801b116:	f003 637e 	and.w	r3, r3, #266338304	; 0xfe00000
 801b11a:	f402 12fe 	and.w	r2, r2, #2080768	; 0x1fc000
 801b11e:	4313      	orrs	r3, r2
 801b120:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
 801b124:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 801b128:	4313      	orrs	r3, r2
 801b12a:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
 801b12e:	01d2      	lsls	r2, r2, #7
 801b130:	f402 527e 	and.w	r2, r2, #16256	; 0x3f80
 801b134:	4313      	orrs	r3, r2
				if(f_lseek(pInFile, f_tell(pInFile) + unExHdrSkip) != FR_OK)
 801b136:	6bb2      	ldr	r2, [r6, #56]	; 0x38
				unExHdrSkip -= 4;
 801b138:	3b04      	subs	r3, #4
				if(f_lseek(pInFile, f_tell(pInFile) + unExHdrSkip) != FR_OK)
 801b13a:	189a      	adds	r2, r3, r2
 801b13c:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 801b13e:	f143 0300 	adc.w	r3, r3, #0
 801b142:	f7f1 f903 	bl	800c34c <f_lseek>
 801b146:	2800      	cmp	r0, #0
 801b148:	f43f af58 	beq.w	801affc <Mp3ReadId3V2Tag+0xa4>
 801b14c:	e718      	b.n	801af80 <Mp3ReadId3V2Tag+0x28>
 801b14e:	bf00      	nop
 801b150:	200154c0 	.word	0x200154c0
 801b154:	080214d8 	.word	0x080214d8
 801b158:	08026df0 	.word	0x08026df0
 801b15c:	08026de8 	.word	0x08026de8

0801b160 <PlayMp3File>:
		}
	}
	return res;
}

void PlayMp3File() {
 801b160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BufferCtl.filetype = 1;
	char szArtist[120];
	char szTitle[120];
	id3tagsize = 0;
	Mp3ReadId3V2Tag(&MyFile, szArtist, sizeof(szArtist), szTitle, sizeof(szTitle));
 801b164:	2278      	movs	r2, #120	; 0x78
	id3tagsize = 0;
 801b166:	2500      	movs	r5, #0
	BufferCtl.filetype = 1;
 801b168:	4c87      	ldr	r4, [pc, #540]	; (801b388 <PlayMp3File+0x228>)
 801b16a:	2101      	movs	r1, #1
	id3tagsize = 0;
 801b16c:	4b87      	ldr	r3, [pc, #540]	; (801b38c <PlayMp3File+0x22c>)
	Mp3ReadId3V2Tag(&MyFile, szArtist, sizeof(szArtist), szTitle, sizeof(szTitle));
 801b16e:	4888      	ldr	r0, [pc, #544]	; (801b390 <PlayMp3File+0x230>)
	bOutOfData = 0;
 801b170:	f8df 926c 	ldr.w	r9, [pc, #620]	; 801b3e0 <PlayMp3File+0x280>
	memset(BufferCtl.buff, 0, AUDIO_OUT_BUFFER_SIZE);
	//memset(g_pMp3DmaBuffer, 0, MP3_DMA_BUFFER_SIZE);
	g_pMp3DmaBufferPtr = g_pMp3DmaBuffer;
 801b174:	f8df b26c 	ldr.w	fp, [pc, #620]	; 801b3e4 <PlayMp3File+0x284>
	unInDataLeft = 0;
 801b178:	4e86      	ldr	r6, [pc, #536]	; (801b394 <PlayMp3File+0x234>)
 801b17a:	f8df a238 	ldr.w	sl, [pc, #568]	; 801b3b4 <PlayMp3File+0x254>
void PlayMp3File() {
 801b17e:	ed2d 8b02 	vpush	{d8}
 801b182:	b0c1      	sub	sp, #260	; 0x104
 801b184:	ed9f 8a84 	vldr	s16, [pc, #528]	; 801b398 <PlayMp3File+0x238>
	Mp3ReadId3V2Tag(&MyFile, szArtist, sizeof(szArtist), szTitle, sizeof(szTitle));
 801b188:	9200      	str	r2, [sp, #0]
	BufferCtl.filetype = 1;
 801b18a:	7221      	strb	r1, [r4, #8]
	Mp3ReadId3V2Tag(&MyFile, szArtist, sizeof(szArtist), szTitle, sizeof(szTitle));
 801b18c:	a904      	add	r1, sp, #16
	id3tagsize = 0;
 801b18e:	601d      	str	r5, [r3, #0]
	Mp3ReadId3V2Tag(&MyFile, szArtist, sizeof(szArtist), szTitle, sizeof(szTitle));
 801b190:	ab22      	add	r3, sp, #136	; 0x88
 801b192:	f7ff fee1 	bl	801af58 <Mp3ReadId3V2Tag>
	memset(BufferCtl.buff, 0, AUDIO_OUT_BUFFER_SIZE);
 801b196:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801b19a:	4629      	mov	r1, r5
 801b19c:	f5a4 5080 	sub.w	r0, r4, #4096	; 0x1000
	bOutOfData = 0;
 801b1a0:	f8c9 5000 	str.w	r5, [r9]
	memset(BufferCtl.buff, 0, AUDIO_OUT_BUFFER_SIZE);
 801b1a4:	f004 ff9a 	bl	80200dc <memset>
	g_pMp3DmaBufferPtr = g_pMp3DmaBuffer;
 801b1a8:	4b7c      	ldr	r3, [pc, #496]	; (801b39c <PlayMp3File+0x23c>)
	do {
		// fill the whole buffer for the first time
		if(unInDataLeft < (2 * MAINBUF_SIZE)) {
			UINT unRead = Mp3FillReadBuffer(pInData, unInDataLeft, &MyFile);
			unInDataLeft += unRead;
			pInData = BufferCtl.buff;
 801b1aa:	f5a4 5280 	sub.w	r2, r4, #4096	; 0x1000
	unDmaBufMode = 0;
 801b1ae:	4c7c      	ldr	r4, [pc, #496]	; (801b3a0 <PlayMp3File+0x240>)
 801b1b0:	4629      	mov	r1, r5
	g_pMp3DmaBufferPtr = g_pMp3DmaBuffer;
 801b1b2:	f8cb 3000 	str.w	r3, [fp]
	unDmaBufferSpace = 0;
 801b1b6:	4b7b      	ldr	r3, [pc, #492]	; (801b3a4 <PlayMp3File+0x244>)
			pInData = BufferCtl.buff;
 801b1b8:	9203      	str	r2, [sp, #12]
	unDmaBufferSpace = 0;
 801b1ba:	601d      	str	r5, [r3, #0]
	unFramesDecoded = 0;
 801b1bc:	4b7a      	ldr	r3, [pc, #488]	; (801b3a8 <PlayMp3File+0x248>)
	nDecodeRes = ERR_MP3_INDATA_UNDERFLOW;
 801b1be:	4a7b      	ldr	r2, [pc, #492]	; (801b3ac <PlayMp3File+0x24c>)
	unFramesDecoded = 0;
 801b1c0:	601d      	str	r5, [r3, #0]
	nDecodeRes = ERR_MP3_INDATA_UNDERFLOW;
 801b1c2:	f04f 33ff 	mov.w	r3, #4294967295
	unInDataLeft = 0;
 801b1c6:	6035      	str	r5, [r6, #0]
	nDecodeRes = ERR_MP3_INDATA_UNDERFLOW;
 801b1c8:	6013      	str	r3, [r2, #0]
	unDmaBufMode = 0;
 801b1ca:	6025      	str	r5, [r4, #0]
 801b1cc:	e006      	b.n	801b1dc <PlayMp3File+0x7c>
		}
		// find start of next MP3 frame - assume EOF if no sync found
		int nOffset = MP3FindSyncWord(pInData, unInDataLeft);
		if(nOffset < 0) {
			unInDataLeft = 0;
 801b1ce:	2300      	movs	r3, #0
 801b1d0:	6033      	str	r3, [r6, #0]
				break;
			}
			}
		}
	}
	while(!bOutOfData);
 801b1d2:	f8d9 3000 	ldr.w	r3, [r9]
 801b1d6:	2b00      	cmp	r3, #0
 801b1d8:	d131      	bne.n	801b23e <PlayMp3File+0xde>
		if(unInDataLeft < (2 * MAINBUF_SIZE)) {
 801b1da:	6831      	ldr	r1, [r6, #0]
 801b1dc:	f640 7327 	movw	r3, #3879	; 0xf27
 801b1e0:	4299      	cmp	r1, r3
 801b1e2:	dd37      	ble.n	801b254 <PlayMp3File+0xf4>
		int nOffset = MP3FindSyncWord(pInData, unInDataLeft);
 801b1e4:	f8da 0000 	ldr.w	r0, [sl]
 801b1e8:	f7f1 fc32 	bl	800ca50 <MP3FindSyncWord>
		if(nOffset < 0) {
 801b1ec:	1e05      	subs	r5, r0, #0
 801b1ee:	dbee      	blt.n	801b1ce <PlayMp3File+0x6e>
			pInData += nOffset;
 801b1f0:	f8da 3000 	ldr.w	r3, [sl]
			nDecodeRes = MP3Decode(hMP3Decoder, &pInData, (int*)&unInDataLeft, (short*)g_pMp3OutBuffer, 0);
 801b1f4:	4f6e      	ldr	r7, [pc, #440]	; (801b3b0 <PlayMp3File+0x250>)
			pInData += nOffset;
 801b1f6:	442b      	add	r3, r5
			nDecodeRes = MP3Decode(hMP3Decoder, &pInData, (int*)&unInDataLeft, (short*)g_pMp3OutBuffer, 0);
 801b1f8:	4a66      	ldr	r2, [pc, #408]	; (801b394 <PlayMp3File+0x234>)
 801b1fa:	496e      	ldr	r1, [pc, #440]	; (801b3b4 <PlayMp3File+0x254>)
			pInData += nOffset;
 801b1fc:	f8ca 3000 	str.w	r3, [sl]
			unInDataLeft -= nOffset;
 801b200:	6833      	ldr	r3, [r6, #0]
 801b202:	1b5b      	subs	r3, r3, r5
 801b204:	6033      	str	r3, [r6, #0]
			nDecodeRes = MP3Decode(hMP3Decoder, &pInData, (int*)&unInDataLeft, (short*)g_pMp3OutBuffer, 0);
 801b206:	2300      	movs	r3, #0
 801b208:	9300      	str	r3, [sp, #0]
 801b20a:	6838      	ldr	r0, [r7, #0]
 801b20c:	4b6a      	ldr	r3, [pc, #424]	; (801b3b8 <PlayMp3File+0x258>)
 801b20e:	f7f1 fc67 	bl	800cae0 <MP3Decode>
 801b212:	4b66      	ldr	r3, [pc, #408]	; (801b3ac <PlayMp3File+0x24c>)
 801b214:	6018      	str	r0, [r3, #0]
			switch(nDecodeRes) {
 801b216:	1c43      	adds	r3, r0, #1
 801b218:	f000 8099 	beq.w	801b34e <PlayMp3File+0x1ee>
 801b21c:	b338      	cbz	r0, 801b26e <PlayMp3File+0x10e>
 801b21e:	3002      	adds	r0, #2
 801b220:	d0d7      	beq.n	801b1d2 <PlayMp3File+0x72>
				if(unInDataLeft > 0) {
 801b222:	6833      	ldr	r3, [r6, #0]
 801b224:	2b00      	cmp	r3, #0
 801b226:	ddd4      	ble.n	801b1d2 <PlayMp3File+0x72>
					unInDataLeft-=MP3_BYTES_SKIP;
 801b228:	3b01      	subs	r3, #1
 801b22a:	6033      	str	r3, [r6, #0]
					pInData+=MP3_BYTES_SKIP;
 801b22c:	f8da 3000 	ldr.w	r3, [sl]
 801b230:	3301      	adds	r3, #1
 801b232:	f8ca 3000 	str.w	r3, [sl]
	while(!bOutOfData);
 801b236:	f8d9 3000 	ldr.w	r3, [r9]
 801b23a:	2b00      	cmp	r3, #0
 801b23c:	d0cd      	beq.n	801b1da <PlayMp3File+0x7a>
	BSP_AUDIO_OUT_SetVolume(0);
 801b23e:	2000      	movs	r0, #0
 801b240:	f001 fdee 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
	while(unDmaBufMode < 3);
 801b244:	6823      	ldr	r3, [r4, #0]
 801b246:	2b02      	cmp	r3, #2
 801b248:	d9fc      	bls.n	801b244 <PlayMp3File+0xe4>
}
 801b24a:	b041      	add	sp, #260	; 0x104
 801b24c:	ecbd 8b02 	vpop	{d8}
 801b250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			UINT unRead = Mp3FillReadBuffer(pInData, unInDataLeft, &MyFile);
 801b254:	4a4e      	ldr	r2, [pc, #312]	; (801b390 <PlayMp3File+0x230>)
 801b256:	f8da 0000 	ldr.w	r0, [sl]
 801b25a:	f001 fefd 	bl	801d058 <Mp3FillReadBuffer>
			unInDataLeft += unRead;
 801b25e:	6831      	ldr	r1, [r6, #0]
			pInData = BufferCtl.buff;
 801b260:	9b03      	ldr	r3, [sp, #12]
			unInDataLeft += unRead;
 801b262:	4401      	add	r1, r0
			pInData = BufferCtl.buff;
 801b264:	f8ca 3000 	str.w	r3, [sl]
 801b268:	4618      	mov	r0, r3
			unInDataLeft += unRead;
 801b26a:	6031      	str	r1, [r6, #0]
			pInData = BufferCtl.buff;
 801b26c:	e7bc      	b.n	801b1e8 <PlayMp3File+0x88>
				MP3GetLastFrameInfo(hMP3Decoder, &mp3FrameInfo);
 801b26e:	4953      	ldr	r1, [pc, #332]	; (801b3bc <PlayMp3File+0x25c>)
 801b270:	6838      	ldr	r0, [r7, #0]
 801b272:	f7f1 fc07 	bl	800ca84 <MP3GetLastFrameInfo>
				g_pMp3OutBufferPtr = g_pMp3OutBuffer;
 801b276:	4a50      	ldr	r2, [pc, #320]	; (801b3b8 <PlayMp3File+0x258>)
				unFramesDecoded++;
 801b278:	494b      	ldr	r1, [pc, #300]	; (801b3a8 <PlayMp3File+0x248>)
				g_pMp3OutBufferPtr = g_pMp3OutBuffer;
 801b27a:	4b51      	ldr	r3, [pc, #324]	; (801b3c0 <PlayMp3File+0x260>)
 801b27c:	601a      	str	r2, [r3, #0]
				unFramesDecoded++;
 801b27e:	680a      	ldr	r2, [r1, #0]
 801b280:	3201      	adds	r2, #1
 801b282:	600a      	str	r2, [r1, #0]
				uint32_t unOutBufferAvail = mp3FrameInfo.outputSamps;
 801b284:	4a4d      	ldr	r2, [pc, #308]	; (801b3bc <PlayMp3File+0x25c>)
 801b286:	f8d2 8010 	ldr.w	r8, [r2, #16]
				while(unOutBufferAvail > 0) {
 801b28a:	f1b8 0f00 	cmp.w	r8, #0
 801b28e:	d0a0      	beq.n	801b1d2 <PlayMp3File+0x72>
					if(unDmaBufMode == 0) {
 801b290:	6822      	ldr	r2, [r4, #0]
 801b292:	b112      	cbz	r2, 801b29a <PlayMp3File+0x13a>
					else if(unDmaBufMode == 1) {
 801b294:	6822      	ldr	r2, [r4, #0]
 801b296:	2a01      	cmp	r2, #1
 801b298:	d053      	beq.n	801b342 <PlayMp3File+0x1e2>
						unDmaBufferSpace = g_pMp3DmaBuffer + MP3_DMA_BUFFER_SIZE - g_pMp3DmaBufferPtr;
 801b29a:	f8db 0000 	ldr.w	r0, [fp]
 801b29e:	4a49      	ldr	r2, [pc, #292]	; (801b3c4 <PlayMp3File+0x264>)
 801b2a0:	1a15      	subs	r5, r2, r0
 801b2a2:	106d      	asrs	r5, r5, #1
					uint32_t unCopy = unDmaBufferSpace > unOutBufferAvail ? unOutBufferAvail : unDmaBufferSpace;
 801b2a4:	4545      	cmp	r5, r8
 801b2a6:	462f      	mov	r7, r5
 801b2a8:	bf28      	it	cs
 801b2aa:	4647      	movcs	r7, r8
					if(unCopy > 0) {
 801b2ac:	2f00      	cmp	r7, #0
 801b2ae:	d133      	bne.n	801b318 <PlayMp3File+0x1b8>
					if(unDmaBufferSpace == 0) {
 801b2b0:	2d00      	cmp	r5, #0
 801b2b2:	d1ed      	bne.n	801b290 <PlayMp3File+0x130>
						if(unDmaBufMode == 0) {
 801b2b4:	6822      	ldr	r2, [r4, #0]
 801b2b6:	bb5a      	cbnz	r2, 801b310 <PlayMp3File+0x1b0>
							if(mp3FrameInfo.samprate > 0) trak.bitrate = mp3FrameInfo.samprate;
 801b2b8:	4a40      	ldr	r2, [pc, #256]	; (801b3bc <PlayMp3File+0x25c>)
 801b2ba:	6892      	ldr	r2, [r2, #8]
 801b2bc:	2a00      	cmp	r2, #0
 801b2be:	dd4d      	ble.n	801b35c <PlayMp3File+0x1fc>
									*(1 + trak.percent), NULL);
 801b2c0:	f3c2 014e 	ubfx	r1, r2, #1, #15
 801b2c4:	b292      	uxth	r2, r2
 801b2c6:	ee07 1a10 	vmov	s14, r1
 801b2ca:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801b2ce:	4d3e      	ldr	r5, [pc, #248]	; (801b3c8 <PlayMp3File+0x268>)
 801b2d0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
							BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, (uint32_t)(trak.bitrate / 2)
 801b2d4:	483d      	ldr	r0, [pc, #244]	; (801b3cc <PlayMp3File+0x26c>)
									*(1 + trak.percent), NULL);
 801b2d6:	edd5 7a01 	vldr	s15, [r5, #4]
 801b2da:	812a      	strh	r2, [r5, #8]
							BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, (uint32_t)(trak.bitrate / 2)
 801b2dc:	2200      	movs	r2, #0
									*(1 + trak.percent), NULL);
 801b2de:	ee77 7aa6 	vadd.f32	s15, s15, s13
							if((rekordbox.autocue == 2) && (trak.state == PLAYING)) {
 801b2e2:	4f3b      	ldr	r7, [pc, #236]	; (801b3d0 <PlayMp3File+0x270>)
									*(1 + trak.percent), NULL);
 801b2e4:	ee67 7a87 	vmul.f32	s15, s15, s14
							BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, (uint32_t)(trak.bitrate / 2)
 801b2e8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801b2ec:	ee17 1a90 	vmov	r1, s15
 801b2f0:	f001 fe3a 	bl	801cf68 <BSP_AUDIO_OUT_ClockConfig>
							BSP_AUDIO_OUT_Play(g_pMp3DmaBuffer, MP3_DMA_BUFFER_SIZE * sizeof(uint16_t));
 801b2f4:	f44f 4190 	mov.w	r1, #18432	; 0x4800
 801b2f8:	4828      	ldr	r0, [pc, #160]	; (801b39c <PlayMp3File+0x23c>)
 801b2fa:	f001 fd43 	bl	801cd84 <BSP_AUDIO_OUT_Play>
							BSP_AUDIO_OUT_SetVolume(volume);
 801b2fe:	4a35      	ldr	r2, [pc, #212]	; (801b3d4 <PlayMp3File+0x274>)
 801b300:	7810      	ldrb	r0, [r2, #0]
 801b302:	f001 fd8d 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
							if((rekordbox.autocue == 2) && (trak.state == PLAYING)) {
 801b306:	f897 23cc 	ldrb.w	r2, [r7, #972]	; 0x3cc
 801b30a:	4b2d      	ldr	r3, [pc, #180]	; (801b3c0 <PlayMp3File+0x260>)
 801b30c:	2a02      	cmp	r2, #2
 801b30e:	d02a      	beq.n	801b366 <PlayMp3File+0x206>
						while(unDmaBufMode == 0);
 801b310:	6822      	ldr	r2, [r4, #0]
 801b312:	2a00      	cmp	r2, #0
 801b314:	d0fc      	beq.n	801b310 <PlayMp3File+0x1b0>
 801b316:	e7b8      	b.n	801b28a <PlayMp3File+0x12a>
						memcpy(g_pMp3DmaBufferPtr, g_pMp3OutBufferPtr, unCopy * sizeof(uint16_t));
 801b318:	007a      	lsls	r2, r7, #1
 801b31a:	6819      	ldr	r1, [r3, #0]
						unOutBufferAvail -= unCopy;
 801b31c:	eba8 0707 	sub.w	r7, r8, r7
						memcpy(g_pMp3DmaBufferPtr, g_pMp3OutBufferPtr, unCopy * sizeof(uint16_t));
 801b320:	9202      	str	r2, [sp, #8]
 801b322:	f004 feb3 	bl	802008c <memcpy>
						g_pMp3OutBufferPtr += unCopy;
 801b326:	4b26      	ldr	r3, [pc, #152]	; (801b3c0 <PlayMp3File+0x260>)
					if(unDmaBufferSpace == 0) {
 801b328:	4545      	cmp	r5, r8
						g_pMp3OutBufferPtr += unCopy;
 801b32a:	9a02      	ldr	r2, [sp, #8]
						unOutBufferAvail -= unCopy;
 801b32c:	46b8      	mov	r8, r7
						g_pMp3OutBufferPtr += unCopy;
 801b32e:	6819      	ldr	r1, [r3, #0]
 801b330:	4411      	add	r1, r2
 801b332:	6019      	str	r1, [r3, #0]
						g_pMp3DmaBufferPtr += unCopy;
 801b334:	f8db 1000 	ldr.w	r1, [fp]
 801b338:	440a      	add	r2, r1
 801b33a:	f8cb 2000 	str.w	r2, [fp]
					if(unDmaBufferSpace == 0) {
 801b33e:	d8a4      	bhi.n	801b28a <PlayMp3File+0x12a>
 801b340:	e7b8      	b.n	801b2b4 <PlayMp3File+0x154>
						unDmaBufferSpace = g_pMp3DmaBuffer + (MP3_DMA_BUFFER_SIZE / 2) - g_pMp3DmaBufferPtr;
 801b342:	f8db 0000 	ldr.w	r0, [fp]
 801b346:	4a24      	ldr	r2, [pc, #144]	; (801b3d8 <PlayMp3File+0x278>)
 801b348:	1a15      	subs	r5, r2, r0
 801b34a:	106d      	asrs	r5, r5, #1
 801b34c:	e7aa      	b.n	801b2a4 <PlayMp3File+0x144>
				if(nOffset == 0)
 801b34e:	2d00      	cmp	r5, #0
 801b350:	f47f af3d 	bne.w	801b1ce <PlayMp3File+0x6e>
					bOutOfData = 1;
 801b354:	2301      	movs	r3, #1
 801b356:	f8c9 3000 	str.w	r3, [r9]
 801b35a:	e73a      	b.n	801b1d2 <PlayMp3File+0x72>
 801b35c:	eeb0 7a48 	vmov.f32	s14, s16
 801b360:	f64a 4244 	movw	r2, #44100	; 0xac44
 801b364:	e7b3      	b.n	801b2ce <PlayMp3File+0x16e>
							if((rekordbox.autocue == 2) && (trak.state == PLAYING)) {
 801b366:	782a      	ldrb	r2, [r5, #0]
 801b368:	2a00      	cmp	r2, #0
 801b36a:	d1d1      	bne.n	801b310 <PlayMp3File+0x1b0>
								BSP_AUDIO_OUT_Pause();
 801b36c:	f001 fd2c 	bl	801cdc8 <BSP_AUDIO_OUT_Pause>
								trak.state = STOPPED;
 801b370:	2201      	movs	r2, #1
								HAL_TIM_Base_Start_IT(&htim8);
 801b372:	481a      	ldr	r0, [pc, #104]	; (801b3dc <PlayMp3File+0x27c>)
								trak.state = STOPPED;
 801b374:	702a      	strb	r2, [r5, #0]
								HAL_TIM_Base_Start_IT(&htim8);
 801b376:	f7eb f9f9 	bl	800676c <HAL_TIM_Base_Start_IT>
								GoToPosition(rekordbox.cue_start_position[0]);
 801b37a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801b37c:	f003 fdc8 	bl	801ef10 <GoToPosition>
								TrackTime();
 801b380:	f003 fd6e 	bl	801ee60 <TrackTime>
 801b384:	4b0e      	ldr	r3, [pc, #56]	; (801b3c0 <PlayMp3File+0x260>)
 801b386:	e7c3      	b.n	801b310 <PlayMp3File+0x1b0>
 801b388:	20001e30 	.word	0x20001e30
 801b38c:	200154c0 	.word	0x200154c0
 801b390:	20001e40 	.word	0x20001e40
 801b394:	200154ec 	.word	0x200154ec
 801b398:	46ac4400 	.word	0x46ac4400
 801b39c:	2000fab8 	.word	0x2000fab8
 801b3a0:	2000fab4 	.word	0x2000fab4
 801b3a4:	200154e4 	.word	0x200154e4
 801b3a8:	200154e8 	.word	0x200154e8
 801b3ac:	200154e0 	.word	0x200154e0
 801b3b0:	2000f0dc 	.word	0x2000f0dc
 801b3b4:	20000060 	.word	0x20000060
 801b3b8:	200142bc 	.word	0x200142bc
 801b3bc:	200154c4 	.word	0x200154c4
 801b3c0:	200154bc 	.word	0x200154bc
 801b3c4:	200142b8 	.word	0x200142b8
 801b3c8:	2000fa7c 	.word	0x2000fa7c
 801b3cc:	20018934 	.word	0x20018934
 801b3d0:	200184f0 	.word	0x200184f0
 801b3d4:	2000005c 	.word	0x2000005c
 801b3d8:	20011eb8 	.word	0x20011eb8
 801b3dc:	20018c84 	.word	0x20018c84
 801b3e0:	2000ec30 	.word	0x2000ec30
 801b3e4:	200142b8 	.word	0x200142b8

0801b3e8 <FindToken>:
static uint8_t FindToken (const char *token);
static int32_t GetLongNumber ();
static int32_t GetBigEndianLongNumber ();

// finds section token in the file. 0 - token is found, 1 - end of file
static uint8_t FindToken (const char *token) {
 801b3e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b3ec:	4d1d      	ldr	r5, [pc, #116]	; (801b464 <FindToken+0x7c>)
 801b3ee:	2300      	movs	r3, #0
 801b3f0:	4c1d      	ldr	r4, [pc, #116]	; (801b468 <FindToken+0x80>)
static uint8_t FindToken (const char *token) {
 801b3f2:	4680      	mov	r8, r0
	while(f_tell(&MyFile) < f_size(&MyFile)) {
		while(f_tell(&MyFile) < f_size(&MyFile)) {
			while(f_read(&MyFile, &tag[0], 1, (void *)&bytesread) != FR_OK);
 801b3f4:	4e1d      	ldr	r6, [pc, #116]	; (801b46c <FindToken+0x84>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b3f6:	602b      	str	r3, [r5, #0]
 801b3f8:	712b      	strb	r3, [r5, #4]
	while(f_tell(&MyFile) < f_size(&MyFile)) {
 801b3fa:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801b3fc:	6921      	ldr	r1, [r4, #16]
 801b3fe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 801b400:	6963      	ldr	r3, [r4, #20]
 801b402:	4288      	cmp	r0, r1
 801b404:	eb72 0303 	sbcs.w	r3, r2, r3
 801b408:	d227      	bcs.n	801b45a <FindToken+0x72>
			while(f_read(&MyFile, &tag[0], 1, (void *)&bytesread) != FR_OK);
 801b40a:	4633      	mov	r3, r6
 801b40c:	2201      	movs	r2, #1
 801b40e:	4629      	mov	r1, r5
 801b410:	4620      	mov	r0, r4
 801b412:	f7f0 fe6f 	bl	800c0f4 <f_read>
 801b416:	2800      	cmp	r0, #0
 801b418:	d1f7      	bne.n	801b40a <FindToken+0x22>
			if(tag[0] == 'P') break;
 801b41a:	782b      	ldrb	r3, [r5, #0]
 801b41c:	2b50      	cmp	r3, #80	; 0x50
 801b41e:	d007      	beq.n	801b430 <FindToken+0x48>
		while(f_tell(&MyFile) < f_size(&MyFile)) {
 801b420:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801b422:	6921      	ldr	r1, [r4, #16]
 801b424:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 801b426:	6963      	ldr	r3, [r4, #20]
 801b428:	4288      	cmp	r0, r1
 801b42a:	eb72 0303 	sbcs.w	r3, r2, r3
 801b42e:	d3ec      	bcc.n	801b40a <FindToken+0x22>
		}
		while(f_read(&MyFile, &tag[1], 3, (void *)&bytesread) != FR_OK);
 801b430:	f8df 903c 	ldr.w	r9, [pc, #60]	; 801b470 <FindToken+0x88>
 801b434:	4633      	mov	r3, r6
 801b436:	2203      	movs	r2, #3
 801b438:	4649      	mov	r1, r9
 801b43a:	4620      	mov	r0, r4
 801b43c:	f7f0 fe5a 	bl	800c0f4 <f_read>
 801b440:	4607      	mov	r7, r0
 801b442:	2800      	cmp	r0, #0
 801b444:	d1f6      	bne.n	801b434 <FindToken+0x4c>
		tag[4] = '\0';
		if(strcmp(tag, token) == 0) return 0;
 801b446:	4641      	mov	r1, r8
 801b448:	4628      	mov	r0, r5
		tag[4] = '\0';
 801b44a:	712f      	strb	r7, [r5, #4]
		if(strcmp(tag, token) == 0) return 0;
 801b44c:	f7e4 fee0 	bl	8000210 <strcmp>
 801b450:	2800      	cmp	r0, #0
 801b452:	d1d2      	bne.n	801b3fa <FindToken+0x12>
	}
	return 1;
}
 801b454:	4638      	mov	r0, r7
 801b456:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return 1;
 801b45a:	2701      	movs	r7, #1
}
 801b45c:	4638      	mov	r0, r7
 801b45e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801b462:	bf00      	nop
 801b464:	200188c8 	.word	0x200188c8
 801b468:	20001e40 	.word	0x20001e40
 801b46c:	2000ec34 	.word	0x2000ec34
 801b470:	200188c9 	.word	0x200188c9

0801b474 <DecodeRekordboxFiles>:
	}
	out_data >>= 8;
	return out_data;
}

uint8_t DecodeRekordboxFiles(TCHAR *path) {
 801b474:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for(i = 0; i < RBX_MAX_TQZ; i++) {
		rekordbox.bpm[i] = 0;
		rekordbox.phase[i] = 0;
		rekordbox.timeindex[i] = 0;
	}
	rekordbox.cues = 0;
 801b478:	4ca9      	ldr	r4, [pc, #676]	; (801b720 <DecodeRekordboxFiles+0x2ac>)
uint8_t DecodeRekordboxFiles(TCHAR *path) {
 801b47a:	4603      	mov	r3, r0
		rekordbox.bpm[i] = 0;
 801b47c:	f44f 5216 	mov.w	r2, #9600	; 0x2580
 801b480:	2100      	movs	r1, #0
 801b482:	f204 5004 	addw	r0, r4, #1284	; 0x504
	rekordbox.cues = 0;
 801b486:	2500      	movs	r5, #0
uint8_t DecodeRekordboxFiles(TCHAR *path) {
 801b488:	ed2d 8b02 	vpush	{d8}
 801b48c:	f2ad 5d0c 	subw	sp, sp, #1292	; 0x50c
 801b490:	ee08 3a90 	vmov	s17, r3
		rekordbox.bpm[i] = 0;
 801b494:	f004 fe22 	bl	80200dc <memset>
	rekordbox.cues = 0;
 801b498:	f504 5200 	add.w	r2, r4, #8192	; 0x2000
 801b49c:	4ba1      	ldr	r3, [pc, #644]	; (801b724 <DecodeRekordboxFiles+0x2b0>)
 801b49e:	f8c2 5b94 	str.w	r5, [r2, #2964]	; 0xb94
	// Clear SDRAM or fill with some pattern/color
	for(i = 0; i < MAX_WAVESIZE; i++) *(__IO uint8_t*)(WAVE_BUFFER+i) = 0;
 801b4a2:	4aa1      	ldr	r2, [pc, #644]	; (801b728 <DecodeRekordboxFiles+0x2b4>)
 801b4a4:	f803 5b01 	strb.w	r5, [r3], #1
 801b4a8:	4293      	cmp	r3, r2
 801b4aa:	d1fb      	bne.n	801b4a4 <DecodeRekordboxFiles+0x30>
	for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.filename[i] = 0;
 801b4ac:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801b4b0:	2100      	movs	r1, #0
 801b4b2:	489b      	ldr	r0, [pc, #620]	; (801b720 <DecodeRekordboxFiles+0x2ac>)
 801b4b4:	f004 fe12 	bl	80200dc <memset>
	char filename[RBX_MAX_PATH] = {0};
 801b4b8:	22fb      	movs	r2, #251	; 0xfb
 801b4ba:	2100      	movs	r1, #0
 801b4bc:	a804      	add	r0, sp, #16
 801b4be:	9503      	str	r5, [sp, #12]
 801b4c0:	f004 fe0c 	bl	80200dc <memset>
	TCHAR my_path[RBX_MAX_PATH] = {0};
 801b4c4:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801b4c8:	2100      	movs	r1, #0
 801b4ca:	a843      	add	r0, sp, #268	; 0x10c
 801b4cc:	f004 fe06 	bl	80200dc <memset>
	wcscpy(my_path, path);
 801b4d0:	ee18 1a90 	vmov	r1, s17
 801b4d4:	a843      	add	r0, sp, #268	; 0x10c
 801b4d6:	f004 ff84 	bl	80203e2 <wcscpy>
	wcscat(my_path, L"/ANLZ0000.DAT");
 801b4da:	4994      	ldr	r1, [pc, #592]	; (801b72c <DecodeRekordboxFiles+0x2b8>)
 801b4dc:	a843      	add	r0, sp, #268	; 0x10c
 801b4de:	f004 ff70 	bl	80203c2 <wcscat>
	res = f_open(&MyFile, my_path, FA_READ);
 801b4e2:	2201      	movs	r2, #1
 801b4e4:	a943      	add	r1, sp, #268	; 0x10c
 801b4e6:	4892      	ldr	r0, [pc, #584]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b4e8:	f7f0 fda2 	bl	800c030 <f_open>
	if(res == FR_OK)
 801b4ec:	2800      	cmp	r0, #0
 801b4ee:	f000 824d 	beq.w	801b98c <DecodeRekordboxFiles+0x518>
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
		}
		f_close(&MyFile);
	}
	for(i = 0; i < RBX_MAX_PATH; i++) my_path[i] = 0;
 801b4f2:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801b4f6:	2100      	movs	r1, #0
 801b4f8:	a843      	add	r0, sp, #268	; 0x10c
 801b4fa:	f004 fdef 	bl	80200dc <memset>
	wcscpy(my_path, path);
 801b4fe:	ee18 1a90 	vmov	r1, s17
 801b502:	a843      	add	r0, sp, #268	; 0x10c
 801b504:	f004 ff6d 	bl	80203e2 <wcscpy>
	wcscat(my_path, L"/ANLZ0000.EXT");
 801b508:	498a      	ldr	r1, [pc, #552]	; (801b734 <DecodeRekordboxFiles+0x2c0>)
 801b50a:	a843      	add	r0, sp, #268	; 0x10c
 801b50c:	f004 ff59 	bl	80203c2 <wcscat>
	res = f_open(&MyFile, my_path, FA_READ);
 801b510:	2201      	movs	r2, #1
 801b512:	a943      	add	r1, sp, #268	; 0x10c
 801b514:	4886      	ldr	r0, [pc, #536]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b516:	f7f0 fd8b 	bl	800c030 <f_open>
	if(res == FR_OK) {
 801b51a:	2800      	cmp	r0, #0
 801b51c:	d075      	beq.n	801b60a <DecodeRekordboxFiles+0x196>
				}
			}
		}
		f_close(&MyFile);
	}
	for(i = 0; i < RBX_MAX_PATH; i++) my_path[i] = 0;
 801b51e:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801b522:	2100      	movs	r1, #0
 801b524:	a843      	add	r0, sp, #268	; 0x10c
 801b526:	f004 fdd9 	bl	80200dc <memset>
	wcscpy(my_path, path);
 801b52a:	ee18 1a90 	vmov	r1, s17
 801b52e:	a843      	add	r0, sp, #268	; 0x10c
 801b530:	f004 ff57 	bl	80203e2 <wcscpy>
	wcscat(my_path, L"/ANLZ0001.DAT");
 801b534:	4980      	ldr	r1, [pc, #512]	; (801b738 <DecodeRekordboxFiles+0x2c4>)
 801b536:	a843      	add	r0, sp, #268	; 0x10c
 801b538:	f004 ff43 	bl	80203c2 <wcscat>
	res = f_open(&MyFile, my_path, FA_READ);
 801b53c:	2201      	movs	r2, #1
 801b53e:	a943      	add	r1, sp, #268	; 0x10c
 801b540:	487b      	ldr	r0, [pc, #492]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b542:	f7f0 fd75 	bl	800c030 <f_open>
	if(res == FR_OK)
 801b546:	2800      	cmp	r0, #0
 801b548:	f000 85b5 	beq.w	801c0b6 <DecodeRekordboxFiles+0xc42>
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
		}
		f_close(&MyFile);
	}
	for(i = 0; i < RBX_MAX_PATH; i++) my_path[i] = 0;
 801b54c:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 801b550:	2100      	movs	r1, #0
 801b552:	a843      	add	r0, sp, #268	; 0x10c
 801b554:	f004 fdc2 	bl	80200dc <memset>
	wcscpy(my_path, path);
 801b558:	ee18 1a90 	vmov	r1, s17
 801b55c:	a843      	add	r0, sp, #268	; 0x10c
 801b55e:	f004 ff40 	bl	80203e2 <wcscpy>
	wcscat(my_path, L"/ANLZ0001.EXT");
 801b562:	4976      	ldr	r1, [pc, #472]	; (801b73c <DecodeRekordboxFiles+0x2c8>)
 801b564:	a843      	add	r0, sp, #268	; 0x10c
 801b566:	f004 ff2c 	bl	80203c2 <wcscat>
	res = f_open(&MyFile, my_path, FA_READ);
 801b56a:	2201      	movs	r2, #1
 801b56c:	a943      	add	r1, sp, #268	; 0x10c
 801b56e:	4870      	ldr	r0, [pc, #448]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b570:	f7f0 fd5e 	bl	800c030 <f_open>
	if(res == FR_OK) {
 801b574:	2800      	cmp	r0, #0
 801b576:	f000 8645 	beq.w	801c204 <DecodeRekordboxFiles+0xd90>
 801b57a:	4b71      	ldr	r3, [pc, #452]	; (801b740 <DecodeRekordboxFiles+0x2cc>)
 801b57c:	f503 5580 	add.w	r5, r3, #4096	; 0x1000
 801b580:	9300      	str	r3, [sp, #0]
		}
		f_close(&MyFile);
	}
	i = 0;
	uint8_t l = 0;
	while(i++  < rekordbox.spectrum_size) {
 801b582:	f8d3 ca8c 	ldr.w	ip, [r3, #2700]	; 0xa8c
 801b586:	f1bc 0f00 	cmp.w	ip, #0
 801b58a:	f001 80ff 	beq.w	801c78c <DecodeRekordboxFiles+0x1318>
 801b58e:	f1bc 0f01 	cmp.w	ip, #1
		if((i % 9000) == 0) {
			rekordbox.remminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * (rekordbox.spectrum_size - i) / rekordbox.spectrum_size);
 801b592:	f8d3 ea88 	ldr.w	lr, [r3, #2696]	; 0xa88
	while(i++  < rekordbox.spectrum_size) {
 801b596:	f001 80f6 	beq.w	801c786 <DecodeRekordboxFiles+0x1312>
 801b59a:	f1ac 0102 	sub.w	r1, ip, #2
 801b59e:	ea4f 004e 	mov.w	r0, lr, lsl #1
 801b5a2:	2200      	movs	r2, #0
 801b5a4:	2302      	movs	r3, #2
 801b5a6:	fb0e f101 	mul.w	r1, lr, r1
 801b5aa:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 801b760 <DecodeRekordboxFiles+0x2ec>
		if((i % 9000) == 0) {
 801b5ae:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 801b764 <DecodeRekordboxFiles+0x2f0>
			rekordbox.remminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * (rekordbox.spectrum_size - i) / rekordbox.spectrum_size);
 801b5b2:	f241 5748 	movw	r7, #5448	; 0x1548
			rekordbox.elminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * i / rekordbox.spectrum_size);
 801b5b6:	f241 5b88 	movw	fp, #5512	; 0x1588
			rekordbox.remminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * (rekordbox.spectrum_size - i) / rekordbox.spectrum_size);
 801b5ba:	fb09 f603 	mul.w	r6, r9, r3
		if((i % 9000) == 0) {
 801b5be:	ebb8 0ff6 	cmp.w	r8, r6, ror #3
			rekordbox.remminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * (rekordbox.spectrum_size - i) / rekordbox.spectrum_size);
 801b5c2:	eb02 0607 	add.w	r6, r2, r7
		if((i % 9000) == 0) {
 801b5c6:	d30c      	bcc.n	801b5e2 <DecodeRekordboxFiles+0x16e>
			rekordbox.remminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * (rekordbox.spectrum_size - i) / rekordbox.spectrum_size);
 801b5c8:	fbb1 fafc 	udiv	sl, r1, ip
 801b5cc:	f824 a016 	strh.w	sl, [r4, r6, lsl #1]
			l++;
 801b5d0:	f102 0a01 	add.w	sl, r2, #1
			rekordbox.elminticks[l] = (uint16_t)(rekordbox.lowp_spectrum_size * i / rekordbox.spectrum_size);
 801b5d4:	445a      	add	r2, fp
 801b5d6:	fbb0 f6fc 	udiv	r6, r0, ip
 801b5da:	f824 6012 	strh.w	r6, [r4, r2, lsl #1]
			l++;
 801b5de:	fa5f f28a 	uxtb.w	r2, sl
	while(i++  < rekordbox.spectrum_size) {
 801b5e2:	1c5e      	adds	r6, r3, #1
 801b5e4:	4563      	cmp	r3, ip
 801b5e6:	eba1 010e 	sub.w	r1, r1, lr
 801b5ea:	4470      	add	r0, lr
 801b5ec:	4633      	mov	r3, r6
 801b5ee:	d1e4      	bne.n	801b5ba <DecodeRekordboxFiles+0x146>
		}
	}
	rekordbox.minutes = l;
	rekordbox.state = 1;
 801b5f0:	2301      	movs	r3, #1
	return 0;
 801b5f2:	2000      	movs	r0, #0
	rekordbox.minutes = l;
 801b5f4:	9900      	ldr	r1, [sp, #0]
	rekordbox.state = 1;
 801b5f6:	f885 33d4 	strb.w	r3, [r5, #980]	; 0x3d4
	rekordbox.minutes = l;
 801b5fa:	f881 2b90 	strb.w	r2, [r1, #2960]	; 0xb90
}
 801b5fe:	f20d 5d0c 	addw	sp, sp, #1292	; 0x50c
 801b602:	ecbd 8b02 	vpop	{d8}
 801b606:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(FindToken(wv3_token) != 0) return 1;
 801b60a:	484e      	ldr	r0, [pc, #312]	; (801b744 <DecodeRekordboxFiles+0x2d0>)
 801b60c:	f7ff feec 	bl	801b3e8 <FindToken>
 801b610:	2800      	cmp	r0, #0
 801b612:	f040 81b4 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK);
 801b616:	4f4c      	ldr	r7, [pc, #304]	; (801b748 <DecodeRekordboxFiles+0x2d4>)
 801b618:	4e4c      	ldr	r6, [pc, #304]	; (801b74c <DecodeRekordboxFiles+0x2d8>)
 801b61a:	4d45      	ldr	r5, [pc, #276]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b61c:	463b      	mov	r3, r7
 801b61e:	220c      	movs	r2, #12
 801b620:	4631      	mov	r1, r6
 801b622:	4628      	mov	r0, r5
 801b624:	f7f0 fd66 	bl	800c0f4 <f_read>
 801b628:	2800      	cmp	r0, #0
 801b62a:	d1f7      	bne.n	801b61c <DecodeRekordboxFiles+0x1a8>
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b62c:	4e48      	ldr	r6, [pc, #288]	; (801b750 <DecodeRekordboxFiles+0x2dc>)
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b62e:	f8df 8118 	ldr.w	r8, [pc, #280]	; 801b748 <DecodeRekordboxFiles+0x2d4>
 801b632:	4637      	mov	r7, r6
 801b634:	4d3e      	ldr	r5, [pc, #248]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b636:	6030      	str	r0, [r6, #0]
 801b638:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b63a:	4643      	mov	r3, r8
 801b63c:	2204      	movs	r2, #4
 801b63e:	4639      	mov	r1, r7
 801b640:	4628      	mov	r0, r5
 801b642:	f7f0 fd57 	bl	800c0f4 <f_read>
 801b646:	2800      	cmp	r0, #0
 801b648:	d1f7      	bne.n	801b63a <DecodeRekordboxFiles+0x1c6>
		out_data |= tag[i];
 801b64a:	7833      	ldrb	r3, [r6, #0]
 801b64c:	7872      	ldrb	r2, [r6, #1]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b64e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 801b748 <DecodeRekordboxFiles+0x2d4>
		out_data |= tag[i];
 801b652:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801b656:	78b3      	ldrb	r3, [r6, #2]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b658:	4f3c      	ldr	r7, [pc, #240]	; (801b74c <DecodeRekordboxFiles+0x2d8>)
		out_data |= tag[i];
 801b65a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801b65e:	78f3      	ldrb	r3, [r6, #3]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b660:	4d33      	ldr	r5, [pc, #204]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
		out_data |= tag[i];
 801b662:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.spectrum_size=((rekordbox.spectrum_size>MAX_WAVESIZE)?MAX_WAVESIZE:rekordbox.spectrum_size);
 801b666:	4a3b      	ldr	r2, [pc, #236]	; (801b754 <DecodeRekordboxFiles+0x2e0>)
	out_data >>= 8;
 801b668:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.spectrum_size=((rekordbox.spectrum_size>MAX_WAVESIZE)?MAX_WAVESIZE:rekordbox.spectrum_size);
 801b66c:	4293      	cmp	r3, r2
 801b66e:	bf28      	it	cs
 801b670:	4613      	movcs	r3, r2
 801b672:	4a33      	ldr	r2, [pc, #204]	; (801b740 <DecodeRekordboxFiles+0x2cc>)
 801b674:	9200      	str	r2, [sp, #0]
 801b676:	f8c2 3a8c 	str.w	r3, [r2, #2700]	; 0xa8c
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b67a:	4643      	mov	r3, r8
 801b67c:	2204      	movs	r2, #4
 801b67e:	4639      	mov	r1, r7
 801b680:	4628      	mov	r0, r5
 801b682:	f7f0 fd37 	bl	800c0f4 <f_read>
 801b686:	2800      	cmp	r0, #0
 801b688:	d1f7      	bne.n	801b67a <DecodeRekordboxFiles+0x206>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801b68a:	9b00      	ldr	r3, [sp, #0]
		rekordbox.cue_start_position[0] = 0;
 801b68c:	4d32      	ldr	r5, [pc, #200]	; (801b758 <DecodeRekordboxFiles+0x2e4>)
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801b68e:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
		rekordbox.cue_start_position[0] = 0;
 801b692:	64a8      	str	r0, [r5, #72]	; 0x48
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801b694:	b1eb      	cbz	r3, 801b6d2 <DecodeRekordboxFiles+0x25e>
 801b696:	4681      	mov	r9, r0
			while(f_read(&MyFile, &tag[0], 1, (void *)&bytesread) != FR_OK);
 801b698:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 801b748 <DecodeRekordboxFiles+0x2d4>
 801b69c:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 801b750 <DecodeRekordboxFiles+0x2dc>
 801b6a0:	4f23      	ldr	r7, [pc, #140]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b6a2:	4653      	mov	r3, sl
 801b6a4:	2201      	movs	r2, #1
 801b6a6:	4641      	mov	r1, r8
 801b6a8:	4638      	mov	r0, r7
 801b6aa:	f7f0 fd23 	bl	800c0f4 <f_read>
 801b6ae:	2800      	cmp	r0, #0
 801b6b0:	d1f7      	bne.n	801b6a2 <DecodeRekordboxFiles+0x22e>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801b6b2:	4a1c      	ldr	r2, [pc, #112]	; (801b724 <DecodeRekordboxFiles+0x2b0>)
			*(__IO uint8_t*)(WAVE_BUFFER+i) = tag[0];
 801b6b4:	7833      	ldrb	r3, [r6, #0]
 801b6b6:	f809 3002 	strb.w	r3, [r9, r2]
			if(rekordbox.autocue == 1) {
 801b6ba:	f895 23cc 	ldrb.w	r2, [r5, #972]	; 0x3cc
 801b6be:	2a01      	cmp	r2, #1
 801b6c0:	f000 858b 	beq.w	801c1da <DecodeRekordboxFiles+0xd66>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801b6c4:	9b00      	ldr	r3, [sp, #0]
 801b6c6:	f109 0901 	add.w	r9, r9, #1
 801b6ca:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
 801b6ce:	454b      	cmp	r3, r9
 801b6d0:	d8e7      	bhi.n	801b6a2 <DecodeRekordboxFiles+0x22e>
		f_close(&MyFile);
 801b6d2:	4817      	ldr	r0, [pc, #92]	; (801b730 <DecodeRekordboxFiles+0x2bc>)
 801b6d4:	f7f0 fe22 	bl	800c31c <f_close>
 801b6d8:	e721      	b.n	801b51e <DecodeRekordboxFiles+0xaa>
		while(i < data_size) {
 801b6da:	2300      	movs	r3, #0
 801b6dc:	aa03      	add	r2, sp, #12
 801b6de:	3b01      	subs	r3, #1
 801b6e0:	4413      	add	r3, r2
 801b6e2:	2200      	movs	r2, #0
			if(filename[i] >= 32) {
 801b6e4:	f813 1f01 	ldrb.w	r1, [r3, #1]!
				k++;
 801b6e8:	f102 0c01 	add.w	ip, r2, #1
				rekordbox.filetype[k] = filename[i];
 801b6ec:	18a0      	adds	r0, r4, r2
			if(filename[i] >= 32) {
 801b6ee:	291f      	cmp	r1, #31
 801b6f0:	f240 856e 	bls.w	801c1d0 <DecodeRekordboxFiles+0xd5c>
				k++;
 801b6f4:	fa5f f28c 	uxtb.w	r2, ip
				rekordbox.filetype[k] = filename[i];
 801b6f8:	f880 14fb 	strb.w	r1, [r0, #1275]	; 0x4fb
		while(k < 5)
 801b6fc:	2a05      	cmp	r2, #5
 801b6fe:	d1f1      	bne.n	801b6e4 <DecodeRekordboxFiles+0x270>
		rekordbox.filetype[4] = 0;
 801b700:	2100      	movs	r1, #0
		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801b702:	22ff      	movs	r2, #255	; 0xff
 801b704:	4815      	ldr	r0, [pc, #84]	; (801b75c <DecodeRekordboxFiles+0x2e8>)
		rekordbox.filetype[4] = 0;
 801b706:	f884 14ff 	strb.w	r1, [r4, #1279]	; 0x4ff
		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801b70a:	f004 fce7 	bl	80200dc <memset>
		while((i > 0) && (filename[i] != '/')) i--;
 801b70e:	2f00      	cmp	r7, #0
 801b710:	f001 8065 	beq.w	801c7de <DecodeRekordboxFiles+0x136a>
 801b714:	ab03      	add	r3, sp, #12
 801b716:	1c7a      	adds	r2, r7, #1
 801b718:	441a      	add	r2, r3
 801b71a:	463b      	mov	r3, r7
 801b71c:	e027      	b.n	801b76e <DecodeRekordboxFiles+0x2fa>
 801b71e:	bf00      	nop
 801b720:	200154f0 	.word	0x200154f0
 801b724:	c0100000 	.word	0xc0100000
 801b728:	c0130d40 	.word	0xc0130d40
 801b72c:	08026df8 	.word	0x08026df8
 801b730:	20001e40 	.word	0x20001e40
 801b734:	08026e30 	.word	0x08026e30
 801b738:	08026e68 	.word	0x08026e68
 801b73c:	08026ea0 	.word	0x08026ea0
 801b740:	200174f0 	.word	0x200174f0
 801b744:	08026f00 	.word	0x08026f00
 801b748:	2000ec34 	.word	0x2000ec34
 801b74c:	20000e30 	.word	0x20000e30
 801b750:	200188c8 	.word	0x200188c8
 801b754:	00030d40 	.word	0x00030d40
 801b758:	200184f0 	.word	0x200184f0
 801b75c:	200158ec 	.word	0x200158ec
 801b760:	e7e10d6d 	.word	0xe7e10d6d
 801b764:	00074822 	.word	0x00074822
 801b768:	3b01      	subs	r3, #1
 801b76a:	f000 85e7 	beq.w	801c33c <DecodeRekordboxFiles+0xec8>
 801b76e:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801b772:	292f      	cmp	r1, #47	; 0x2f
 801b774:	d1f8      	bne.n	801b768 <DecodeRekordboxFiles+0x2f4>
		i++;
 801b776:	3301      	adds	r3, #1
		while(i < data_size)
 801b778:	429f      	cmp	r7, r3
 801b77a:	f241 802d 	bls.w	801c7d8 <DecodeRekordboxFiles+0x1364>
 801b77e:	aa03      	add	r2, sp, #12
 801b780:	3b01      	subs	r3, #1
 801b782:	4413      	add	r3, r2
 801b784:	f10d 020b 	add.w	r2, sp, #11
 801b788:	eb02 0c07 	add.w	ip, r2, r7
			if(filename[i] >= 32) {
 801b78c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
				k++;
 801b790:	1c68      	adds	r0, r5, #1
				rekordbox.file[k] = filename[i];
 801b792:	1961      	adds	r1, r4, r5
			if(filename[i] >= 32) {
 801b794:	2a1f      	cmp	r2, #31
 801b796:	d902      	bls.n	801b79e <DecodeRekordboxFiles+0x32a>
				k++;
 801b798:	b2c5      	uxtb	r5, r0
				rekordbox.file[k] = filename[i];
 801b79a:	f881 23fc 	strb.w	r2, [r1, #1020]	; 0x3fc
		while(i < data_size)
 801b79e:	4563      	cmp	r3, ip
 801b7a0:	d1f4      	bne.n	801b78c <DecodeRekordboxFiles+0x318>
		rekordbox.file[i] = 0;
 801b7a2:	4427      	add	r7, r4
 801b7a4:	2300      	movs	r3, #0
		if(FindToken(qtz_token) != 0) return 1;
 801b7a6:	48c2      	ldr	r0, [pc, #776]	; (801bab0 <DecodeRekordboxFiles+0x63c>)
		rekordbox.file[i] = 0;
 801b7a8:	f887 33fc 	strb.w	r3, [r7, #1020]	; 0x3fc
		if(FindToken(qtz_token) != 0) return 1;
 801b7ac:	f7ff fe1c 	bl	801b3e8 <FindToken>
 801b7b0:	2800      	cmp	r0, #0
 801b7b2:	f040 80e4 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 16, (void *)&bytesread) != FR_OK); // dummy read 22 bytes
 801b7b6:	f8df 8324 	ldr.w	r8, [pc, #804]	; 801badc <DecodeRekordboxFiles+0x668>
 801b7ba:	4fbe      	ldr	r7, [pc, #760]	; (801bab4 <DecodeRekordboxFiles+0x640>)
 801b7bc:	4dbe      	ldr	r5, [pc, #760]	; (801bab8 <DecodeRekordboxFiles+0x644>)
 801b7be:	4643      	mov	r3, r8
 801b7c0:	2210      	movs	r2, #16
 801b7c2:	4639      	mov	r1, r7
 801b7c4:	4628      	mov	r0, r5
 801b7c6:	f7f0 fc95 	bl	800c0f4 <f_read>
 801b7ca:	2800      	cmp	r0, #0
 801b7cc:	d1f7      	bne.n	801b7be <DecodeRekordboxFiles+0x34a>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b7ce:	f8df 830c 	ldr.w	r8, [pc, #780]	; 801badc <DecodeRekordboxFiles+0x668>
 801b7d2:	4fba      	ldr	r7, [pc, #744]	; (801babc <DecodeRekordboxFiles+0x648>)
 801b7d4:	4db8      	ldr	r5, [pc, #736]	; (801bab8 <DecodeRekordboxFiles+0x644>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b7d6:	6030      	str	r0, [r6, #0]
 801b7d8:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b7da:	4643      	mov	r3, r8
 801b7dc:	2204      	movs	r2, #4
 801b7de:	4639      	mov	r1, r7
 801b7e0:	4628      	mov	r0, r5
 801b7e2:	f7f0 fc87 	bl	800c0f4 <f_read>
 801b7e6:	2800      	cmp	r0, #0
 801b7e8:	d1f7      	bne.n	801b7da <DecodeRekordboxFiles+0x366>
		out_data |= tag[i];
 801b7ea:	7833      	ldrb	r3, [r6, #0]
 801b7ec:	7872      	ldrb	r2, [r6, #1]
 801b7ee:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801b7f2:	78b3      	ldrb	r3, [r6, #2]
 801b7f4:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801b7f8:	78f3      	ldrb	r3, [r6, #3]
 801b7fa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	out_data >>= 8;
 801b7fe:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.timezones = ((data_size>RBX_MAX_TQZ)?RBX_MAX_TQZ:data_size);  //memory protect!
 801b802:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 801b806:	461a      	mov	r2, r3
 801b808:	bf28      	it	cs
 801b80a:	f44f 6296 	movcs.w	r2, #1200	; 0x4b0
 801b80e:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
		for(i=0; i<rekordbox.timezones; i++) {
 801b812:	2b00      	cmp	r3, #0
 801b814:	d059      	beq.n	801b8ca <DecodeRekordboxFiles+0x456>
 801b816:	4baa      	ldr	r3, [pc, #680]	; (801bac0 <DecodeRekordboxFiles+0x64c>)
 801b818:	4680      	mov	r8, r0
 801b81a:	4aaa      	ldr	r2, [pc, #680]	; (801bac4 <DecodeRekordboxFiles+0x650>)
				while(f_read(&MyFile, &tag[k], 1, (void *)&bytesread) != FR_OK);
 801b81c:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 801badc <DecodeRekordboxFiles+0x668>
 801b820:	f6a3 195e 	subw	r9, r3, #2398	; 0x95e
 801b824:	4fa5      	ldr	r7, [pc, #660]	; (801babc <DecodeRekordboxFiles+0x648>)
 801b826:	4da4      	ldr	r5, [pc, #656]	; (801bab8 <DecodeRekordboxFiles+0x644>)
 801b828:	9300      	str	r3, [sp, #0]
 801b82a:	9201      	str	r2, [sp, #4]
 801b82c:	465b      	mov	r3, fp
 801b82e:	2201      	movs	r2, #1
 801b830:	4639      	mov	r1, r7
 801b832:	4628      	mov	r0, r5
 801b834:	f7f0 fc5e 	bl	800c0f4 <f_read>
 801b838:	2800      	cmp	r0, #0
 801b83a:	d1f7      	bne.n	801b82c <DecodeRekordboxFiles+0x3b8>
 801b83c:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 801bae4 <DecodeRekordboxFiles+0x670>
 801b840:	465b      	mov	r3, fp
 801b842:	2201      	movs	r2, #1
 801b844:	4651      	mov	r1, sl
 801b846:	4628      	mov	r0, r5
 801b848:	f7f0 fc54 	bl	800c0f4 <f_read>
 801b84c:	2800      	cmp	r0, #0
 801b84e:	d1f7      	bne.n	801b840 <DecodeRekordboxFiles+0x3cc>
			rekordbox.phase[i] |= tag[0];
 801b850:	f839 2f02 	ldrh.w	r2, [r9, #2]!
 801b854:	7833      	ldrb	r3, [r6, #0]
 801b856:	431a      	orrs	r2, r3
			rekordbox.phase[i] |= tag[1];
 801b858:	7873      	ldrb	r3, [r6, #1]
 801b85a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801b85e:	f8a9 3000 	strh.w	r3, [r9]
				while(f_read(&MyFile, &tag[k], 1, (void *)&bytesread) != FR_OK);
 801b862:	465b      	mov	r3, fp
 801b864:	2201      	movs	r2, #1
 801b866:	4639      	mov	r1, r7
 801b868:	4628      	mov	r0, r5
 801b86a:	f7f0 fc43 	bl	800c0f4 <f_read>
 801b86e:	2800      	cmp	r0, #0
 801b870:	d1f7      	bne.n	801b862 <DecodeRekordboxFiles+0x3ee>
 801b872:	f8df a270 	ldr.w	sl, [pc, #624]	; 801bae4 <DecodeRekordboxFiles+0x670>
 801b876:	465b      	mov	r3, fp
 801b878:	2201      	movs	r2, #1
 801b87a:	4651      	mov	r1, sl
 801b87c:	4628      	mov	r0, r5
 801b87e:	f7f0 fc39 	bl	800c0f4 <f_read>
 801b882:	2800      	cmp	r0, #0
 801b884:	d1f7      	bne.n	801b876 <DecodeRekordboxFiles+0x402>
			rekordbox.bpm[i] |= tag[0];
 801b886:	9901      	ldr	r1, [sp, #4]
 801b888:	7833      	ldrb	r3, [r6, #0]
 801b88a:	f831 2f02 	ldrh.w	r2, [r1, #2]!
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b88e:	7130      	strb	r0, [r6, #4]
			rekordbox.bpm[i] |= tag[0];
 801b890:	431a      	orrs	r2, r3
			rekordbox.bpm[i] |= tag[1];
 801b892:	7873      	ldrb	r3, [r6, #1]
			rekordbox.bpm[i] |= tag[0];
 801b894:	9101      	str	r1, [sp, #4]
			rekordbox.bpm[i] |= tag[1];
 801b896:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b89a:	6030      	str	r0, [r6, #0]
			rekordbox.bpm[i] |= tag[1];
 801b89c:	800b      	strh	r3, [r1, #0]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b89e:	465b      	mov	r3, fp
 801b8a0:	2204      	movs	r2, #4
 801b8a2:	4639      	mov	r1, r7
 801b8a4:	4628      	mov	r0, r5
 801b8a6:	f7f0 fc25 	bl	800c0f4 <f_read>
 801b8aa:	2800      	cmp	r0, #0
 801b8ac:	d1f7      	bne.n	801b89e <DecodeRekordboxFiles+0x42a>
		out_data |= tag[i];
 801b8ae:	6833      	ldr	r3, [r6, #0]
		for(i=0; i<rekordbox.timezones; i++) {
 801b8b0:	f108 0801 	add.w	r8, r8, #1
			rekordbox.timeindex[i] = GetLongNumber();
 801b8b4:	9a00      	ldr	r2, [sp, #0]
 801b8b6:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801b8b8:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.timeindex[i] = GetLongNumber();
 801b8bc:	f842 3f04 	str.w	r3, [r2, #4]!
		for(i=0; i<rekordbox.timezones; i++) {
 801b8c0:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
			rekordbox.timeindex[i] = GetLongNumber();
 801b8c4:	9200      	str	r2, [sp, #0]
		for(i=0; i<rekordbox.timezones; i++) {
 801b8c6:	4543      	cmp	r3, r8
 801b8c8:	d8b0      	bhi.n	801b82c <DecodeRekordboxFiles+0x3b8>
		if(rekordbox.phase[0] == 1) rekordbox.beat_grid_offset = 4;
 801b8ca:	f8b4 3e64 	ldrh.w	r3, [r4, #3684]	; 0xe64
 801b8ce:	2b01      	cmp	r3, #1
 801b8d0:	f000 875f 	beq.w	801c792 <DecodeRekordboxFiles+0x131e>
		else rekordbox.beat_grid_offset = rekordbox.phase[0] - 1;
 801b8d4:	3b01      	subs	r3, #1
 801b8d6:	b2db      	uxtb	r3, r3
 801b8d8:	4a7b      	ldr	r2, [pc, #492]	; (801bac8 <DecodeRekordboxFiles+0x654>)
		if(FindToken(wave_token) != 0) return 1;
 801b8da:	487c      	ldr	r0, [pc, #496]	; (801bacc <DecodeRekordboxFiles+0x658>)
 801b8dc:	9200      	str	r2, [sp, #0]
 801b8de:	f882 3a84 	strb.w	r3, [r2, #2692]	; 0xa84
 801b8e2:	f7ff fd81 	bl	801b3e8 <FindToken>
 801b8e6:	2800      	cmp	r0, #0
 801b8e8:	d149      	bne.n	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801b8ea:	f8df 81f0 	ldr.w	r8, [pc, #496]	; 801badc <DecodeRekordboxFiles+0x668>
 801b8ee:	4f71      	ldr	r7, [pc, #452]	; (801bab4 <DecodeRekordboxFiles+0x640>)
 801b8f0:	4d71      	ldr	r5, [pc, #452]	; (801bab8 <DecodeRekordboxFiles+0x644>)
 801b8f2:	4643      	mov	r3, r8
 801b8f4:	2208      	movs	r2, #8
 801b8f6:	4639      	mov	r1, r7
 801b8f8:	4628      	mov	r0, r5
 801b8fa:	f7f0 fbfb 	bl	800c0f4 <f_read>
 801b8fe:	2800      	cmp	r0, #0
 801b900:	d1f7      	bne.n	801b8f2 <DecodeRekordboxFiles+0x47e>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b902:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 801badc <DecodeRekordboxFiles+0x668>
 801b906:	4f6d      	ldr	r7, [pc, #436]	; (801babc <DecodeRekordboxFiles+0x648>)
 801b908:	4d6b      	ldr	r5, [pc, #428]	; (801bab8 <DecodeRekordboxFiles+0x644>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b90a:	6030      	str	r0, [r6, #0]
 801b90c:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b90e:	4643      	mov	r3, r8
 801b910:	2204      	movs	r2, #4
 801b912:	4639      	mov	r1, r7
 801b914:	4628      	mov	r0, r5
 801b916:	f7f0 fbed 	bl	800c0f4 <f_read>
 801b91a:	2800      	cmp	r0, #0
 801b91c:	d1f7      	bne.n	801b90e <DecodeRekordboxFiles+0x49a>
		out_data |= tag[i];
 801b91e:	7833      	ldrb	r3, [r6, #0]
 801b920:	7872      	ldrb	r2, [r6, #1]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b922:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 801badc <DecodeRekordboxFiles+0x668>
		out_data |= tag[i];
 801b926:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801b92a:	78b3      	ldrb	r3, [r6, #2]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b92c:	4f61      	ldr	r7, [pc, #388]	; (801bab4 <DecodeRekordboxFiles+0x640>)
		out_data |= tag[i];
 801b92e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801b932:	78f3      	ldrb	r3, [r6, #3]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b934:	4d60      	ldr	r5, [pc, #384]	; (801bab8 <DecodeRekordboxFiles+0x644>)
		out_data |= tag[i];
 801b936:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.lowp_spectrum_size = GetLongNumber();
 801b93a:	9a00      	ldr	r2, [sp, #0]
	out_data >>= 8;
 801b93c:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.lowp_spectrum_size = GetLongNumber();
 801b940:	f8c2 3a88 	str.w	r3, [r2, #2696]	; 0xa88
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801b944:	4643      	mov	r3, r8
 801b946:	2204      	movs	r2, #4
 801b948:	4639      	mov	r1, r7
 801b94a:	4628      	mov	r0, r5
 801b94c:	f7f0 fbd2 	bl	800c0f4 <f_read>
 801b950:	2800      	cmp	r0, #0
 801b952:	d1f7      	bne.n	801b944 <DecodeRekordboxFiles+0x4d0>
		while(f_read(&MyFile, &lowp_wavebuffer[0], rekordbox.lowp_spectrum_size, (void *)&bytesread) != FR_OK);
 801b954:	f8df 8184 	ldr.w	r8, [pc, #388]	; 801badc <DecodeRekordboxFiles+0x668>
 801b958:	4f5d      	ldr	r7, [pc, #372]	; (801bad0 <DecodeRekordboxFiles+0x65c>)
 801b95a:	4d57      	ldr	r5, [pc, #348]	; (801bab8 <DecodeRekordboxFiles+0x644>)
 801b95c:	f8dd 9000 	ldr.w	r9, [sp]
 801b960:	4643      	mov	r3, r8
 801b962:	f8d9 2a88 	ldr.w	r2, [r9, #2696]	; 0xa88
 801b966:	4639      	mov	r1, r7
 801b968:	4628      	mov	r0, r5
 801b96a:	f7f0 fbc3 	bl	800c0f4 <f_read>
 801b96e:	2800      	cmp	r0, #0
 801b970:	d1f6      	bne.n	801b960 <DecodeRekordboxFiles+0x4ec>
		if(FindToken(cob_token) != 0) return 1;
 801b972:	4858      	ldr	r0, [pc, #352]	; (801bad4 <DecodeRekordboxFiles+0x660>)
 801b974:	f7ff fd38 	bl	801b3e8 <FindToken>
 801b978:	2800      	cmp	r0, #0
 801b97a:	f000 84f9 	beq.w	801c370 <DecodeRekordboxFiles+0xefc>
		if(FindToken(path_token) != 0) return 1;
 801b97e:	2001      	movs	r0, #1
}
 801b980:	f20d 5d0c 	addw	sp, sp, #1292	; 0x50c
 801b984:	ecbd 8b02 	vpop	{d8}
 801b988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(FindToken(path_token) != 0) return 1;
 801b98c:	4852      	ldr	r0, [pc, #328]	; (801bad8 <DecodeRekordboxFiles+0x664>)
 801b98e:	f7ff fd2b 	bl	801b3e8 <FindToken>
 801b992:	2800      	cmp	r0, #0
 801b994:	d1f3      	bne.n	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801b996:	4f51      	ldr	r7, [pc, #324]	; (801badc <DecodeRekordboxFiles+0x668>)
 801b998:	4e46      	ldr	r6, [pc, #280]	; (801bab4 <DecodeRekordboxFiles+0x640>)
 801b99a:	4d47      	ldr	r5, [pc, #284]	; (801bab8 <DecodeRekordboxFiles+0x644>)
 801b99c:	463b      	mov	r3, r7
 801b99e:	2208      	movs	r2, #8
 801b9a0:	4631      	mov	r1, r6
 801b9a2:	4628      	mov	r0, r5
 801b9a4:	f7f0 fba6 	bl	800c0f4 <f_read>
 801b9a8:	2800      	cmp	r0, #0
 801b9aa:	d1f7      	bne.n	801b99c <DecodeRekordboxFiles+0x528>
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b9ac:	4e43      	ldr	r6, [pc, #268]	; (801babc <DecodeRekordboxFiles+0x648>)
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b9ae:	f8df 812c 	ldr.w	r8, [pc, #300]	; 801badc <DecodeRekordboxFiles+0x668>
 801b9b2:	4637      	mov	r7, r6
 801b9b4:	4d40      	ldr	r5, [pc, #256]	; (801bab8 <DecodeRekordboxFiles+0x644>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801b9b6:	6030      	str	r0, [r6, #0]
 801b9b8:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801b9ba:	4643      	mov	r3, r8
 801b9bc:	2204      	movs	r2, #4
 801b9be:	4639      	mov	r1, r7
 801b9c0:	4628      	mov	r0, r5
 801b9c2:	f7f0 fb97 	bl	800c0f4 <f_read>
 801b9c6:	2800      	cmp	r0, #0
 801b9c8:	d1f7      	bne.n	801b9ba <DecodeRekordboxFiles+0x546>
		out_data |= tag[i];
 801b9ca:	7873      	ldrb	r3, [r6, #1]
 801b9cc:	7837      	ldrb	r7, [r6, #0]
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801b9ce:	f8df 910c 	ldr.w	r9, [pc, #268]	; 801badc <DecodeRekordboxFiles+0x668>
		out_data |= tag[i];
 801b9d2:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
 801b9d6:	78b3      	ldrb	r3, [r6, #2]
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801b9d8:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 801bab8 <DecodeRekordboxFiles+0x644>
		out_data |= tag[i];
 801b9dc:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 801b9e0:	78f7      	ldrb	r7, [r6, #3]
 801b9e2:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
	out_data >>= 8;
 801b9e6:	f347 0717 	sbfx	r7, r7, #0, #24
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801b9ea:	464b      	mov	r3, r9
 801b9ec:	463a      	mov	r2, r7
 801b9ee:	a903      	add	r1, sp, #12
 801b9f0:	4640      	mov	r0, r8
 801b9f2:	f7f0 fb7f 	bl	800c0f4 <f_read>
 801b9f6:	2800      	cmp	r0, #0
 801b9f8:	d1f7      	bne.n	801b9ea <DecodeRekordboxFiles+0x576>
		while(i < data_size) {
 801b9fa:	4605      	mov	r5, r0
 801b9fc:	2f00      	cmp	r7, #0
 801b9fe:	f000 83ce 	beq.w	801c19e <DecodeRekordboxFiles+0xd2a>
 801ba02:	f107 3aff 	add.w	sl, r7, #4294967295
 801ba06:	f10d 030d 	add.w	r3, sp, #13
 801ba0a:	f10d 0b0c 	add.w	fp, sp, #12
 801ba0e:	eb03 095a 	add.w	r9, r3, sl, lsr #1
 801ba12:	46d8      	mov	r8, fp
 801ba14:	ea4f 035a 	mov.w	r3, sl, lsr #1
 801ba18:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 801bae8 <DecodeRekordboxFiles+0x674>
 801ba1c:	9300      	str	r3, [sp, #0]
			WCHAR c = filename[i];
 801ba1e:	f898 3000 	ldrb.w	r3, [r8]
			filename[k] = ff_convert(c, 0);
 801ba22:	2100      	movs	r1, #0
			c |= filename[i];
 801ba24:	f898 0001 	ldrb.w	r0, [r8, #1]
		while(i < data_size) {
 801ba28:	f108 0802 	add.w	r8, r8, #2
			c |= filename[i];
 801ba2c:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			rekordbox.filename[k] = c;
 801ba30:	f84a 0b04 	str.w	r0, [sl], #4
			filename[k] = ff_convert(c, 0);
 801ba34:	f7f0 ffae 	bl	800c994 <ff_convert>
 801ba38:	f80b 0b01 	strb.w	r0, [fp], #1
		while(i < data_size) {
 801ba3c:	45d9      	cmp	r9, fp
 801ba3e:	d1ee      	bne.n	801ba1e <DecodeRekordboxFiles+0x5aa>
			k++;
 801ba40:	9800      	ldr	r0, [sp, #0]
 801ba42:	3001      	adds	r0, #1
		for(i = k; i < data_size; i++) filename[i] = 0;
 801ba44:	b2c0      	uxtb	r0, r0
 801ba46:	42b8      	cmp	r0, r7
 801ba48:	d205      	bcs.n	801ba56 <DecodeRekordboxFiles+0x5e2>
 801ba4a:	ab03      	add	r3, sp, #12
 801ba4c:	1a3a      	subs	r2, r7, r0
 801ba4e:	2100      	movs	r1, #0
 801ba50:	4418      	add	r0, r3
 801ba52:	f004 fb43 	bl	80200dc <memset>
 801ba56:	ab03      	add	r3, sp, #12
 801ba58:	1c7a      	adds	r2, r7, #1
 801ba5a:	441a      	add	r2, r3
		while(i < data_size) {
 801ba5c:	463b      	mov	r3, r7
 801ba5e:	e002      	b.n	801ba66 <DecodeRekordboxFiles+0x5f2>
		while((i > 0) && (filename[i] != '.')) i--;
 801ba60:	3b01      	subs	r3, #1
 801ba62:	f000 839c 	beq.w	801c19e <DecodeRekordboxFiles+0xd2a>
 801ba66:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801ba6a:	292e      	cmp	r1, #46	; 0x2e
 801ba6c:	d1f8      	bne.n	801ba60 <DecodeRekordboxFiles+0x5ec>
 801ba6e:	aa03      	add	r2, sp, #12
 801ba70:	3b01      	subs	r3, #1
 801ba72:	4413      	add	r3, r2
		while(i < data_size) {
 801ba74:	2200      	movs	r2, #0
			if(filename[i] >= 32) {
 801ba76:	f813 1f01 	ldrb.w	r1, [r3, #1]!
				k++;
 801ba7a:	f102 0c01 	add.w	ip, r2, #1
				rekordbox.filetype[k] = filename[i];
 801ba7e:	18a0      	adds	r0, r4, r2
			if(filename[i] >= 32) {
 801ba80:	291f      	cmp	r1, #31
 801ba82:	f240 83a1 	bls.w	801c1c8 <DecodeRekordboxFiles+0xd54>
				k++;
 801ba86:	fa5f f28c 	uxtb.w	r2, ip
				rekordbox.filetype[k] = filename[i];
 801ba8a:	f880 14fb 	strb.w	r1, [r0, #1275]	; 0x4fb
		while(k < 5)
 801ba8e:	2a05      	cmp	r2, #5
 801ba90:	d1f1      	bne.n	801ba76 <DecodeRekordboxFiles+0x602>
		rekordbox.filetype[4] = 0;
 801ba92:	2100      	movs	r1, #0
		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801ba94:	22ff      	movs	r2, #255	; 0xff
 801ba96:	4812      	ldr	r0, [pc, #72]	; (801bae0 <DecodeRekordboxFiles+0x66c>)
		rekordbox.filetype[4] = 0;
 801ba98:	f884 14ff 	strb.w	r1, [r4, #1279]	; 0x4ff
		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801ba9c:	f004 fb1e 	bl	80200dc <memset>
		while((i > 0) && (filename[i] != '/')) i--;
 801baa0:	2f00      	cmp	r7, #0
 801baa2:	f000 86a2 	beq.w	801c7ea <DecodeRekordboxFiles+0x1376>
 801baa6:	ab03      	add	r3, sp, #12
 801baa8:	1c7a      	adds	r2, r7, #1
 801baaa:	441a      	add	r2, r3
 801baac:	463b      	mov	r3, r7
 801baae:	e020      	b.n	801baf2 <DecodeRekordboxFiles+0x67e>
 801bab0:	08026ef0 	.word	0x08026ef0
 801bab4:	20000e30 	.word	0x20000e30
 801bab8:	20001e40 	.word	0x20001e40
 801babc:	200188c8 	.word	0x200188c8
 801bac0:	20016cb0 	.word	0x20016cb0
 801bac4:	200159f2 	.word	0x200159f2
 801bac8:	200174f0 	.word	0x200174f0
 801bacc:	08026ef8 	.word	0x08026ef8
 801bad0:	2000f0e0 	.word	0x2000f0e0
 801bad4:	08026ed8 	.word	0x08026ed8
 801bad8:	08026ee8 	.word	0x08026ee8
 801badc:	2000ec34 	.word	0x2000ec34
 801bae0:	200158ec 	.word	0x200158ec
 801bae4:	200188c9 	.word	0x200188c9
 801bae8:	200154f0 	.word	0x200154f0
 801baec:	3b01      	subs	r3, #1
 801baee:	f000 8422 	beq.w	801c336 <DecodeRekordboxFiles+0xec2>
 801baf2:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801baf6:	292f      	cmp	r1, #47	; 0x2f
 801baf8:	d1f8      	bne.n	801baec <DecodeRekordboxFiles+0x678>
		i++;
 801bafa:	3301      	adds	r3, #1
		while(i < data_size)
 801bafc:	429f      	cmp	r7, r3
 801bafe:	f240 8671 	bls.w	801c7e4 <DecodeRekordboxFiles+0x1370>
 801bb02:	aa03      	add	r2, sp, #12
 801bb04:	3b01      	subs	r3, #1
 801bb06:	4413      	add	r3, r2
 801bb08:	f10d 020b 	add.w	r2, sp, #11
 801bb0c:	eb02 0c07 	add.w	ip, r2, r7
			if(filename[i] >= 32) {
 801bb10:	f813 2f01 	ldrb.w	r2, [r3, #1]!
				k++;
 801bb14:	1c68      	adds	r0, r5, #1
				rekordbox.file[k] = filename[i];
 801bb16:	1961      	adds	r1, r4, r5
			if(filename[i] >= 32) {
 801bb18:	2a1f      	cmp	r2, #31
 801bb1a:	d902      	bls.n	801bb22 <DecodeRekordboxFiles+0x6ae>
				k++;
 801bb1c:	b2c5      	uxtb	r5, r0
				rekordbox.file[k] = filename[i];
 801bb1e:	f881 23fc 	strb.w	r2, [r1, #1020]	; 0x3fc
		while(i < data_size)
 801bb22:	4563      	cmp	r3, ip
 801bb24:	d1f4      	bne.n	801bb10 <DecodeRekordboxFiles+0x69c>
		rekordbox.file[i] = 0;
 801bb26:	4427      	add	r7, r4
 801bb28:	2300      	movs	r3, #0
		if(FindToken(qtz_token) != 0) return 1;
 801bb2a:	48bf      	ldr	r0, [pc, #764]	; (801be28 <DecodeRekordboxFiles+0x9b4>)
		rekordbox.file[i] = 0;
 801bb2c:	f887 33fc 	strb.w	r3, [r7, #1020]	; 0x3fc
		if(FindToken(qtz_token) != 0) return 1;
 801bb30:	f7ff fc5a 	bl	801b3e8 <FindToken>
 801bb34:	2800      	cmp	r0, #0
 801bb36:	f47f af22 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 16, (void *)&bytesread) != FR_OK); // dummy read 16 bytes
 801bb3a:	f8df 831c 	ldr.w	r8, [pc, #796]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bb3e:	4fbb      	ldr	r7, [pc, #748]	; (801be2c <DecodeRekordboxFiles+0x9b8>)
 801bb40:	4dbb      	ldr	r5, [pc, #748]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bb42:	4643      	mov	r3, r8
 801bb44:	2210      	movs	r2, #16
 801bb46:	4639      	mov	r1, r7
 801bb48:	4628      	mov	r0, r5
 801bb4a:	f7f0 fad3 	bl	800c0f4 <f_read>
 801bb4e:	2800      	cmp	r0, #0
 801bb50:	d1f7      	bne.n	801bb42 <DecodeRekordboxFiles+0x6ce>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bb52:	f8df 8304 	ldr.w	r8, [pc, #772]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bb56:	4fb7      	ldr	r7, [pc, #732]	; (801be34 <DecodeRekordboxFiles+0x9c0>)
 801bb58:	4db5      	ldr	r5, [pc, #724]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bb5a:	6030      	str	r0, [r6, #0]
 801bb5c:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bb5e:	4643      	mov	r3, r8
 801bb60:	2204      	movs	r2, #4
 801bb62:	4639      	mov	r1, r7
 801bb64:	4628      	mov	r0, r5
 801bb66:	f7f0 fac5 	bl	800c0f4 <f_read>
 801bb6a:	2800      	cmp	r0, #0
 801bb6c:	d1f7      	bne.n	801bb5e <DecodeRekordboxFiles+0x6ea>
		out_data |= tag[i];
 801bb6e:	7833      	ldrb	r3, [r6, #0]
 801bb70:	7872      	ldrb	r2, [r6, #1]
 801bb72:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801bb76:	78b3      	ldrb	r3, [r6, #2]
 801bb78:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801bb7c:	78f3      	ldrb	r3, [r6, #3]
 801bb7e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	out_data >>= 8;
 801bb82:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.timezones = ((data_size>RBX_MAX_TQZ)?RBX_MAX_TQZ:data_size);  //memory protect!
 801bb86:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 801bb8a:	461a      	mov	r2, r3
 801bb8c:	bf28      	it	cs
 801bb8e:	f44f 6296 	movcs.w	r2, #1200	; 0x4b0
 801bb92:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
		for(i=0; i<rekordbox.timezones; i++) {
 801bb96:	2b00      	cmp	r3, #0
 801bb98:	d059      	beq.n	801bc4e <DecodeRekordboxFiles+0x7da>
 801bb9a:	4ba7      	ldr	r3, [pc, #668]	; (801be38 <DecodeRekordboxFiles+0x9c4>)
 801bb9c:	4680      	mov	r8, r0
 801bb9e:	4aa7      	ldr	r2, [pc, #668]	; (801be3c <DecodeRekordboxFiles+0x9c8>)
				while(f_read(&MyFile, &tag[k], 1, (void *)&bytesread) != FR_OK);
 801bba0:	f8df b2b4 	ldr.w	fp, [pc, #692]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bba4:	f6a3 195e 	subw	r9, r3, #2398	; 0x95e
 801bba8:	4fa2      	ldr	r7, [pc, #648]	; (801be34 <DecodeRekordboxFiles+0x9c0>)
 801bbaa:	4da1      	ldr	r5, [pc, #644]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bbac:	9300      	str	r3, [sp, #0]
 801bbae:	9201      	str	r2, [sp, #4]
 801bbb0:	465b      	mov	r3, fp
 801bbb2:	2201      	movs	r2, #1
 801bbb4:	4639      	mov	r1, r7
 801bbb6:	4628      	mov	r0, r5
 801bbb8:	f7f0 fa9c 	bl	800c0f4 <f_read>
 801bbbc:	2800      	cmp	r0, #0
 801bbbe:	d1f7      	bne.n	801bbb0 <DecodeRekordboxFiles+0x73c>
 801bbc0:	f8df a298 	ldr.w	sl, [pc, #664]	; 801be5c <DecodeRekordboxFiles+0x9e8>
 801bbc4:	465b      	mov	r3, fp
 801bbc6:	2201      	movs	r2, #1
 801bbc8:	4651      	mov	r1, sl
 801bbca:	4628      	mov	r0, r5
 801bbcc:	f7f0 fa92 	bl	800c0f4 <f_read>
 801bbd0:	2800      	cmp	r0, #0
 801bbd2:	d1f7      	bne.n	801bbc4 <DecodeRekordboxFiles+0x750>
			rekordbox.phase[i] |= tag[0];
 801bbd4:	f839 2f02 	ldrh.w	r2, [r9, #2]!
 801bbd8:	7833      	ldrb	r3, [r6, #0]
 801bbda:	431a      	orrs	r2, r3
			rekordbox.phase[i] |= tag[1];
 801bbdc:	7873      	ldrb	r3, [r6, #1]
 801bbde:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801bbe2:	f8a9 3000 	strh.w	r3, [r9]
				while(f_read(&MyFile, &tag[k], 1, (void *)&bytesread) != FR_OK);
 801bbe6:	465b      	mov	r3, fp
 801bbe8:	2201      	movs	r2, #1
 801bbea:	4639      	mov	r1, r7
 801bbec:	4628      	mov	r0, r5
 801bbee:	f7f0 fa81 	bl	800c0f4 <f_read>
 801bbf2:	2800      	cmp	r0, #0
 801bbf4:	d1f7      	bne.n	801bbe6 <DecodeRekordboxFiles+0x772>
 801bbf6:	f8df a264 	ldr.w	sl, [pc, #612]	; 801be5c <DecodeRekordboxFiles+0x9e8>
 801bbfa:	465b      	mov	r3, fp
 801bbfc:	2201      	movs	r2, #1
 801bbfe:	4651      	mov	r1, sl
 801bc00:	4628      	mov	r0, r5
 801bc02:	f7f0 fa77 	bl	800c0f4 <f_read>
 801bc06:	2800      	cmp	r0, #0
 801bc08:	d1f7      	bne.n	801bbfa <DecodeRekordboxFiles+0x786>
			rekordbox.bpm[i] |= tag[0];
 801bc0a:	9901      	ldr	r1, [sp, #4]
 801bc0c:	7833      	ldrb	r3, [r6, #0]
 801bc0e:	f831 2f02 	ldrh.w	r2, [r1, #2]!
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bc12:	7130      	strb	r0, [r6, #4]
			rekordbox.bpm[i] |= tag[0];
 801bc14:	431a      	orrs	r2, r3
			rekordbox.bpm[i] |= tag[1];
 801bc16:	7873      	ldrb	r3, [r6, #1]
			rekordbox.bpm[i] |= tag[0];
 801bc18:	9101      	str	r1, [sp, #4]
			rekordbox.bpm[i] |= tag[1];
 801bc1a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bc1e:	6030      	str	r0, [r6, #0]
			rekordbox.bpm[i] |= tag[1];
 801bc20:	800b      	strh	r3, [r1, #0]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bc22:	465b      	mov	r3, fp
 801bc24:	2204      	movs	r2, #4
 801bc26:	4639      	mov	r1, r7
 801bc28:	4628      	mov	r0, r5
 801bc2a:	f7f0 fa63 	bl	800c0f4 <f_read>
 801bc2e:	2800      	cmp	r0, #0
 801bc30:	d1f7      	bne.n	801bc22 <DecodeRekordboxFiles+0x7ae>
		out_data |= tag[i];
 801bc32:	6833      	ldr	r3, [r6, #0]
		for(i=0; i<rekordbox.timezones; i++) {
 801bc34:	f108 0801 	add.w	r8, r8, #1
			rekordbox.timeindex[i] = GetLongNumber();
 801bc38:	9a00      	ldr	r2, [sp, #0]
 801bc3a:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801bc3c:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.timeindex[i] = GetLongNumber();
 801bc40:	f842 3f04 	str.w	r3, [r2, #4]!
		for(i=0; i<rekordbox.timezones; i++) {
 801bc44:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
			rekordbox.timeindex[i] = GetLongNumber();
 801bc48:	9200      	str	r2, [sp, #0]
		for(i=0; i<rekordbox.timezones; i++) {
 801bc4a:	4543      	cmp	r3, r8
 801bc4c:	d8b0      	bhi.n	801bbb0 <DecodeRekordboxFiles+0x73c>
		if(rekordbox.phase[0] == 1) rekordbox.beat_grid_offset = 4;
 801bc4e:	f8b4 3e64 	ldrh.w	r3, [r4, #3684]	; 0xe64
 801bc52:	2b01      	cmp	r3, #1
 801bc54:	f000 8574 	beq.w	801c740 <DecodeRekordboxFiles+0x12cc>
		else rekordbox.beat_grid_offset = rekordbox.phase[0] - 1;
 801bc58:	3b01      	subs	r3, #1
 801bc5a:	b2db      	uxtb	r3, r3
 801bc5c:	4a78      	ldr	r2, [pc, #480]	; (801be40 <DecodeRekordboxFiles+0x9cc>)
		if(FindToken(wave_token) != 0) return 1;
 801bc5e:	4879      	ldr	r0, [pc, #484]	; (801be44 <DecodeRekordboxFiles+0x9d0>)
 801bc60:	9200      	str	r2, [sp, #0]
 801bc62:	f882 3a84 	strb.w	r3, [r2, #2692]	; 0xa84
 801bc66:	f7ff fbbf 	bl	801b3e8 <FindToken>
 801bc6a:	2800      	cmp	r0, #0
 801bc6c:	f47f ae87 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801bc70:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bc74:	4f6d      	ldr	r7, [pc, #436]	; (801be2c <DecodeRekordboxFiles+0x9b8>)
 801bc76:	4d6e      	ldr	r5, [pc, #440]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bc78:	4643      	mov	r3, r8
 801bc7a:	2208      	movs	r2, #8
 801bc7c:	4639      	mov	r1, r7
 801bc7e:	4628      	mov	r0, r5
 801bc80:	f7f0 fa38 	bl	800c0f4 <f_read>
 801bc84:	2800      	cmp	r0, #0
 801bc86:	d1f7      	bne.n	801bc78 <DecodeRekordboxFiles+0x804>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bc88:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bc8c:	4f69      	ldr	r7, [pc, #420]	; (801be34 <DecodeRekordboxFiles+0x9c0>)
 801bc8e:	4d68      	ldr	r5, [pc, #416]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bc90:	6030      	str	r0, [r6, #0]
 801bc92:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bc94:	4643      	mov	r3, r8
 801bc96:	2204      	movs	r2, #4
 801bc98:	4639      	mov	r1, r7
 801bc9a:	4628      	mov	r0, r5
 801bc9c:	f7f0 fa2a 	bl	800c0f4 <f_read>
 801bca0:	2800      	cmp	r0, #0
 801bca2:	d1f7      	bne.n	801bc94 <DecodeRekordboxFiles+0x820>
		out_data |= tag[i];
 801bca4:	7833      	ldrb	r3, [r6, #0]
 801bca6:	7872      	ldrb	r2, [r6, #1]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bca8:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 801be58 <DecodeRekordboxFiles+0x9e4>
		out_data |= tag[i];
 801bcac:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801bcb0:	78b3      	ldrb	r3, [r6, #2]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bcb2:	4f5e      	ldr	r7, [pc, #376]	; (801be2c <DecodeRekordboxFiles+0x9b8>)
		out_data |= tag[i];
 801bcb4:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801bcb8:	78f3      	ldrb	r3, [r6, #3]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bcba:	4d5d      	ldr	r5, [pc, #372]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
		out_data |= tag[i];
 801bcbc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.lowp_spectrum_size = GetLongNumber();
 801bcc0:	9a00      	ldr	r2, [sp, #0]
	out_data >>= 8;
 801bcc2:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.lowp_spectrum_size = GetLongNumber();
 801bcc6:	f8c2 3a88 	str.w	r3, [r2, #2696]	; 0xa88
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bcca:	4643      	mov	r3, r8
 801bccc:	2204      	movs	r2, #4
 801bcce:	4639      	mov	r1, r7
 801bcd0:	4628      	mov	r0, r5
 801bcd2:	f7f0 fa0f 	bl	800c0f4 <f_read>
 801bcd6:	2800      	cmp	r0, #0
 801bcd8:	d1f7      	bne.n	801bcca <DecodeRekordboxFiles+0x856>
		while(f_read(&MyFile, &lowp_wavebuffer[0], rekordbox.lowp_spectrum_size, (void *)&bytesread) != FR_OK);
 801bcda:	f8df 817c 	ldr.w	r8, [pc, #380]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bcde:	4f5a      	ldr	r7, [pc, #360]	; (801be48 <DecodeRekordboxFiles+0x9d4>)
 801bce0:	4d53      	ldr	r5, [pc, #332]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bce2:	f8dd 9000 	ldr.w	r9, [sp]
 801bce6:	4643      	mov	r3, r8
 801bce8:	f8d9 2a88 	ldr.w	r2, [r9, #2696]	; 0xa88
 801bcec:	4639      	mov	r1, r7
 801bcee:	4628      	mov	r0, r5
 801bcf0:	f7f0 fa00 	bl	800c0f4 <f_read>
 801bcf4:	2800      	cmp	r0, #0
 801bcf6:	d1f6      	bne.n	801bce6 <DecodeRekordboxFiles+0x872>
		if(FindToken(cob_token) != 0) return 1;
 801bcf8:	4854      	ldr	r0, [pc, #336]	; (801be4c <DecodeRekordboxFiles+0x9d8>)
 801bcfa:	f7ff fb75 	bl	801b3e8 <FindToken>
 801bcfe:	2800      	cmp	r0, #0
 801bd00:	f47f ae3d 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK); // dummy read 12 bytes
 801bd04:	f8df 8150 	ldr.w	r8, [pc, #336]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bd08:	4f48      	ldr	r7, [pc, #288]	; (801be2c <DecodeRekordboxFiles+0x9b8>)
 801bd0a:	4d49      	ldr	r5, [pc, #292]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bd0c:	4643      	mov	r3, r8
 801bd0e:	220c      	movs	r2, #12
 801bd10:	4639      	mov	r1, r7
 801bd12:	4628      	mov	r0, r5
 801bd14:	f7f0 f9ee 	bl	800c0f4 <f_read>
 801bd18:	2800      	cmp	r0, #0
 801bd1a:	d1f7      	bne.n	801bd0c <DecodeRekordboxFiles+0x898>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bd1c:	f8df 8138 	ldr.w	r8, [pc, #312]	; 801be58 <DecodeRekordboxFiles+0x9e4>
 801bd20:	4f44      	ldr	r7, [pc, #272]	; (801be34 <DecodeRekordboxFiles+0x9c0>)
 801bd22:	4d43      	ldr	r5, [pc, #268]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bd24:	6030      	str	r0, [r6, #0]
 801bd26:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bd28:	4643      	mov	r3, r8
 801bd2a:	2204      	movs	r2, #4
 801bd2c:	4639      	mov	r1, r7
 801bd2e:	4628      	mov	r0, r5
 801bd30:	f7f0 f9e0 	bl	800c0f4 <f_read>
 801bd34:	2800      	cmp	r0, #0
 801bd36:	d1f7      	bne.n	801bd28 <DecodeRekordboxFiles+0x8b4>
		out_data |= tag[i];
 801bd38:	7833      	ldrb	r3, [r6, #0]
 801bd3a:	7872      	ldrb	r2, [r6, #1]
 801bd3c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801bd40:	78b3      	ldrb	r3, [r6, #2]
 801bd42:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801bd46:	78f3      	ldrb	r3, [r6, #3]
 801bd48:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801bd4c:	9a00      	ldr	r2, [sp, #0]
	out_data >>= 8;
 801bd4e:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.cues = GetLongNumber() + 1;
 801bd52:	3301      	adds	r3, #1
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801bd54:	2b64      	cmp	r3, #100	; 0x64
 801bd56:	bfa8      	it	ge
 801bd58:	2364      	movge	r3, #100	; 0x64
		for(i = 1; i < rekordbox.cues; i++) {
 801bd5a:	2b01      	cmp	r3, #1
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801bd5c:	f8c2 3b94 	str.w	r3, [r2, #2964]	; 0xb94
		for(i = 1; i < rekordbox.cues; i++) {
 801bd60:	f240 8549 	bls.w	801c7f6 <DecodeRekordboxFiles+0x1382>
 801bd64:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 801be60 <DecodeRekordboxFiles+0x9ec>
 801bd68:	f04f 0a01 	mov.w	sl, #1
			rekordbox.cue_start_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801bd6c:	ed9f 8a38 	vldr	s16, [pc, #224]	; 801be50 <DecodeRekordboxFiles+0x9dc>
 801bd70:	f208 75d1 	addw	r5, r8, #2001	; 0x7d1
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801bd74:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 801be58 <DecodeRekordboxFiles+0x9e4>
			if(FindToken(cue_token) != 0) return 1;
 801bd78:	4836      	ldr	r0, [pc, #216]	; (801be54 <DecodeRekordboxFiles+0x9e0>)
 801bd7a:	f7ff fb35 	bl	801b3e8 <FindToken>
 801bd7e:	2800      	cmp	r0, #0
 801bd80:	f47f adfd 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801bd84:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 801be2c <DecodeRekordboxFiles+0x9b8>
 801bd88:	4f29      	ldr	r7, [pc, #164]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801bd8a:	465b      	mov	r3, fp
 801bd8c:	2208      	movs	r2, #8
 801bd8e:	4649      	mov	r1, r9
 801bd90:	4638      	mov	r0, r7
 801bd92:	f7f0 f9af 	bl	800c0f4 <f_read>
 801bd96:	2800      	cmp	r0, #0
 801bd98:	d1f7      	bne.n	801bd8a <DecodeRekordboxFiles+0x916>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bd9a:	f8df 9098 	ldr.w	r9, [pc, #152]	; 801be34 <DecodeRekordboxFiles+0x9c0>
 801bd9e:	4f24      	ldr	r7, [pc, #144]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bda0:	6030      	str	r0, [r6, #0]
 801bda2:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bda4:	465b      	mov	r3, fp
 801bda6:	2204      	movs	r2, #4
 801bda8:	4649      	mov	r1, r9
 801bdaa:	4638      	mov	r0, r7
 801bdac:	f7f0 f9a2 	bl	800c0f4 <f_read>
 801bdb0:	2800      	cmp	r0, #0
 801bdb2:	d1f7      	bne.n	801bda4 <DecodeRekordboxFiles+0x930>
		out_data |= tag[i];
 801bdb4:	6833      	ldr	r3, [r6, #0]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bdb6:	f8df 907c 	ldr.w	r9, [pc, #124]	; 801be34 <DecodeRekordboxFiles+0x9c0>
 801bdba:	ba1b      	rev	r3, r3
 801bdbc:	4f1c      	ldr	r7, [pc, #112]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bdbe:	7130      	strb	r0, [r6, #4]
	out_data >>= 8;
 801bdc0:	f343 0317 	sbfx	r3, r3, #0, #24
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bdc4:	6030      	str	r0, [r6, #0]
			rekordbox.cue_number[i] = GetLongNumber();
 801bdc6:	f848 3f04 	str.w	r3, [r8, #4]!
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bdca:	465b      	mov	r3, fp
 801bdcc:	2204      	movs	r2, #4
 801bdce:	4649      	mov	r1, r9
 801bdd0:	4638      	mov	r0, r7
 801bdd2:	f7f0 f98f 	bl	800c0f4 <f_read>
 801bdd6:	2800      	cmp	r0, #0
 801bdd8:	d1f7      	bne.n	801bdca <DecodeRekordboxFiles+0x956>
		out_data |= tag[i];
 801bdda:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bddc:	f8df 904c 	ldr.w	r9, [pc, #76]	; 801be2c <DecodeRekordboxFiles+0x9b8>
 801bde0:	ba1b      	rev	r3, r3
 801bde2:	4f13      	ldr	r7, [pc, #76]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	out_data >>= 8;
 801bde4:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_active[i] = GetLongNumber();
 801bde8:	f8c8 3190 	str.w	r3, [r8, #400]	; 0x190
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bdec:	465b      	mov	r3, fp
 801bdee:	2204      	movs	r2, #4
 801bdf0:	4649      	mov	r1, r9
 801bdf2:	4638      	mov	r0, r7
 801bdf4:	f7f0 f97e 	bl	800c0f4 <f_read>
 801bdf8:	2800      	cmp	r0, #0
 801bdfa:	d1f7      	bne.n	801bdec <DecodeRekordboxFiles+0x978>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bdfc:	f8df 9034 	ldr.w	r9, [pc, #52]	; 801be34 <DecodeRekordboxFiles+0x9c0>
 801be00:	4f0b      	ldr	r7, [pc, #44]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801be02:	6030      	str	r0, [r6, #0]
 801be04:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801be06:	465b      	mov	r3, fp
 801be08:	2204      	movs	r2, #4
 801be0a:	4649      	mov	r1, r9
 801be0c:	4638      	mov	r0, r7
 801be0e:	f7f0 f971 	bl	800c0f4 <f_read>
 801be12:	2800      	cmp	r0, #0
 801be14:	d1f7      	bne.n	801be06 <DecodeRekordboxFiles+0x992>
		out_data |= tag[i];
 801be16:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[i], 1, (void *)&bytesread) != FR_OK);
 801be18:	4f05      	ldr	r7, [pc, #20]	; (801be30 <DecodeRekordboxFiles+0x9bc>)
 801be1a:	ba1b      	rev	r3, r3
 801be1c:	9501      	str	r5, [sp, #4]
	out_data >>= 8;
 801be1e:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_type[i] = GetLongNumber();
 801be22:	f8c8 3320 	str.w	r3, [r8, #800]	; 0x320
 801be26:	e01d      	b.n	801be64 <DecodeRekordboxFiles+0x9f0>
 801be28:	08026ef0 	.word	0x08026ef0
 801be2c:	20000e30 	.word	0x20000e30
 801be30:	20001e40 	.word	0x20001e40
 801be34:	200188c8 	.word	0x200188c8
 801be38:	20016cb0 	.word	0x20016cb0
 801be3c:	200159f2 	.word	0x200159f2
 801be40:	200174f0 	.word	0x200174f0
 801be44:	08026ef8 	.word	0x08026ef8
 801be48:	2000f0e0 	.word	0x2000f0e0
 801be4c:	08026ed8 	.word	0x08026ed8
 801be50:	3e19999a 	.word	0x3e19999a
 801be54:	08026ee0 	.word	0x08026ee0
 801be58:	2000ec34 	.word	0x2000ec34
 801be5c:	200188c9 	.word	0x200188c9
 801be60:	20018088 	.word	0x20018088
			while(f_read(&MyFile, &rekordbox.cue_singleloop[i], 1, (void *)&bytesread) != FR_OK);
 801be64:	465b      	mov	r3, fp
 801be66:	2201      	movs	r2, #1
 801be68:	4629      	mov	r1, r5
 801be6a:	4638      	mov	r0, r7
 801be6c:	f7f0 f942 	bl	800c0f4 <f_read>
 801be70:	2800      	cmp	r0, #0
 801be72:	d1f7      	bne.n	801be64 <DecodeRekordboxFiles+0x9f0>
			while(f_read(&MyFile, BufferCtl.buff, 3, (void *)&bytesread) != FR_OK); // dummy read 3 bytes
 801be74:	f8df 9334 	ldr.w	r9, [pc, #820]	; 801c1ac <DecodeRekordboxFiles+0xd38>
 801be78:	4fca      	ldr	r7, [pc, #808]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801be7a:	465b      	mov	r3, fp
 801be7c:	2203      	movs	r2, #3
 801be7e:	4649      	mov	r1, r9
 801be80:	4638      	mov	r0, r7
 801be82:	f7f0 f937 	bl	800c0f4 <f_read>
 801be86:	2800      	cmp	r0, #0
 801be88:	d1f7      	bne.n	801be7a <DecodeRekordboxFiles+0xa06>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801be8a:	f8df 9324 	ldr.w	r9, [pc, #804]	; 801c1b0 <DecodeRekordboxFiles+0xd3c>
 801be8e:	4fc5      	ldr	r7, [pc, #788]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801be90:	6030      	str	r0, [r6, #0]
 801be92:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801be94:	465b      	mov	r3, fp
 801be96:	2204      	movs	r2, #4
 801be98:	4649      	mov	r1, r9
 801be9a:	4638      	mov	r0, r7
 801be9c:	f7f0 f92a 	bl	800c0f4 <f_read>
 801bea0:	2800      	cmp	r0, #0
 801bea2:	d1f7      	bne.n	801be94 <DecodeRekordboxFiles+0xa20>
		out_data |= tag[i];
 801bea4:	6833      	ldr	r3, [r6, #0]
 801bea6:	3501      	adds	r5, #1
 801bea8:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801beaa:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_start_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801beae:	ee07 3a90 	vmov	s15, r3
 801beb2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801beb6:	ee67 7a88 	vmul.f32	s15, s15, s16
 801beba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801bebe:	ee17 3a90 	vmov	r3, s15
 801bec2:	f8c8 34b0 	str.w	r3, [r8, #1200]	; 0x4b0
			if(rekordbox.cue_singleloop[i] == 2) rekordbox.cue_end_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801bec6:	9b01      	ldr	r3, [sp, #4]
 801bec8:	781b      	ldrb	r3, [r3, #0]
 801beca:	2b02      	cmp	r3, #2
 801becc:	f000 8215 	beq.w	801c2fa <DecodeRekordboxFiles+0xe86>
		for(i = 1; i < rekordbox.cues; i++) {
 801bed0:	9b00      	ldr	r3, [sp, #0]
 801bed2:	f10a 0a01 	add.w	sl, sl, #1
 801bed6:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801beda:	4553      	cmp	r3, sl
 801bedc:	f63f af4c 	bhi.w	801bd78 <DecodeRekordboxFiles+0x904>
		if(FindToken(cob_token) != 0) return 1;
 801bee0:	48b1      	ldr	r0, [pc, #708]	; (801c1a8 <DecodeRekordboxFiles+0xd34>)
 801bee2:	f7ff fa81 	bl	801b3e8 <FindToken>
 801bee6:	2800      	cmp	r0, #0
 801bee8:	f47f ad49 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK); // dummy read 12 bytes
 801beec:	f8df 82cc 	ldr.w	r8, [pc, #716]	; 801c1bc <DecodeRekordboxFiles+0xd48>
 801bef0:	4fae      	ldr	r7, [pc, #696]	; (801c1ac <DecodeRekordboxFiles+0xd38>)
 801bef2:	4dac      	ldr	r5, [pc, #688]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801bef4:	4643      	mov	r3, r8
 801bef6:	220c      	movs	r2, #12
 801bef8:	4639      	mov	r1, r7
 801befa:	4628      	mov	r0, r5
 801befc:	f7f0 f8fa 	bl	800c0f4 <f_read>
 801bf00:	2800      	cmp	r0, #0
 801bf02:	d1f7      	bne.n	801bef4 <DecodeRekordboxFiles+0xa80>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bf04:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 801c1bc <DecodeRekordboxFiles+0xd48>
 801bf08:	4fa9      	ldr	r7, [pc, #676]	; (801c1b0 <DecodeRekordboxFiles+0xd3c>)
 801bf0a:	4da6      	ldr	r5, [pc, #664]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bf0c:	6030      	str	r0, [r6, #0]
 801bf0e:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bf10:	4643      	mov	r3, r8
 801bf12:	2204      	movs	r2, #4
 801bf14:	4639      	mov	r1, r7
 801bf16:	4628      	mov	r0, r5
 801bf18:	f7f0 f8ec 	bl	800c0f4 <f_read>
 801bf1c:	2800      	cmp	r0, #0
 801bf1e:	d1f7      	bne.n	801bf10 <DecodeRekordboxFiles+0xa9c>
		out_data |= tag[i];
 801bf20:	7833      	ldrb	r3, [r6, #0]
		for(k = i; k < rekordbox.cues; k++) {
 801bf22:	4657      	mov	r7, sl
		out_data |= tag[i];
 801bf24:	7872      	ldrb	r2, [r6, #1]
		k = i;
 801bf26:	fa5f fa8a 	uxtb.w	sl, sl
		rekordbox.cues += GetLongNumber();
 801bf2a:	9900      	ldr	r1, [sp, #0]
		out_data |= tag[i];
 801bf2c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801bf30:	78b3      	ldrb	r3, [r6, #2]
 801bf32:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801bf36:	78f3      	ldrb	r3, [r6, #3]
 801bf38:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.cues += GetLongNumber();
 801bf3c:	f8d1 2b94 	ldr.w	r2, [r1, #2964]	; 0xb94
	out_data >>= 8;
 801bf40:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.cues += GetLongNumber();
 801bf44:	4413      	add	r3, r2
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801bf46:	2b64      	cmp	r3, #100	; 0x64
 801bf48:	bfa8      	it	ge
 801bf4a:	2364      	movge	r3, #100	; 0x64
		for(k = i; k < rekordbox.cues; k++) {
 801bf4c:	42bb      	cmp	r3, r7
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801bf4e:	f8c1 3b94 	str.w	r3, [r1, #2964]	; 0xb94
		for(k = i; k < rekordbox.cues; k++) {
 801bf52:	f340 80ab 	ble.w	801c0ac <DecodeRekordboxFiles+0xc38>
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801bf56:	ed9f 8a97 	vldr	s16, [pc, #604]	; 801c1b4 <DecodeRekordboxFiles+0xd40>
			if(FindToken(cue_token) != 0) return 1;
 801bf5a:	f8df 8264 	ldr.w	r8, [pc, #612]	; 801c1c0 <DecodeRekordboxFiles+0xd4c>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801bf5e:	f8df 925c 	ldr.w	r9, [pc, #604]	; 801c1bc <DecodeRekordboxFiles+0xd48>
			if(FindToken(cue_token) != 0) return 1;
 801bf62:	4640      	mov	r0, r8
 801bf64:	f7ff fa40 	bl	801b3e8 <FindToken>
 801bf68:	2800      	cmp	r0, #0
 801bf6a:	f47f ad08 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801bf6e:	f8df b23c 	ldr.w	fp, [pc, #572]	; 801c1ac <DecodeRekordboxFiles+0xd38>
 801bf72:	4d8c      	ldr	r5, [pc, #560]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801bf74:	464b      	mov	r3, r9
 801bf76:	2208      	movs	r2, #8
 801bf78:	4659      	mov	r1, fp
 801bf7a:	4628      	mov	r0, r5
 801bf7c:	f7f0 f8ba 	bl	800c0f4 <f_read>
 801bf80:	2800      	cmp	r0, #0
 801bf82:	d1f7      	bne.n	801bf74 <DecodeRekordboxFiles+0xb00>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bf84:	f8df b228 	ldr.w	fp, [pc, #552]	; 801c1b0 <DecodeRekordboxFiles+0xd3c>
 801bf88:	4d86      	ldr	r5, [pc, #536]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bf8a:	6030      	str	r0, [r6, #0]
 801bf8c:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bf8e:	464b      	mov	r3, r9
 801bf90:	2204      	movs	r2, #4
 801bf92:	4659      	mov	r1, fp
 801bf94:	4628      	mov	r0, r5
 801bf96:	f7f0 f8ad 	bl	800c0f4 <f_read>
 801bf9a:	2800      	cmp	r0, #0
 801bf9c:	d1f7      	bne.n	801bf8e <DecodeRekordboxFiles+0xb1a>
		out_data |= tag[i];
 801bf9e:	6833      	ldr	r3, [r6, #0]
			rekordbox.cue_number[k] = GetLongNumber();
 801bfa0:	f607 22e6 	addw	r2, r7, #2790	; 0xae6
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bfa4:	f8df b208 	ldr.w	fp, [pc, #520]	; 801c1b0 <DecodeRekordboxFiles+0xd3c>
 801bfa8:	ba1b      	rev	r3, r3
 801bfaa:	4d7e      	ldr	r5, [pc, #504]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bfac:	7130      	strb	r0, [r6, #4]
	out_data >>= 8;
 801bfae:	f343 0317 	sbfx	r3, r3, #0, #24
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bfb2:	6030      	str	r0, [r6, #0]
			rekordbox.cue_number[k] = GetLongNumber();
 801bfb4:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bfb8:	464b      	mov	r3, r9
 801bfba:	2204      	movs	r2, #4
 801bfbc:	4659      	mov	r1, fp
 801bfbe:	4628      	mov	r0, r5
 801bfc0:	f7f0 f898 	bl	800c0f4 <f_read>
 801bfc4:	2800      	cmp	r0, #0
 801bfc6:	d1f7      	bne.n	801bfb8 <DecodeRekordboxFiles+0xb44>
		out_data |= tag[i];
 801bfc8:	6833      	ldr	r3, [r6, #0]
			rekordbox.cue_active[k] = GetLongNumber();
 801bfca:	f607 324a 	addw	r2, r7, #2890	; 0xb4a
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bfce:	f8df b1dc 	ldr.w	fp, [pc, #476]	; 801c1ac <DecodeRekordboxFiles+0xd38>
 801bfd2:	ba1b      	rev	r3, r3
 801bfd4:	4d73      	ldr	r5, [pc, #460]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	out_data >>= 8;
 801bfd6:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_active[k] = GetLongNumber();
 801bfda:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801bfde:	464b      	mov	r3, r9
 801bfe0:	2204      	movs	r2, #4
 801bfe2:	4659      	mov	r1, fp
 801bfe4:	4628      	mov	r0, r5
 801bfe6:	f7f0 f885 	bl	800c0f4 <f_read>
 801bfea:	2800      	cmp	r0, #0
 801bfec:	d1f7      	bne.n	801bfde <DecodeRekordboxFiles+0xb6a>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bfee:	f8df b1c0 	ldr.w	fp, [pc, #448]	; 801c1b0 <DecodeRekordboxFiles+0xd3c>
 801bff2:	4d6c      	ldr	r5, [pc, #432]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801bff4:	6030      	str	r0, [r6, #0]
 801bff6:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801bff8:	464b      	mov	r3, r9
 801bffa:	2204      	movs	r2, #4
 801bffc:	4659      	mov	r1, fp
 801bffe:	4628      	mov	r0, r5
 801c000:	f7f0 f878 	bl	800c0f4 <f_read>
 801c004:	2800      	cmp	r0, #0
 801c006:	d1f7      	bne.n	801bff8 <DecodeRekordboxFiles+0xb84>
		out_data |= tag[i];
 801c008:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c00a:	f243 3168 	movw	r1, #13160	; 0x3368
			rekordbox.cue_type[k] = GetLongNumber();
 801c00e:	f607 32ae 	addw	r2, r7, #2990	; 0xbae
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c012:	4d64      	ldr	r5, [pc, #400]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801c014:	ba1b      	rev	r3, r3
 801c016:	4439      	add	r1, r7
	out_data >>= 8;
 801c018:	f343 0317 	sbfx	r3, r3, #0, #24
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c01c:	eb04 0b01 	add.w	fp, r4, r1
			rekordbox.cue_type[k] = GetLongNumber();
 801c020:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c024:	464b      	mov	r3, r9
 801c026:	2201      	movs	r2, #1
 801c028:	4659      	mov	r1, fp
 801c02a:	4628      	mov	r0, r5
 801c02c:	f7f0 f862 	bl	800c0f4 <f_read>
 801c030:	2800      	cmp	r0, #0
 801c032:	d1f7      	bne.n	801c024 <DecodeRekordboxFiles+0xbb0>
			while(f_read(&MyFile, BufferCtl.buff, 3, (void *)&bytesread) != FR_OK); // dummy read 3 bytes
 801c034:	f8df b174 	ldr.w	fp, [pc, #372]	; 801c1ac <DecodeRekordboxFiles+0xd38>
 801c038:	4d5a      	ldr	r5, [pc, #360]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801c03a:	464b      	mov	r3, r9
 801c03c:	2203      	movs	r2, #3
 801c03e:	4659      	mov	r1, fp
 801c040:	4628      	mov	r0, r5
 801c042:	f7f0 f857 	bl	800c0f4 <f_read>
 801c046:	2800      	cmp	r0, #0
 801c048:	d1f7      	bne.n	801c03a <DecodeRekordboxFiles+0xbc6>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c04a:	f8df b164 	ldr.w	fp, [pc, #356]	; 801c1b0 <DecodeRekordboxFiles+0xd3c>
 801c04e:	4d55      	ldr	r5, [pc, #340]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c050:	6030      	str	r0, [r6, #0]
 801c052:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c054:	464b      	mov	r3, r9
 801c056:	2204      	movs	r2, #4
 801c058:	4659      	mov	r1, fp
 801c05a:	4628      	mov	r0, r5
 801c05c:	f7f0 f84a 	bl	800c0f4 <f_read>
 801c060:	2800      	cmp	r0, #0
 801c062:	d1f7      	bne.n	801c054 <DecodeRekordboxFiles+0xbe0>
		out_data |= tag[i];
 801c064:	6833      	ldr	r3, [r6, #0]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c066:	f243 3268 	movw	r2, #13160	; 0x3368
 801c06a:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c06c:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c070:	ee07 3a90 	vmov	s15, r3
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c074:	19e3      	adds	r3, r4, r7
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c076:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c07a:	5c9b      	ldrb	r3, [r3, r2]
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c07c:	f607 4212 	addw	r2, r7, #3090	; 0xc12
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c080:	2b02      	cmp	r3, #2
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c082:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c086:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c08a:	ee17 1a90 	vmov	r1, s15
 801c08e:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c092:	f000 8358 	beq.w	801c746 <DecodeRekordboxFiles+0x12d2>
		for(k = i; k < rekordbox.cues; k++) {
 801c096:	f10a 0a01 	add.w	sl, sl, #1
 801c09a:	9b00      	ldr	r3, [sp, #0]
 801c09c:	fa5f fa8a 	uxtb.w	sl, sl
 801c0a0:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801c0a4:	459a      	cmp	sl, r3
 801c0a6:	4657      	mov	r7, sl
 801c0a8:	f6ff af5b 	blt.w	801bf62 <DecodeRekordboxFiles+0xaee>
		f_close(&MyFile);
 801c0ac:	483d      	ldr	r0, [pc, #244]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801c0ae:	f7f0 f935 	bl	800c31c <f_close>
 801c0b2:	f7ff ba1e 	b.w	801b4f2 <DecodeRekordboxFiles+0x7e>
		if(FindToken(path_token) != 0) return 1;
 801c0b6:	4840      	ldr	r0, [pc, #256]	; (801c1b8 <DecodeRekordboxFiles+0xd44>)
 801c0b8:	f7ff f996 	bl	801b3e8 <FindToken>
 801c0bc:	2800      	cmp	r0, #0
 801c0be:	f47f ac5e 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c0c2:	4f3e      	ldr	r7, [pc, #248]	; (801c1bc <DecodeRekordboxFiles+0xd48>)
 801c0c4:	4e39      	ldr	r6, [pc, #228]	; (801c1ac <DecodeRekordboxFiles+0xd38>)
 801c0c6:	4d37      	ldr	r5, [pc, #220]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
 801c0c8:	463b      	mov	r3, r7
 801c0ca:	2208      	movs	r2, #8
 801c0cc:	4631      	mov	r1, r6
 801c0ce:	4628      	mov	r0, r5
 801c0d0:	f7f0 f810 	bl	800c0f4 <f_read>
 801c0d4:	2800      	cmp	r0, #0
 801c0d6:	d1f7      	bne.n	801c0c8 <DecodeRekordboxFiles+0xc54>
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c0d8:	4e35      	ldr	r6, [pc, #212]	; (801c1b0 <DecodeRekordboxFiles+0xd3c>)
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c0da:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 801c1bc <DecodeRekordboxFiles+0xd48>
 801c0de:	4637      	mov	r7, r6
 801c0e0:	4d30      	ldr	r5, [pc, #192]	; (801c1a4 <DecodeRekordboxFiles+0xd30>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c0e2:	6030      	str	r0, [r6, #0]
 801c0e4:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c0e6:	4643      	mov	r3, r8
 801c0e8:	2204      	movs	r2, #4
 801c0ea:	4639      	mov	r1, r7
 801c0ec:	4628      	mov	r0, r5
 801c0ee:	f7f0 f801 	bl	800c0f4 <f_read>
 801c0f2:	2800      	cmp	r0, #0
 801c0f4:	d1f7      	bne.n	801c0e6 <DecodeRekordboxFiles+0xc72>
		out_data |= tag[i];
 801c0f6:	7873      	ldrb	r3, [r6, #1]
 801c0f8:	7837      	ldrb	r7, [r6, #0]
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801c0fa:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 801c1bc <DecodeRekordboxFiles+0xd48>
		out_data |= tag[i];
 801c0fe:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
 801c102:	78b3      	ldrb	r3, [r6, #2]
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801c104:	f8df 809c 	ldr.w	r8, [pc, #156]	; 801c1a4 <DecodeRekordboxFiles+0xd30>
		out_data |= tag[i];
 801c108:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 801c10c:	78f7      	ldrb	r7, [r6, #3]
 801c10e:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
	out_data >>= 8;
 801c112:	f347 0717 	sbfx	r7, r7, #0, #24
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801c116:	464b      	mov	r3, r9
 801c118:	463a      	mov	r2, r7
 801c11a:	a903      	add	r1, sp, #12
 801c11c:	4640      	mov	r0, r8
 801c11e:	f7ef ffe9 	bl	800c0f4 <f_read>
 801c122:	2800      	cmp	r0, #0
 801c124:	d1f7      	bne.n	801c116 <DecodeRekordboxFiles+0xca2>
		while(i < data_size) {
 801c126:	4605      	mov	r5, r0
 801c128:	2f00      	cmp	r7, #0
 801c12a:	f43f aad6 	beq.w	801b6da <DecodeRekordboxFiles+0x266>
 801c12e:	f107 39ff 	add.w	r9, r7, #4294967295
 801c132:	f10d 030d 	add.w	r3, sp, #13
 801c136:	f10d 0b0c 	add.w	fp, sp, #12
 801c13a:	eb03 0a59 	add.w	sl, r3, r9, lsr #1
 801c13e:	46d8      	mov	r8, fp
 801c140:	ea4f 0359 	mov.w	r3, r9, lsr #1
 801c144:	f8df 907c 	ldr.w	r9, [pc, #124]	; 801c1c4 <DecodeRekordboxFiles+0xd50>
 801c148:	9300      	str	r3, [sp, #0]
			WCHAR c = filename[i];
 801c14a:	f898 3000 	ldrb.w	r3, [r8]
			filename[k] = ff_convert(c, 0);
 801c14e:	2100      	movs	r1, #0
			c |= filename[i];
 801c150:	f898 0001 	ldrb.w	r0, [r8, #1]
		while(i < data_size) {
 801c154:	f108 0802 	add.w	r8, r8, #2
			c |= filename[i];
 801c158:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			rekordbox.filename[k] = c;
 801c15c:	f849 0b04 	str.w	r0, [r9], #4
			filename[k] = ff_convert(c, 0);
 801c160:	f7f0 fc18 	bl	800c994 <ff_convert>
 801c164:	f80b 0b01 	strb.w	r0, [fp], #1
		while(i < data_size) {
 801c168:	45d3      	cmp	fp, sl
 801c16a:	d1ee      	bne.n	801c14a <DecodeRekordboxFiles+0xcd6>
			k++;
 801c16c:	9800      	ldr	r0, [sp, #0]
 801c16e:	3001      	adds	r0, #1
		for(i = k; i < data_size; i++) filename[i] = 0;
 801c170:	b2c0      	uxtb	r0, r0
 801c172:	42b8      	cmp	r0, r7
 801c174:	d205      	bcs.n	801c182 <DecodeRekordboxFiles+0xd0e>
 801c176:	ab03      	add	r3, sp, #12
 801c178:	1a3a      	subs	r2, r7, r0
 801c17a:	2100      	movs	r1, #0
 801c17c:	4418      	add	r0, r3
 801c17e:	f003 ffad 	bl	80200dc <memset>
 801c182:	ab03      	add	r3, sp, #12
 801c184:	1c7a      	adds	r2, r7, #1
 801c186:	441a      	add	r2, r3
		while(i < data_size) {
 801c188:	463b      	mov	r3, r7
 801c18a:	e002      	b.n	801c192 <DecodeRekordboxFiles+0xd1e>
		while((i > 0) && (filename[i] != '.')) i--;
 801c18c:	3b01      	subs	r3, #1
 801c18e:	f43f aaa4 	beq.w	801b6da <DecodeRekordboxFiles+0x266>
 801c192:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801c196:	292e      	cmp	r1, #46	; 0x2e
 801c198:	d1f8      	bne.n	801c18c <DecodeRekordboxFiles+0xd18>
 801c19a:	f7ff ba9f 	b.w	801b6dc <DecodeRekordboxFiles+0x268>
		while(i < data_size) {
 801c19e:	2300      	movs	r3, #0
 801c1a0:	e465      	b.n	801ba6e <DecodeRekordboxFiles+0x5fa>
 801c1a2:	bf00      	nop
 801c1a4:	20001e40 	.word	0x20001e40
 801c1a8:	08026ed8 	.word	0x08026ed8
 801c1ac:	20000e30 	.word	0x20000e30
 801c1b0:	200188c8 	.word	0x200188c8
 801c1b4:	3e19999a 	.word	0x3e19999a
 801c1b8:	08026ee8 	.word	0x08026ee8
 801c1bc:	2000ec34 	.word	0x2000ec34
 801c1c0:	08026ee0 	.word	0x08026ee0
 801c1c4:	200154f0 	.word	0x200154f0
		while(k < 5)
 801c1c8:	2a04      	cmp	r2, #4
 801c1ca:	f67f ac54 	bls.w	801ba76 <DecodeRekordboxFiles+0x602>
 801c1ce:	e460      	b.n	801ba92 <DecodeRekordboxFiles+0x61e>
		while(k < 5)
 801c1d0:	2a04      	cmp	r2, #4
 801c1d2:	f67f aa87 	bls.w	801b6e4 <DecodeRekordboxFiles+0x270>
 801c1d6:	f7ff ba93 	b.w	801b700 <DecodeRekordboxFiles+0x28c>
				if(((tag[0] & 0x1F) > acue_sensitivity/10) && ((tag[0] & 0xE0) < 128)) {
 801c1da:	4a5a      	ldr	r2, [pc, #360]	; (801c344 <DecodeRekordboxFiles+0xed0>)
 801c1dc:	495a      	ldr	r1, [pc, #360]	; (801c348 <DecodeRekordboxFiles+0xed4>)
 801c1de:	7812      	ldrb	r2, [r2, #0]
 801c1e0:	fba1 1202 	umull	r1, r2, r1, r2
 801c1e4:	f003 011f 	and.w	r1, r3, #31
 801c1e8:	ebb1 0fd2 	cmp.w	r1, r2, lsr #3
 801c1ec:	f67f aa6a 	bls.w	801b6c4 <DecodeRekordboxFiles+0x250>
 801c1f0:	09db      	lsrs	r3, r3, #7
 801c1f2:	f47f aa67 	bne.w	801b6c4 <DecodeRekordboxFiles+0x250>
					rekordbox.autocue = 2;
 801c1f6:	2302      	movs	r3, #2
					rekordbox.cue_start_position[0] = i;
 801c1f8:	f8c5 9048 	str.w	r9, [r5, #72]	; 0x48
					rekordbox.autocue = 2;
 801c1fc:	f885 33cc 	strb.w	r3, [r5, #972]	; 0x3cc
					rekordbox.cue_start_position[0] = i;
 801c200:	f7ff ba60 	b.w	801b6c4 <DecodeRekordboxFiles+0x250>
		if(FindToken(wv3_token) != 0) return 1;
 801c204:	4851      	ldr	r0, [pc, #324]	; (801c34c <DecodeRekordboxFiles+0xed8>)
 801c206:	f7ff f8ef 	bl	801b3e8 <FindToken>
 801c20a:	2800      	cmp	r0, #0
 801c20c:	f47f abb7 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK);
 801c210:	4f4f      	ldr	r7, [pc, #316]	; (801c350 <DecodeRekordboxFiles+0xedc>)
 801c212:	4e50      	ldr	r6, [pc, #320]	; (801c354 <DecodeRekordboxFiles+0xee0>)
 801c214:	4d50      	ldr	r5, [pc, #320]	; (801c358 <DecodeRekordboxFiles+0xee4>)
 801c216:	463b      	mov	r3, r7
 801c218:	220c      	movs	r2, #12
 801c21a:	4631      	mov	r1, r6
 801c21c:	4628      	mov	r0, r5
 801c21e:	f7ef ff69 	bl	800c0f4 <f_read>
 801c222:	2800      	cmp	r0, #0
 801c224:	d1f7      	bne.n	801c216 <DecodeRekordboxFiles+0xda2>
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c226:	4e4d      	ldr	r6, [pc, #308]	; (801c35c <DecodeRekordboxFiles+0xee8>)
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c228:	f8df 8124 	ldr.w	r8, [pc, #292]	; 801c350 <DecodeRekordboxFiles+0xedc>
 801c22c:	4637      	mov	r7, r6
 801c22e:	4d4a      	ldr	r5, [pc, #296]	; (801c358 <DecodeRekordboxFiles+0xee4>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c230:	6030      	str	r0, [r6, #0]
 801c232:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c234:	4643      	mov	r3, r8
 801c236:	2204      	movs	r2, #4
 801c238:	4639      	mov	r1, r7
 801c23a:	4628      	mov	r0, r5
 801c23c:	f7ef ff5a 	bl	800c0f4 <f_read>
 801c240:	2800      	cmp	r0, #0
 801c242:	d1f7      	bne.n	801c234 <DecodeRekordboxFiles+0xdc0>
		out_data |= tag[i];
 801c244:	7831      	ldrb	r1, [r6, #0]
 801c246:	7872      	ldrb	r2, [r6, #1]
 801c248:	78b3      	ldrb	r3, [r6, #2]
 801c24a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
		rekordbox.spectrum_size=((rekordbox.spectrum_size>MAX_WAVESIZE)?MAX_WAVESIZE:rekordbox.spectrum_size);
 801c24e:	4944      	ldr	r1, [pc, #272]	; (801c360 <DecodeRekordboxFiles+0xeec>)
 801c250:	4844      	ldr	r0, [pc, #272]	; (801c364 <DecodeRekordboxFiles+0xef0>)
		out_data |= tag[i];
 801c252:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801c256:	78f3      	ldrb	r3, [r6, #3]
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c258:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 801c350 <DecodeRekordboxFiles+0xedc>
		out_data |= tag[i];
 801c25c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c260:	4f3c      	ldr	r7, [pc, #240]	; (801c354 <DecodeRekordboxFiles+0xee0>)
 801c262:	4d3d      	ldr	r5, [pc, #244]	; (801c358 <DecodeRekordboxFiles+0xee4>)
	out_data >>= 8;
 801c264:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.spectrum_size=((rekordbox.spectrum_size>MAX_WAVESIZE)?MAX_WAVESIZE:rekordbox.spectrum_size);
 801c268:	9000      	str	r0, [sp, #0]
 801c26a:	428b      	cmp	r3, r1
 801c26c:	bf28      	it	cs
 801c26e:	460b      	movcs	r3, r1
 801c270:	f8c0 3a8c 	str.w	r3, [r0, #2700]	; 0xa8c
		while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c274:	4643      	mov	r3, r8
 801c276:	2204      	movs	r2, #4
 801c278:	4639      	mov	r1, r7
 801c27a:	4628      	mov	r0, r5
 801c27c:	f7ef ff3a 	bl	800c0f4 <f_read>
 801c280:	2800      	cmp	r0, #0
 801c282:	d1f7      	bne.n	801c274 <DecodeRekordboxFiles+0xe00>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801c284:	9b00      	ldr	r3, [sp, #0]
		rekordbox.cue_start_position[0] = 0;
 801c286:	4d38      	ldr	r5, [pc, #224]	; (801c368 <DecodeRekordboxFiles+0xef4>)
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801c288:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
		rekordbox.cue_start_position[0] = 0;
 801c28c:	64a8      	str	r0, [r5, #72]	; 0x48
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801c28e:	b1e3      	cbz	r3, 801c2ca <DecodeRekordboxFiles+0xe56>
 801c290:	4681      	mov	r9, r0
			while(f_read(&MyFile, &tag[0], 1, (void *)&bytesread) != FR_OK);
 801c292:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 801c350 <DecodeRekordboxFiles+0xedc>
 801c296:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 801c35c <DecodeRekordboxFiles+0xee8>
 801c29a:	4f2f      	ldr	r7, [pc, #188]	; (801c358 <DecodeRekordboxFiles+0xee4>)
 801c29c:	4653      	mov	r3, sl
 801c29e:	2201      	movs	r2, #1
 801c2a0:	4641      	mov	r1, r8
 801c2a2:	4638      	mov	r0, r7
 801c2a4:	f7ef ff26 	bl	800c0f4 <f_read>
 801c2a8:	2800      	cmp	r0, #0
 801c2aa:	d1f7      	bne.n	801c29c <DecodeRekordboxFiles+0xe28>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801c2ac:	4a2f      	ldr	r2, [pc, #188]	; (801c36c <DecodeRekordboxFiles+0xef8>)
			*(__IO uint8_t*)(WAVE_BUFFER+i) = tag[0];
 801c2ae:	7833      	ldrb	r3, [r6, #0]
 801c2b0:	f809 3002 	strb.w	r3, [r9, r2]
			if(rekordbox.autocue == 1) {
 801c2b4:	f895 23cc 	ldrb.w	r2, [r5, #972]	; 0x3cc
 801c2b8:	2a01      	cmp	r2, #1
 801c2ba:	d00c      	beq.n	801c2d6 <DecodeRekordboxFiles+0xe62>
		for(i = 0; i < rekordbox.spectrum_size; i++) {
 801c2bc:	9b00      	ldr	r3, [sp, #0]
 801c2be:	f109 0901 	add.w	r9, r9, #1
 801c2c2:	f8d3 3a8c 	ldr.w	r3, [r3, #2700]	; 0xa8c
 801c2c6:	454b      	cmp	r3, r9
 801c2c8:	d8e8      	bhi.n	801c29c <DecodeRekordboxFiles+0xe28>
		f_close(&MyFile);
 801c2ca:	4823      	ldr	r0, [pc, #140]	; (801c358 <DecodeRekordboxFiles+0xee4>)
 801c2cc:	f7f0 f826 	bl	800c31c <f_close>
 801c2d0:	9b00      	ldr	r3, [sp, #0]
 801c2d2:	f7ff b956 	b.w	801b582 <DecodeRekordboxFiles+0x10e>
				if(((tag[0] & 0x1F) > acue_sensitivity/10) && ((tag[0] & 0xE0) < 128)) {
 801c2d6:	4a1b      	ldr	r2, [pc, #108]	; (801c344 <DecodeRekordboxFiles+0xed0>)
 801c2d8:	491b      	ldr	r1, [pc, #108]	; (801c348 <DecodeRekordboxFiles+0xed4>)
 801c2da:	7812      	ldrb	r2, [r2, #0]
 801c2dc:	fba1 1202 	umull	r1, r2, r1, r2
 801c2e0:	f003 011f 	and.w	r1, r3, #31
 801c2e4:	ebb1 0fd2 	cmp.w	r1, r2, lsr #3
 801c2e8:	d9e8      	bls.n	801c2bc <DecodeRekordboxFiles+0xe48>
 801c2ea:	09db      	lsrs	r3, r3, #7
 801c2ec:	d1e6      	bne.n	801c2bc <DecodeRekordboxFiles+0xe48>
					rekordbox.autocue = 2;
 801c2ee:	2302      	movs	r3, #2
					rekordbox.cue_start_position[0] = i;
 801c2f0:	f8c5 9048 	str.w	r9, [r5, #72]	; 0x48
					rekordbox.autocue = 2;
 801c2f4:	f885 33cc 	strb.w	r3, [r5, #972]	; 0x3cc
					rekordbox.cue_start_position[0] = i;
 801c2f8:	e7e0      	b.n	801c2bc <DecodeRekordboxFiles+0xe48>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c2fa:	f8df 9060 	ldr.w	r9, [pc, #96]	; 801c35c <DecodeRekordboxFiles+0xee8>
 801c2fe:	4f16      	ldr	r7, [pc, #88]	; (801c358 <DecodeRekordboxFiles+0xee4>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c300:	6030      	str	r0, [r6, #0]
 801c302:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c304:	465b      	mov	r3, fp
 801c306:	2204      	movs	r2, #4
 801c308:	4649      	mov	r1, r9
 801c30a:	4638      	mov	r0, r7
 801c30c:	f7ef fef2 	bl	800c0f4 <f_read>
 801c310:	2800      	cmp	r0, #0
 801c312:	d1f7      	bne.n	801c304 <DecodeRekordboxFiles+0xe90>
		out_data |= tag[i];
 801c314:	6833      	ldr	r3, [r6, #0]
 801c316:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c318:	f343 0317 	sbfx	r3, r3, #0, #24
			if(rekordbox.cue_singleloop[i] == 2) rekordbox.cue_end_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801c31c:	ee07 3a90 	vmov	s15, r3
 801c320:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c324:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c328:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c32c:	ee17 3a90 	vmov	r3, s15
 801c330:	f8c8 3640 	str.w	r3, [r8, #1600]	; 0x640
 801c334:	e5cc      	b.n	801bed0 <DecodeRekordboxFiles+0xa5c>
 801c336:	2301      	movs	r3, #1
 801c338:	f7ff bbe0 	b.w	801bafc <DecodeRekordboxFiles+0x688>
 801c33c:	2301      	movs	r3, #1
 801c33e:	f7ff ba1b 	b.w	801b778 <DecodeRekordboxFiles+0x304>
 801c342:	bf00      	nop
 801c344:	20000054 	.word	0x20000054
 801c348:	cccccccd 	.word	0xcccccccd
 801c34c:	08026f00 	.word	0x08026f00
 801c350:	2000ec34 	.word	0x2000ec34
 801c354:	20000e30 	.word	0x20000e30
 801c358:	20001e40 	.word	0x20001e40
 801c35c:	200188c8 	.word	0x200188c8
 801c360:	00030d40 	.word	0x00030d40
 801c364:	200174f0 	.word	0x200174f0
 801c368:	200184f0 	.word	0x200184f0
 801c36c:	c0100000 	.word	0xc0100000
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK); // dummy read 12 bytes
 801c370:	f8df 8328 	ldr.w	r8, [pc, #808]	; 801c69c <DecodeRekordboxFiles+0x1228>
 801c374:	4fc3      	ldr	r7, [pc, #780]	; (801c684 <DecodeRekordboxFiles+0x1210>)
 801c376:	4dc4      	ldr	r5, [pc, #784]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c378:	4643      	mov	r3, r8
 801c37a:	220c      	movs	r2, #12
 801c37c:	4639      	mov	r1, r7
 801c37e:	4628      	mov	r0, r5
 801c380:	f7ef feb8 	bl	800c0f4 <f_read>
 801c384:	2800      	cmp	r0, #0
 801c386:	d1f7      	bne.n	801c378 <DecodeRekordboxFiles+0xf04>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c388:	f8df 8310 	ldr.w	r8, [pc, #784]	; 801c69c <DecodeRekordboxFiles+0x1228>
 801c38c:	4fbf      	ldr	r7, [pc, #764]	; (801c68c <DecodeRekordboxFiles+0x1218>)
 801c38e:	4dbe      	ldr	r5, [pc, #760]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c390:	6030      	str	r0, [r6, #0]
 801c392:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c394:	4643      	mov	r3, r8
 801c396:	2204      	movs	r2, #4
 801c398:	4639      	mov	r1, r7
 801c39a:	4628      	mov	r0, r5
 801c39c:	f7ef feaa 	bl	800c0f4 <f_read>
 801c3a0:	2800      	cmp	r0, #0
 801c3a2:	d1f7      	bne.n	801c394 <DecodeRekordboxFiles+0xf20>
		out_data |= tag[i];
 801c3a4:	7833      	ldrb	r3, [r6, #0]
 801c3a6:	7872      	ldrb	r2, [r6, #1]
 801c3a8:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801c3ac:	78b3      	ldrb	r3, [r6, #2]
 801c3ae:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801c3b2:	78f3      	ldrb	r3, [r6, #3]
 801c3b4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801c3b8:	9a00      	ldr	r2, [sp, #0]
	out_data >>= 8;
 801c3ba:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.cues = GetLongNumber() + 1;
 801c3be:	3301      	adds	r3, #1
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801c3c0:	2b64      	cmp	r3, #100	; 0x64
 801c3c2:	bfa8      	it	ge
 801c3c4:	2364      	movge	r3, #100	; 0x64
		for(i = 1; i < rekordbox.cues; i++) {
 801c3c6:	2b01      	cmp	r3, #1
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801c3c8:	f8c2 3b94 	str.w	r3, [r2, #2964]	; 0xb94
		for(i = 1; i < rekordbox.cues; i++) {
 801c3cc:	f240 8210 	bls.w	801c7f0 <DecodeRekordboxFiles+0x137c>
 801c3d0:	f8df 82cc 	ldr.w	r8, [pc, #716]	; 801c6a0 <DecodeRekordboxFiles+0x122c>
 801c3d4:	f04f 0a01 	mov.w	sl, #1
			rekordbox.cue_start_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801c3d8:	ed9f 8aad 	vldr	s16, [pc, #692]	; 801c690 <DecodeRekordboxFiles+0x121c>
 801c3dc:	f208 75d1 	addw	r5, r8, #2001	; 0x7d1
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c3e0:	f8df b2b8 	ldr.w	fp, [pc, #696]	; 801c69c <DecodeRekordboxFiles+0x1228>
			if(FindToken(cue_token) != 0) return 1;
 801c3e4:	48ab      	ldr	r0, [pc, #684]	; (801c694 <DecodeRekordboxFiles+0x1220>)
 801c3e6:	f7fe ffff 	bl	801b3e8 <FindToken>
 801c3ea:	2800      	cmp	r0, #0
 801c3ec:	f47f aac7 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c3f0:	f8df 9290 	ldr.w	r9, [pc, #656]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c3f4:	4fa4      	ldr	r7, [pc, #656]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c3f6:	465b      	mov	r3, fp
 801c3f8:	2208      	movs	r2, #8
 801c3fa:	4649      	mov	r1, r9
 801c3fc:	4638      	mov	r0, r7
 801c3fe:	f7ef fe79 	bl	800c0f4 <f_read>
 801c402:	2800      	cmp	r0, #0
 801c404:	d1f7      	bne.n	801c3f6 <DecodeRekordboxFiles+0xf82>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c406:	f8df 9284 	ldr.w	r9, [pc, #644]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c40a:	4f9f      	ldr	r7, [pc, #636]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c40c:	6030      	str	r0, [r6, #0]
 801c40e:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c410:	465b      	mov	r3, fp
 801c412:	2204      	movs	r2, #4
 801c414:	4649      	mov	r1, r9
 801c416:	4638      	mov	r0, r7
 801c418:	f7ef fe6c 	bl	800c0f4 <f_read>
 801c41c:	2800      	cmp	r0, #0
 801c41e:	d1f7      	bne.n	801c410 <DecodeRekordboxFiles+0xf9c>
		out_data |= tag[i];
 801c420:	6833      	ldr	r3, [r6, #0]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c422:	f8df 9268 	ldr.w	r9, [pc, #616]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c426:	ba1b      	rev	r3, r3
 801c428:	4f97      	ldr	r7, [pc, #604]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c42a:	7130      	strb	r0, [r6, #4]
	out_data >>= 8;
 801c42c:	f343 0317 	sbfx	r3, r3, #0, #24
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c430:	6030      	str	r0, [r6, #0]
			rekordbox.cue_number[i] = GetLongNumber();
 801c432:	f848 3f04 	str.w	r3, [r8, #4]!
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c436:	465b      	mov	r3, fp
 801c438:	2204      	movs	r2, #4
 801c43a:	4649      	mov	r1, r9
 801c43c:	4638      	mov	r0, r7
 801c43e:	f7ef fe59 	bl	800c0f4 <f_read>
 801c442:	2800      	cmp	r0, #0
 801c444:	d1f7      	bne.n	801c436 <DecodeRekordboxFiles+0xfc2>
		out_data |= tag[i];
 801c446:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c448:	f8df 9238 	ldr.w	r9, [pc, #568]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c44c:	ba1b      	rev	r3, r3
 801c44e:	4f8e      	ldr	r7, [pc, #568]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	out_data >>= 8;
 801c450:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_active[i] = GetLongNumber();
 801c454:	f8c8 3190 	str.w	r3, [r8, #400]	; 0x190
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c458:	465b      	mov	r3, fp
 801c45a:	2204      	movs	r2, #4
 801c45c:	4649      	mov	r1, r9
 801c45e:	4638      	mov	r0, r7
 801c460:	f7ef fe48 	bl	800c0f4 <f_read>
 801c464:	2800      	cmp	r0, #0
 801c466:	d1f7      	bne.n	801c458 <DecodeRekordboxFiles+0xfe4>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c468:	f8df 9220 	ldr.w	r9, [pc, #544]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c46c:	4f86      	ldr	r7, [pc, #536]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c46e:	6030      	str	r0, [r6, #0]
 801c470:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c472:	465b      	mov	r3, fp
 801c474:	2204      	movs	r2, #4
 801c476:	4649      	mov	r1, r9
 801c478:	4638      	mov	r0, r7
 801c47a:	f7ef fe3b 	bl	800c0f4 <f_read>
 801c47e:	2800      	cmp	r0, #0
 801c480:	d1f7      	bne.n	801c472 <DecodeRekordboxFiles+0xffe>
		out_data |= tag[i];
 801c482:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[i], 1, (void *)&bytesread) != FR_OK);
 801c484:	4f80      	ldr	r7, [pc, #512]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c486:	ba1b      	rev	r3, r3
 801c488:	9501      	str	r5, [sp, #4]
	out_data >>= 8;
 801c48a:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_type[i] = GetLongNumber();
 801c48e:	f8c8 3320 	str.w	r3, [r8, #800]	; 0x320
			while(f_read(&MyFile, &rekordbox.cue_singleloop[i], 1, (void *)&bytesread) != FR_OK);
 801c492:	465b      	mov	r3, fp
 801c494:	2201      	movs	r2, #1
 801c496:	4629      	mov	r1, r5
 801c498:	4638      	mov	r0, r7
 801c49a:	f7ef fe2b 	bl	800c0f4 <f_read>
 801c49e:	2800      	cmp	r0, #0
 801c4a0:	d1f7      	bne.n	801c492 <DecodeRekordboxFiles+0x101e>
			while(f_read(&MyFile, BufferCtl.buff, 3, (void *)&bytesread) != FR_OK); // dummy read 3 bytes
 801c4a2:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c4a6:	4f78      	ldr	r7, [pc, #480]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c4a8:	465b      	mov	r3, fp
 801c4aa:	2203      	movs	r2, #3
 801c4ac:	4649      	mov	r1, r9
 801c4ae:	4638      	mov	r0, r7
 801c4b0:	f7ef fe20 	bl	800c0f4 <f_read>
 801c4b4:	2800      	cmp	r0, #0
 801c4b6:	d1f7      	bne.n	801c4a8 <DecodeRekordboxFiles+0x1034>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c4b8:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c4bc:	4f72      	ldr	r7, [pc, #456]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c4be:	6030      	str	r0, [r6, #0]
 801c4c0:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c4c2:	465b      	mov	r3, fp
 801c4c4:	2204      	movs	r2, #4
 801c4c6:	4649      	mov	r1, r9
 801c4c8:	4638      	mov	r0, r7
 801c4ca:	f7ef fe13 	bl	800c0f4 <f_read>
 801c4ce:	2800      	cmp	r0, #0
 801c4d0:	d1f7      	bne.n	801c4c2 <DecodeRekordboxFiles+0x104e>
		out_data |= tag[i];
 801c4d2:	6833      	ldr	r3, [r6, #0]
 801c4d4:	3501      	adds	r5, #1
 801c4d6:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c4d8:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_start_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801c4dc:	ee07 3a90 	vmov	s15, r3
 801c4e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c4e4:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c4e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c4ec:	ee17 3a90 	vmov	r3, s15
 801c4f0:	f8c8 34b0 	str.w	r3, [r8, #1200]	; 0x4b0
			if(rekordbox.cue_singleloop[i] == 2) rekordbox.cue_end_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801c4f4:	9b01      	ldr	r3, [sp, #4]
 801c4f6:	781b      	ldrb	r3, [r3, #0]
 801c4f8:	2b02      	cmp	r3, #2
 801c4fa:	f000 8103 	beq.w	801c704 <DecodeRekordboxFiles+0x1290>
		for(i = 1; i < rekordbox.cues; i++) {
 801c4fe:	9b00      	ldr	r3, [sp, #0]
 801c500:	f10a 0a01 	add.w	sl, sl, #1
 801c504:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801c508:	4553      	cmp	r3, sl
 801c50a:	f63f af6b 	bhi.w	801c3e4 <DecodeRekordboxFiles+0xf70>
		if(FindToken(cob_token) != 0) return 1;
 801c50e:	4862      	ldr	r0, [pc, #392]	; (801c698 <DecodeRekordboxFiles+0x1224>)
 801c510:	f7fe ff6a 	bl	801b3e8 <FindToken>
 801c514:	2800      	cmp	r0, #0
 801c516:	f47f aa32 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
		while(f_read(&MyFile, BufferCtl.buff, 12, (void *)&bytesread) != FR_OK); // dummy read 12 bytes
 801c51a:	f8df 8180 	ldr.w	r8, [pc, #384]	; 801c69c <DecodeRekordboxFiles+0x1228>
 801c51e:	4f59      	ldr	r7, [pc, #356]	; (801c684 <DecodeRekordboxFiles+0x1210>)
 801c520:	4d59      	ldr	r5, [pc, #356]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c522:	4643      	mov	r3, r8
 801c524:	220c      	movs	r2, #12
 801c526:	4639      	mov	r1, r7
 801c528:	4628      	mov	r0, r5
 801c52a:	f7ef fde3 	bl	800c0f4 <f_read>
 801c52e:	2800      	cmp	r0, #0
 801c530:	d1f7      	bne.n	801c522 <DecodeRekordboxFiles+0x10ae>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c532:	f8df 8168 	ldr.w	r8, [pc, #360]	; 801c69c <DecodeRekordboxFiles+0x1228>
 801c536:	4f55      	ldr	r7, [pc, #340]	; (801c68c <DecodeRekordboxFiles+0x1218>)
 801c538:	4d53      	ldr	r5, [pc, #332]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c53a:	6030      	str	r0, [r6, #0]
 801c53c:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c53e:	4643      	mov	r3, r8
 801c540:	2204      	movs	r2, #4
 801c542:	4639      	mov	r1, r7
 801c544:	4628      	mov	r0, r5
 801c546:	f7ef fdd5 	bl	800c0f4 <f_read>
 801c54a:	2800      	cmp	r0, #0
 801c54c:	d1f7      	bne.n	801c53e <DecodeRekordboxFiles+0x10ca>
		out_data |= tag[i];
 801c54e:	7833      	ldrb	r3, [r6, #0]
		for(k = i; k < rekordbox.cues; k++) {
 801c550:	4655      	mov	r5, sl
		out_data |= tag[i];
 801c552:	7872      	ldrb	r2, [r6, #1]
		k = i;
 801c554:	fa5f fa8a 	uxtb.w	sl, sl
		rekordbox.cues += GetLongNumber();
 801c558:	9900      	ldr	r1, [sp, #0]
		out_data |= tag[i];
 801c55a:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 801c55e:	78b3      	ldrb	r3, [r6, #2]
 801c560:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 801c564:	78f3      	ldrb	r3, [r6, #3]
 801c566:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		rekordbox.cues += GetLongNumber();
 801c56a:	f8d1 2b94 	ldr.w	r2, [r1, #2964]	; 0xb94
	out_data >>= 8;
 801c56e:	f343 0317 	sbfx	r3, r3, #0, #24
		rekordbox.cues += GetLongNumber();
 801c572:	4413      	add	r3, r2
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801c574:	2b64      	cmp	r3, #100	; 0x64
 801c576:	bfa8      	it	ge
 801c578:	2364      	movge	r3, #100	; 0x64
		for(k = i; k < rekordbox.cues; k++) {
 801c57a:	42ab      	cmp	r3, r5
		rekordbox.cues=((rekordbox.cues>RBX_NUM_COB)?RBX_NUM_COB:rekordbox.cues);
 801c57c:	f8c1 3b94 	str.w	r3, [r1, #2964]	; 0xb94
		for(k = i; k < rekordbox.cues; k++) {
 801c580:	f340 80bb 	ble.w	801c6fa <DecodeRekordboxFiles+0x1286>
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c584:	ed9f 8a42 	vldr	s16, [pc, #264]	; 801c690 <DecodeRekordboxFiles+0x121c>
			if(FindToken(cue_token) != 0) return 1;
 801c588:	f8df 8108 	ldr.w	r8, [pc, #264]	; 801c694 <DecodeRekordboxFiles+0x1220>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c58c:	f8df 910c 	ldr.w	r9, [pc, #268]	; 801c69c <DecodeRekordboxFiles+0x1228>
			if(FindToken(cue_token) != 0) return 1;
 801c590:	4640      	mov	r0, r8
 801c592:	f7fe ff29 	bl	801b3e8 <FindToken>
 801c596:	2800      	cmp	r0, #0
 801c598:	f47f a9f1 	bne.w	801b97e <DecodeRekordboxFiles+0x50a>
			while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c59c:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c5a0:	4f39      	ldr	r7, [pc, #228]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c5a2:	464b      	mov	r3, r9
 801c5a4:	2208      	movs	r2, #8
 801c5a6:	4659      	mov	r1, fp
 801c5a8:	4638      	mov	r0, r7
 801c5aa:	f7ef fda3 	bl	800c0f4 <f_read>
 801c5ae:	2800      	cmp	r0, #0
 801c5b0:	d1f7      	bne.n	801c5a2 <DecodeRekordboxFiles+0x112e>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c5b2:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c5b6:	4f34      	ldr	r7, [pc, #208]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c5b8:	6030      	str	r0, [r6, #0]
 801c5ba:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c5bc:	464b      	mov	r3, r9
 801c5be:	2204      	movs	r2, #4
 801c5c0:	4659      	mov	r1, fp
 801c5c2:	4638      	mov	r0, r7
 801c5c4:	f7ef fd96 	bl	800c0f4 <f_read>
 801c5c8:	2800      	cmp	r0, #0
 801c5ca:	d1f7      	bne.n	801c5bc <DecodeRekordboxFiles+0x1148>
		out_data |= tag[i];
 801c5cc:	6833      	ldr	r3, [r6, #0]
			rekordbox.cue_number[k] = GetLongNumber();
 801c5ce:	f605 22e6 	addw	r2, r5, #2790	; 0xae6
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c5d2:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c5d6:	ba1b      	rev	r3, r3
 801c5d8:	4f2b      	ldr	r7, [pc, #172]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c5da:	7130      	strb	r0, [r6, #4]
	out_data >>= 8;
 801c5dc:	f343 0317 	sbfx	r3, r3, #0, #24
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c5e0:	6030      	str	r0, [r6, #0]
			rekordbox.cue_number[k] = GetLongNumber();
 801c5e2:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c5e6:	464b      	mov	r3, r9
 801c5e8:	2204      	movs	r2, #4
 801c5ea:	4659      	mov	r1, fp
 801c5ec:	4638      	mov	r0, r7
 801c5ee:	f7ef fd81 	bl	800c0f4 <f_read>
 801c5f2:	2800      	cmp	r0, #0
 801c5f4:	d1f7      	bne.n	801c5e6 <DecodeRekordboxFiles+0x1172>
		out_data |= tag[i];
 801c5f6:	6833      	ldr	r3, [r6, #0]
			rekordbox.cue_active[k] = GetLongNumber();
 801c5f8:	f605 324a 	addw	r2, r5, #2890	; 0xb4a
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c5fc:	f8df b084 	ldr.w	fp, [pc, #132]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c600:	ba1b      	rev	r3, r3
 801c602:	4f21      	ldr	r7, [pc, #132]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	out_data >>= 8;
 801c604:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_active[k] = GetLongNumber();
 801c608:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
			while(f_read(&MyFile, BufferCtl.buff, 4, (void *)&bytesread) != FR_OK); // dummy read 4 bytes
 801c60c:	464b      	mov	r3, r9
 801c60e:	2204      	movs	r2, #4
 801c610:	4659      	mov	r1, fp
 801c612:	4638      	mov	r0, r7
 801c614:	f7ef fd6e 	bl	800c0f4 <f_read>
 801c618:	2800      	cmp	r0, #0
 801c61a:	d1f7      	bne.n	801c60c <DecodeRekordboxFiles+0x1198>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c61c:	f8df b06c 	ldr.w	fp, [pc, #108]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c620:	4f19      	ldr	r7, [pc, #100]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c622:	6030      	str	r0, [r6, #0]
 801c624:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c626:	464b      	mov	r3, r9
 801c628:	2204      	movs	r2, #4
 801c62a:	4659      	mov	r1, fp
 801c62c:	4638      	mov	r0, r7
 801c62e:	f7ef fd61 	bl	800c0f4 <f_read>
 801c632:	2800      	cmp	r0, #0
 801c634:	d1f7      	bne.n	801c626 <DecodeRekordboxFiles+0x11b2>
		out_data |= tag[i];
 801c636:	6833      	ldr	r3, [r6, #0]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c638:	f243 3168 	movw	r1, #13160	; 0x3368
			rekordbox.cue_type[k] = GetLongNumber();
 801c63c:	f605 32ae 	addw	r2, r5, #2990	; 0xbae
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c640:	4f11      	ldr	r7, [pc, #68]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c642:	ba1b      	rev	r3, r3
 801c644:	4429      	add	r1, r5
	out_data >>= 8;
 801c646:	f343 0317 	sbfx	r3, r3, #0, #24
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c64a:	eb04 0b01 	add.w	fp, r4, r1
			rekordbox.cue_type[k] = GetLongNumber();
 801c64e:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
			while(f_read(&MyFile, &rekordbox.cue_singleloop[k], 1, (void *)&bytesread) != FR_OK);
 801c652:	464b      	mov	r3, r9
 801c654:	2201      	movs	r2, #1
 801c656:	4659      	mov	r1, fp
 801c658:	4638      	mov	r0, r7
 801c65a:	f7ef fd4b 	bl	800c0f4 <f_read>
 801c65e:	2800      	cmp	r0, #0
 801c660:	d1f7      	bne.n	801c652 <DecodeRekordboxFiles+0x11de>
			while(f_read(&MyFile, BufferCtl.buff, 3, (void *)&bytesread) != FR_OK); // dummy read 3 bytes
 801c662:	f8df b020 	ldr.w	fp, [pc, #32]	; 801c684 <DecodeRekordboxFiles+0x1210>
 801c666:	4f08      	ldr	r7, [pc, #32]	; (801c688 <DecodeRekordboxFiles+0x1214>)
 801c668:	464b      	mov	r3, r9
 801c66a:	2203      	movs	r2, #3
 801c66c:	4659      	mov	r1, fp
 801c66e:	4638      	mov	r0, r7
 801c670:	f7ef fd40 	bl	800c0f4 <f_read>
 801c674:	2800      	cmp	r0, #0
 801c676:	d1f7      	bne.n	801c668 <DecodeRekordboxFiles+0x11f4>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c678:	f8df b010 	ldr.w	fp, [pc, #16]	; 801c68c <DecodeRekordboxFiles+0x1218>
 801c67c:	4f02      	ldr	r7, [pc, #8]	; (801c688 <DecodeRekordboxFiles+0x1214>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c67e:	6030      	str	r0, [r6, #0]
 801c680:	7130      	strb	r0, [r6, #4]
 801c682:	e00f      	b.n	801c6a4 <DecodeRekordboxFiles+0x1230>
 801c684:	20000e30 	.word	0x20000e30
 801c688:	20001e40 	.word	0x20001e40
 801c68c:	200188c8 	.word	0x200188c8
 801c690:	3e19999a 	.word	0x3e19999a
 801c694:	08026ee0 	.word	0x08026ee0
 801c698:	08026ed8 	.word	0x08026ed8
 801c69c:	2000ec34 	.word	0x2000ec34
 801c6a0:	20018088 	.word	0x20018088
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c6a4:	464b      	mov	r3, r9
 801c6a6:	2204      	movs	r2, #4
 801c6a8:	4659      	mov	r1, fp
 801c6aa:	4638      	mov	r0, r7
 801c6ac:	f7ef fd22 	bl	800c0f4 <f_read>
 801c6b0:	2800      	cmp	r0, #0
 801c6b2:	d1f7      	bne.n	801c6a4 <DecodeRekordboxFiles+0x1230>
		out_data |= tag[i];
 801c6b4:	6833      	ldr	r3, [r6, #0]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6b6:	f243 3268 	movw	r2, #13160	; 0x3368
 801c6ba:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c6bc:	f343 0317 	sbfx	r3, r3, #0, #24
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6c0:	ee07 3a90 	vmov	s15, r3
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6c4:	1963      	adds	r3, r4, r5
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6ca:	5c9b      	ldrb	r3, [r3, r2]
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6cc:	f605 4212 	addw	r2, r5, #3090	; 0xc12
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6d0:	2b02      	cmp	r3, #2
			rekordbox.cue_start_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6d2:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c6d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c6da:	ee17 1a90 	vmov	r1, s15
 801c6de:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c6e2:	d059      	beq.n	801c798 <DecodeRekordboxFiles+0x1324>
		for(k = i; k < rekordbox.cues; k++) {
 801c6e4:	f10a 0a01 	add.w	sl, sl, #1
 801c6e8:	9b00      	ldr	r3, [sp, #0]
 801c6ea:	fa5f fa8a 	uxtb.w	sl, sl
 801c6ee:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801c6f2:	459a      	cmp	sl, r3
 801c6f4:	4655      	mov	r5, sl
 801c6f6:	f6ff af4b 	blt.w	801c590 <DecodeRekordboxFiles+0x111c>
		f_close(&MyFile);
 801c6fa:	4841      	ldr	r0, [pc, #260]	; (801c800 <DecodeRekordboxFiles+0x138c>)
 801c6fc:	f7ef fe0e 	bl	800c31c <f_close>
 801c700:	f7fe bf24 	b.w	801b54c <DecodeRekordboxFiles+0xd8>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c704:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 801c804 <DecodeRekordboxFiles+0x1390>
 801c708:	4f3d      	ldr	r7, [pc, #244]	; (801c800 <DecodeRekordboxFiles+0x138c>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c70a:	6030      	str	r0, [r6, #0]
 801c70c:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c70e:	465b      	mov	r3, fp
 801c710:	2204      	movs	r2, #4
 801c712:	4649      	mov	r1, r9
 801c714:	4638      	mov	r0, r7
 801c716:	f7ef fced 	bl	800c0f4 <f_read>
 801c71a:	2800      	cmp	r0, #0
 801c71c:	d1f7      	bne.n	801c70e <DecodeRekordboxFiles+0x129a>
		out_data |= tag[i];
 801c71e:	6833      	ldr	r3, [r6, #0]
 801c720:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c722:	f343 0317 	sbfx	r3, r3, #0, #24
			if(rekordbox.cue_singleloop[i] == 2) rekordbox.cue_end_position[i] = (int32_t)((float)GetLongNumber()*150/1000);
 801c726:	ee07 3a90 	vmov	s15, r3
 801c72a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c72e:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c732:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c736:	ee17 3a90 	vmov	r3, s15
 801c73a:	f8c8 3640 	str.w	r3, [r8, #1600]	; 0x640
 801c73e:	e6de      	b.n	801c4fe <DecodeRekordboxFiles+0x108a>
		if(rekordbox.phase[0] == 1) rekordbox.beat_grid_offset = 4;
 801c740:	2304      	movs	r3, #4
 801c742:	f7ff ba8b 	b.w	801bc5c <DecodeRekordboxFiles+0x7e8>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c746:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 801c804 <DecodeRekordboxFiles+0x1390>
 801c74a:	4d2d      	ldr	r5, [pc, #180]	; (801c800 <DecodeRekordboxFiles+0x138c>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c74c:	6030      	str	r0, [r6, #0]
 801c74e:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c750:	464b      	mov	r3, r9
 801c752:	2204      	movs	r2, #4
 801c754:	4659      	mov	r1, fp
 801c756:	4628      	mov	r0, r5
 801c758:	f7ef fccc 	bl	800c0f4 <f_read>
 801c75c:	2800      	cmp	r0, #0
 801c75e:	d1f7      	bne.n	801c750 <DecodeRekordboxFiles+0x12dc>
		out_data |= tag[i];
 801c760:	6833      	ldr	r3, [r6, #0]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c762:	f607 4776 	addw	r7, r7, #3190	; 0xc76
 801c766:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c768:	f343 0317 	sbfx	r3, r3, #0, #24
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c76c:	ee07 3a90 	vmov	s15, r3
 801c770:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c774:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c778:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c77c:	ee17 3a90 	vmov	r3, s15
 801c780:	f844 3027 	str.w	r3, [r4, r7, lsl #2]
 801c784:	e487      	b.n	801c096 <DecodeRekordboxFiles+0xc22>
	while(i++  < rekordbox.spectrum_size) {
 801c786:	2200      	movs	r2, #0
 801c788:	f7fe bf32 	b.w	801b5f0 <DecodeRekordboxFiles+0x17c>
 801c78c:	4662      	mov	r2, ip
 801c78e:	f7fe bf2f 	b.w	801b5f0 <DecodeRekordboxFiles+0x17c>
		if(rekordbox.phase[0] == 1) rekordbox.beat_grid_offset = 4;
 801c792:	2304      	movs	r3, #4
 801c794:	f7ff b8a0 	b.w	801b8d8 <DecodeRekordboxFiles+0x464>
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c798:	f8df b068 	ldr.w	fp, [pc, #104]	; 801c804 <DecodeRekordboxFiles+0x1390>
 801c79c:	4f18      	ldr	r7, [pc, #96]	; (801c800 <DecodeRekordboxFiles+0x138c>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c79e:	6030      	str	r0, [r6, #0]
 801c7a0:	7130      	strb	r0, [r6, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c7a2:	464b      	mov	r3, r9
 801c7a4:	2204      	movs	r2, #4
 801c7a6:	4659      	mov	r1, fp
 801c7a8:	4638      	mov	r0, r7
 801c7aa:	f7ef fca3 	bl	800c0f4 <f_read>
 801c7ae:	2800      	cmp	r0, #0
 801c7b0:	d1f7      	bne.n	801c7a2 <DecodeRekordboxFiles+0x132e>
		out_data |= tag[i];
 801c7b2:	6833      	ldr	r3, [r6, #0]
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c7b4:	f605 4576 	addw	r5, r5, #3190	; 0xc76
 801c7b8:	ba1b      	rev	r3, r3
	out_data >>= 8;
 801c7ba:	f343 0317 	sbfx	r3, r3, #0, #24
			if(rekordbox.cue_singleloop[k] == 2) rekordbox.cue_end_position[k] = (int32_t)((float)GetLongNumber()*150/1000);
 801c7be:	ee07 3a90 	vmov	s15, r3
 801c7c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c7c6:	ee67 7a88 	vmul.f32	s15, s15, s16
 801c7ca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c7ce:	ee17 3a90 	vmov	r3, s15
 801c7d2:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
 801c7d6:	e785      	b.n	801c6e4 <DecodeRekordboxFiles+0x1270>
		while(i < data_size)
 801c7d8:	461f      	mov	r7, r3
 801c7da:	f7fe bfe2 	b.w	801b7a2 <DecodeRekordboxFiles+0x32e>
		i++;
 801c7de:	2701      	movs	r7, #1
 801c7e0:	f7fe bfdf 	b.w	801b7a2 <DecodeRekordboxFiles+0x32e>
		while(i < data_size)
 801c7e4:	461f      	mov	r7, r3
 801c7e6:	f7ff b99e 	b.w	801bb26 <DecodeRekordboxFiles+0x6b2>
		i++;
 801c7ea:	2701      	movs	r7, #1
 801c7ec:	f7ff b99b 	b.w	801bb26 <DecodeRekordboxFiles+0x6b2>
		for(i = 1; i < rekordbox.cues; i++) {
 801c7f0:	f04f 0a01 	mov.w	sl, #1
 801c7f4:	e68b      	b.n	801c50e <DecodeRekordboxFiles+0x109a>
		for(i = 1; i < rekordbox.cues; i++) {
 801c7f6:	f04f 0a01 	mov.w	sl, #1
 801c7fa:	f7ff bb71 	b.w	801bee0 <DecodeRekordboxFiles+0xa6c>
 801c7fe:	bf00      	nop
 801c800:	20001e40 	.word	0x20001e40
 801c804:	200188c8 	.word	0x200188c8

0801c808 <GetFileName>:

uint8_t GetFileName(TCHAR *path)
{
 801c808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t data_size = 0;
	uint8_t k;
	uint32_t i;
	uint8_t res = FR_OK;
	for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.filename[i] = 0;
 801c80c:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
{
 801c810:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
 801c814:	4604      	mov	r4, r0
	for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.filename[i] = 0;
 801c816:	2100      	movs	r1, #0
 801c818:	4866      	ldr	r0, [pc, #408]	; (801c9b4 <GetFileName+0x1ac>)
 801c81a:	f003 fc5f 	bl	80200dc <memset>
	char filename[RBX_MAX_PATH*2] = {0};		//UTF16 -- will be converted down to char
 801c81e:	2100      	movs	r1, #0
 801c820:	f44f 72fd 	mov.w	r2, #506	; 0x1fa
 801c824:	a801      	add	r0, sp, #4
 801c826:	9100      	str	r1, [sp, #0]
 801c828:	f003 fc58 	bl	80200dc <memset>

	res = f_open(&MyFile, path, FA_READ);
 801c82c:	2201      	movs	r2, #1
 801c82e:	4621      	mov	r1, r4
 801c830:	4861      	ldr	r0, [pc, #388]	; (801c9b8 <GetFileName+0x1b0>)
 801c832:	f7ef fbfd 	bl	800c030 <f_open>
	if(res == FR_OK)
 801c836:	2800      	cmp	r0, #0
 801c838:	f040 809f 	bne.w	801c97a <GetFileName+0x172>
	{
		if(FindToken(path_token) != 0) return 1;
 801c83c:	485f      	ldr	r0, [pc, #380]	; (801c9bc <GetFileName+0x1b4>)
 801c83e:	f7fe fdd3 	bl	801b3e8 <FindToken>
 801c842:	2800      	cmp	r0, #0
 801c844:	f040 80a4 	bne.w	801c990 <GetFileName+0x188>
		while(f_read(&MyFile, BufferCtl.buff, 8, (void *)&bytesread) != FR_OK); // dummy read 8 bytes
 801c848:	4e5d      	ldr	r6, [pc, #372]	; (801c9c0 <GetFileName+0x1b8>)
 801c84a:	4d5e      	ldr	r5, [pc, #376]	; (801c9c4 <GetFileName+0x1bc>)
 801c84c:	4c5a      	ldr	r4, [pc, #360]	; (801c9b8 <GetFileName+0x1b0>)
 801c84e:	4633      	mov	r3, r6
 801c850:	2208      	movs	r2, #8
 801c852:	4629      	mov	r1, r5
 801c854:	4620      	mov	r0, r4
 801c856:	f7ef fc4d 	bl	800c0f4 <f_read>
 801c85a:	2800      	cmp	r0, #0
 801c85c:	d1f7      	bne.n	801c84e <GetFileName+0x46>
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c85e:	4c5a      	ldr	r4, [pc, #360]	; (801c9c8 <GetFileName+0x1c0>)
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c860:	4e57      	ldr	r6, [pc, #348]	; (801c9c0 <GetFileName+0x1b8>)
 801c862:	4d55      	ldr	r5, [pc, #340]	; (801c9b8 <GetFileName+0x1b0>)
	for(int i = 0; i < 5; i++) tag[i] = 0;
 801c864:	6020      	str	r0, [r4, #0]
 801c866:	7120      	strb	r0, [r4, #4]
	while(f_read(&MyFile, &tag[0], 4, (void *)&bytesread) != FR_OK);
 801c868:	4633      	mov	r3, r6
 801c86a:	2204      	movs	r2, #4
 801c86c:	4621      	mov	r1, r4
 801c86e:	4628      	mov	r0, r5
 801c870:	f7ef fc40 	bl	800c0f4 <f_read>
 801c874:	2800      	cmp	r0, #0
 801c876:	d1f7      	bne.n	801c868 <GetFileName+0x60>
		out_data |= tag[i];
 801c878:	7821      	ldrb	r1, [r4, #0]
 801c87a:	7862      	ldrb	r2, [r4, #1]
 801c87c:	78a3      	ldrb	r3, [r4, #2]
 801c87e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 801c882:	78e5      	ldrb	r5, [r4, #3]
 801c884:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801c888:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
	out_data >>= 8;
 801c88c:	f345 0517 	sbfx	r5, r5, #0, #24
		data_size = GetLongNumber();
		if (data_size>=RBX_MAX_PATH){
 801c890:	2dfe      	cmp	r5, #254	; 0xfe
 801c892:	f200 8086 	bhi.w	801c9a2 <GetFileName+0x19a>
			//ERROR  -- TOO LONG PATH!!!!
			f_close(&MyFile);
			return 1;
		}
		while(f_read(&MyFile, filename, data_size, (void *)&bytesread) != FR_OK);
 801c896:	4f4a      	ldr	r7, [pc, #296]	; (801c9c0 <GetFileName+0x1b8>)
 801c898:	4e47      	ldr	r6, [pc, #284]	; (801c9b8 <GetFileName+0x1b0>)
 801c89a:	463b      	mov	r3, r7
 801c89c:	462a      	mov	r2, r5
 801c89e:	4669      	mov	r1, sp
 801c8a0:	4630      	mov	r0, r6
 801c8a2:	f7ef fc27 	bl	800c0f4 <f_read>
 801c8a6:	4604      	mov	r4, r0
 801c8a8:	2800      	cmp	r0, #0
 801c8aa:	d1f6      	bne.n	801c89a <GetFileName+0x92>
		i = 0;
		k = 0;
		while(i < data_size) {
 801c8ac:	4e41      	ldr	r6, [pc, #260]	; (801c9b4 <GetFileName+0x1ac>)
 801c8ae:	2d00      	cmp	r5, #0
 801c8b0:	d073      	beq.n	801c99a <GetFileName+0x192>
 801c8b2:	f105 39ff 	add.w	r9, r5, #4294967295
 801c8b6:	f10d 0301 	add.w	r3, sp, #1
 801c8ba:	46ea      	mov	sl, sp
 801c8bc:	46b3      	mov	fp, r6
 801c8be:	eb03 0859 	add.w	r8, r3, r9, lsr #1
 801c8c2:	466f      	mov	r7, sp
 801c8c4:	ea4f 0959 	mov.w	r9, r9, lsr #1
			WCHAR c = filename[i];
 801c8c8:	783b      	ldrb	r3, [r7, #0]
			c <<= 8;
			i++;
			c |= filename[i];
			i++;
			rekordbox.filename[k] = c;
			filename[k] = ff_convert(c, 0);
 801c8ca:	2100      	movs	r1, #0
			c |= filename[i];
 801c8cc:	7878      	ldrb	r0, [r7, #1]
		while(i < data_size) {
 801c8ce:	3702      	adds	r7, #2
			c |= filename[i];
 801c8d0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			rekordbox.filename[k] = c;
 801c8d4:	f84b 0b04 	str.w	r0, [fp], #4
			filename[k] = ff_convert(c, 0);
 801c8d8:	f7f0 f85c 	bl	800c994 <ff_convert>
 801c8dc:	f80a 0b01 	strb.w	r0, [sl], #1
		while(i < data_size) {
 801c8e0:	45c2      	cmp	sl, r8
 801c8e2:	d1f1      	bne.n	801c8c8 <GetFileName+0xc0>
			k++;
 801c8e4:	f109 0001 	add.w	r0, r9, #1
		}
		for(i = k; i < data_size; i++) filename[i] = 0;
 801c8e8:	b2c0      	uxtb	r0, r0
 801c8ea:	42a8      	cmp	r0, r5
 801c8ec:	d204      	bcs.n	801c8f8 <GetFileName+0xf0>
 801c8ee:	1a2a      	subs	r2, r5, r0
 801c8f0:	2100      	movs	r1, #0
 801c8f2:	4468      	add	r0, sp
 801c8f4:	f003 fbf2 	bl	80200dc <memset>
 801c8f8:	1c6a      	adds	r2, r5, #1
		while(i < data_size) {
 801c8fa:	462b      	mov	r3, r5
 801c8fc:	446a      	add	r2, sp
 801c8fe:	e001      	b.n	801c904 <GetFileName+0xfc>
		i = data_size;
		while((i > 0) && (filename[i] != '.')) i--;
 801c900:	3b01      	subs	r3, #1
 801c902:	d04a      	beq.n	801c99a <GetFileName+0x192>
 801c904:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801c908:	292e      	cmp	r1, #46	; 0x2e
 801c90a:	d1f9      	bne.n	801c900 <GetFileName+0xf8>
 801c90c:	3b01      	subs	r3, #1
		while(i < data_size) {
 801c90e:	2200      	movs	r2, #0
 801c910:	446b      	add	r3, sp
		k = 0;
		while(k < 5)
		{
			if(filename[i] >= 32) {
 801c912:	f813 1f01 	ldrb.w	r1, [r3, #1]!
				rekordbox.filetype[k] = filename[i];
				k++;
 801c916:	1c57      	adds	r7, r2, #1
				rekordbox.filetype[k] = filename[i];
 801c918:	18b0      	adds	r0, r6, r2
			if(filename[i] >= 32) {
 801c91a:	291f      	cmp	r1, #31
 801c91c:	d935      	bls.n	801c98a <GetFileName+0x182>
				k++;
 801c91e:	b2fa      	uxtb	r2, r7
				rekordbox.filetype[k] = filename[i];
 801c920:	f880 14fb 	strb.w	r1, [r0, #1275]	; 0x4fb
		while(k < 5)
 801c924:	2a05      	cmp	r2, #5
 801c926:	d1f4      	bne.n	801c912 <GetFileName+0x10a>
			}
			i++;
		}
		rekordbox.filetype[4] = 0;
 801c928:	2100      	movs	r1, #0

		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801c92a:	22ff      	movs	r2, #255	; 0xff
 801c92c:	4827      	ldr	r0, [pc, #156]	; (801c9cc <GetFileName+0x1c4>)
		rekordbox.filetype[4] = 0;
 801c92e:	f886 14ff 	strb.w	r1, [r6, #1279]	; 0x4ff
		for(i = 0; i < RBX_MAX_PATH; i++) rekordbox.file[i] = 0;
 801c932:	f003 fbd3 	bl	80200dc <memset>
		i = data_size;
		while((i > 0) && (filename[i] != '/')) i--;
 801c936:	b3dd      	cbz	r5, 801c9b0 <GetFileName+0x1a8>
 801c938:	1c6a      	adds	r2, r5, #1
 801c93a:	462b      	mov	r3, r5
 801c93c:	446a      	add	r2, sp
 801c93e:	e001      	b.n	801c944 <GetFileName+0x13c>
 801c940:	3b01      	subs	r3, #1
 801c942:	d02c      	beq.n	801c99e <GetFileName+0x196>
 801c944:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 801c948:	292f      	cmp	r1, #47	; 0x2f
 801c94a:	d1f9      	bne.n	801c940 <GetFileName+0x138>
		k = 0;
		i++;
 801c94c:	3301      	adds	r3, #1
		while(i < data_size)
 801c94e:	429d      	cmp	r5, r3
 801c950:	d92c      	bls.n	801c9ac <GetFileName+0x1a4>
 801c952:	3b01      	subs	r3, #1
 801c954:	f10d 32ff 	add.w	r2, sp, #4294967295
 801c958:	446b      	add	r3, sp
 801c95a:	1957      	adds	r7, r2, r5
		{
			if(filename[i] >= 32) {
 801c95c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
				rekordbox.file[k] = filename[i];
				k++;
 801c960:	1c60      	adds	r0, r4, #1
				rekordbox.file[k] = filename[i];
 801c962:	1931      	adds	r1, r6, r4
			if(filename[i] >= 32) {
 801c964:	2a1f      	cmp	r2, #31
 801c966:	d902      	bls.n	801c96e <GetFileName+0x166>
				k++;
 801c968:	b2c4      	uxtb	r4, r0
				rekordbox.file[k] = filename[i];
 801c96a:	f881 23fc 	strb.w	r2, [r1, #1020]	; 0x3fc
		while(i < data_size)
 801c96e:	42bb      	cmp	r3, r7
 801c970:	d1f4      	bne.n	801c95c <GetFileName+0x154>
			}
			i++;
		}
		rekordbox.file[i] = 0;
 801c972:	4435      	add	r5, r6
 801c974:	2300      	movs	r3, #0
 801c976:	f885 33fc 	strb.w	r3, [r5, #1020]	; 0x3fc
	}
	f_close(&MyFile);
 801c97a:	480f      	ldr	r0, [pc, #60]	; (801c9b8 <GetFileName+0x1b0>)
 801c97c:	f7ef fcce 	bl	800c31c <f_close>
	return 0;
 801c980:	2000      	movs	r0, #0
}
 801c982:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
 801c986:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while(k < 5)
 801c98a:	2a04      	cmp	r2, #4
 801c98c:	d9c1      	bls.n	801c912 <GetFileName+0x10a>
 801c98e:	e7cb      	b.n	801c928 <GetFileName+0x120>
		if(FindToken(path_token) != 0) return 1;
 801c990:	2001      	movs	r0, #1
}
 801c992:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
 801c996:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while(i < data_size) {
 801c99a:	2300      	movs	r3, #0
 801c99c:	e7b6      	b.n	801c90c <GetFileName+0x104>
 801c99e:	2301      	movs	r3, #1
 801c9a0:	e7d5      	b.n	801c94e <GetFileName+0x146>
			f_close(&MyFile);
 801c9a2:	4805      	ldr	r0, [pc, #20]	; (801c9b8 <GetFileName+0x1b0>)
 801c9a4:	f7ef fcba 	bl	800c31c <f_close>
			return 1;
 801c9a8:	2001      	movs	r0, #1
 801c9aa:	e7ea      	b.n	801c982 <GetFileName+0x17a>
		while(i < data_size)
 801c9ac:	461d      	mov	r5, r3
 801c9ae:	e7e0      	b.n	801c972 <GetFileName+0x16a>
		i++;
 801c9b0:	2501      	movs	r5, #1
 801c9b2:	e7de      	b.n	801c972 <GetFileName+0x16a>
 801c9b4:	200154f0 	.word	0x200154f0
 801c9b8:	20001e40 	.word	0x20001e40
 801c9bc:	08026ee8 	.word	0x08026ee8
 801c9c0:	2000ec34 	.word	0x2000ec34
 801c9c4:	20000e30 	.word	0x20000e30
 801c9c8:	200188c8 	.word	0x200188c8
 801c9cc:	200158ec 	.word	0x200158ec

0801c9d0 <MX_SAI2_Init>:

  /* USER CODE BEGIN SAI2_Init 1 */

  /* USER CODE END SAI2_Init 1 */

  hsai_BlockA2.Instance = SAI2_Block_A;
 801c9d0:	4818      	ldr	r0, [pc, #96]	; (801ca34 <MX_SAI2_Init+0x64>)
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
 801c9d2:	2300      	movs	r3, #0
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
  hsai_BlockA2.Init.FirstBit = SAI_FIRSTBIT_MSB;
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 801c9d4:	2201      	movs	r2, #1
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
 801c9d6:	2180      	movs	r1, #128	; 0x80
{
 801c9d8:	b510      	push	{r4, lr}
  hsai_BlockA2.Instance = SAI2_Block_A;
 801c9da:	4c17      	ldr	r4, [pc, #92]	; (801ca38 <MX_SAI2_Init+0x68>)
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
 801c9dc:	6341      	str	r1, [r0, #52]	; 0x34
  hsai_BlockA2.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA2.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLE;
 801c9de:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 801c9e2:	6182      	str	r2, [r0, #24]
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
 801c9e4:	6303      	str	r3, [r0, #48]	; 0x30
  hsai_BlockA2.Init.Synchro = SAI_ASYNCHRONOUS;
 801c9e6:	6083      	str	r3, [r0, #8]
  hsai_BlockA2.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
  hsai_BlockA2.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 801c9e8:	60c3      	str	r3, [r0, #12]
  hsai_BlockA2.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA2.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA2.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 801c9ea:	62c3      	str	r3, [r0, #44]	; 0x2c
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 801c9ec:	e9c0 320e 	strd	r3, r2, [r0, #56]	; 0x38
  hsai_BlockA2.FrameInit.FrameLength = 64;
 801c9f0:	2240      	movs	r2, #64	; 0x40
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
 801c9f2:	e9c0 4300 	strd	r4, r3, [r0]
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 801c9f6:	e9c0 1304 	strd	r1, r3, [r0, #16]
  hsai_BlockA2.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 801c9fa:	f64b 3480 	movw	r4, #48000	; 0xbb80
  hsai_BlockA2.FrameInit.ActiveFrameLength = 32;
 801c9fe:	2120      	movs	r1, #32
  hsai_BlockA2.FrameInit.FrameLength = 64;
 801ca00:	6402      	str	r2, [r0, #64]	; 0x40
  hsai_BlockA2.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 801ca02:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  hsai_BlockA2.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 801ca06:	61c4      	str	r4, [r0, #28]
  hsai_BlockA2.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
  hsai_BlockA2.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 801ca08:	f44f 2480 	mov.w	r4, #262144	; 0x40000
  hsai_BlockA2.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 801ca0c:	e9c0 1211 	strd	r1, r2, [r0, #68]	; 0x44
  hsai_BlockA2.SlotInit.FirstBitOffset = 0;
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
  hsai_BlockA2.SlotInit.SlotNumber = 4;
 801ca10:	2104      	movs	r1, #4
  hsai_BlockA2.SlotInit.SlotActive = 0x0000000F;
 801ca12:	220f      	movs	r2, #15
  hsai_BlockA2.Init.CompandingMode = SAI_NOCOMPANDING;
 801ca14:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hsai_BlockA2.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 801ca18:	e9c0 3413 	strd	r3, r4, [r0, #76]	; 0x4c
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 801ca1c:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hsai_BlockA2.SlotInit.SlotActive = 0x0000000F;
 801ca20:	e9c0 1217 	strd	r1, r2, [r0, #92]	; 0x5c
  if (HAL_SAI_Init(&hsai_BlockA2) != HAL_OK)
 801ca24:	f7e8 fd44 	bl	80054b0 <HAL_SAI_Init>
 801ca28:	b900      	cbnz	r0, 801ca2c <MX_SAI2_Init+0x5c>

  /* USER CODE BEGIN SAI2_Init 2 */

  /* USER CODE END SAI2_Init 2 */

}
 801ca2a:	bd10      	pop	{r4, pc}
 801ca2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 801ca30:	f7fe ba36 	b.w	801aea0 <Error_Handler>
 801ca34:	20018934 	.word	0x20018934
 801ca38:	40015c04 	.word	0x40015c04
 801ca3c:	00000000 	.word	0x00000000

0801ca40 <HAL_SAI_MspInit>:
static uint32_t SAI2_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* saiHandle)
{
 801ca40:	b530      	push	{r4, r5, lr}
 801ca42:	b0ab      	sub	sp, #172	; 0xac
 801ca44:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801ca46:	2284      	movs	r2, #132	; 0x84
 801ca48:	2100      	movs	r1, #0
 801ca4a:	a808      	add	r0, sp, #32
 801ca4c:	f003 fb46 	bl	80200dc <memset>
/* SAI2 */
    if(saiHandle->Instance==SAI2_Block_A)
 801ca50:	4b35      	ldr	r3, [pc, #212]	; (801cb28 <HAL_SAI_MspInit+0xe8>)
 801ca52:	6822      	ldr	r2, [r4, #0]
 801ca54:	429a      	cmp	r2, r3
 801ca56:	d001      	beq.n	801ca5c <HAL_SAI_MspInit+0x1c>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one stream to perform all the requested DMAs. */
    __HAL_LINKDMA(saiHandle,hdmarx,hdma_sai2_a);
    __HAL_LINKDMA(saiHandle,hdmatx,hdma_sai2_a);
    }
}
 801ca58:	b02b      	add	sp, #172	; 0xac
 801ca5a:	bd30      	pop	{r4, r5, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801ca5c:	ed9f 7b2c 	vldr	d7, [pc, #176]	; 801cb10 <HAL_SAI_MspInit+0xd0>
    PeriphClkInitStruct.PLLI2S.PLLI2SP = RCC_PLLP_DIV2;
 801ca60:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801ca62:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.PLLI2S.PLLI2SP = RCC_PLLP_DIV2;
 801ca64:	930c      	str	r3, [sp, #48]	; 0x30
    PeriphClkInitStruct.PLLI2SDivQ = 1;
 801ca66:	2301      	movs	r3, #1
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801ca68:	ed8d 7b08 	vstr	d7, [sp, #32]
 801ca6c:	ed9f 7b2a 	vldr	d7, [pc, #168]	; 801cb18 <HAL_SAI_MspInit+0xd8>
    PeriphClkInitStruct.PLLI2SDivQ = 1;
 801ca70:	9311      	str	r3, [sp, #68]	; 0x44
    PeriphClkInitStruct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801ca72:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801ca76:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    PeriphClkInitStruct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801ca7a:	9318      	str	r3, [sp, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801ca7c:	f7e7 ff6c 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
 801ca80:	2800      	cmp	r0, #0
 801ca82:	d13d      	bne.n	801cb00 <HAL_SAI_MspInit+0xc0>
    if (SAI2_client == 0)
 801ca84:	4a29      	ldr	r2, [pc, #164]	; (801cb2c <HAL_SAI_MspInit+0xec>)
 801ca86:	6813      	ldr	r3, [r2, #0]
 801ca88:	b94b      	cbnz	r3, 801ca9e <HAL_SAI_MspInit+0x5e>
       __HAL_RCC_SAI2_CLK_ENABLE();
 801ca8a:	4929      	ldr	r1, [pc, #164]	; (801cb30 <HAL_SAI_MspInit+0xf0>)
 801ca8c:	6c48      	ldr	r0, [r1, #68]	; 0x44
 801ca8e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 801ca92:	6448      	str	r0, [r1, #68]	; 0x44
 801ca94:	6c49      	ldr	r1, [r1, #68]	; 0x44
 801ca96:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 801ca9a:	9101      	str	r1, [sp, #4]
 801ca9c:	9901      	ldr	r1, [sp, #4]
    SAI2_client ++;
 801ca9e:	3301      	adds	r3, #1
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_6;
 801caa0:	20f0      	movs	r0, #240	; 0xf0
 801caa2:	2102      	movs	r1, #2
    hdma_sai2_a.Instance = DMA2_Stream4;
 801caa4:	4d23      	ldr	r5, [pc, #140]	; (801cb34 <HAL_SAI_MspInit+0xf4>)
    SAI2_client ++;
 801caa6:	6013      	str	r3, [r2, #0]
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 801caa8:	230a      	movs	r3, #10
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_6;
 801caaa:	ed9f 7b1d 	vldr	d7, [pc, #116]	; 801cb20 <HAL_SAI_MspInit+0xe0>
 801caae:	e9cd 0102 	strd	r0, r1, [sp, #8]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801cab2:	a902      	add	r1, sp, #8
 801cab4:	4820      	ldr	r0, [pc, #128]	; (801cb38 <HAL_SAI_MspInit+0xf8>)
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 801cab6:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_6;
 801cab8:	ed8d 7b04 	vstr	d7, [sp, #16]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801cabc:	f7e5 f996 	bl	8001dec <HAL_GPIO_Init>
    hdma_sai2_a.Instance = DMA2_Stream4;
 801cac0:	491e      	ldr	r1, [pc, #120]	; (801cb3c <HAL_SAI_MspInit+0xfc>)
    hdma_sai2_a.Init.Channel = DMA_CHANNEL_3;
 801cac2:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
    hdma_sai2_a.Init.PeriphInc = DMA_PINC_DISABLE;
 801cac6:	2300      	movs	r3, #0
    if (HAL_DMA_Init(&hdma_sai2_a) != HAL_OK)
 801cac8:	4628      	mov	r0, r5
    hdma_sai2_a.Init.PeriphInc = DMA_PINC_DISABLE;
 801caca:	60eb      	str	r3, [r5, #12]
    hdma_sai2_a.Init.Priority = DMA_PRIORITY_LOW;
 801cacc:	622b      	str	r3, [r5, #32]
    hdma_sai2_a.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 801cace:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_sai2_a.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 801cad0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    hdma_sai2_a.Init.Channel = DMA_CHANNEL_3;
 801cad4:	e9c5 1200 	strd	r1, r2, [r5]
    hdma_sai2_a.Init.MemInc = DMA_MINC_ENABLE;
 801cad8:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_sai2_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801cadc:	2140      	movs	r1, #64	; 0x40
    hdma_sai2_a.Init.MemInc = DMA_MINC_ENABLE;
 801cade:	612a      	str	r2, [r5, #16]
    hdma_sai2_a.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 801cae0:	f44f 6200 	mov.w	r2, #2048	; 0x800
    hdma_sai2_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801cae4:	60a9      	str	r1, [r5, #8]
    hdma_sai2_a.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 801cae6:	e9c5 2305 	strd	r2, r3, [r5, #20]
    hdma_sai2_a.Init.Mode = DMA_CIRCULAR;
 801caea:	f44f 7380 	mov.w	r3, #256	; 0x100
 801caee:	61eb      	str	r3, [r5, #28]
    if (HAL_DMA_Init(&hdma_sai2_a) != HAL_OK)
 801caf0:	f7e4 fc48 	bl	8001384 <HAL_DMA_Init>
 801caf4:	b938      	cbnz	r0, 801cb06 <HAL_SAI_MspInit+0xc6>
    __HAL_LINKDMA(saiHandle,hdmarx,hdma_sai2_a);
 801caf6:	6725      	str	r5, [r4, #112]	; 0x70
 801caf8:	63ac      	str	r4, [r5, #56]	; 0x38
    __HAL_LINKDMA(saiHandle,hdmatx,hdma_sai2_a);
 801cafa:	66e5      	str	r5, [r4, #108]	; 0x6c
}
 801cafc:	b02b      	add	sp, #172	; 0xac
 801cafe:	bd30      	pop	{r4, r5, pc}
      Error_Handler();
 801cb00:	f7fe f9ce 	bl	801aea0 <Error_Handler>
 801cb04:	e7be      	b.n	801ca84 <HAL_SAI_MspInit+0x44>
      Error_Handler();
 801cb06:	f7fe f9cb 	bl	801aea0 <Error_Handler>
 801cb0a:	e7f4      	b.n	801caf6 <HAL_SAI_MspInit+0xb6>
 801cb0c:	f3af 8000 	nop.w
 801cb10:	00100000 	.word	0x00100000
 801cb14:	00000064 	.word	0x00000064
 801cb18:	00000002 	.word	0x00000002
 801cb1c:	00000002 	.word	0x00000002
 801cb20:	00000000 	.word	0x00000000
 801cb24:	00000002 	.word	0x00000002
 801cb28:	40015c04 	.word	0x40015c04
 801cb2c:	200188d0 	.word	0x200188d0
 801cb30:	40023800 	.word	0x40023800
 801cb34:	200188d4 	.word	0x200188d4
 801cb38:	40022000 	.word	0x40022000
 801cb3c:	40026470 	.word	0x40026470

0801cb40 <MX_SDMMC1_SD_Init>:
SD_HandleTypeDef hsd1;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
 801cb40:	b410      	push	{r4}
  /* USER CODE END SDMMC1_Init 0 */

  /* USER CODE BEGIN SDMMC1_Init 1 */

  /* USER CODE END SDMMC1_Init 1 */
  hsd1.Instance = SDMMC1;
 801cb42:	4b09      	ldr	r3, [pc, #36]	; (801cb68 <MX_SDMMC1_SD_Init+0x28>)
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 801cb44:	2200      	movs	r2, #0
  hsd1.Instance = SDMMC1;
 801cb46:	4c09      	ldr	r4, [pc, #36]	; (801cb6c <MX_SDMMC1_SD_Init+0x2c>)
  hsd1.Init.ClockBypass = SDMMC_CLOCK_BYPASS_DISABLE;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 801cb48:	f44f 6000 	mov.w	r0, #2048	; 0x800
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;
 801cb4c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
 801cb50:	e9c3 4200 	strd	r4, r2, [r3]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 801cb54:	e9c3 2202 	strd	r2, r2, [r3, #8]
  hsd1.Init.ClockDiv = 2;
 801cb58:	2202      	movs	r2, #2
  /* USER CODE BEGIN SDMMC1_Init 2 */

  /* USER CODE END SDMMC1_Init 2 */

}
 801cb5a:	f85d 4b04 	ldr.w	r4, [sp], #4
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;
 801cb5e:	e9c3 0104 	strd	r0, r1, [r3, #16]
  hsd1.Init.ClockDiv = 2;
 801cb62:	619a      	str	r2, [r3, #24]
}
 801cb64:	4770      	bx	lr
 801cb66:	bf00      	nop
 801cb68:	200189b8 	.word	0x200189b8
 801cb6c:	40012c00 	.word	0x40012c00

0801cb70 <MX_SPI2_Init>:
  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  hspi2.Instance = SPI2;
 801cb70:	4811      	ldr	r0, [pc, #68]	; (801cbb8 <MX_SPI2_Init+0x48>)
  hspi2.Init.Mode = SPI_MODE_SLAVE;
 801cb72:	2100      	movs	r1, #0
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 801cb74:	2200      	movs	r2, #0
 801cb76:	2300      	movs	r3, #0
{
 801cb78:	b510      	push	{r4, lr}
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 801cb7a:	e9c0 1101 	strd	r1, r1, [r0, #4]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 801cb7e:	f44f 61e0 	mov.w	r1, #1792	; 0x700
  hspi2.Instance = SPI2;
 801cb82:	4c0e      	ldr	r4, [pc, #56]	; (801cbbc <MX_SPI2_Init+0x4c>)
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 801cb84:	e9c0 2308 	strd	r2, r3, [r0, #32]
 801cb88:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 801cb8c:	60c1      	str	r1, [r0, #12]
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
 801cb8e:	2201      	movs	r2, #1
  hspi2.Init.NSS = SPI_NSS_SOFT;
 801cb90:	f44f 7300 	mov.w	r3, #512	; 0x200
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
 801cb94:	2102      	movs	r1, #2
  hspi2.Instance = SPI2;
 801cb96:	6004      	str	r4, [r0, #0]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 801cb98:	6183      	str	r3, [r0, #24]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 801cb9a:	2307      	movs	r3, #7
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
 801cb9c:	e9c0 1204 	strd	r1, r2, [r0, #16]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 801cba0:	2200      	movs	r2, #0
 801cba2:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 7;
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 801cba6:	f7e9 f92b 	bl	8005e00 <HAL_SPI_Init>
 801cbaa:	b900      	cbnz	r0, 801cbae <MX_SPI2_Init+0x3e>
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
 801cbac:	bd10      	pop	{r4, pc}
 801cbae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 801cbb2:	f7fe b975 	b.w	801aea0 <Error_Handler>
 801cbb6:	bf00      	nop
 801cbb8:	20018a40 	.word	0x20018a40
 801cbbc:	40003800 	.word	0x40003800

0801cbc0 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(spiHandle->Instance==SPI2)
 801cbc0:	4b27      	ldr	r3, [pc, #156]	; (801cc60 <HAL_SPI_MspInit+0xa0>)
 801cbc2:	6802      	ldr	r2, [r0, #0]
{
 801cbc4:	b530      	push	{r4, r5, lr}
  if(spiHandle->Instance==SPI2)
 801cbc6:	429a      	cmp	r2, r3
{
 801cbc8:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801cbca:	f04f 0400 	mov.w	r4, #0
 801cbce:	e9cd 4404 	strd	r4, r4, [sp, #16]
 801cbd2:	e9cd 4406 	strd	r4, r4, [sp, #24]
 801cbd6:	9408      	str	r4, [sp, #32]
  if(spiHandle->Instance==SPI2)
 801cbd8:	d001      	beq.n	801cbde <HAL_SPI_MspInit+0x1e>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 801cbda:	b00b      	add	sp, #44	; 0x2c
 801cbdc:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_SPI2_CLK_ENABLE();
 801cbde:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801cbe2:	2505      	movs	r5, #5
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801cbe4:	481f      	ldr	r0, [pc, #124]	; (801cc64 <HAL_SPI_MspInit+0xa4>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 801cbe6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801cbe8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801cbec:	641a      	str	r2, [r3, #64]	; 0x40
 801cbee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801cbf0:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 801cbf4:	9201      	str	r2, [sp, #4]
 801cbf6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 801cbf8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801cbfa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 801cbfe:	631a      	str	r2, [r3, #48]	; 0x30
 801cc00:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801cc02:	f402 7280 	and.w	r2, r2, #256	; 0x100
 801cc06:	9202      	str	r2, [sp, #8]
 801cc08:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801cc0a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801cc0c:	f042 0202 	orr.w	r2, r2, #2
 801cc10:	631a      	str	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 801cc12:	2202      	movs	r2, #2
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801cc14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801cc16:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801cc18:	f003 0302 	and.w	r3, r3, #2
 801cc1c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 801cc1e:	2302      	movs	r3, #2
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801cc20:	9903      	ldr	r1, [sp, #12]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801cc22:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 801cc24:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801cc28:	2303      	movs	r3, #3
 801cc2a:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 801cc2c:	f7e5 f8de 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
 801cc30:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 801cc34:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801cc36:	a904      	add	r1, sp, #16
 801cc38:	480b      	ldr	r0, [pc, #44]	; (801cc68 <HAL_SPI_MspInit+0xa8>)
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801cc3a:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
 801cc3c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 801cc40:	2303      	movs	r3, #3
 801cc42:	2200      	movs	r2, #0
 801cc44:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801cc48:	f7e5 f8d0 	bl	8001dec <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(SPI2_IRQn, 2, 0);
 801cc4c:	4622      	mov	r2, r4
 801cc4e:	2102      	movs	r1, #2
 801cc50:	2024      	movs	r0, #36	; 0x24
 801cc52:	f7e4 fa43 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 801cc56:	2024      	movs	r0, #36	; 0x24
 801cc58:	f7e4 fa8a 	bl	8001170 <HAL_NVIC_EnableIRQ>
}
 801cc5c:	b00b      	add	sp, #44	; 0x2c
 801cc5e:	bd30      	pop	{r4, r5, pc}
 801cc60:	40003800 	.word	0x40003800
 801cc64:	40022000 	.word	0x40022000
 801cc68:	40020400 	.word	0x40020400

0801cc6c <BSP_AUDIO_OUT_Init>:
  * @param  AudioFreq: Audio frequency used to play the audio stream.
  * @note   The I2S PLL input clock must be done in the user application.  
  * @retval AUDIO_OK if correct communication, else wrong communication
  */
uint8_t BSP_AUDIO_OUT_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{ 
 801cc6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801cc70:	b0a3      	sub	sp, #140	; 0x8c
 801cc72:	4614      	mov	r4, r2
 801cc74:	4605      	mov	r5, r0
 801cc76:	4688      	mov	r8, r1
  */
void BSP_AUDIO_OUT_ClockConfig(SAI_HandleTypeDef *hsai, uint32_t AudioFreq, void *Params)
{ 
  RCC_PeriphCLKInitTypeDef rcc_ex_clk_init_struct;

  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
 801cc78:	a801      	add	r0, sp, #4
 801cc7a:	f7e8 fb05 	bl	8005288 <HAL_RCCEx_GetPeriphCLKConfig>
  
  uint32_t I2SDivQ = 33;
  uint32_t I2SN = 49;
  uint32_t new_frequency_Hz = (203000000 / 9 * (float)AudioFreq /
 801cc7e:	ee07 4a90 	vmov	s15, r4
 801cc82:	ed9f 7a39 	vldr	s14, [pc, #228]	; 801cd68 <BSP_AUDIO_OUT_Init+0xfc>
		(float) AUDIO_FREQUENCY_22K);
  uint32_t set_frequency_Hz = 0;
  for(I2SDivQ = 32; I2SDivQ > 1; I2SDivQ--) {
 801cc86:	2220      	movs	r2, #32
  uint32_t new_frequency_Hz = (203000000 / 9 * (float)AudioFreq /
 801cc88:	eef8 7a67 	vcvt.f32.u32	s15, s15
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801cc8c:	4837      	ldr	r0, [pc, #220]	; (801cd6c <BSP_AUDIO_OUT_Init+0x100>)
  uint32_t new_frequency_Hz = (203000000 / 9 * (float)AudioFreq /
 801cc8e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801cc92:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801cc96:	ee17 1a90 	vmov	r1, s15
  for(I2SDivQ = 32; I2SDivQ > 1; I2SDivQ--) {
 801cc9a:	e006      	b.n	801ccaa <BSP_AUDIO_OUT_Init+0x3e>
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801cc9c:	3601      	adds	r6, #1
 801cc9e:	f5b6 7fd8 	cmp.w	r6, #432	; 0x1b0
 801cca2:	d104      	bne.n	801ccae <BSP_AUDIO_OUT_Init+0x42>
  for(I2SDivQ = 32; I2SDivQ > 1; I2SDivQ--) {
 801cca4:	3a01      	subs	r2, #1
 801cca6:	2a01      	cmp	r2, #1
 801cca8:	d006      	beq.n	801ccb8 <BSP_AUDIO_OUT_Init+0x4c>
{ 
 801ccaa:	4b31      	ldr	r3, [pc, #196]	; (801cd70 <BSP_AUDIO_OUT_Init+0x104>)
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801ccac:	2632      	movs	r6, #50	; 0x32
		  set_frequency_Hz = I2SN * 1000000 / I2SDivQ;
 801ccae:	fbb3 fef2 	udiv	lr, r3, r2
		  if(set_frequency_Hz >= new_frequency_Hz) break;
 801ccb2:	4571      	cmp	r1, lr
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801ccb4:	4403      	add	r3, r0
		  if(set_frequency_Hz >= new_frequency_Hz) break;
 801ccb6:	d8f1      	bhi.n	801cc9c <BSP_AUDIO_OUT_Init+0x30>
	  }
	  if(set_frequency_Hz >= new_frequency_Hz) break;
  }
  rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801ccb8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000

  rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = I2SN;
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
  rcc_ex_clk_init_struct.PLLI2SDivQ = I2SDivQ;
    
  HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 801ccbc:	a801      	add	r0, sp, #4
  * @retval None
  */
static void SAIx_Out_Init(uint32_t AudioFreq)
{
  /* Initialize the hsai_BlockA2 Instance parameter */
  hsai_BlockA2.Instance = AUDIO_OUT_SAIx;
 801ccbe:	4f2d      	ldr	r7, [pc, #180]	; (801cd74 <BSP_AUDIO_OUT_Init+0x108>)
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
  hsai_BlockA2.Init.FirstBit = SAI_FIRSTBIT_MSB;
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 801ccc0:	f04f 0901 	mov.w	r9, #1
  rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801ccc4:	9301      	str	r3, [sp, #4]
  rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801ccc6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  rcc_ex_clk_init_struct.PLLI2SDivQ = I2SDivQ;
 801ccca:	920a      	str	r2, [sp, #40]	; 0x28
  rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801cccc:	9311      	str	r3, [sp, #68]	; 0x44
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
 801ccce:	2302      	movs	r3, #2
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = I2SN;
 801ccd0:	9602      	str	r6, [sp, #8]
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
 801ccd2:	2600      	movs	r6, #0
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
 801ccd4:	9304      	str	r3, [sp, #16]
  HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 801ccd6:	f7e7 fe3f 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
  hsai_BlockA2.Instance = AUDIO_OUT_SAIx;
 801ccda:	4b27      	ldr	r3, [pc, #156]	; (801cd78 <BSP_AUDIO_OUT_Init+0x10c>)
  Frame active Length: 32
  FS Definition: Start frame + Channel Side identification
  FS Polarity: FS active Low
  FS Offset: FS asserted one bit before the first bit of slot 0 */ 
  hsai_BlockA2.FrameInit.FrameLength = 64;
  hsai_BlockA2.FrameInit.ActiveFrameLength = 32;
 801ccdc:	f04f 0e40 	mov.w	lr, #64	; 0x40
  Slot Number: 4
  Slot Active: All slot actives */
  hsai_BlockA2.SlotInit.FirstBitOffset = 0;
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
  hsai_BlockA2.SlotInit.SlotNumber = 4;
  hsai_BlockA2.SlotInit.SlotActive = CODEC_AUDIOFRAME_SLOT_0123;
 801cce0:	2004      	movs	r0, #4
  hsai_BlockA2.Init.AudioFrequency = AudioFreq;
 801cce2:	61fc      	str	r4, [r7, #28]
  hsai_BlockA2.Instance = AUDIO_OUT_SAIx;
 801cce4:	603b      	str	r3, [r7, #0]
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
 801cce6:	2380      	movs	r3, #128	; 0x80
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
 801cce8:	607e      	str	r6, [r7, #4]
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_16;
 801ccea:	637b      	str	r3, [r7, #52]	; 0x34
  hsai_BlockA2.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
 801ccec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
 801ccf0:	617e      	str	r6, [r7, #20]
  hsai_BlockA2.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
 801ccf2:	613b      	str	r3, [r7, #16]
  hsai_BlockA2.FrameInit.ActiveFrameLength = 32;
 801ccf4:	2320      	movs	r3, #32
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
 801ccf6:	633e      	str	r6, [r7, #48]	; 0x30
  hsai_BlockA2.Init.FirstBit = SAI_FIRSTBIT_MSB;
 801ccf8:	63be      	str	r6, [r7, #56]	; 0x38
  hsai_BlockA2.Init.Synchro = SAI_ASYNCHRONOUS;
 801ccfa:	60be      	str	r6, [r7, #8]
  hsai_BlockA2.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 801ccfc:	64fe      	str	r6, [r7, #76]	; 0x4c
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 801ccfe:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
  hsai_BlockA2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 801cd02:	f8c7 9018 	str.w	r9, [r7, #24]
  hsai_BlockA2.FrameInit.ActiveFrameLength = 32;
 801cd06:	e9c7 e310 	strd	lr, r3, [r7, #64]	; 0x40
  hsai_BlockA2.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 801cd0a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 801cd0e:	64bb      	str	r3, [r7, #72]	; 0x48
  hsai_BlockA2.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 801cd10:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 801cd14:	653b      	str	r3, [r7, #80]	; 0x50
  hsai_BlockA2.SlotInit.SlotActive = CODEC_AUDIOFRAME_SLOT_0123;
 801cd16:	230f      	movs	r3, #15
 801cd18:	e9c7 0317 	strd	r0, r3, [r7, #92]	; 0x5c

  HAL_SAI_Init(&hsai_BlockA2);
 801cd1c:	4638      	mov	r0, r7
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 801cd1e:	e9c7 6615 	strd	r6, r6, [r7, #84]	; 0x54
  HAL_SAI_Init(&hsai_BlockA2);
 801cd22:	f7e8 fbc5 	bl	80054b0 <HAL_SAI_Init>
  
  /* Enable SAI peripheral to generate MCLK */
  __HAL_SAI_ENABLE(&hsai_BlockA2);
 801cd26:	683a      	ldr	r2, [r7, #0]
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 801cd28:	4f14      	ldr	r7, [pc, #80]	; (801cd7c <BSP_AUDIO_OUT_Init+0x110>)
 801cd2a:	2034      	movs	r0, #52	; 0x34
  __HAL_SAI_ENABLE(&hsai_BlockA2);
 801cd2c:	6813      	ldr	r3, [r2, #0]
 801cd2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801cd32:	6013      	str	r3, [r2, #0]
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 801cd34:	68bb      	ldr	r3, [r7, #8]
 801cd36:	4798      	blx	r3
  if((deviceid) == WM8994_ID)
 801cd38:	f648 1394 	movw	r3, #35220	; 0x8994
 801cd3c:	4298      	cmp	r0, r3
 801cd3e:	d003      	beq.n	801cd48 <BSP_AUDIO_OUT_Init+0xdc>
    ret = AUDIO_ERROR;
 801cd40:	4648      	mov	r0, r9
}
 801cd42:	b023      	add	sp, #140	; 0x8c
 801cd44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
 801cd48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cd4a:	2034      	movs	r0, #52	; 0x34
 801cd4c:	4798      	blx	r3
    audio_drv = &wm8994_drv; 
 801cd4e:	480c      	ldr	r0, [pc, #48]	; (801cd80 <BSP_AUDIO_OUT_Init+0x114>)
    audio_drv->Init(AUDIO_I2C_ADDRESS, OutputDevice, Volume, AudioFreq);
 801cd50:	4623      	mov	r3, r4
 801cd52:	4642      	mov	r2, r8
    audio_drv = &wm8994_drv; 
 801cd54:	6007      	str	r7, [r0, #0]
    audio_drv->Init(AUDIO_I2C_ADDRESS, OutputDevice, Volume, AudioFreq);
 801cd56:	4629      	mov	r1, r5
 801cd58:	683c      	ldr	r4, [r7, #0]
 801cd5a:	2034      	movs	r0, #52	; 0x34
 801cd5c:	47a0      	blx	r4
    ret = AUDIO_OK;
 801cd5e:	4630      	mov	r0, r6
}
 801cd60:	b023      	add	sp, #140	; 0x8c
 801cd62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801cd66:	bf00      	nop
 801cd68:	447fbb5f 	.word	0x447fbb5f
 801cd6c:	000f4240 	.word	0x000f4240
 801cd70:	02faf080 	.word	0x02faf080
 801cd74:	20018934 	.word	0x20018934
 801cd78:	40015c04 	.word	0x40015c04
 801cd7c:	2000007c 	.word	0x2000007c
 801cd80:	20018aa4 	.word	0x20018aa4

0801cd84 <BSP_AUDIO_OUT_Play>:
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
 801cd84:	4b0e      	ldr	r3, [pc, #56]	; (801cdc0 <BSP_AUDIO_OUT_Play+0x3c>)
{
 801cd86:	b510      	push	{r4, lr}
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
 801cd88:	681b      	ldr	r3, [r3, #0]
{
 801cd8a:	b082      	sub	sp, #8
 801cd8c:	460c      	mov	r4, r1
 801cd8e:	4601      	mov	r1, r0
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
 801cd90:	9001      	str	r0, [sp, #4]
 801cd92:	2034      	movs	r0, #52	; 0x34
 801cd94:	b2a2      	uxth	r2, r4
 801cd96:	68db      	ldr	r3, [r3, #12]
 801cd98:	4798      	blx	r3
 801cd9a:	b968      	cbnz	r0, 801cdb8 <BSP_AUDIO_OUT_Play+0x34>
    HAL_SAI_Transmit_DMA(&hsai_BlockA2, (uint8_t*) pBuffer, DMA_MAX(Size / AUDIODATA_SIZE));
 801cd9c:	f5b4 3f00 	cmp.w	r4, #131072	; 0x20000
 801cda0:	9901      	ldr	r1, [sp, #4]
 801cda2:	4808      	ldr	r0, [pc, #32]	; (801cdc4 <BSP_AUDIO_OUT_Play+0x40>)
 801cda4:	bf34      	ite	cc
 801cda6:	f3c4 024f 	ubfxcc	r2, r4, #1, #16
 801cdaa:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
 801cdae:	f7e8 fea9 	bl	8005b04 <HAL_SAI_Transmit_DMA>
    return AUDIO_OK;
 801cdb2:	2000      	movs	r0, #0
}
 801cdb4:	b002      	add	sp, #8
 801cdb6:	bd10      	pop	{r4, pc}
    return AUDIO_ERROR;
 801cdb8:	2001      	movs	r0, #1
}
 801cdba:	b002      	add	sp, #8
 801cdbc:	bd10      	pop	{r4, pc}
 801cdbe:	bf00      	nop
 801cdc0:	20018aa4 	.word	0x20018aa4
 801cdc4:	20018934 	.word	0x20018934

0801cdc8 <BSP_AUDIO_OUT_Pause>:
{    
 801cdc8:	b508      	push	{r3, lr}
    HAL_SAI_DMAPause(&hsai_BlockA2);
 801cdca:	4802      	ldr	r0, [pc, #8]	; (801cdd4 <BSP_AUDIO_OUT_Pause+0xc>)
 801cdcc:	f7e8 fe08 	bl	80059e0 <HAL_SAI_DMAPause>
}
 801cdd0:	2000      	movs	r0, #0
 801cdd2:	bd08      	pop	{r3, pc}
 801cdd4:	20018934 	.word	0x20018934

0801cdd8 <BSP_AUDIO_OUT_Resume>:
{    
 801cdd8:	b508      	push	{r3, lr}
    HAL_SAI_DMAResume(&hsai_BlockA2);
 801cdda:	4802      	ldr	r0, [pc, #8]	; (801cde4 <BSP_AUDIO_OUT_Resume+0xc>)
 801cddc:	f7e8 fe14 	bl	8005a08 <HAL_SAI_DMAResume>
}
 801cde0:	2000      	movs	r0, #0
 801cde2:	bd08      	pop	{r3, pc}
 801cde4:	20018934 	.word	0x20018934

0801cde8 <BSP_AUDIO_OUT_Stop>:
{
 801cde8:	b538      	push	{r3, r4, r5, lr}
 801cdea:	4605      	mov	r5, r0
  HAL_SAI_DMAStop(&hsai_BlockA2);
 801cdec:	480a      	ldr	r0, [pc, #40]	; (801ce18 <BSP_AUDIO_OUT_Stop+0x30>)
 801cdee:	f7e8 fe23 	bl	8005a38 <HAL_SAI_DMAStop>
  if(audio_drv->Stop(AUDIO_I2C_ADDRESS, Option) != 0)
 801cdf2:	4b0a      	ldr	r3, [pc, #40]	; (801ce1c <BSP_AUDIO_OUT_Stop+0x34>)
 801cdf4:	2034      	movs	r0, #52	; 0x34
 801cdf6:	4629      	mov	r1, r5
 801cdf8:	681b      	ldr	r3, [r3, #0]
 801cdfa:	699b      	ldr	r3, [r3, #24]
 801cdfc:	4798      	blx	r3
 801cdfe:	b918      	cbnz	r0, 801ce08 <BSP_AUDIO_OUT_Stop+0x20>
    if(Option == CODEC_PDWN_HW)
 801ce00:	2d01      	cmp	r5, #1
 801ce02:	4604      	mov	r4, r0
 801ce04:	d002      	beq.n	801ce0c <BSP_AUDIO_OUT_Stop+0x24>
}
 801ce06:	bd38      	pop	{r3, r4, r5, pc}
    return AUDIO_ERROR;
 801ce08:	2001      	movs	r0, #1
}
 801ce0a:	bd38      	pop	{r3, r4, r5, pc}
      HAL_Delay(1);
 801ce0c:	4628      	mov	r0, r5
 801ce0e:	f7e4 f935 	bl	800107c <HAL_Delay>
    return AUDIO_OK;
 801ce12:	4620      	mov	r0, r4
}
 801ce14:	bd38      	pop	{r3, r4, r5, pc}
 801ce16:	bf00      	nop
 801ce18:	20018934 	.word	0x20018934
 801ce1c:	20018aa4 	.word	0x20018aa4

0801ce20 <BSP_AUDIO_OUT_SetVolume>:
{
 801ce20:	b508      	push	{r3, lr}
  if(audio_drv->SetVolume(AUDIO_I2C_ADDRESS, Volume) != 0)
 801ce22:	4b05      	ldr	r3, [pc, #20]	; (801ce38 <BSP_AUDIO_OUT_SetVolume+0x18>)
{
 801ce24:	4601      	mov	r1, r0
  if(audio_drv->SetVolume(AUDIO_I2C_ADDRESS, Volume) != 0)
 801ce26:	2034      	movs	r0, #52	; 0x34
 801ce28:	681b      	ldr	r3, [r3, #0]
 801ce2a:	6a1b      	ldr	r3, [r3, #32]
 801ce2c:	4798      	blx	r3
}
 801ce2e:	3800      	subs	r0, #0
 801ce30:	bf18      	it	ne
 801ce32:	2001      	movne	r0, #1
 801ce34:	bd08      	pop	{r3, pc}
 801ce36:	bf00      	nop
 801ce38:	20018aa4 	.word	0x20018aa4

0801ce3c <HAL_SAI_TxCpltCallback>:
{
 801ce3c:	b570      	push	{r4, r5, r6, lr}
	if(BufferCtl.filetype == 0) {
 801ce3e:	4c19      	ldr	r4, [pc, #100]	; (801cea4 <HAL_SAI_TxCpltCallback+0x68>)
 801ce40:	7a23      	ldrb	r3, [r4, #8]
 801ce42:	b9a3      	cbnz	r3, 801ce6e <HAL_SAI_TxCpltCallback+0x32>
 801ce44:	f5a4 6400 	sub.w	r4, r4, #2048	; 0x800
		while(f_read(&MyFile, &BufferCtl.buff[AUDIO_OUT_BUFFER_SIZE / 2],
 801ce48:	4e17      	ldr	r6, [pc, #92]	; (801cea8 <HAL_SAI_TxCpltCallback+0x6c>)
 801ce4a:	4d18      	ldr	r5, [pc, #96]	; (801ceac <HAL_SAI_TxCpltCallback+0x70>)
 801ce4c:	4633      	mov	r3, r6
 801ce4e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801ce52:	4621      	mov	r1, r4
 801ce54:	4628      	mov	r0, r5
 801ce56:	f7ef f94d 	bl	800c0f4 <f_read>
 801ce5a:	2800      	cmp	r0, #0
 801ce5c:	d1f6      	bne.n	801ce4c <HAL_SAI_TxCpltCallback+0x10>
		BufferCtl.fptr += AUDIO_OUT_BUFFER_SIZE / 2;
 801ce5e:	f8d4 2804 	ldr.w	r2, [r4, #2052]	; 0x804
	if(BufferCtl.filetype == 1) {
 801ce62:	f894 3808 	ldrb.w	r3, [r4, #2056]	; 0x808
		BufferCtl.fptr += AUDIO_OUT_BUFFER_SIZE / 2;
 801ce66:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 801ce6a:	f8c4 2804 	str.w	r2, [r4, #2052]	; 0x804
	if(BufferCtl.filetype == 1) {
 801ce6e:	2b01      	cmp	r3, #1
 801ce70:	d105      	bne.n	801ce7e <HAL_SAI_TxCpltCallback+0x42>
        unDmaBufMode = 2;
 801ce72:	490f      	ldr	r1, [pc, #60]	; (801ceb0 <HAL_SAI_TxCpltCallback+0x74>)
 801ce74:	2002      	movs	r0, #2
        g_pMp3DmaBufferPtr = g_pMp3DmaBuffer + (MP3_DMA_BUFFER_SIZE / 2);
 801ce76:	4b0f      	ldr	r3, [pc, #60]	; (801ceb4 <HAL_SAI_TxCpltCallback+0x78>)
 801ce78:	4a0f      	ldr	r2, [pc, #60]	; (801ceb8 <HAL_SAI_TxCpltCallback+0x7c>)
        unDmaBufMode = 2;
 801ce7a:	6008      	str	r0, [r1, #0]
        g_pMp3DmaBufferPtr = g_pMp3DmaBuffer + (MP3_DMA_BUFFER_SIZE / 2);
 801ce7c:	601a      	str	r2, [r3, #0]
	GetTrackTime();
 801ce7e:	f002 f8f5 	bl	801f06c <GetTrackTime>
	if(f_eof(&MyFile) == 1) {
 801ce82:	4b0a      	ldr	r3, [pc, #40]	; (801ceac <HAL_SAI_TxCpltCallback+0x70>)
 801ce84:	e9d3 020e 	ldrd	r0, r2, [r3, #56]	; 0x38
 801ce88:	e9d3 1304 	ldrd	r1, r3, [r3, #16]
 801ce8c:	429a      	cmp	r2, r3
 801ce8e:	bf08      	it	eq
 801ce90:	4288      	cmpeq	r0, r1
 801ce92:	d000      	beq.n	801ce96 <HAL_SAI_TxCpltCallback+0x5a>
}
 801ce94:	bd70      	pop	{r4, r5, r6, pc}
		bOutOfData = 1;
 801ce96:	4909      	ldr	r1, [pc, #36]	; (801cebc <HAL_SAI_TxCpltCallback+0x80>)
 801ce98:	2001      	movs	r0, #1
		unDmaBufMode = 3;
 801ce9a:	4b05      	ldr	r3, [pc, #20]	; (801ceb0 <HAL_SAI_TxCpltCallback+0x74>)
 801ce9c:	2203      	movs	r2, #3
		bOutOfData = 1;
 801ce9e:	6008      	str	r0, [r1, #0]
		unDmaBufMode = 3;
 801cea0:	601a      	str	r2, [r3, #0]
}
 801cea2:	bd70      	pop	{r4, r5, r6, pc}
 801cea4:	20001e30 	.word	0x20001e30
 801cea8:	2000ec34 	.word	0x2000ec34
 801ceac:	20001e40 	.word	0x20001e40
 801ceb0:	2000fab4 	.word	0x2000fab4
 801ceb4:	200142b8 	.word	0x200142b8
 801ceb8:	20011eb8 	.word	0x20011eb8
 801cebc:	2000ec30 	.word	0x2000ec30

0801cec0 <HAL_SAI_TxHalfCpltCallback>:
{
 801cec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(BufferCtl.filetype == 0) {
 801cec2:	4f17      	ldr	r7, [pc, #92]	; (801cf20 <HAL_SAI_TxHalfCpltCallback+0x60>)
 801cec4:	7a3b      	ldrb	r3, [r7, #8]
 801cec6:	b98b      	cbnz	r3, 801ceec <HAL_SAI_TxHalfCpltCallback+0x2c>
		while(f_read(&MyFile, &BufferCtl.buff[0],
 801cec8:	4e16      	ldr	r6, [pc, #88]	; (801cf24 <HAL_SAI_TxHalfCpltCallback+0x64>)
 801ceca:	f5a7 5580 	sub.w	r5, r7, #4096	; 0x1000
 801cece:	4c16      	ldr	r4, [pc, #88]	; (801cf28 <HAL_SAI_TxHalfCpltCallback+0x68>)
 801ced0:	4633      	mov	r3, r6
 801ced2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801ced6:	4629      	mov	r1, r5
 801ced8:	4620      	mov	r0, r4
 801ceda:	f7ef f90b 	bl	800c0f4 <f_read>
 801cede:	2800      	cmp	r0, #0
 801cee0:	d1f6      	bne.n	801ced0 <HAL_SAI_TxHalfCpltCallback+0x10>
		BufferCtl.fptr += AUDIO_OUT_BUFFER_SIZE / 2;
 801cee2:	687a      	ldr	r2, [r7, #4]
	if(BufferCtl.filetype == 1) {
 801cee4:	7a3b      	ldrb	r3, [r7, #8]
		BufferCtl.fptr += AUDIO_OUT_BUFFER_SIZE / 2;
 801cee6:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 801ceea:	607a      	str	r2, [r7, #4]
	if(BufferCtl.filetype == 1) {
 801ceec:	2b01      	cmp	r3, #1
 801ceee:	d104      	bne.n	801cefa <HAL_SAI_TxHalfCpltCallback+0x3a>
        unDmaBufMode = 1;
 801cef0:	480e      	ldr	r0, [pc, #56]	; (801cf2c <HAL_SAI_TxHalfCpltCallback+0x6c>)
        g_pMp3DmaBufferPtr = g_pMp3DmaBuffer;
 801cef2:	4a0f      	ldr	r2, [pc, #60]	; (801cf30 <HAL_SAI_TxHalfCpltCallback+0x70>)
 801cef4:	490f      	ldr	r1, [pc, #60]	; (801cf34 <HAL_SAI_TxHalfCpltCallback+0x74>)
        unDmaBufMode = 1;
 801cef6:	6003      	str	r3, [r0, #0]
        g_pMp3DmaBufferPtr = g_pMp3DmaBuffer;
 801cef8:	6011      	str	r1, [r2, #0]
	GetTrackTime();
 801cefa:	f002 f8b7 	bl	801f06c <GetTrackTime>
	if(f_eof(&MyFile) == 1) {
 801cefe:	4b0a      	ldr	r3, [pc, #40]	; (801cf28 <HAL_SAI_TxHalfCpltCallback+0x68>)
 801cf00:	e9d3 020e 	ldrd	r0, r2, [r3, #56]	; 0x38
 801cf04:	e9d3 1304 	ldrd	r1, r3, [r3, #16]
 801cf08:	429a      	cmp	r2, r3
 801cf0a:	bf08      	it	eq
 801cf0c:	4288      	cmpeq	r0, r1
 801cf0e:	d000      	beq.n	801cf12 <HAL_SAI_TxHalfCpltCallback+0x52>
}
 801cf10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		bOutOfData = 1;
 801cf12:	4909      	ldr	r1, [pc, #36]	; (801cf38 <HAL_SAI_TxHalfCpltCallback+0x78>)
 801cf14:	2001      	movs	r0, #1
		unDmaBufMode = 3;
 801cf16:	4b05      	ldr	r3, [pc, #20]	; (801cf2c <HAL_SAI_TxHalfCpltCallback+0x6c>)
 801cf18:	2203      	movs	r2, #3
		bOutOfData = 1;
 801cf1a:	6008      	str	r0, [r1, #0]
		unDmaBufMode = 3;
 801cf1c:	601a      	str	r2, [r3, #0]
}
 801cf1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801cf20:	20001e30 	.word	0x20001e30
 801cf24:	2000ec34 	.word	0x2000ec34
 801cf28:	20001e40 	.word	0x20001e40
 801cf2c:	2000fab4 	.word	0x2000fab4
 801cf30:	200142b8 	.word	0x200142b8
 801cf34:	2000fab8 	.word	0x2000fab8
 801cf38:	2000ec30 	.word	0x2000ec30

0801cf3c <BSP_AUDIO_OUT_Error_CallBack>:
 801cf3c:	4770      	bx	lr
 801cf3e:	bf00      	nop

0801cf40 <HAL_SAI_ErrorCallback>:
{
 801cf40:	b510      	push	{r4, lr}
  audio_out_state = HAL_SAI_GetState(&hsai_BlockA2);
 801cf42:	4807      	ldr	r0, [pc, #28]	; (801cf60 <HAL_SAI_ErrorCallback+0x20>)
 801cf44:	f7e8 feb8 	bl	8005cb8 <HAL_SAI_GetState>
 801cf48:	4604      	mov	r4, r0
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
 801cf4a:	4806      	ldr	r0, [pc, #24]	; (801cf64 <HAL_SAI_ErrorCallback+0x24>)
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
 801cf4c:	f004 04ef 	and.w	r4, r4, #239	; 0xef
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
 801cf50:	f7e8 feb2 	bl	8005cb8 <HAL_SAI_GetState>
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
 801cf54:	2c02      	cmp	r4, #2
 801cf56:	d000      	beq.n	801cf5a <HAL_SAI_ErrorCallback+0x1a>
}
 801cf58:	bd10      	pop	{r4, pc}
    BSP_AUDIO_OUT_Error_CallBack();
 801cf5a:	f7ff ffef 	bl	801cf3c <BSP_AUDIO_OUT_Error_CallBack>
}
 801cf5e:	bd10      	pop	{r4, pc}
 801cf60:	20018934 	.word	0x20018934
 801cf64:	20018aa8 	.word	0x20018aa8

0801cf68 <BSP_AUDIO_OUT_ClockConfig>:
{ 
 801cf68:	b530      	push	{r4, r5, lr}
 801cf6a:	ed2d 8b02 	vpush	{d8}
 801cf6e:	b0a3      	sub	sp, #140	; 0x8c
 801cf70:	ee08 1a10 	vmov	s16, r1
  for(I2SDivQ = 32; I2SDivQ > 1; I2SDivQ--) {
 801cf74:	2420      	movs	r4, #32
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801cf76:	4d17      	ldr	r5, [pc, #92]	; (801cfd4 <BSP_AUDIO_OUT_ClockConfig+0x6c>)
  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
 801cf78:	a801      	add	r0, sp, #4
 801cf7a:	f7e8 f985 	bl	8005288 <HAL_RCCEx_GetPeriphCLKConfig>
  uint32_t new_frequency_Hz = (203000000 / 9 * (float)AudioFreq /
 801cf7e:	eef8 7a48 	vcvt.f32.u32	s15, s16
 801cf82:	ed9f 7a15 	vldr	s14, [pc, #84]	; 801cfd8 <BSP_AUDIO_OUT_ClockConfig+0x70>
 801cf86:	ee67 7a87 	vmul.f32	s15, s15, s14
 801cf8a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801cf8e:	ee17 0a90 	vmov	r0, s15
{ 
 801cf92:	4b12      	ldr	r3, [pc, #72]	; (801cfdc <BSP_AUDIO_OUT_ClockConfig+0x74>)
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801cf94:	2232      	movs	r2, #50	; 0x32
 801cf96:	e003      	b.n	801cfa0 <BSP_AUDIO_OUT_ClockConfig+0x38>
 801cf98:	3201      	adds	r2, #1
 801cf9a:	f5b2 7fd8 	cmp.w	r2, #432	; 0x1b0
 801cf9e:	d015      	beq.n	801cfcc <BSP_AUDIO_OUT_ClockConfig+0x64>
		  set_frequency_Hz = I2SN * 1000000 / I2SDivQ;
 801cfa0:	fbb3 f1f4 	udiv	r1, r3, r4
		  if(set_frequency_Hz >= new_frequency_Hz) break;
 801cfa4:	4288      	cmp	r0, r1
	  for(I2SN = 50; I2SN < 432; I2SN++) {
 801cfa6:	442b      	add	r3, r5
		  if(set_frequency_Hz >= new_frequency_Hz) break;
 801cfa8:	d8f6      	bhi.n	801cf98 <BSP_AUDIO_OUT_ClockConfig+0x30>
  rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801cfaa:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
 801cfae:	2302      	movs	r3, #2
  rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801cfb0:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
  HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 801cfb4:	a801      	add	r0, sp, #4
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = I2SN;
 801cfb6:	9202      	str	r2, [sp, #8]
  rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 801cfb8:	9501      	str	r5, [sp, #4]
  rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 801cfba:	9111      	str	r1, [sp, #68]	; 0x44
  rcc_ex_clk_init_struct.PLLI2SDivQ = I2SDivQ;
 801cfbc:	940a      	str	r4, [sp, #40]	; 0x28
  rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
 801cfbe:	9304      	str	r3, [sp, #16]
  HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 801cfc0:	f7e7 fcca 	bl	8004958 <HAL_RCCEx_PeriphCLKConfig>
}
 801cfc4:	b023      	add	sp, #140	; 0x8c
 801cfc6:	ecbd 8b02 	vpop	{d8}
 801cfca:	bd30      	pop	{r4, r5, pc}
  for(I2SDivQ = 32; I2SDivQ > 1; I2SDivQ--) {
 801cfcc:	3c01      	subs	r4, #1
 801cfce:	2c01      	cmp	r4, #1
 801cfd0:	d1df      	bne.n	801cf92 <BSP_AUDIO_OUT_ClockConfig+0x2a>
 801cfd2:	e7ea      	b.n	801cfaa <BSP_AUDIO_OUT_ClockConfig+0x42>
 801cfd4:	000f4240 	.word	0x000f4240
 801cfd8:	447fbb5f 	.word	0x447fbb5f
 801cfdc:	02faf080 	.word	0x02faf080

0801cfe0 <AUDIO_IO_Init>:
  * @brief  Initializes Audio low level.
  * @retval None
  */
void AUDIO_IO_Init(void)
{
	HAL_I2C_Init(&hi2c3);
 801cfe0:	4801      	ldr	r0, [pc, #4]	; (801cfe8 <AUDIO_IO_Init+0x8>)
 801cfe2:	f7e6 b86b 	b.w	80030bc <HAL_I2C_Init>
 801cfe6:	bf00      	nop
 801cfe8:	20000d38 	.word	0x20000d38

0801cfec <AUDIO_IO_DeInit>:
  * @brief  Deinitializes Audio low level.
  * @retval None
  */
void AUDIO_IO_DeInit(void)
{
}
 801cfec:	4770      	bx	lr
 801cfee:	bf00      	nop

0801cff0 <AUDIO_IO_Write>:
  * @param  Reg: Reg address
  * @param  Value: Data to be written
  * @retval None
  */
void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
 801cff0:	b510      	push	{r4, lr}
 801cff2:	b086      	sub	sp, #24
 801cff4:	4694      	mov	ip, r2

  Value = ((uint16_t)(tmp >> 8) & 0x00FF);

  Value |= ((uint16_t)(tmp << 8)& 0xFF00);

  HAL_I2C_Mem_Write(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2, 1000);
 801cff6:	2302      	movs	r3, #2
{
 801cff8:	460a      	mov	r2, r1
  HAL_I2C_Mem_Write(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2, 1000);
 801cffa:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 801cffe:	4601      	mov	r1, r0
 801d000:	f10d 0016 	add.w	r0, sp, #22
  Value |= ((uint16_t)(tmp << 8)& 0xFF00);
 801d004:	fa9c fc9c 	rev16.w	ip, ip
  HAL_I2C_Mem_Write(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2, 1000);
 801d008:	9402      	str	r4, [sp, #8]
  Value |= ((uint16_t)(tmp << 8)& 0xFF00);
 801d00a:	f8ad c016 	strh.w	ip, [sp, #22]
  HAL_I2C_Mem_Write(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2, 1000);
 801d00e:	e9cd 0300 	strd	r0, r3, [sp]
 801d012:	4802      	ldr	r0, [pc, #8]	; (801d01c <AUDIO_IO_Write+0x2c>)
 801d014:	f7e6 f924 	bl	8003260 <HAL_I2C_Mem_Write>
}
 801d018:	b006      	add	sp, #24
 801d01a:	bd10      	pop	{r4, pc}
 801d01c:	20000d38 	.word	0x20000d38

0801d020 <AUDIO_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address
  * @retval Data to be read
  */
uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
{
 801d020:	b530      	push	{r4, r5, lr}
 801d022:	b087      	sub	sp, #28
 801d024:	460a      	mov	r2, r1
  uint16_t read_value = 0, tmp = 0;

  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2, 1000);
 801d026:	2302      	movs	r3, #2
 801d028:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 801d02c:	f10d 0416 	add.w	r4, sp, #22
  uint16_t read_value = 0, tmp = 0;
 801d030:	2100      	movs	r1, #0
  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2, 1000);
 801d032:	9502      	str	r5, [sp, #8]
  uint16_t read_value = 0, tmp = 0;
 801d034:	f8ad 1016 	strh.w	r1, [sp, #22]
  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2, 1000);
 801d038:	4601      	mov	r1, r0
 801d03a:	4805      	ldr	r0, [pc, #20]	; (801d050 <AUDIO_IO_Read+0x30>)
 801d03c:	e9cd 4300 	strd	r4, r3, [sp]
 801d040:	f7e6 fa7c 	bl	800353c <HAL_I2C_Mem_Read>

  tmp = ((uint16_t)(read_value >> 8) & 0x00FF);

  tmp |= ((uint16_t)(read_value << 8)& 0xFF00);
 801d044:	f8bd 0016 	ldrh.w	r0, [sp, #22]
 801d048:	ba40      	rev16	r0, r0

  read_value = tmp;

  return read_value;
}
 801d04a:	b280      	uxth	r0, r0
 801d04c:	b007      	add	sp, #28
 801d04e:	bd30      	pop	{r4, r5, pc}
 801d050:	20000d38 	.word	0x20000d38

0801d054 <AUDIO_IO_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void AUDIO_IO_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 801d054:	f7e4 b812 	b.w	800107c <HAL_Delay>

0801d058 <Mp3FillReadBuffer>:
}

UINT Mp3FillReadBuffer(BYTE* pInData, UINT unInDataLeft, FIL* pInFile)
{
 801d058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d05c:	460c      	mov	r4, r1
	// move last, small chunk from end of buffer to start, then fill with new data
	memmove(BufferCtl.buff, pInData, unInDataLeft);
 801d05e:	4f12      	ldr	r7, [pc, #72]	; (801d0a8 <Mp3FillReadBuffer+0x50>)
{
 801d060:	b082      	sub	sp, #8
 801d062:	4616      	mov	r6, r2

	UINT unSpaceLeft = MP3_INBUF_SIZE - unInDataLeft;
 801d064:	f5c4 5880 	rsb	r8, r4, #4096	; 0x1000
	memmove(BufferCtl.buff, pInData, unInDataLeft);
 801d068:	4601      	mov	r1, r0
 801d06a:	4622      	mov	r2, r4
 801d06c:	4638      	mov	r0, r7
	UINT unRead = 0;
 801d06e:	2500      	movs	r5, #0
	memmove(BufferCtl.buff, pInData, unInDataLeft);
 801d070:	f003 f81a 	bl	80200a8 <memmove>
	FRESULT fr = f_read(pInFile, BufferCtl.buff + unInDataLeft, unSpaceLeft, &unRead);
 801d074:	4630      	mov	r0, r6
 801d076:	ab01      	add	r3, sp, #4
 801d078:	4642      	mov	r2, r8
 801d07a:	1939      	adds	r1, r7, r4
	UINT unRead = 0;
 801d07c:	9501      	str	r5, [sp, #4]
	FRESULT fr = f_read(pInFile, BufferCtl.buff + unInDataLeft, unSpaceLeft, &unRead);
 801d07e:	f7ef f839 	bl	800c0f4 <f_read>
	if(fr != FR_OK)
 801d082:	b900      	cbnz	r0, 801d086 <Mp3FillReadBuffer+0x2e>
	{
		unRead = 0;
	}
	if(unRead < unSpaceLeft)
 801d084:	9d01      	ldr	r5, [sp, #4]
 801d086:	45a8      	cmp	r8, r5
 801d088:	d803      	bhi.n	801d092 <Mp3FillReadBuffer+0x3a>
	{
	    // zero-pad to avoid finding false sync word after last frame (from old data in readBuf)
	    memset(BufferCtl.buff + unInDataLeft + unRead, 0, unSpaceLeft - unRead);
	}
	return unRead;
}
 801d08a:	4628      	mov	r0, r5
 801d08c:	b002      	add	sp, #8
 801d08e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    memset(BufferCtl.buff + unInDataLeft + unRead, 0, unSpaceLeft - unRead);
 801d092:	1960      	adds	r0, r4, r5
 801d094:	eba8 0205 	sub.w	r2, r8, r5
 801d098:	2100      	movs	r1, #0
 801d09a:	4438      	add	r0, r7
 801d09c:	f003 f81e 	bl	80200dc <memset>
}
 801d0a0:	4628      	mov	r0, r5
 801d0a2:	b002      	add	sp, #8
 801d0a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d0a8:	20000e30 	.word	0x20000e30

0801d0ac <BSP_TS_Init>:
  * @param  ts_SizeX: Maximum X size of the TS area on LCD
  * @param  ts_SizeY: Maximum Y size of the TS area on LCD
  * @retval TS_OK if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
{
 801d0ac:	b510      	push	{r4, lr}
  uint8_t status = TS_OK;
  tsXBoundary = ts_SizeX;
 801d0ae:	4b0d      	ldr	r3, [pc, #52]	; (801d0e4 <BSP_TS_Init+0x38>)
  tsYBoundary = ts_SizeY;
  
  /* Read ID and verify if the touch screen driver is ready */
  ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 801d0b0:	4c0d      	ldr	r4, [pc, #52]	; (801d0e8 <BSP_TS_Init+0x3c>)
  tsYBoundary = ts_SizeY;
 801d0b2:	4a0e      	ldr	r2, [pc, #56]	; (801d0ec <BSP_TS_Init+0x40>)
  tsXBoundary = ts_SizeX;
 801d0b4:	8018      	strh	r0, [r3, #0]
  ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 801d0b6:	2070      	movs	r0, #112	; 0x70
 801d0b8:	6823      	ldr	r3, [r4, #0]
  tsYBoundary = ts_SizeY;
 801d0ba:	8011      	strh	r1, [r2, #0]
  ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 801d0bc:	4798      	blx	r3
  if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
 801d0be:	6863      	ldr	r3, [r4, #4]
 801d0c0:	2070      	movs	r0, #112	; 0x70
 801d0c2:	4798      	blx	r3
 801d0c4:	2851      	cmp	r0, #81	; 0x51
 801d0c6:	d001      	beq.n	801d0cc <BSP_TS_Init+0x20>
    /* Initialize the TS driver */
    tsDriver->Start(I2cAddress);
  }
  else
  {
    status = TS_DEVICE_NOT_FOUND;
 801d0c8:	2003      	movs	r0, #3
  }

  return status;
}
 801d0ca:	bd10      	pop	{r4, pc}
    I2cAddress = TS_I2C_ADDRESS;
 801d0cc:	2070      	movs	r0, #112	; 0x70
 801d0ce:	4908      	ldr	r1, [pc, #32]	; (801d0f0 <BSP_TS_Init+0x44>)
    tsDriver = &ft5336_ts_drv;
 801d0d0:	4b08      	ldr	r3, [pc, #32]	; (801d0f4 <BSP_TS_Init+0x48>)
    tsOrientation = TS_SWAP_XY;
 801d0d2:	4a09      	ldr	r2, [pc, #36]	; (801d0f8 <BSP_TS_Init+0x4c>)
    I2cAddress = TS_I2C_ADDRESS;
 801d0d4:	7008      	strb	r0, [r1, #0]
    tsOrientation = TS_SWAP_XY;
 801d0d6:	2108      	movs	r1, #8
    tsDriver = &ft5336_ts_drv;
 801d0d8:	601c      	str	r4, [r3, #0]
    tsDriver->Start(I2cAddress);
 801d0da:	68e3      	ldr	r3, [r4, #12]
    tsOrientation = TS_SWAP_XY;
 801d0dc:	7011      	strb	r1, [r2, #0]
    tsDriver->Start(I2cAddress);
 801d0de:	4798      	blx	r3
  uint8_t status = TS_OK;
 801d0e0:	2000      	movs	r0, #0
}
 801d0e2:	bd10      	pop	{r4, pc}
 801d0e4:	20018b5e 	.word	0x20018b5e
 801d0e8:	2000002c 	.word	0x2000002c
 801d0ec:	20018b60 	.word	0x20018b60
 801d0f0:	20018b2c 	.word	0x20018b2c
 801d0f4:	20018b58 	.word	0x20018b58
 801d0f8:	20018b5c 	.word	0x20018b5c
 801d0fc:	00000000 	.word	0x00000000

0801d100 <BSP_TS_ITConfig>:
/**
  * @brief  Configures and enables the touch screen interrupts.
  * @retval TS_OK if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_ITConfig(void)
{
 801d100:	b500      	push	{lr}
	GPIO_InitTypeDef gpio_init_structure;

	/* Configure Interrupt mode for SD detection pin */
	gpio_init_structure.Pin = TS_INT_PIN;
 801d102:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 801d140 <BSP_TS_ITConfig+0x40>
{
 801d106:	b087      	sub	sp, #28
	gpio_init_structure.Pin = TS_INT_PIN;
 801d108:	2302      	movs	r3, #2
 801d10a:	2200      	movs	r2, #0
	gpio_init_structure.Pull = GPIO_NOPULL;
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
	gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
	HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
 801d10c:	480e      	ldr	r0, [pc, #56]	; (801d148 <BSP_TS_ITConfig+0x48>)
 801d10e:	4669      	mov	r1, sp
	gpio_init_structure.Pin = TS_INT_PIN;
 801d110:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801d114:	ed8d 7b00 	vstr	d7, [sp]
	HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
 801d118:	f7e4 fe68 	bl	8001dec <HAL_GPIO_Init>

	/* Enable and set Touch screen EXTI Interrupt to the lowest priority */
	HAL_NVIC_SetPriority((IRQn_Type)(TS_INT_EXTI_IRQn), 0x0F, 0x00);
 801d11c:	210f      	movs	r1, #15
 801d11e:	2200      	movs	r2, #0
 801d120:	2028      	movs	r0, #40	; 0x28
 801d122:	f7e3 ffdb 	bl	80010dc <HAL_NVIC_SetPriority>
	/* Enable the TS ITs */
  tsDriver->EnableIT(I2cAddress);
 801d126:	4b09      	ldr	r3, [pc, #36]	; (801d14c <BSP_TS_ITConfig+0x4c>)
 801d128:	4a09      	ldr	r2, [pc, #36]	; (801d150 <BSP_TS_ITConfig+0x50>)
 801d12a:	681b      	ldr	r3, [r3, #0]
 801d12c:	7810      	ldrb	r0, [r2, #0]
 801d12e:	699b      	ldr	r3, [r3, #24]
 801d130:	4798      	blx	r3

  return TS_OK;  
}
 801d132:	2000      	movs	r0, #0
 801d134:	b007      	add	sp, #28
 801d136:	f85d fb04 	ldr.w	pc, [sp], #4
 801d13a:	bf00      	nop
 801d13c:	f3af 8000 	nop.w
 801d140:	00002000 	.word	0x00002000
 801d144:	10110000 	.word	0x10110000
 801d148:	40022000 	.word	0x40022000
 801d14c:	20018b58 	.word	0x20018b58
 801d150:	20018b2c 	.word	0x20018b2c

0801d154 <BSP_TS_GetState>:
  uint32_t area = 0;
  uint32_t event = 0;
#endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */

  /* Check and update the number of touches active detected */
  TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 801d154:	4b7a      	ldr	r3, [pc, #488]	; (801d340 <BSP_TS_GetState+0x1ec>)
 801d156:	4a7b      	ldr	r2, [pc, #492]	; (801d344 <BSP_TS_GetState+0x1f0>)
 801d158:	681b      	ldr	r3, [r3, #0]
{
 801d15a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t weight = 0;
 801d15e:	2400      	movs	r4, #0
{
 801d160:	b095      	sub	sp, #84	; 0x54
 801d162:	4605      	mov	r5, r0
  TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 801d164:	691b      	ldr	r3, [r3, #16]
{
 801d166:	9003      	str	r0, [sp, #12]
  uint32_t event = 0;
 801d168:	9406      	str	r4, [sp, #24]
  TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 801d16a:	7810      	ldrb	r0, [r2, #0]
  uint32_t area = 0;
 801d16c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 801d170:	4798      	blx	r3
 801d172:	7028      	strb	r0, [r5, #0]
  
  if(TS_State->touchDetected)
 801d174:	2800      	cmp	r0, #0
 801d176:	f000 80a4 	beq.w	801d2c2 <BSP_TS_GetState+0x16e>
 801d17a:	462b      	mov	r3, r5
 801d17c:	ae0e      	add	r6, sp, #56	; 0x38
 801d17e:	ad11      	add	r5, sp, #68	; 0x44
 801d180:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 801d358 <BSP_TS_GetState+0x204>
 801d184:	f103 0916 	add.w	r9, r3, #22
 801d188:	f103 0b02 	add.w	fp, r3, #2
 801d18c:	f10d 082c 	add.w	r8, sp, #44	; 0x2c
 801d190:	af08      	add	r7, sp, #32
  {
    for(index=0; index < TS_State->touchDetected; index++)
    {
      /* Get each touch coordinates */
      tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
 801d192:	4b6b      	ldr	r3, [pc, #428]	; (801d340 <BSP_TS_GetState+0x1ec>)
 801d194:	462a      	mov	r2, r5
 801d196:	486b      	ldr	r0, [pc, #428]	; (801d344 <BSP_TS_GetState+0x1f0>)
 801d198:	4631      	mov	r1, r6
 801d19a:	681b      	ldr	r3, [r3, #0]
 801d19c:	7800      	ldrb	r0, [r0, #0]
 801d19e:	695b      	ldr	r3, [r3, #20]
 801d1a0:	4798      	blx	r3

      if(tsOrientation == TS_SWAP_NONE)
 801d1a2:	4b69      	ldr	r3, [pc, #420]	; (801d348 <BSP_TS_GetState+0x1f4>)
 801d1a4:	781b      	ldrb	r3, [r3, #0]
 801d1a6:	2b01      	cmp	r3, #1
 801d1a8:	f000 8094 	beq.w	801d2d4 <BSP_TS_GetState+0x180>
      {
        x[index] = brute_x[index];
        y[index] = brute_y[index];
      }

      if(tsOrientation & TS_SWAP_X)
 801d1ac:	0799      	lsls	r1, r3, #30
 801d1ae:	d503      	bpl.n	801d1b8 <BSP_TS_GetState+0x64>
      {
        x[index] = 4096 - brute_x[index];
 801d1b0:	8832      	ldrh	r2, [r6, #0]
 801d1b2:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
 801d1b6:	803a      	strh	r2, [r7, #0]
      }

      if(tsOrientation & TS_SWAP_Y)
 801d1b8:	075a      	lsls	r2, r3, #29
 801d1ba:	d504      	bpl.n	801d1c6 <BSP_TS_GetState+0x72>
      {
        y[index] = 4096 - brute_y[index];
 801d1bc:	882a      	ldrh	r2, [r5, #0]
 801d1be:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
 801d1c2:	f8a8 2000 	strh.w	r2, [r8]
      }

      if(tsOrientation & TS_SWAP_XY)
 801d1c6:	071b      	lsls	r3, r3, #28
 801d1c8:	d47e      	bmi.n	801d2c8 <BSP_TS_GetState+0x174>
      {
        y[index] = brute_x[index];
        x[index] = brute_y[index];
      }

      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 801d1ca:	883b      	ldrh	r3, [r7, #0]
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 801d1cc:	f8b8 2000 	ldrh.w	r2, [r8]
 801d1d0:	485e      	ldr	r0, [pc, #376]	; (801d34c <BSP_TS_GetState+0x1f8>)
      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 801d1d2:	f8da e000 	ldr.w	lr, [sl]
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 801d1d6:	f850 c024 	ldr.w	ip, [r0, r4, lsl #2]
      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 801d1da:	4573      	cmp	r3, lr
 801d1dc:	bf8c      	ite	hi
 801d1de:	eba3 010e 	subhi.w	r1, r3, lr
 801d1e2:	ebae 0103 	subls.w	r1, lr, r3
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 801d1e6:	4562      	cmp	r2, ip
      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 801d1e8:	b289      	uxth	r1, r1
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 801d1ea:	bf8c      	ite	hi
 801d1ec:	eba2 000c 	subhi.w	r0, r2, ip
 801d1f0:	ebac 0002 	subls.w	r0, ip, r2
 801d1f4:	b280      	uxth	r0, r0

      if ((x_diff + y_diff) > 5)
 801d1f6:	4401      	add	r1, r0
 801d1f8:	2905      	cmp	r1, #5
 801d1fa:	dd06      	ble.n	801d20a <BSP_TS_GetState+0xb6>
      {
        _x[index] = x[index];
        _y[index] = y[index];
 801d1fc:	4953      	ldr	r1, [pc, #332]	; (801d34c <BSP_TS_GetState+0x1f8>)
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 801d1fe:	4694      	mov	ip, r2
      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 801d200:	469e      	mov	lr, r3
        _x[index] = x[index];
 801d202:	f8ca 3000 	str.w	r3, [sl]
        _y[index] = y[index];
 801d206:	f841 2024 	str.w	r2, [r1, r4, lsl #2]
      }

      if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
 801d20a:	494e      	ldr	r1, [pc, #312]	; (801d344 <BSP_TS_GetState+0x1f0>)
 801d20c:	7808      	ldrb	r0, [r1, #0]
 801d20e:	2870      	cmp	r0, #112	; 0x70
 801d210:	d00b      	beq.n	801d22a <BSP_TS_GetState+0xd6>
        TS_State->touchY[index] = y[index];
      }
      else
      {
        /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
        TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 801d212:	4b4f      	ldr	r3, [pc, #316]	; (801d350 <BSP_TS_GetState+0x1fc>)
        TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 801d214:	4a4f      	ldr	r2, [pc, #316]	; (801d354 <BSP_TS_GetState+0x200>)
        TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 801d216:	881b      	ldrh	r3, [r3, #0]
        TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 801d218:	8812      	ldrh	r2, [r2, #0]
        TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 801d21a:	fb0e f303 	mul.w	r3, lr, r3
        TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 801d21e:	fb0c f202 	mul.w	r2, ip, r2
        TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 801d222:	f3c3 330f 	ubfx	r3, r3, #12, #16
        TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 801d226:	f3c2 320f 	ubfx	r2, r2, #12, #16
 801d22a:	f8ab 200a 	strh.w	r2, [fp, #10]
      }

#if (TS_MULTI_TOUCH_SUPPORTED == 1)

      /* Get touch info related to the current touch */
      ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
 801d22e:	4621      	mov	r1, r4
 801d230:	f82b 3b02 	strh.w	r3, [fp], #2
 801d234:	ab06      	add	r3, sp, #24
 801d236:	aa04      	add	r2, sp, #16
 801d238:	9300      	str	r3, [sp, #0]
 801d23a:	ab05      	add	r3, sp, #20
 801d23c:	f7fc feec 	bl	801a018 <ft5336_TS_GetTouchInfo>

      /* Update TS_State structure */
      TS_State->touchWeight[index] = weight;
 801d240:	9b04      	ldr	r3, [sp, #16]
 801d242:	f809 3b01 	strb.w	r3, [r9], #1
      TS_State->touchArea[index]   = area;
 801d246:	9b05      	ldr	r3, [sp, #20]
 801d248:	f889 3009 	strb.w	r3, [r9, #9]

      /* Remap touch event */
      switch(event)
 801d24c:	9b06      	ldr	r3, [sp, #24]
 801d24e:	2b03      	cmp	r3, #3
 801d250:	d806      	bhi.n	801d260 <BSP_TS_GetState+0x10c>
 801d252:	e8df f003 	tbb	[pc, r3]
 801d256:	4e02      	.short	0x4e02
 801d258:	454a      	.short	0x454a
      {
        case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
          TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
 801d25a:	2301      	movs	r3, #1
 801d25c:	f889 3004 	strb.w	r3, [r9, #4]
    for(index=0; index < TS_State->touchDetected; index++)
 801d260:	9b03      	ldr	r3, [sp, #12]
 801d262:	3401      	adds	r4, #1
 801d264:	3602      	adds	r6, #2
 801d266:	3502      	adds	r5, #2
 801d268:	781b      	ldrb	r3, [r3, #0]
 801d26a:	f10a 0a04 	add.w	sl, sl, #4
 801d26e:	f108 0802 	add.w	r8, r8, #2
 801d272:	3702      	adds	r7, #2
 801d274:	42a3      	cmp	r3, r4
 801d276:	d88c      	bhi.n	801d192 <BSP_TS_GetState+0x3e>
{
  uint32_t gestureId = 0;
  uint8_t  ts_status = TS_OK;

  /* Get gesture Id */
  ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 801d278:	4b32      	ldr	r3, [pc, #200]	; (801d344 <BSP_TS_GetState+0x1f0>)
  uint32_t gestureId = 0;
 801d27a:	2400      	movs	r4, #0
  ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 801d27c:	a907      	add	r1, sp, #28
 801d27e:	7818      	ldrb	r0, [r3, #0]
  uint32_t gestureId = 0;
 801d280:	9407      	str	r4, [sp, #28]
  ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 801d282:	f7fc feb7 	bl	8019ff4 <ft5336_TS_GetGestureID>

  /* Remap gesture Id to a TS_GestureIdTypeDef value */
  switch(gestureId)
 801d286:	9b07      	ldr	r3, [sp, #28]
 801d288:	2b1c      	cmp	r3, #28
 801d28a:	d812      	bhi.n	801d2b2 <BSP_TS_GetState+0x15e>
 801d28c:	2b1c      	cmp	r3, #28
 801d28e:	d834      	bhi.n	801d2fa <BSP_TS_GetState+0x1a6>
 801d290:	e8df f003 	tbb	[pc, r3]
 801d294:	33333350 	.word	0x33333350
 801d298:	33333333 	.word	0x33333333
 801d29c:	33333333 	.word	0x33333333
 801d2a0:	33333333 	.word	0x33333333
 801d2a4:	3333333c 	.word	0x3333333c
 801d2a8:	33333341 	.word	0x33333341
 801d2ac:	33333346 	.word	0x33333346
 801d2b0:	4b          	.byte	0x4b
 801d2b1:	00          	.byte	0x00
 801d2b2:	2b40      	cmp	r3, #64	; 0x40
 801d2b4:	d025      	beq.n	801d302 <BSP_TS_GetState+0x1ae>
 801d2b6:	2b49      	cmp	r3, #73	; 0x49
 801d2b8:	d11f      	bne.n	801d2fa <BSP_TS_GetState+0x1a6>
      break;
    case FT5336_GEST_ID_ZOOM_IN :
      TS_State->gestureId = GEST_ID_ZOOM_IN;
      break;
    case FT5336_GEST_ID_ZOOM_OUT :
      TS_State->gestureId = GEST_ID_ZOOM_OUT;
 801d2ba:	2306      	movs	r3, #6
 801d2bc:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d2be:	4620      	mov	r0, r4
      TS_State->gestureId = GEST_ID_ZOOM_OUT;
 801d2c0:	6293      	str	r3, [r2, #40]	; 0x28
}
 801d2c2:	b015      	add	sp, #84	; 0x54
 801d2c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        y[index] = brute_x[index];
 801d2c8:	8832      	ldrh	r2, [r6, #0]
        x[index] = brute_y[index];
 801d2ca:	882b      	ldrh	r3, [r5, #0]
        y[index] = brute_x[index];
 801d2cc:	f8a8 2000 	strh.w	r2, [r8]
        x[index] = brute_y[index];
 801d2d0:	803b      	strh	r3, [r7, #0]
 801d2d2:	e77d      	b.n	801d1d0 <BSP_TS_GetState+0x7c>
        x[index] = brute_x[index];
 801d2d4:	8832      	ldrh	r2, [r6, #0]
 801d2d6:	803a      	strh	r2, [r7, #0]
        y[index] = brute_y[index];
 801d2d8:	882a      	ldrh	r2, [r5, #0]
 801d2da:	f8a8 2000 	strh.w	r2, [r8]
      if(tsOrientation & TS_SWAP_Y)
 801d2de:	e772      	b.n	801d1c6 <BSP_TS_GetState+0x72>
          TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
 801d2e0:	f04f 0300 	mov.w	r3, #0
 801d2e4:	f889 3004 	strb.w	r3, [r9, #4]
          break;
 801d2e8:	e7ba      	b.n	801d260 <BSP_TS_GetState+0x10c>
          TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
 801d2ea:	2303      	movs	r3, #3
 801d2ec:	f889 3004 	strb.w	r3, [r9, #4]
          break;
 801d2f0:	e7b6      	b.n	801d260 <BSP_TS_GetState+0x10c>
          TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
 801d2f2:	2302      	movs	r3, #2
 801d2f4:	f889 3004 	strb.w	r3, [r9, #4]
          break;
 801d2f8:	e7b2      	b.n	801d260 <BSP_TS_GetState+0x10c>
  switch(gestureId)
 801d2fa:	2001      	movs	r0, #1
}
 801d2fc:	b015      	add	sp, #84	; 0x54
 801d2fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      TS_State->gestureId = GEST_ID_ZOOM_IN;
 801d302:	2305      	movs	r3, #5
 801d304:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d306:	4620      	mov	r0, r4
      TS_State->gestureId = GEST_ID_ZOOM_IN;
 801d308:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d30a:	e7da      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
      TS_State->gestureId = GEST_ID_MOVE_UP;
 801d30c:	2301      	movs	r3, #1
 801d30e:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d310:	2000      	movs	r0, #0
      TS_State->gestureId = GEST_ID_MOVE_UP;
 801d312:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d314:	e7d5      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
      TS_State->gestureId = GEST_ID_MOVE_RIGHT;
 801d316:	2302      	movs	r3, #2
 801d318:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d31a:	2000      	movs	r0, #0
      TS_State->gestureId = GEST_ID_MOVE_RIGHT;
 801d31c:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d31e:	e7d0      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
      TS_State->gestureId = GEST_ID_MOVE_DOWN;
 801d320:	2303      	movs	r3, #3
 801d322:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d324:	2000      	movs	r0, #0
      TS_State->gestureId = GEST_ID_MOVE_DOWN;
 801d326:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d328:	e7cb      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
      TS_State->gestureId = GEST_ID_MOVE_LEFT;
 801d32a:	2304      	movs	r3, #4
 801d32c:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d32e:	2000      	movs	r0, #0
      TS_State->gestureId = GEST_ID_MOVE_LEFT;
 801d330:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d332:	e7c6      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
      TS_State->gestureId = GEST_ID_NO_GESTURE;
 801d334:	2300      	movs	r3, #0
 801d336:	9a03      	ldr	r2, [sp, #12]
  uint8_t  ts_status = TS_OK;
 801d338:	4618      	mov	r0, r3
      TS_State->gestureId = GEST_ID_NO_GESTURE;
 801d33a:	6293      	str	r3, [r2, #40]	; 0x28
      break;
 801d33c:	e7c1      	b.n	801d2c2 <BSP_TS_GetState+0x16e>
 801d33e:	bf00      	nop
 801d340:	20018b58 	.word	0x20018b58
 801d344:	20018b2c 	.word	0x20018b2c
 801d348:	20018b5c 	.word	0x20018b5c
 801d34c:	20018b44 	.word	0x20018b44
 801d350:	20018b5e 	.word	0x20018b5e
 801d354:	20018b60 	.word	0x20018b60
 801d358:	20018b30 	.word	0x20018b30

0801d35c <BSP_TS_ITClear>:
  * @brief  Clears all touch screen interrupts.
  */
void BSP_TS_ITClear(void)
{
  /* Clear TS IT pending bits */
  tsDriver->ClearIT(I2cAddress); 
 801d35c:	4b02      	ldr	r3, [pc, #8]	; (801d368 <BSP_TS_ITClear+0xc>)
 801d35e:	4a03      	ldr	r2, [pc, #12]	; (801d36c <BSP_TS_ITClear+0x10>)
 801d360:	681b      	ldr	r3, [r3, #0]
 801d362:	7810      	ldrb	r0, [r2, #0]
 801d364:	69db      	ldr	r3, [r3, #28]
 801d366:	4718      	bx	r3
 801d368:	20018b58 	.word	0x20018b58
 801d36c:	20018b2c 	.word	0x20018b2c

0801d370 <BSP_TS_ResetTouchData>:
uint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)
{
  uint8_t ts_status = TS_ERROR;
  uint32_t index;

  if (TS_State != (TS_StateTypeDef *)NULL)
 801d370:	b160      	cbz	r0, 801d38c <BSP_TS_ResetTouchData+0x1c>
  {
    TS_State->gestureId = GEST_ID_NO_GESTURE;
    TS_State->touchDetected = 0;
 801d372:	4603      	mov	r3, r0

    for(index = 0; index < TS_MAX_NB_TOUCH; index++)
    {
      TS_State->touchX[index]       = 0;
 801d374:	2223      	movs	r2, #35	; 0x23
{
 801d376:	b510      	push	{r4, lr}
    TS_State->gestureId = GEST_ID_NO_GESTURE;
 801d378:	2400      	movs	r4, #0
 801d37a:	6284      	str	r4, [r0, #40]	; 0x28
      TS_State->touchX[index]       = 0;
 801d37c:	4621      	mov	r1, r4
    TS_State->touchDetected = 0;
 801d37e:	f803 4b02 	strb.w	r4, [r3], #2
      TS_State->touchX[index]       = 0;
 801d382:	4618      	mov	r0, r3
 801d384:	f002 feaa 	bl	80200dc <memset>
      TS_State->touchArea[index]    = 0;
      TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
      TS_State->touchWeight[index]  = 0;
    }

    ts_status = TS_OK;
 801d388:	4620      	mov	r0, r4

  } /* of if (TS_State != (TS_StateTypeDef *)NULL) */

  return (ts_status);
}
 801d38a:	bd10      	pop	{r4, pc}
  uint8_t ts_status = TS_ERROR;
 801d38c:	2001      	movs	r0, #1
}
 801d38e:	4770      	bx	lr

0801d390 <TS_IO_Init>:
  * @brief  Initializes Touchscreen low level.
  * @retval None
  */
void TS_IO_Init(void)
{
	HAL_I2C_Init(&hi2c3);
 801d390:	4801      	ldr	r0, [pc, #4]	; (801d398 <TS_IO_Init+0x8>)
 801d392:	f7e5 be93 	b.w	80030bc <HAL_I2C_Init>
 801d396:	bf00      	nop
 801d398:	20000d38 	.word	0x20000d38

0801d39c <TS_IO_Write>:
  * @param  Reg: Reg address
  * @param  Value: Data to be written
  * @retval None
  */
void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 801d39c:	b510      	push	{r4, lr}
 801d39e:	b086      	sub	sp, #24
 801d3a0:	468e      	mov	lr, r1
	HAL_I2C_Mem_Write(&hi2c3, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1, 1000);
 801d3a2:	2301      	movs	r3, #1
 801d3a4:	4601      	mov	r1, r0
 801d3a6:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 801d3aa:	f10d 0017 	add.w	r0, sp, #23
{
 801d3ae:	4694      	mov	ip, r2
	HAL_I2C_Mem_Write(&hi2c3, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1, 1000);
 801d3b0:	4672      	mov	r2, lr
 801d3b2:	9000      	str	r0, [sp, #0]
 801d3b4:	9402      	str	r4, [sp, #8]
 801d3b6:	9301      	str	r3, [sp, #4]
 801d3b8:	4803      	ldr	r0, [pc, #12]	; (801d3c8 <TS_IO_Write+0x2c>)
{
 801d3ba:	f88d c017 	strb.w	ip, [sp, #23]
	HAL_I2C_Mem_Write(&hi2c3, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1, 1000);
 801d3be:	f7e5 ff4f 	bl	8003260 <HAL_I2C_Mem_Write>
}
 801d3c2:	b006      	add	sp, #24
 801d3c4:	bd10      	pop	{r4, pc}
 801d3c6:	bf00      	nop
 801d3c8:	20000d38 	.word	0x20000d38

0801d3cc <TS_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address
  * @retval Data to be read
  */
uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
{
 801d3cc:	b530      	push	{r4, r5, lr}
 801d3ce:	b087      	sub	sp, #28
 801d3d0:	460a      	mov	r2, r1
  uint8_t read_value = 0;
  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1, 1000);
 801d3d2:	2301      	movs	r3, #1
 801d3d4:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 801d3d8:	f10d 0417 	add.w	r4, sp, #23
  uint8_t read_value = 0;
 801d3dc:	2100      	movs	r1, #0
  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1, 1000);
 801d3de:	9502      	str	r5, [sp, #8]
  uint8_t read_value = 0;
 801d3e0:	f88d 1017 	strb.w	r1, [sp, #23]
  HAL_I2C_Mem_Read(&hi2c3, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1, 1000);
 801d3e4:	4601      	mov	r1, r0
 801d3e6:	4804      	ldr	r0, [pc, #16]	; (801d3f8 <TS_IO_Read+0x2c>)
 801d3e8:	e9cd 4300 	strd	r4, r3, [sp]
 801d3ec:	f7e6 f8a6 	bl	800353c <HAL_I2C_Mem_Read>
  return read_value;
}
 801d3f0:	f89d 0017 	ldrb.w	r0, [sp, #23]
 801d3f4:	b007      	add	sp, #28
 801d3f6:	bd30      	pop	{r4, r5, pc}
 801d3f8:	20000d38 	.word	0x20000d38

0801d3fc <TS_IO_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void TS_IO_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 801d3fc:	f7e3 be3e 	b.w	800107c <HAL_Delay>

0801d400 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 801d400:	4b0a      	ldr	r3, [pc, #40]	; (801d42c <HAL_MspInit+0x2c>)
{
 801d402:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 801d404:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801d406:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 801d40a:	641a      	str	r2, [r3, #64]	; 0x40
 801d40c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801d40e:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 801d412:	9200      	str	r2, [sp, #0]
 801d414:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801d416:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801d418:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801d41c:	645a      	str	r2, [r3, #68]	; 0x44
 801d41e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801d420:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801d424:	9301      	str	r3, [sp, #4]
 801d426:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 801d428:	b002      	add	sp, #8
 801d42a:	4770      	bx	lr
 801d42c:	40023800 	.word	0x40023800

0801d430 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 801d430:	4770      	bx	lr
 801d432:	bf00      	nop

0801d434 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 801d434:	e7fe      	b.n	801d434 <HardFault_Handler>
 801d436:	bf00      	nop

0801d438 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 801d438:	e7fe      	b.n	801d438 <MemManage_Handler>
 801d43a:	bf00      	nop

0801d43c <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 801d43c:	e7fe      	b.n	801d43c <BusFault_Handler>
 801d43e:	bf00      	nop

0801d440 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 801d440:	e7fe      	b.n	801d440 <UsageFault_Handler>
 801d442:	bf00      	nop

0801d444 <SVC_Handler>:
 801d444:	4770      	bx	lr
 801d446:	bf00      	nop

0801d448 <DebugMon_Handler>:
 801d448:	4770      	bx	lr
 801d44a:	bf00      	nop

0801d44c <PendSV_Handler>:
 801d44c:	4770      	bx	lr
 801d44e:	bf00      	nop

0801d450 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 801d450:	f7e3 be02 	b.w	8001058 <HAL_IncTick>

0801d454 <EXTI0_IRQHandler>:

/**
  * @brief This function handles EXTI line0 interrupt.
  */
void EXTI0_IRQHandler(void)
{
 801d454:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI0_IRQn 0 */
	HAL_SPI_TransmitReceive_IT(&hspi2, spi_tx, spi_rx, 4);
 801d456:	4a05      	ldr	r2, [pc, #20]	; (801d46c <EXTI0_IRQHandler+0x18>)
 801d458:	2304      	movs	r3, #4
 801d45a:	4905      	ldr	r1, [pc, #20]	; (801d470 <EXTI0_IRQHandler+0x1c>)
 801d45c:	4805      	ldr	r0, [pc, #20]	; (801d474 <EXTI0_IRQHandler+0x20>)
 801d45e:	f7e8 fdf9 	bl	8006054 <HAL_SPI_TransmitReceive_IT>
  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(SPI2_NSS_Pin);
 801d462:	2001      	movs	r0, #1
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}
 801d464:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_EXTI_IRQHandler(SPI2_NSS_Pin);
 801d468:	f7e4 be8a 	b.w	8002180 <HAL_GPIO_EXTI_IRQHandler>
 801d46c:	2000fa74 	.word	0x2000fa74
 801d470:	20000058 	.word	0x20000058
 801d474:	20018a40 	.word	0x20018a40

0801d478 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI2_IRQn 0 */

  /* USER CODE END EXTI2_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(KBD_INT_Pin);
 801d478:	2004      	movs	r0, #4
 801d47a:	f7e4 be81 	b.w	8002180 <HAL_GPIO_EXTI_IRQHandler>
 801d47e:	bf00      	nop

0801d480 <TIM1_BRK_TIM9_IRQHandler>:
  * @brief This function handles TIM1 break interrupt and TIM9 global interrupt.
  */
void TIM1_BRK_TIM9_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_BRK_TIM9_IRQn 0 */
	if(button_flag & (1 << 0)) {
 801d480:	4913      	ldr	r1, [pc, #76]	; (801d4d0 <TIM1_BRK_TIM9_IRQHandler+0x50>)
{
 801d482:	b508      	push	{r3, lr}
	if(button_flag & (1 << 0)) {
 801d484:	880b      	ldrh	r3, [r1, #0]
 801d486:	07da      	lsls	r2, r3, #31
 801d488:	d510      	bpl.n	801d4ac <TIM1_BRK_TIM9_IRQHandler+0x2c>
		if(display.cuemode == 0) display.cuemode = 1;
 801d48a:	4812      	ldr	r0, [pc, #72]	; (801d4d4 <TIM1_BRK_TIM9_IRQHandler+0x54>)
		else display.cuemode = 0;
		button_flag ^= (1 << 0);
 801d48c:	f083 0301 	eor.w	r3, r3, #1
		if(display.cuemode == 0) display.cuemode = 1;
 801d490:	7882      	ldrb	r2, [r0, #2]
		button_flag ^= (1 << 0);
 801d492:	800b      	strh	r3, [r1, #0]
		if(display.cuemode == 0) display.cuemode = 1;
 801d494:	fab2 f382 	clz	r3, r2
 801d498:	095b      	lsrs	r3, r3, #5
 801d49a:	7083      	strb	r3, [r0, #2]
	else if(button_flag & (1 << 3)) {
		if(display.quantize == 0) display.quantize = 1;
		else display.quantize = 0;
		button_flag ^= (1 << 3);
	}
	HAL_TIM_Base_Stop_IT(&htim9);
 801d49c:	480e      	ldr	r0, [pc, #56]	; (801d4d8 <TIM1_BRK_TIM9_IRQHandler+0x58>)
 801d49e:	f7e9 f9e5 	bl	800686c <HAL_TIM_Base_Stop_IT>
  /* USER CODE END TIM1_BRK_TIM9_IRQn 0 */
  HAL_TIM_IRQHandler(&htim9);
 801d4a2:	480d      	ldr	r0, [pc, #52]	; (801d4d8 <TIM1_BRK_TIM9_IRQHandler+0x58>)
  /* USER CODE BEGIN TIM1_BRK_TIM9_IRQn 1 */

  /* USER CODE END TIM1_BRK_TIM9_IRQn 1 */
}
 801d4a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_IRQHandler(&htim9);
 801d4a8:	f7e9 bd3c 	b.w	8006f24 <HAL_TIM_IRQHandler>
	else if(button_flag & (1 << 1)) {
 801d4ac:	0798      	lsls	r0, r3, #30
 801d4ae:	d503      	bpl.n	801d4b8 <TIM1_BRK_TIM9_IRQHandler+0x38>
		button_flag ^= (1 << 1);
 801d4b0:	f083 0302 	eor.w	r3, r3, #2
 801d4b4:	800b      	strh	r3, [r1, #0]
 801d4b6:	e7f1      	b.n	801d49c <TIM1_BRK_TIM9_IRQHandler+0x1c>
	else if(button_flag & (1 << 3)) {
 801d4b8:	071a      	lsls	r2, r3, #28
 801d4ba:	d5ef      	bpl.n	801d49c <TIM1_BRK_TIM9_IRQHandler+0x1c>
		if(display.quantize == 0) display.quantize = 1;
 801d4bc:	4805      	ldr	r0, [pc, #20]	; (801d4d4 <TIM1_BRK_TIM9_IRQHandler+0x54>)
		button_flag ^= (1 << 3);
 801d4be:	f083 0308 	eor.w	r3, r3, #8
		if(display.quantize == 0) display.quantize = 1;
 801d4c2:	7c42      	ldrb	r2, [r0, #17]
		button_flag ^= (1 << 3);
 801d4c4:	800b      	strh	r3, [r1, #0]
		if(display.quantize == 0) display.quantize = 1;
 801d4c6:	fab2 f382 	clz	r3, r2
 801d4ca:	095b      	lsrs	r3, r3, #5
 801d4cc:	7443      	strb	r3, [r0, #17]
		button_flag ^= (1 << 3);
 801d4ce:	e7e5      	b.n	801d49c <TIM1_BRK_TIM9_IRQHandler+0x1c>
 801d4d0:	20018b62 	.word	0x20018b62
 801d4d4:	20000c70 	.word	0x20000c70
 801d4d8:	20018cc4 	.word	0x20018cc4

0801d4dc <TIM4_IRQHandler>:

/**
  * @brief This function handles TIM4 global interrupt.
  */
void TIM4_IRQHandler(void)
{
 801d4dc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM4_IRQn 0 */
	ClearLayer();
	SetBeatGrid();
	if(menu_mode == 0) DrawSpectrum();
 801d4de:	4c0d      	ldr	r4, [pc, #52]	; (801d514 <TIM4_IRQHandler+0x38>)
	ClearLayer();
 801d4e0:	f7f6 ff0c 	bl	80142fc <ClearLayer>
	SetBeatGrid();
 801d4e4:	f7f6 ff54 	bl	8014390 <SetBeatGrid>
	if(menu_mode == 0) DrawSpectrum();
 801d4e8:	f994 3000 	ldrsb.w	r3, [r4]
 801d4ec:	b163      	cbz	r3, 801d508 <TIM4_IRQHandler+0x2c>
	if(menu_mode != 3) 	DrawLowSpectrum();
 801d4ee:	2b03      	cmp	r3, #3
 801d4f0:	d001      	beq.n	801d4f6 <TIM4_IRQHandler+0x1a>
 801d4f2:	f7f7 fc5d 	bl	8014db0 <DrawLowSpectrum>
	DrawMenu();
 801d4f6:	f7fb feeb 	bl	80192d0 <DrawMenu>
	//DrawFrequencySpectrum();
	ChangeLayers();
 801d4fa:	f7f6 ff29 	bl	8014350 <ChangeLayers>
  /* USER CODE END TIM4_IRQn 0 */
  HAL_TIM_IRQHandler(&htim4);
 801d4fe:	4806      	ldr	r0, [pc, #24]	; (801d518 <TIM4_IRQHandler+0x3c>)
  /* USER CODE BEGIN TIM4_IRQn 1 */

  /* USER CODE END TIM4_IRQn 1 */
}
 801d500:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_TIM_IRQHandler(&htim4);
 801d504:	f7e9 bd0e 	b.w	8006f24 <HAL_TIM_IRQHandler>
	if(menu_mode == 0) DrawSpectrum();
 801d508:	f7fb f906 	bl	8018718 <DrawSpectrum>
	if(menu_mode != 3) 	DrawLowSpectrum();
 801d50c:	f994 3000 	ldrsb.w	r3, [r4]
 801d510:	e7ed      	b.n	801d4ee <TIM4_IRQHandler+0x12>
 801d512:	bf00      	nop
 801d514:	20000c8c 	.word	0x20000c8c
 801d518:	20018b84 	.word	0x20018b84

0801d51c <SPI2_IRQHandler>:
void SPI2_IRQHandler(void)
{
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 801d51c:	4801      	ldr	r0, [pc, #4]	; (801d524 <SPI2_IRQHandler+0x8>)
 801d51e:	f7e8 be75 	b.w	800620c <HAL_SPI_IRQHandler>
 801d522:	bf00      	nop
 801d524:	20018a40 	.word	0x20018a40

0801d528 <EXTI15_10_IRQHandler>:
  *
  * TouchScreen handler routines
  *
  */
void EXTI15_10_IRQHandler(void)
{
 801d528:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */
	BSP_TS_GetState(&ts_State);
 801d52c:	4cbc      	ldr	r4, [pc, #752]	; (801d820 <EXTI15_10_IRQHandler+0x2f8>)
{
 801d52e:	ed2d 8b02 	vpush	{d8}
	BSP_TS_GetState(&ts_State);
 801d532:	4620      	mov	r0, r4
{
 801d534:	b082      	sub	sp, #8
	BSP_TS_GetState(&ts_State);
 801d536:	f7ff fe0d 	bl	801d154 <BSP_TS_GetState>
	if(ts_State.touchDetected == 1) {
 801d53a:	7823      	ldrb	r3, [r4, #0]
 801d53c:	2b01      	cmp	r3, #1
 801d53e:	d00d      	beq.n	801d55c <EXTI15_10_IRQHandler+0x34>
				if(stretch > 4) stretch = 4;
			}
			touch_count++;
		}
	}*/
	BSP_TS_ResetTouchData(&ts_State);
 801d540:	48b7      	ldr	r0, [pc, #732]	; (801d820 <EXTI15_10_IRQHandler+0x2f8>)
 801d542:	f7ff ff15 	bl	801d370 <BSP_TS_ResetTouchData>
	BSP_TS_ITClear();
 801d546:	f7ff ff09 	bl	801d35c <BSP_TS_ITClear>
  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(LCD_INT_Pin);
 801d54a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 801d54e:	b002      	add	sp, #8
 801d550:	ecbd 8b02 	vpop	{d8}
 801d554:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  HAL_GPIO_EXTI_IRQHandler(LCD_INT_Pin);
 801d558:	f7e4 be12 	b.w	8002180 <HAL_GPIO_EXTI_IRQHandler>
		if((ts_State.touchX[0] > 40) && (ts_State.touchX[0] < 440) && (ts_State.touchY[0] > 220) && (ts_State.touchY[0] < 260)) {
 801d55c:	8865      	ldrh	r5, [r4, #2]
 801d55e:	f1a5 0329 	sub.w	r3, r5, #41	; 0x29
 801d562:	f5b3 7fc7 	cmp.w	r3, #398	; 0x18e
 801d566:	89a3      	ldrh	r3, [r4, #12]
 801d568:	d804      	bhi.n	801d574 <EXTI15_10_IRQHandler+0x4c>
 801d56a:	f1a3 02dd 	sub.w	r2, r3, #221	; 0xdd
 801d56e:	2a26      	cmp	r2, #38	; 0x26
 801d570:	f240 8119 	bls.w	801d7a6 <EXTI15_10_IRQHandler+0x27e>
		else if((ts_State.touchY[0] > 20) && (ts_State.touchY[0] < 165)) {
 801d574:	f1a3 0215 	sub.w	r2, r3, #21
 801d578:	2a8f      	cmp	r2, #143	; 0x8f
 801d57a:	d90e      	bls.n	801d59a <EXTI15_10_IRQHandler+0x72>
		else if((ts_State.touchY[0] > 0) && (ts_State.touchY[0] < 20)) {
 801d57c:	1e5a      	subs	r2, r3, #1
 801d57e:	2a12      	cmp	r2, #18
 801d580:	f240 80f4 	bls.w	801d76c <EXTI15_10_IRQHandler+0x244>
		else if((ts_State.touchX[0] > 80) && (ts_State.touchX[0] < 280) && (ts_State.touchY[0] > 180) && (ts_State.touchY[0] < 210)) {
 801d584:	3bb5      	subs	r3, #181	; 0xb5
 801d586:	2b1c      	cmp	r3, #28
 801d588:	d803      	bhi.n	801d592 <EXTI15_10_IRQHandler+0x6a>
 801d58a:	3d51      	subs	r5, #81	; 0x51
 801d58c:	2dc6      	cmp	r5, #198	; 0xc6
 801d58e:	f240 816d 	bls.w	801d86c <EXTI15_10_IRQHandler+0x344>
			touch_count = 0;
 801d592:	4ba4      	ldr	r3, [pc, #656]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
 801d594:	2200      	movs	r2, #0
 801d596:	701a      	strb	r2, [r3, #0]
 801d598:	e7d2      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
			if(menu_mode == 0) {
 801d59a:	f8df a2b8 	ldr.w	sl, [pc, #696]	; 801d854 <EXTI15_10_IRQHandler+0x32c>
 801d59e:	f99a 6000 	ldrsb.w	r6, [sl]
 801d5a2:	2e00      	cmp	r6, #0
 801d5a4:	d159      	bne.n	801d65a <EXTI15_10_IRQHandler+0x132>
				if((ts_State.touchY[0] > 75) && (ts_State.touchY[0] < 165)) {
 801d5a6:	3b4c      	subs	r3, #76	; 0x4c
 801d5a8:	2b58      	cmp	r3, #88	; 0x58
 801d5aa:	d8c9      	bhi.n	801d540 <EXTI15_10_IRQHandler+0x18>
					__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d5ac:	f8df 8284 	ldr.w	r8, [pc, #644]	; 801d834 <EXTI15_10_IRQHandler+0x30c>
					HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801d5b0:	2028      	movs	r0, #40	; 0x28
 801d5b2:	f7e3 fdf1 	bl	8001198 <HAL_NVIC_DisableIRQ>
					__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d5b6:	f06f 0201 	mvn.w	r2, #1
 801d5ba:	f8d8 3000 	ldr.w	r3, [r8]
					HAL_TIM_Base_Start_IT(&htim6);
 801d5be:	4640      	mov	r0, r8
					touch_count = 0;
 801d5c0:	4f98      	ldr	r7, [pc, #608]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
					__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d5c2:	611a      	str	r2, [r3, #16]
					__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d5c4:	625e      	str	r6, [r3, #36]	; 0x24
					HAL_TIM_Base_Start_IT(&htim6);
 801d5c6:	f7e9 f8d1 	bl	800676c <HAL_TIM_Base_Start_IT>
					if(ts_State.touchX[0] > 280) {
 801d5ca:	8865      	ldrh	r5, [r4, #2]
					touch_count = 0;
 801d5cc:	703e      	strb	r6, [r7, #0]
					if(ts_State.touchX[0] > 280) {
 801d5ce:	f5b5 7f8c 	cmp.w	r5, #280	; 0x118
 801d5d2:	f240 8185 	bls.w	801d8e0 <EXTI15_10_IRQHandler+0x3b8>
						if(stretch > 1) stretch--;
 801d5d6:	4e94      	ldr	r6, [pc, #592]	; (801d828 <EXTI15_10_IRQHandler+0x300>)
 801d5d8:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801d5dc:	edd6 7a00 	vldr	s15, [r6]
 801d5e0:	eef4 7ac8 	vcmpe.f32	s15, s16
 801d5e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d5e8:	f340 81b3 	ble.w	801d952 <EXTI15_10_IRQHandler+0x42a>
 801d5ec:	ee37 8ac8 	vsub.f32	s16, s15, s16
						if(stretch < 0.1) stretch = 0.125;
 801d5f0:	ee18 0a10 	vmov	r0, s16
 801d5f4:	f7e3 f8fa 	bl	80007ec <__aeabi_f2d>
 801d5f8:	a385      	add	r3, pc, #532	; (adr r3, 801d810 <EXTI15_10_IRQHandler+0x2e8>)
 801d5fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d5fe:	f7e3 f9ad 	bl	800095c <__aeabi_dcmplt>
 801d602:	2800      	cmp	r0, #0
 801d604:	f000 819d 	beq.w	801d942 <EXTI15_10_IRQHandler+0x41a>
 801d608:	f04f 5378 	mov.w	r3, #1040187392	; 0x3e000000
 801d60c:	6033      	str	r3, [r6, #0]
			if(menu_mode == 1) {
 801d60e:	f99a 6000 	ldrsb.w	r6, [sl]
 801d612:	2e01      	cmp	r6, #1
 801d614:	d17e      	bne.n	801d714 <EXTI15_10_IRQHandler+0x1ec>
					String_number = ts_State.touchY[0] / 20 - 1;
 801d616:	89a3      	ldrh	r3, [r4, #12]
 801d618:	4a84      	ldr	r2, [pc, #528]	; (801d82c <EXTI15_10_IRQHandler+0x304>)
					__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d61a:	f06f 0001 	mvn.w	r0, #1
 801d61e:	f8d8 1000 	ldr.w	r1, [r8]
					String_number = ts_State.touchY[0] / 20 - 1;
 801d622:	fba2 2303 	umull	r2, r3, r2, r3
					str_offset = 0;
 801d626:	f8df 923c 	ldr.w	r9, [pc, #572]	; 801d864 <EXTI15_10_IRQHandler+0x33c>
 801d62a:	2200      	movs	r2, #0
					__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d62c:	6108      	str	r0, [r1, #16]
					String_number = ts_State.touchY[0] / 20 - 1;
 801d62e:	091b      	lsrs	r3, r3, #4
 801d630:	f8df 8234 	ldr.w	r8, [pc, #564]	; 801d868 <EXTI15_10_IRQHandler+0x340>
					__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d634:	624a      	str	r2, [r1, #36]	; 0x24
					str_offset = 0;
 801d636:	f8c9 2000 	str.w	r2, [r9]
					String_number = ts_State.touchY[0] / 20 - 1;
 801d63a:	3b01      	subs	r3, #1
					prev_x = ts_State.touchX[0];
 801d63c:	4a7c      	ldr	r2, [pc, #496]	; (801d830 <EXTI15_10_IRQHandler+0x308>)
					HAL_TIM_Base_Start_IT(&htim6);
 801d63e:	487d      	ldr	r0, [pc, #500]	; (801d834 <EXTI15_10_IRQHandler+0x30c>)
					prev_x = ts_State.touchX[0];
 801d640:	8015      	strh	r5, [r2, #0]
					Mark_number = String_number;
 801d642:	4a7d      	ldr	r2, [pc, #500]	; (801d838 <EXTI15_10_IRQHandler+0x310>)
					String_number = ts_State.touchY[0] / 20 - 1;
 801d644:	f8c8 3000 	str.w	r3, [r8]
					Mark_number = String_number;
 801d648:	6013      	str	r3, [r2, #0]
					HAL_TIM_Base_Start_IT(&htim6);
 801d64a:	f7e9 f88f 	bl	800676c <HAL_TIM_Base_Start_IT>
			if(menu_mode == 2) {
 801d64e:	f99a 6000 	ldrsb.w	r6, [sl]
				touch_count++;
 801d652:	783a      	ldrb	r2, [r7, #0]
				if((String_number != ts_State.touchY[0] / 20 - 1)) {
 801d654:	89a3      	ldrh	r3, [r4, #12]
				if(ts_State.touchX[0] > 380) {
 801d656:	8865      	ldrh	r5, [r4, #2]
 801d658:	e015      	b.n	801d686 <EXTI15_10_IRQHandler+0x15e>
			if(menu_mode == 1) {
 801d65a:	2e01      	cmp	r6, #1
 801d65c:	d15a      	bne.n	801d714 <EXTI15_10_IRQHandler+0x1ec>
				if(touch_count == 0) {
 801d65e:	4f71      	ldr	r7, [pc, #452]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
 801d660:	783a      	ldrb	r2, [r7, #0]
 801d662:	2a00      	cmp	r2, #0
 801d664:	f000 817e 	beq.w	801d964 <EXTI15_10_IRQHandler+0x43c>
					str_offset = ts_State.touchX[0] - prev_x;
 801d668:	4971      	ldr	r1, [pc, #452]	; (801d830 <EXTI15_10_IRQHandler+0x308>)
					__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d66a:	f04f 0c00 	mov.w	ip, #0
 801d66e:	4871      	ldr	r0, [pc, #452]	; (801d834 <EXTI15_10_IRQHandler+0x30c>)
					str_offset = ts_State.touchX[0] - prev_x;
 801d670:	8809      	ldrh	r1, [r1, #0]
					__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d672:	6800      	ldr	r0, [r0, #0]
					str_offset = ts_State.touchX[0] - prev_x;
 801d674:	1a69      	subs	r1, r5, r1
 801d676:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 801d864 <EXTI15_10_IRQHandler+0x33c>
 801d67a:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 801d868 <EXTI15_10_IRQHandler+0x340>
					__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d67e:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
					str_offset = ts_State.touchX[0] - prev_x;
 801d682:	f8c9 1000 	str.w	r1, [r9]
				touch_count++;
 801d686:	3201      	adds	r2, #1
 801d688:	703a      	strb	r2, [r7, #0]
				if((String_number != ts_State.touchY[0] / 20 - 1)) {
 801d68a:	4a68      	ldr	r2, [pc, #416]	; (801d82c <EXTI15_10_IRQHandler+0x304>)
 801d68c:	fba2 2303 	umull	r2, r3, r2, r3
 801d690:	f8d8 2000 	ldr.w	r2, [r8]
 801d694:	f3c3 130f 	ubfx	r3, r3, #4, #16
 801d698:	1e59      	subs	r1, r3, #1
 801d69a:	4291      	cmp	r1, r2
 801d69c:	d01f      	beq.n	801d6de <EXTI15_10_IRQHandler+0x1b6>
					if(Total_tracks > 7) {
 801d69e:	4867      	ldr	r0, [pc, #412]	; (801d83c <EXTI15_10_IRQHandler+0x314>)
 801d6a0:	8800      	ldrh	r0, [r0, #0]
 801d6a2:	2807      	cmp	r0, #7
 801d6a4:	d913      	bls.n	801d6ce <EXTI15_10_IRQHandler+0x1a6>
						if(String_number > (ts_State.touchY[0] / 20 - 1)) {
 801d6a6:	4293      	cmp	r3, r2
							str_increment += abs((ts_State.touchY[0] / 20 - 1) - String_number);
 801d6a8:	eba1 0302 	sub.w	r3, r1, r2
						if(String_number > (ts_State.touchY[0] / 20 - 1)) {
 801d6ac:	f300 813f 	bgt.w	801d92e <EXTI15_10_IRQHandler+0x406>
							str_increment += abs((ts_State.touchY[0] / 20 - 1) - String_number);
 801d6b0:	2b00      	cmp	r3, #0
 801d6b2:	f8df c18c 	ldr.w	ip, [pc, #396]	; 801d840 <EXTI15_10_IRQHandler+0x318>
							if(str_increment > Total_tracks - 7) str_increment = Total_tracks - 7;
 801d6b6:	f1a0 0106 	sub.w	r1, r0, #6
							str_increment += abs((ts_State.touchY[0] / 20 - 1) - String_number);
 801d6ba:	bfb8      	it	lt
 801d6bc:	425b      	neglt	r3, r3
 801d6be:	f8dc 2000 	ldr.w	r2, [ip]
 801d6c2:	4413      	add	r3, r2
							if(str_increment > Total_tracks - 7) str_increment = Total_tracks - 7;
 801d6c4:	428b      	cmp	r3, r1
 801d6c6:	f280 8149 	bge.w	801d95c <EXTI15_10_IRQHandler+0x434>
							str_increment += abs((ts_State.touchY[0] / 20 - 1) - String_number);
 801d6ca:	f8cc 3000 	str.w	r3, [ip]
					str_offset = 0;
 801d6ce:	2300      	movs	r3, #0
					String_number = -1;
 801d6d0:	f04f 32ff 	mov.w	r2, #4294967295
					str_offset = 0;
 801d6d4:	f8c9 3000 	str.w	r3, [r9]
					String_number = -1;
 801d6d8:	f8c8 2000 	str.w	r2, [r8]
					touch_count = 0;
 801d6dc:	703b      	strb	r3, [r7, #0]
				if(ts_State.touchX[0] > 380) {
 801d6de:	f5b5 7fbe 	cmp.w	r5, #380	; 0x17c
 801d6e2:	d917      	bls.n	801d714 <EXTI15_10_IRQHandler+0x1ec>
					Track_number = String_number + str_increment;
 801d6e4:	4b56      	ldr	r3, [pc, #344]	; (801d840 <EXTI15_10_IRQHandler+0x318>)
					bOutOfData = 1;
 801d6e6:	2101      	movs	r1, #1
					Track_number = String_number + str_increment;
 801d6e8:	681b      	ldr	r3, [r3, #0]
 801d6ea:	441a      	add	r2, r3
					if(Track_number >= Total_tracks) Track_number = 0;
 801d6ec:	4b53      	ldr	r3, [pc, #332]	; (801d83c <EXTI15_10_IRQHandler+0x314>)
 801d6ee:	881b      	ldrh	r3, [r3, #0]
 801d6f0:	429a      	cmp	r2, r3
 801d6f2:	bfa8      	it	ge
 801d6f4:	2200      	movge	r2, #0
					str_offset = 0;
 801d6f6:	2300      	movs	r3, #0
 801d6f8:	f8c9 3000 	str.w	r3, [r9]
					touch_count = 0;
 801d6fc:	703b      	strb	r3, [r7, #0]
					bOutOfData = 1;
 801d6fe:	4b51      	ldr	r3, [pc, #324]	; (801d844 <EXTI15_10_IRQHandler+0x31c>)
 801d700:	6019      	str	r1, [r3, #0]
					unDmaBufMode = 3;
 801d702:	2103      	movs	r1, #3
 801d704:	4b50      	ldr	r3, [pc, #320]	; (801d848 <EXTI15_10_IRQHandler+0x320>)
 801d706:	6019      	str	r1, [r3, #0]
					Track_number = String_number + str_increment;
 801d708:	4b50      	ldr	r3, [pc, #320]	; (801d84c <EXTI15_10_IRQHandler+0x324>)
					if(Track_number >= Total_tracks) Track_number = 0;
 801d70a:	601a      	str	r2, [r3, #0]
					String_number = -1;
 801d70c:	f04f 33ff 	mov.w	r3, #4294967295
 801d710:	f8c8 3000 	str.w	r3, [r8]
			if(menu_mode == 2) {
 801d714:	2e02      	cmp	r6, #2
 801d716:	f47f af13 	bne.w	801d540 <EXTI15_10_IRQHandler+0x18>
				if((ts_State.touchX[0] >= 40) && (ts_State.touchX[0] <= 440)) {
 801d71a:	3d28      	subs	r5, #40	; 0x28
				touch_count = 0;
 801d71c:	4a41      	ldr	r2, [pc, #260]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
 801d71e:	2100      	movs	r1, #0
				if((ts_State.touchX[0] >= 40) && (ts_State.touchX[0] <= 440)) {
 801d720:	b2ab      	uxth	r3, r5
				touch_count = 0;
 801d722:	7011      	strb	r1, [r2, #0]
				if((ts_State.touchX[0] >= 40) && (ts_State.touchX[0] <= 440)) {
 801d724:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 801d728:	f63f af0a 	bhi.w	801d540 <EXTI15_10_IRQHandler+0x18>
					if((ts_State.touchY[0] > 40) && (ts_State.touchY[0] < 60))	{
 801d72c:	89a3      	ldrh	r3, [r4, #12]
 801d72e:	f1a3 0229 	sub.w	r2, r3, #41	; 0x29
 801d732:	2a12      	cmp	r2, #18
 801d734:	f240 80eb 	bls.w	801d90e <EXTI15_10_IRQHandler+0x3e6>
					if((ts_State.touchY[0] > 80) && (ts_State.touchY[0] < 100)) {
 801d738:	f1a3 0251 	sub.w	r2, r3, #81	; 0x51
 801d73c:	2a12      	cmp	r2, #18
 801d73e:	f200 80ba 	bhi.w	801d8b6 <EXTI15_10_IRQHandler+0x38e>
						jog_sensitivity = 0.01 * (float)(ts_State.touchX[0]-40) / 400;
 801d742:	8863      	ldrh	r3, [r4, #2]
 801d744:	4c42      	ldr	r4, [pc, #264]	; (801d850 <EXTI15_10_IRQHandler+0x328>)
 801d746:	f1a3 0028 	sub.w	r0, r3, #40	; 0x28
 801d74a:	ee07 0a90 	vmov	s15, r0
 801d74e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d752:	ee17 0a90 	vmov	r0, s15
 801d756:	f7e3 f849 	bl	80007ec <__aeabi_f2d>
 801d75a:	a32f      	add	r3, pc, #188	; (adr r3, 801d818 <EXTI15_10_IRQHandler+0x2f0>)
 801d75c:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d760:	f7e2 fdb6 	bl	80002d0 <__aeabi_dmul>
 801d764:	f7e3 f942 	bl	80009ec <__aeabi_d2f>
 801d768:	6020      	str	r0, [r4, #0]
					if((ts_State.touchY[0] > 120) && (ts_State.touchY[0] < 140)) {
 801d76a:	e6e9      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801d76c:	2028      	movs	r0, #40	; 0x28
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d76e:	2500      	movs	r5, #0
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801d770:	f7e3 fd12 	bl	8001198 <HAL_NVIC_DisableIRQ>
			__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d774:	482f      	ldr	r0, [pc, #188]	; (801d834 <EXTI15_10_IRQHandler+0x30c>)
 801d776:	f06f 0201 	mvn.w	r2, #1
 801d77a:	6803      	ldr	r3, [r0, #0]
 801d77c:	611a      	str	r2, [r3, #16]
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d77e:	625d      	str	r5, [r3, #36]	; 0x24
			HAL_TIM_Base_Start_IT(&htim6);
 801d780:	f7e8 fff4 	bl	800676c <HAL_TIM_Base_Start_IT>
			if(ts_State.touchX[0] < 200) {
 801d784:	8863      	ldrh	r3, [r4, #2]
			touch_count = 0;
 801d786:	4a27      	ldr	r2, [pc, #156]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
			if(ts_State.touchX[0] < 200) {
 801d788:	2bc7      	cmp	r3, #199	; 0xc7
			touch_count = 0;
 801d78a:	7015      	strb	r5, [r2, #0]
			if(ts_State.touchX[0] < 200) {
 801d78c:	d934      	bls.n	801d7f8 <EXTI15_10_IRQHandler+0x2d0>
			else if(ts_State.touchX[0] > 280) {
 801d78e:	f5b3 7f8c 	cmp.w	r3, #280	; 0x118
 801d792:	f67f aed5 	bls.w	801d540 <EXTI15_10_IRQHandler+0x18>
				menu_mode++;
 801d796:	4a2f      	ldr	r2, [pc, #188]	; (801d854 <EXTI15_10_IRQHandler+0x32c>)
 801d798:	7813      	ldrb	r3, [r2, #0]
 801d79a:	3301      	adds	r3, #1
 801d79c:	b25b      	sxtb	r3, r3
				if(menu_mode > 2) menu_mode = 0;
 801d79e:	2b02      	cmp	r3, #2
 801d7a0:	dd30      	ble.n	801d804 <EXTI15_10_IRQHandler+0x2dc>
 801d7a2:	7015      	strb	r5, [r2, #0]
 801d7a4:	e6cc      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
			GoToPosition(((float)ts_State.touchX[0] - 40) * (float)rekordbox.spectrum_size / rekordbox.lowp_spectrum_size);
 801d7a6:	4b2c      	ldr	r3, [pc, #176]	; (801d858 <EXTI15_10_IRQHandler+0x330>)
 801d7a8:	ee07 5a90 	vmov	s15, r5
 801d7ac:	ed9f 6a2b 	vldr	s12, [pc, #172]	; 801d85c <EXTI15_10_IRQHandler+0x334>
 801d7b0:	f603 218c 	addw	r1, r3, #2700	; 0xa8c
 801d7b4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801d7b8:	f603 2388 	addw	r3, r3, #2696	; 0xa88
			touch_count = 0;
 801d7bc:	4a19      	ldr	r2, [pc, #100]	; (801d824 <EXTI15_10_IRQHandler+0x2fc>)
			GoToPosition(((float)ts_State.touchX[0] - 40) * (float)rekordbox.spectrum_size / rekordbox.lowp_spectrum_size);
 801d7be:	edd1 7a00 	vldr	s15, [r1]
 801d7c2:	ee37 7a46 	vsub.f32	s14, s14, s12
 801d7c6:	edd3 6a00 	vldr	s13, [r3]
 801d7ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
			touch_count = 0;
 801d7ce:	2300      	movs	r3, #0
			GoToPosition(((float)ts_State.touchX[0] - 40) * (float)rekordbox.spectrum_size / rekordbox.lowp_spectrum_size);
 801d7d0:	eef8 6a66 	vcvt.f32.u32	s13, s13
			if(trak.state == PLAYING) BSP_AUDIO_OUT_Resume();
 801d7d4:	4c22      	ldr	r4, [pc, #136]	; (801d860 <EXTI15_10_IRQHandler+0x338>)
			touch_count = 0;
 801d7d6:	7013      	strb	r3, [r2, #0]
			GoToPosition(((float)ts_State.touchX[0] - 40) * (float)rekordbox.spectrum_size / rekordbox.lowp_spectrum_size);
 801d7d8:	ee67 7a27 	vmul.f32	s15, s14, s15
 801d7dc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801d7e0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 801d7e4:	ee17 0a90 	vmov	r0, s15
 801d7e8:	f001 fb92 	bl	801ef10 <GoToPosition>
			if(trak.state == PLAYING) BSP_AUDIO_OUT_Resume();
 801d7ec:	7823      	ldrb	r3, [r4, #0]
 801d7ee:	2b00      	cmp	r3, #0
 801d7f0:	d152      	bne.n	801d898 <EXTI15_10_IRQHandler+0x370>
 801d7f2:	f7ff faf1 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
 801d7f6:	e6a3      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
				menu_mode--;
 801d7f8:	4a16      	ldr	r2, [pc, #88]	; (801d854 <EXTI15_10_IRQHandler+0x32c>)
 801d7fa:	7813      	ldrb	r3, [r2, #0]
 801d7fc:	3b01      	subs	r3, #1
 801d7fe:	b25b      	sxtb	r3, r3
				if(menu_mode < 0) menu_mode = 2;
 801d800:	42ab      	cmp	r3, r5
 801d802:	db01      	blt.n	801d808 <EXTI15_10_IRQHandler+0x2e0>
				menu_mode++;
 801d804:	7013      	strb	r3, [r2, #0]
 801d806:	e69b      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
				if(menu_mode < 0) menu_mode = 2;
 801d808:	2302      	movs	r3, #2
 801d80a:	7013      	strb	r3, [r2, #0]
 801d80c:	e698      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
 801d80e:	bf00      	nop
 801d810:	9999999a 	.word	0x9999999a
 801d814:	3fb99999 	.word	0x3fb99999
 801d818:	eb1c432d 	.word	0xeb1c432d
 801d81c:	3efa36e2 	.word	0x3efa36e2
 801d820:	2000fa88 	.word	0x2000fa88
 801d824:	20018b7c 	.word	0x20018b7c
 801d828:	20000028 	.word	0x20000028
 801d82c:	cccccccd 	.word	0xcccccccd
 801d830:	20018b6c 	.word	0x20018b6c
 801d834:	20018c04 	.word	0x20018c04
 801d838:	20000064 	.word	0x20000064
 801d83c:	200022c0 	.word	0x200022c0
 801d840:	20018b74 	.word	0x20018b74
 801d844:	2000ec30 	.word	0x2000ec30
 801d848:	2000fab4 	.word	0x2000fab4
 801d84c:	2000e9fc 	.word	0x2000e9fc
 801d850:	20000070 	.word	0x20000070
 801d854:	20000c8c 	.word	0x20000c8c
 801d858:	200174f0 	.word	0x200174f0
 801d85c:	42200000 	.word	0x42200000
 801d860:	2000fa7c 	.word	0x2000fa7c
 801d864:	20018b78 	.word	0x20018b78
 801d868:	2000006c 	.word	0x2000006c
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801d86c:	2028      	movs	r0, #40	; 0x28
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d86e:	2400      	movs	r4, #0
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801d870:	f7e3 fc92 	bl	8001198 <HAL_NVIC_DisableIRQ>
			__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801d874:	483e      	ldr	r0, [pc, #248]	; (801d970 <EXTI15_10_IRQHandler+0x448>)
 801d876:	f06f 0201 	mvn.w	r2, #1
 801d87a:	6803      	ldr	r3, [r0, #0]
 801d87c:	611a      	str	r2, [r3, #16]
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801d87e:	625c      	str	r4, [r3, #36]	; 0x24
			HAL_TIM_Base_Start_IT(&htim6);
 801d880:	f7e8 ff74 	bl	800676c <HAL_TIM_Base_Start_IT>
			if(display.timemode == 0) {
 801d884:	4b3b      	ldr	r3, [pc, #236]	; (801d974 <EXTI15_10_IRQHandler+0x44c>)
			touch_count = 0;
 801d886:	493c      	ldr	r1, [pc, #240]	; (801d978 <EXTI15_10_IRQHandler+0x450>)
			if(display.timemode == 0) {
 801d888:	781a      	ldrb	r2, [r3, #0]
			touch_count = 0;
 801d88a:	700c      	strb	r4, [r1, #0]
			if(display.timemode == 0) {
 801d88c:	2a00      	cmp	r2, #0
 801d88e:	d16c      	bne.n	801d96a <EXTI15_10_IRQHandler+0x442>
				display.timemode = 1;
 801d890:	2201      	movs	r2, #1
 801d892:	701a      	strb	r2, [r3, #0]
				display.trackbarmode = 1;
 801d894:	711a      	strb	r2, [r3, #4]
 801d896:	e653      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
				GetTrackTime();
 801d898:	f001 fbe8 	bl	801f06c <GetTrackTime>
				if(spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801d89c:	4a37      	ldr	r2, [pc, #220]	; (801d97c <EXTI15_10_IRQHandler+0x454>)
 801d89e:	7893      	ldrb	r3, [r2, #2]
 801d8a0:	07d9      	lsls	r1, r3, #31
				trak.state = SETCUE;
 801d8a2:	f04f 0102 	mov.w	r1, #2
				if(spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801d8a6:	bf4c      	ite	mi
 801d8a8:	f043 0302 	orrmi.w	r3, r3, #2
				else spi_tx[2] &= ~(1 << 1);
 801d8ac:	f003 03fd 	andpl.w	r3, r3, #253	; 0xfd
				trak.state = SETCUE;
 801d8b0:	7021      	strb	r1, [r4, #0]
 801d8b2:	7093      	strb	r3, [r2, #2]
 801d8b4:	e644      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
					if((ts_State.touchY[0] > 120) && (ts_State.touchY[0] < 140)) {
 801d8b6:	3b79      	subs	r3, #121	; 0x79
 801d8b8:	2b12      	cmp	r3, #18
 801d8ba:	f63f ae41 	bhi.w	801d540 <EXTI15_10_IRQHandler+0x18>
						acue_sensitivity = 250 * (float)(ts_State.touchX[0]-40) / 400;
 801d8be:	8863      	ldrh	r3, [r4, #2]
 801d8c0:	eeb6 7a04 	vmov.f32	s14, #100	; 0x3f200000  0.625
 801d8c4:	4a2e      	ldr	r2, [pc, #184]	; (801d980 <EXTI15_10_IRQHandler+0x458>)
 801d8c6:	3b28      	subs	r3, #40	; 0x28
 801d8c8:	ee07 3a90 	vmov	s15, r3
 801d8cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d8d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d8d4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801d8d8:	ee17 3a90 	vmov	r3, s15
 801d8dc:	7013      	strb	r3, [r2, #0]
 801d8de:	e62f      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
					else if(ts_State.touchX[0] < 200) {
 801d8e0:	2dc7      	cmp	r5, #199	; 0xc7
 801d8e2:	d831      	bhi.n	801d948 <EXTI15_10_IRQHandler+0x420>
						if(stretch >= 1) stretch++;
 801d8e4:	4e27      	ldr	r6, [pc, #156]	; (801d984 <EXTI15_10_IRQHandler+0x45c>)
 801d8e6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801d8ea:	edd6 7a00 	vldr	s15, [r6]
 801d8ee:	eef4 7ac7 	vcmpe.f32	s15, s14
 801d8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d8f6:	bfac      	ite	ge
 801d8f8:	ee77 7a87 	vaddge.f32	s15, s15, s14
						else stretch *= 2;
 801d8fc:	ee77 7aa7 	vaddlt.f32	s15, s15, s15
						if(stretch > 4) stretch = 4;
 801d900:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 801d904:	fec7 7ac7 	vminnm.f32	s15, s15, s14
 801d908:	edc6 7a00 	vstr	s15, [r6]
 801d90c:	e67f      	b.n	801d60e <EXTI15_10_IRQHandler+0xe6>
						volume = 100 * (float)(ts_State.touchX[0]-40) / 400;
 801d90e:	ee07 5a90 	vmov	s15, r5
 801d912:	4b1d      	ldr	r3, [pc, #116]	; (801d988 <EXTI15_10_IRQHandler+0x460>)
 801d914:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
 801d918:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801d91c:	edcd 7a01 	vstr	s15, [sp, #4]
 801d920:	f89d 0004 	ldrb.w	r0, [sp, #4]
 801d924:	7018      	strb	r0, [r3, #0]
						BSP_AUDIO_OUT_SetVolume(volume);
 801d926:	f7ff fa7b 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
					if((ts_State.touchY[0] > 80) && (ts_State.touchY[0] < 100)) {
 801d92a:	89a3      	ldrh	r3, [r4, #12]
 801d92c:	e704      	b.n	801d738 <EXTI15_10_IRQHandler+0x210>
							str_increment -= abs((ts_State.touchY[0] / 20 - 1) - String_number);
 801d92e:	2b00      	cmp	r3, #0
 801d930:	4916      	ldr	r1, [pc, #88]	; (801d98c <EXTI15_10_IRQHandler+0x464>)
 801d932:	bfb8      	it	lt
 801d934:	425b      	neglt	r3, r3
 801d936:	680a      	ldr	r2, [r1, #0]
							if(str_increment < 0) str_increment = 0;
 801d938:	1ad3      	subs	r3, r2, r3
 801d93a:	bf48      	it	mi
 801d93c:	2300      	movmi	r3, #0
 801d93e:	600b      	str	r3, [r1, #0]
 801d940:	e6c5      	b.n	801d6ce <EXTI15_10_IRQHandler+0x1a6>
 801d942:	ed86 8a00 	vstr	s16, [r6]
 801d946:	e662      	b.n	801d60e <EXTI15_10_IRQHandler+0xe6>
					else stretch = 1;
 801d948:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801d94c:	4b0d      	ldr	r3, [pc, #52]	; (801d984 <EXTI15_10_IRQHandler+0x45c>)
 801d94e:	601a      	str	r2, [r3, #0]
 801d950:	e65d      	b.n	801d60e <EXTI15_10_IRQHandler+0xe6>
						else stretch /= 2;
 801d952:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 801d956:	ee27 8a88 	vmul.f32	s16, s15, s16
 801d95a:	e649      	b.n	801d5f0 <EXTI15_10_IRQHandler+0xc8>
							if(str_increment > Total_tracks - 7) str_increment = Total_tracks - 7;
 801d95c:	3807      	subs	r0, #7
 801d95e:	f8cc 0000 	str.w	r0, [ip]
 801d962:	e6b4      	b.n	801d6ce <EXTI15_10_IRQHandler+0x1a6>
 801d964:	f8df 8008 	ldr.w	r8, [pc, #8]	; 801d970 <EXTI15_10_IRQHandler+0x448>
 801d968:	e656      	b.n	801d618 <EXTI15_10_IRQHandler+0xf0>
				display.timemode = 0;
 801d96a:	701c      	strb	r4, [r3, #0]
				display.trackbarmode = 0;
 801d96c:	711c      	strb	r4, [r3, #4]
 801d96e:	e5e7      	b.n	801d540 <EXTI15_10_IRQHandler+0x18>
 801d970:	20018c04 	.word	0x20018c04
 801d974:	20000c70 	.word	0x20000c70
 801d978:	20018b7c 	.word	0x20018b7c
 801d97c:	20000058 	.word	0x20000058
 801d980:	20000054 	.word	0x20000054
 801d984:	20000028 	.word	0x20000028
 801d988:	2000005c 	.word	0x2000005c
 801d98c:	20018b74 	.word	0x20018b74

0801d990 <TIM8_UP_TIM13_IRQHandler>:
  * @brief This function handles TIM8 update interrupt and TIM13 global interrupt.
  */
void TIM8_UP_TIM13_IRQHandler(void)
{
  /* USER CODE BEGIN TIM8_UP_TIM13_IRQn 0 */
	if(trak.state == STOPPED) {
 801d990:	4b0a      	ldr	r3, [pc, #40]	; (801d9bc <TIM8_UP_TIM13_IRQHandler+0x2c>)
 801d992:	781b      	ldrb	r3, [r3, #0]
 801d994:	2b01      	cmp	r3, #1
 801d996:	d009      	beq.n	801d9ac <TIM8_UP_TIM13_IRQHandler+0x1c>
		spi_tx[2] ^= (1 << 0);
	}
	if(trak.state == SETCUE) {
 801d998:	2b02      	cmp	r3, #2
 801d99a:	d104      	bne.n	801d9a6 <TIM8_UP_TIM13_IRQHandler+0x16>
		spi_tx[2] ^= (1 << 0);
		spi_tx[2] ^= (1 << 1);
 801d99c:	4a08      	ldr	r2, [pc, #32]	; (801d9c0 <TIM8_UP_TIM13_IRQHandler+0x30>)
 801d99e:	7893      	ldrb	r3, [r2, #2]
 801d9a0:	f083 0303 	eor.w	r3, r3, #3
 801d9a4:	7093      	strb	r3, [r2, #2]
	}
  /* USER CODE END TIM8_UP_TIM13_IRQn 0 */
  HAL_TIM_IRQHandler(&htim8);
 801d9a6:	4807      	ldr	r0, [pc, #28]	; (801d9c4 <TIM8_UP_TIM13_IRQHandler+0x34>)
 801d9a8:	f7e9 babc 	b.w	8006f24 <HAL_TIM_IRQHandler>
		spi_tx[2] ^= (1 << 0);
 801d9ac:	4a04      	ldr	r2, [pc, #16]	; (801d9c0 <TIM8_UP_TIM13_IRQHandler+0x30>)
  HAL_TIM_IRQHandler(&htim8);
 801d9ae:	4805      	ldr	r0, [pc, #20]	; (801d9c4 <TIM8_UP_TIM13_IRQHandler+0x34>)
		spi_tx[2] ^= (1 << 0);
 801d9b0:	7893      	ldrb	r3, [r2, #2]
 801d9b2:	f083 0301 	eor.w	r3, r3, #1
 801d9b6:	7093      	strb	r3, [r2, #2]
  HAL_TIM_IRQHandler(&htim8);
 801d9b8:	f7e9 bab4 	b.w	8006f24 <HAL_TIM_IRQHandler>
 801d9bc:	2000fa7c 	.word	0x2000fa7c
 801d9c0:	20000058 	.word	0x20000058
 801d9c4:	20018c84 	.word	0x20018c84

0801d9c8 <TIM5_IRQHandler>:

/**
  * @brief This function handles TIM5 global interrupt.
  */
void TIM5_IRQHandler(void)
{
 801d9c8:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE BEGIN TIM5_IRQn 0 */
	if(pulses != old_pulses) {
 801d9ca:	4c23      	ldr	r4, [pc, #140]	; (801da58 <TIM5_IRQHandler+0x90>)
 801d9cc:	4d23      	ldr	r5, [pc, #140]	; (801da5c <TIM5_IRQHandler+0x94>)
 801d9ce:	6823      	ldr	r3, [r4, #0]
 801d9d0:	682a      	ldr	r2, [r5, #0]
 801d9d2:	4293      	cmp	r3, r2
 801d9d4:	d01b      	beq.n	801da0e <TIM5_IRQHandler+0x46>
		if(pulses != 0) {
 801d9d6:	bb0b      	cbnz	r3, 801da1c <TIM5_IRQHandler+0x54>
			New_frequency = (uint32_t)((trak.bitrate / 2)
					*(1 + trak.percent + jog_sensitivity*pulses));
		}
		else {
			New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801d9d8:	4921      	ldr	r1, [pc, #132]	; (801da60 <TIM5_IRQHandler+0x98>)
 801d9da:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801d9de:	4a21      	ldr	r2, [pc, #132]	; (801da64 <TIM5_IRQHandler+0x9c>)
 801d9e0:	890b      	ldrh	r3, [r1, #8]
 801d9e2:	ed91 7a01 	vldr	s14, [r1, #4]
 801d9e6:	085b      	lsrs	r3, r3, #1
 801d9e8:	ee37 7a26 	vadd.f32	s14, s14, s13
 801d9ec:	ee07 3a90 	vmov	s15, r3
 801d9f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d9f4:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d9f8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801d9fc:	edc2 7a00 	vstr	s15, [r2]
		}
		BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801da00:	6811      	ldr	r1, [r2, #0]
 801da02:	2200      	movs	r2, #0
 801da04:	4818      	ldr	r0, [pc, #96]	; (801da68 <TIM5_IRQHandler+0xa0>)
 801da06:	f7ff faaf 	bl	801cf68 <BSP_AUDIO_OUT_ClockConfig>
		old_pulses = pulses;
 801da0a:	6823      	ldr	r3, [r4, #0]
 801da0c:	602b      	str	r3, [r5, #0]
	}
	pulses = 0;
 801da0e:	2300      	movs	r3, #0
  /* USER CODE END TIM5_IRQn 0 */
  HAL_TIM_IRQHandler(&htim5);
 801da10:	4816      	ldr	r0, [pc, #88]	; (801da6c <TIM5_IRQHandler+0xa4>)
	pulses = 0;
 801da12:	6023      	str	r3, [r4, #0]
  /* USER CODE BEGIN TIM5_IRQn 1 */

  /* USER CODE END TIM5_IRQn 1 */
}
 801da14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_TIM_IRQHandler(&htim5);
 801da18:	f7e9 ba84 	b.w	8006f24 <HAL_TIM_IRQHandler>
					*(1 + trak.percent + jog_sensitivity*pulses));
 801da1c:	4a10      	ldr	r2, [pc, #64]	; (801da60 <TIM5_IRQHandler+0x98>)
 801da1e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801da22:	ee07 3a90 	vmov	s15, r3
 801da26:	4912      	ldr	r1, [pc, #72]	; (801da70 <TIM5_IRQHandler+0xa8>)
 801da28:	edd2 6a01 	vldr	s13, [r2, #4]
 801da2c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			New_frequency = (uint32_t)((trak.bitrate / 2)
 801da30:	8913      	ldrh	r3, [r2, #8]
					*(1 + trak.percent + jog_sensitivity*pulses));
 801da32:	ee76 6a87 	vadd.f32	s13, s13, s14
 801da36:	ed91 6a00 	vldr	s12, [r1]
			New_frequency = (uint32_t)((trak.bitrate / 2)
 801da3a:	085b      	lsrs	r3, r3, #1
 801da3c:	4a09      	ldr	r2, [pc, #36]	; (801da64 <TIM5_IRQHandler+0x9c>)
					*(1 + trak.percent + jog_sensitivity*pulses));
 801da3e:	eee7 6a86 	vfma.f32	s13, s15, s12
 801da42:	ee07 3a10 	vmov	s14, r3
 801da46:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801da4a:	ee67 7a26 	vmul.f32	s15, s14, s13
			New_frequency = (uint32_t)((trak.bitrate / 2)
 801da4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801da52:	edc2 7a00 	vstr	s15, [r2]
 801da56:	e7d3      	b.n	801da00 <TIM5_IRQHandler+0x38>
 801da58:	20018b70 	.word	0x20018b70
 801da5c:	20018b68 	.word	0x20018b68
 801da60:	2000fa7c 	.word	0x2000fa7c
 801da64:	20000068 	.word	0x20000068
 801da68:	20018934 	.word	0x20018934
 801da6c:	20018bc4 	.word	0x20018bc4
 801da70:	20000070 	.word	0x20000070

0801da74 <TIM6_DAC_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt, DAC1 and DAC2 underrun error interrupts.
  */
void TIM6_DAC_IRQHandler(void)
{
 801da74:	b510      	push	{r4, lr}
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 801da76:	4b08      	ldr	r3, [pc, #32]	; (801da98 <TIM6_DAC_IRQHandler+0x24>)
 801da78:	f44f 7280 	mov.w	r2, #256	; 0x100
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */
	NVIC_EnableIRQ(EXTI15_10_IRQn);
	HAL_TIM_Base_Stop_IT(&htim6);
 801da7c:	4c07      	ldr	r4, [pc, #28]	; (801da9c <TIM6_DAC_IRQHandler+0x28>)
 801da7e:	605a      	str	r2, [r3, #4]
 801da80:	4620      	mov	r0, r4
 801da82:	f7e8 fef3 	bl	800686c <HAL_TIM_Base_Stop_IT>
	touch_count = 0;
 801da86:	4b06      	ldr	r3, [pc, #24]	; (801daa0 <TIM6_DAC_IRQHandler+0x2c>)
 801da88:	2200      	movs	r2, #0

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 801da8a:	4620      	mov	r0, r4
	touch_count = 0;
 801da8c:	701a      	strb	r2, [r3, #0]
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
 801da8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_TIM_IRQHandler(&htim6);
 801da92:	f7e9 ba47 	b.w	8006f24 <HAL_TIM_IRQHandler>
 801da96:	bf00      	nop
 801da98:	e000e100 	.word	0xe000e100
 801da9c:	20018c04 	.word	0x20018c04
 801daa0:	20018b7c 	.word	0x20018b7c

0801daa4 <TIM7_IRQHandler>:
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
  /* USER CODE BEGIN TIM7_IRQn 0 */
	if(display.trackbarmode == 0) display.trackbarmode = 1;
 801daa4:	4a04      	ldr	r2, [pc, #16]	; (801dab8 <TIM7_IRQHandler+0x14>)
	else display.trackbarmode = 0;
  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
 801daa6:	4805      	ldr	r0, [pc, #20]	; (801dabc <TIM7_IRQHandler+0x18>)
	if(display.trackbarmode == 0) display.trackbarmode = 1;
 801daa8:	7913      	ldrb	r3, [r2, #4]
 801daaa:	fab3 f383 	clz	r3, r3
 801daae:	095b      	lsrs	r3, r3, #5
 801dab0:	7113      	strb	r3, [r2, #4]
  HAL_TIM_IRQHandler(&htim7);
 801dab2:	f7e9 ba37 	b.w	8006f24 <HAL_TIM_IRQHandler>
 801dab6:	bf00      	nop
 801dab8:	20000c70 	.word	0x20000c70
 801dabc:	20018c44 	.word	0x20018c44

0801dac0 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai2_a);
 801dac0:	4801      	ldr	r0, [pc, #4]	; (801dac8 <DMA2_Stream4_IRQHandler+0x8>)
 801dac2:	f7e3 beb7 	b.w	8001834 <HAL_DMA_IRQHandler>
 801dac6:	bf00      	nop
 801dac8:	200188d4 	.word	0x200188d4

0801dacc <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_FS);
 801dacc:	4801      	ldr	r0, [pc, #4]	; (801dad4 <OTG_FS_IRQHandler+0x8>)
 801dace:	f7e4 bc83 	b.w	80023d8 <HAL_HCD_IRQHandler>
 801dad2:	bf00      	nop
 801dad4:	200191e0 	.word	0x200191e0

0801dad8 <OTG_HS_IRQHandler>:
void OTG_HS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

  /* USER CODE END OTG_HS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_HS);
 801dad8:	4801      	ldr	r0, [pc, #4]	; (801dae0 <OTG_HS_IRQHandler+0x8>)
 801dada:	f7e4 bc7d 	b.w	80023d8 <HAL_HCD_IRQHandler>
 801dade:	bf00      	nop
 801dae0:	200194e8 	.word	0x200194e8

0801dae4 <HAL_SPI_TxRxCpltCallback>:
/*
 *
 * External MIDI signal handler
 *
 */
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
 801dae4:	b570      	push	{r4, r5, r6, lr}
	switch(spi_rx[1] & 0xF0) {
 801dae6:	4cae      	ldr	r4, [pc, #696]	; (801dda0 <HAL_SPI_TxRxCpltCallback+0x2bc>)
 801dae8:	7863      	ldrb	r3, [r4, #1]
 801daea:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801daee:	2bb0      	cmp	r3, #176	; 0xb0
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
 801daf0:	ed2d 8b02 	vpush	{d8}
	switch(spi_rx[1] & 0xF0) {
 801daf4:	d018      	beq.n	801db28 <HAL_SPI_TxRxCpltCallback+0x44>
 801daf6:	d832      	bhi.n	801db5e <HAL_SPI_TxRxCpltCallback+0x7a>
 801daf8:	2b80      	cmp	r3, #128	; 0x80
 801dafa:	d03e      	beq.n	801db7a <HAL_SPI_TxRxCpltCallback+0x96>
 801dafc:	2b90      	cmp	r3, #144	; 0x90
 801dafe:	d122      	bne.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
	case 0x90: {
		switch(spi_rx[2]) {
 801db00:	78a3      	ldrb	r3, [r4, #2]
 801db02:	3b40      	subs	r3, #64	; 0x40
 801db04:	2b0d      	cmp	r3, #13
 801db06:	d81e      	bhi.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
 801db08:	e8df f013 	tbh	[pc, r3, lsl #1]
 801db0c:	027301a2 	.word	0x027301a2
 801db10:	01f9001d 	.word	0x01f9001d
 801db14:	01390176 	.word	0x01390176
 801db18:	020201f0 	.word	0x020201f0
 801db1c:	0186023c 	.word	0x0186023c
 801db20:	02450257 	.word	0x02450257
 801db24:	021401b1 	.word	0x021401b1
			default: break;
			}
			break;
		}
		case 0xB0: {
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801db28:	2028      	movs	r0, #40	; 0x28
			__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801db2a:	2500      	movs	r5, #0
			HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801db2c:	f7e3 fb34 	bl	8001198 <HAL_NVIC_DisableIRQ>
			__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801db30:	489c      	ldr	r0, [pc, #624]	; (801dda4 <HAL_SPI_TxRxCpltCallback+0x2c0>)
 801db32:	f06f 0201 	mvn.w	r2, #1
 801db36:	6803      	ldr	r3, [r0, #0]
 801db38:	611a      	str	r2, [r3, #16]
			__HAL_TIM_SET_COUNTER(&htim6, 0);
 801db3a:	625d      	str	r5, [r3, #36]	; 0x24
			HAL_TIM_Base_Start_IT(&htim6);
 801db3c:	f7e8 fe16 	bl	800676c <HAL_TIM_Base_Start_IT>
			if(spi_rx[2] == 0x24) {
 801db40:	78a3      	ldrb	r3, [r4, #2]
 801db42:	2b24      	cmp	r3, #36	; 0x24
 801db44:	d06c      	beq.n	801dc20 <HAL_SPI_TxRxCpltCallback+0x13c>
			}
			break;
		}
		default: break;
		}
	for(int i = 0; i < 4; i++) spi_rx[i] = 0;
 801db46:	2000      	movs	r0, #0
	HAL_SPI_TransmitReceive_IT(&hspi2, spi_tx, spi_rx, 4);
 801db48:	2304      	movs	r3, #4
 801db4a:	4a95      	ldr	r2, [pc, #596]	; (801dda0 <HAL_SPI_TxRxCpltCallback+0x2bc>)
	for(int i = 0; i < 4; i++) spi_rx[i] = 0;
 801db4c:	6020      	str	r0, [r4, #0]
	HAL_SPI_TransmitReceive_IT(&hspi2, spi_tx, spi_rx, 4);
 801db4e:	4996      	ldr	r1, [pc, #600]	; (801dda8 <HAL_SPI_TxRxCpltCallback+0x2c4>)
 801db50:	4896      	ldr	r0, [pc, #600]	; (801ddac <HAL_SPI_TxRxCpltCallback+0x2c8>)
}
 801db52:	ecbd 8b02 	vpop	{d8}
 801db56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	HAL_SPI_TransmitReceive_IT(&hspi2, spi_tx, spi_rx, 4);
 801db5a:	f7e8 ba7b 	b.w	8006054 <HAL_SPI_TransmitReceive_IT>
	switch(spi_rx[1] & 0xF0) {
 801db5e:	2be0      	cmp	r3, #224	; 0xe0
 801db60:	d1f1      	bne.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(flag == 0) {
 801db62:	4993      	ldr	r1, [pc, #588]	; (801ddb0 <HAL_SPI_TxRxCpltCallback+0x2cc>)
			pitch_rx |= spi_rx[2];
 801db64:	8863      	ldrh	r3, [r4, #2]
			if(flag == 0) {
 801db66:	780a      	ldrb	r2, [r1, #0]
				if(trak.pitch == 0) trak.pitch = pitch_rx;
 801db68:	4e92      	ldr	r6, [pc, #584]	; (801ddb4 <HAL_SPI_TxRxCpltCallback+0x2d0>)
			if(flag == 0) {
 801db6a:	bb1a      	cbnz	r2, 801dbb4 <HAL_SPI_TxRxCpltCallback+0xd0>
				if(trak.pitch == 0) trak.pitch = pitch_rx;
 801db6c:	8872      	ldrh	r2, [r6, #2]
 801db6e:	b90a      	cbnz	r2, 801db74 <HAL_SPI_TxRxCpltCallback+0x90>
 801db70:	461a      	mov	r2, r3
 801db72:	8073      	strh	r3, [r6, #2]
				flag = 1;
 801db74:	2001      	movs	r0, #1
 801db76:	7008      	strb	r0, [r1, #0]
 801db78:	e01d      	b.n	801dbb6 <HAL_SPI_TxRxCpltCallback+0xd2>
			switch(spi_rx[2]) {
 801db7a:	78a3      	ldrb	r3, [r4, #2]
 801db7c:	3b40      	subs	r3, #64	; 0x40
 801db7e:	2b0a      	cmp	r3, #10
 801db80:	d8e1      	bhi.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
 801db82:	a201      	add	r2, pc, #4	; (adr r2, 801db88 <HAL_SPI_TxRxCpltCallback+0xa4>)
 801db84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801db88:	0801dc4d 	.word	0x0801dc4d
 801db8c:	0801dc77 	.word	0x0801dc77
 801db90:	0801db47 	.word	0x0801db47
 801db94:	0801dcd9 	.word	0x0801dcd9
 801db98:	0801db47 	.word	0x0801db47
 801db9c:	0801db47 	.word	0x0801db47
 801dba0:	0801db47 	.word	0x0801db47
 801dba4:	0801db47 	.word	0x0801db47
 801dba8:	0801dc6f 	.word	0x0801dc6f
 801dbac:	0801db47 	.word	0x0801db47
 801dbb0:	0801dca5 	.word	0x0801dca5
			int delta = trak.pitch - pitch_rx;
 801dbb4:	8872      	ldrh	r2, [r6, #2]
			if(delta < 0) delta = pitch_rx - trak.pitch;
 801dbb6:	1ad1      	subs	r1, r2, r3
 801dbb8:	bf48      	it	mi
 801dbba:	1a99      	submi	r1, r3, r2
			if(delta < 16384) {
 801dbbc:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 801dbc0:	dac1      	bge.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
 801dbc2:	2b40      	cmp	r3, #64	; 0x40
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dbc4:	eddf 7a7c 	vldr	s15, [pc, #496]	; 801ddb8 <HAL_SPI_TxRxCpltCallback+0x2d4>
 801dbc8:	eddf 5a7c 	vldr	s11, [pc, #496]	; 801ddbc <HAL_SPI_TxRxCpltCallback+0x2d8>
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dbcc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801dbd0:	bf38      	it	cc
 801dbd2:	2340      	movcc	r3, #64	; 0x40
 801dbd4:	4a7a      	ldr	r2, [pc, #488]	; (801ddc0 <HAL_SPI_TxRxCpltCallback+0x2dc>)
				BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801dbd6:	487b      	ldr	r0, [pc, #492]	; (801ddc4 <HAL_SPI_TxRxCpltCallback+0x2e0>)
 801dbd8:	461d      	mov	r5, r3
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dbda:	4b7b      	ldr	r3, [pc, #492]	; (801ddc8 <HAL_SPI_TxRxCpltCallback+0x2e4>)
 801dbdc:	ee07 5a10 	vmov	s14, r5
 801dbe0:	ed93 6a00 	vldr	s12, [r3]
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dbe4:	8933      	ldrh	r3, [r6, #8]
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dbe6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801dbea:	ee26 6a25 	vmul.f32	s12, s12, s11
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dbee:	085b      	lsrs	r3, r3, #1
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dbf0:	ee37 7a67 	vsub.f32	s14, s14, s15
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dbf4:	ee07 3a90 	vmov	s15, r3
 801dbf8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dbfc:	ee27 7a06 	vmul.f32	s14, s14, s12
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dc00:	ee77 6a26 	vadd.f32	s13, s14, s13
				trak.percent = ((float)pitch_rx - 16383) / 16384 * scale_pitch;
 801dc04:	ed86 7a01 	vstr	s14, [r6, #4]
				New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dc08:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801dc0c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801dc10:	edc2 7a00 	vstr	s15, [r2]
				BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801dc14:	6811      	ldr	r1, [r2, #0]
 801dc16:	2200      	movs	r2, #0
 801dc18:	f7ff f9a6 	bl	801cf68 <BSP_AUDIO_OUT_ClockConfig>
				trak.pitch = pitch_rx;
 801dc1c:	8075      	strh	r5, [r6, #2]
 801dc1e:	e792      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if(spi_rx[3] == 0x01) {
 801dc20:	78e3      	ldrb	r3, [r4, #3]
 801dc22:	2b01      	cmp	r3, #1
 801dc24:	f000 809b 	beq.w	801dd5e <HAL_SPI_TxRxCpltCallback+0x27a>
				else if(spi_rx[3] == 0x7F) {
 801dc28:	2b7f      	cmp	r3, #127	; 0x7f
 801dc2a:	d18c      	bne.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					if(menu_mode == 1) {
 801dc2c:	4b67      	ldr	r3, [pc, #412]	; (801ddcc <HAL_SPI_TxRxCpltCallback+0x2e8>)
 801dc2e:	f993 3000 	ldrsb.w	r3, [r3]
 801dc32:	2b01      	cmp	r3, #1
 801dc34:	f000 82d2 	beq.w	801e1dc <HAL_SPI_TxRxCpltCallback+0x6f8>
						if(trak.state == PLAYING) {
 801dc38:	4b5e      	ldr	r3, [pc, #376]	; (801ddb4 <HAL_SPI_TxRxCpltCallback+0x2d0>)
 801dc3a:	781b      	ldrb	r3, [r3, #0]
 801dc3c:	2b00      	cmp	r3, #0
 801dc3e:	f040 82c2 	bne.w	801e1c6 <HAL_SPI_TxRxCpltCallback+0x6e2>
							pulses--;
 801dc42:	4a63      	ldr	r2, [pc, #396]	; (801ddd0 <HAL_SPI_TxRxCpltCallback+0x2ec>)
 801dc44:	6813      	ldr	r3, [r2, #0]
 801dc46:	3b01      	subs	r3, #1
 801dc48:	6013      	str	r3, [r2, #0]
 801dc4a:	e77c      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if((__HAL_TIM_GET_COUNTER(&htim9) < 65535)
 801dc4c:	4861      	ldr	r0, [pc, #388]	; (801ddd4 <HAL_SPI_TxRxCpltCallback+0x2f0>)
 801dc4e:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 801dc52:	6803      	ldr	r3, [r0, #0]
 801dc54:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801dc56:	4291      	cmp	r1, r2
 801dc58:	d809      	bhi.n	801dc6e <HAL_SPI_TxRxCpltCallback+0x18a>
						&& (__HAL_TIM_GET_COUNTER(&htim9) > 0)) {
 801dc5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801dc5c:	b13b      	cbz	r3, 801dc6e <HAL_SPI_TxRxCpltCallback+0x18a>
					HAL_TIM_Base_Stop_IT(&htim9);
 801dc5e:	f7e8 fe05 	bl	800686c <HAL_TIM_Base_Stop_IT>
					if(display.loop == 1) display.loop = 0;
 801dc62:	4b5d      	ldr	r3, [pc, #372]	; (801ddd8 <HAL_SPI_TxRxCpltCallback+0x2f4>)
 801dc64:	7c1a      	ldrb	r2, [r3, #16]
 801dc66:	2a01      	cmp	r2, #1
 801dc68:	d101      	bne.n	801dc6e <HAL_SPI_TxRxCpltCallback+0x18a>
 801dc6a:	2200      	movs	r2, #0
 801dc6c:	741a      	strb	r2, [r3, #16]
				button_flag &= (0 << 2);
 801dc6e:	4b5b      	ldr	r3, [pc, #364]	; (801dddc <HAL_SPI_TxRxCpltCallback+0x2f8>)
 801dc70:	2200      	movs	r2, #0
 801dc72:	801a      	strh	r2, [r3, #0]
				break;
 801dc74:	e767      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if((__HAL_TIM_GET_COUNTER(&htim9) < 65535)
 801dc76:	4857      	ldr	r0, [pc, #348]	; (801ddd4 <HAL_SPI_TxRxCpltCallback+0x2f0>)
 801dc78:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 801dc7c:	6803      	ldr	r3, [r0, #0]
 801dc7e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801dc80:	4291      	cmp	r1, r2
 801dc82:	f63f af60 	bhi.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
						&& (__HAL_TIM_GET_COUNTER(&htim9) > 0)) {
 801dc86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801dc88:	2b00      	cmp	r3, #0
 801dc8a:	f43f af5c 	beq.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					HAL_TIM_Base_Stop_IT(&htim9);
 801dc8e:	f7e8 fded 	bl	800686c <HAL_TIM_Base_Stop_IT>
					if(display.timemode == 0) {
 801dc92:	4b51      	ldr	r3, [pc, #324]	; (801ddd8 <HAL_SPI_TxRxCpltCallback+0x2f4>)
 801dc94:	781a      	ldrb	r2, [r3, #0]
 801dc96:	2a00      	cmp	r2, #0
 801dc98:	f040 82ec 	bne.w	801e274 <HAL_SPI_TxRxCpltCallback+0x790>
						display.timemode = 1;
 801dc9c:	2201      	movs	r2, #1
 801dc9e:	701a      	strb	r2, [r3, #0]
						display.trackbarmode = 1;
 801dca0:	711a      	strb	r2, [r3, #4]
 801dca2:	e750      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if(trak.state == PLAYING) {
 801dca4:	4d43      	ldr	r5, [pc, #268]	; (801ddb4 <HAL_SPI_TxRxCpltCallback+0x2d0>)
 801dca6:	782b      	ldrb	r3, [r5, #0]
 801dca8:	2b00      	cmp	r3, #0
 801dcaa:	f47f af4c 	bne.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					BSP_AUDIO_OUT_Pause();
 801dcae:	f7ff f88b 	bl	801cdc8 <BSP_AUDIO_OUT_Pause>
					trak.state = STOPPED;
 801dcb2:	2301      	movs	r3, #1
					HAL_TIM_Base_Start_IT(&htim8); //start blinking
 801dcb4:	484a      	ldr	r0, [pc, #296]	; (801dde0 <HAL_SPI_TxRxCpltCallback+0x2fc>)
					trak.state = STOPPED;
 801dcb6:	702b      	strb	r3, [r5, #0]
					HAL_TIM_Base_Start_IT(&htim8); //start blinking
 801dcb8:	f7e8 fd58 	bl	800676c <HAL_TIM_Base_Start_IT>
					GoToPosition(rekordbox.cue_start_position[rekordbox.currentcue]);
 801dcbc:	4a49      	ldr	r2, [pc, #292]	; (801dde4 <HAL_SPI_TxRxCpltCallback+0x300>)
 801dcbe:	f502 5340 	add.w	r3, r2, #12288	; 0x3000
 801dcc2:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 801dcc6:	f603 4312 	addw	r3, r3, #3090	; 0xc12
 801dcca:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 801dcce:	f001 f91f 	bl	801ef10 <GoToPosition>
					TrackTime();
 801dcd2:	f001 f8c5 	bl	801ee60 <TrackTime>
 801dcd6:	e736      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if((__HAL_TIM_GET_COUNTER(&htim9) < 65535)
 801dcd8:	483e      	ldr	r0, [pc, #248]	; (801ddd4 <HAL_SPI_TxRxCpltCallback+0x2f0>)
 801dcda:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 801dcde:	6803      	ldr	r3, [r0, #0]
 801dce0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801dce2:	4291      	cmp	r1, r2
 801dce4:	f63f af2f 	bhi.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
						&& (__HAL_TIM_GET_COUNTER(&htim9) > 0)) {
 801dce8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801dcea:	2b00      	cmp	r3, #0
 801dcec:	f43f af2b 	beq.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					HAL_TIM_Base_Stop_IT(&htim9);
 801dcf0:	f7e8 fdbc 	bl	800686c <HAL_TIM_Base_Stop_IT>
					display.pitchmode++;
 801dcf4:	4a38      	ldr	r2, [pc, #224]	; (801ddd8 <HAL_SPI_TxRxCpltCallback+0x2f4>)
 801dcf6:	7853      	ldrb	r3, [r2, #1]
 801dcf8:	3301      	adds	r3, #1
 801dcfa:	b2db      	uxtb	r3, r3
					if(display.pitchmode > 3) display.pitchmode = 0;
 801dcfc:	2b03      	cmp	r3, #3
					display.pitchmode++;
 801dcfe:	7053      	strb	r3, [r2, #1]
					if(display.pitchmode > 3) display.pitchmode = 0;
 801dd00:	f240 82ab 	bls.w	801e25a <HAL_SPI_TxRxCpltCallback+0x776>
 801dd04:	2300      	movs	r3, #0
 801dd06:	7053      	strb	r3, [r2, #1]
					if(display.pitchmode == 0) scale_pitch = 1; //wide
 801dd08:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801dd0c:	4b2e      	ldr	r3, [pc, #184]	; (801ddc8 <HAL_SPI_TxRxCpltCallback+0x2e4>)
 801dd0e:	eddf 6a2b 	vldr	s13, [pc, #172]	; 801ddbc <HAL_SPI_TxRxCpltCallback+0x2d8>
 801dd12:	601a      	str	r2, [r3, #0]
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd14:	4927      	ldr	r1, [pc, #156]	; (801ddb4 <HAL_SPI_TxRxCpltCallback+0x2d0>)
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd16:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd1a:	eddf 5a33 	vldr	s11, [pc, #204]	; 801dde8 <HAL_SPI_TxRxCpltCallback+0x304>
					BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801dd1e:	2200      	movs	r2, #0
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd20:	884b      	ldrh	r3, [r1, #2]
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd22:	4d27      	ldr	r5, [pc, #156]	; (801ddc0 <HAL_SPI_TxRxCpltCallback+0x2dc>)
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd24:	ee07 3a10 	vmov	s14, r3
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd28:	890b      	ldrh	r3, [r1, #8]
					BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801dd2a:	4826      	ldr	r0, [pc, #152]	; (801ddc4 <HAL_SPI_TxRxCpltCallback+0x2e0>)
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd2c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd30:	085b      	lsrs	r3, r3, #1
 801dd32:	ee07 3a90 	vmov	s15, r3
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd36:	ee37 7a65 	vsub.f32	s14, s14, s11
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd3e:	ee27 7a26 	vmul.f32	s14, s14, s13
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd42:	ee77 6a06 	vadd.f32	s13, s14, s12
					trak.percent = ((float)trak.pitch - 16384) / 16384 * scale_pitch;
 801dd46:	ed81 7a01 	vstr	s14, [r1, #4]
					New_frequency = (uint32_t)((trak.bitrate / 2)*(1 + trak.percent));
 801dd4a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801dd4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801dd52:	edc5 7a00 	vstr	s15, [r5]
					BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, New_frequency, NULL);
 801dd56:	6829      	ldr	r1, [r5, #0]
 801dd58:	f7ff f906 	bl	801cf68 <BSP_AUDIO_OUT_ClockConfig>
 801dd5c:	e6f3      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					if(menu_mode == 1) {
 801dd5e:	4b1b      	ldr	r3, [pc, #108]	; (801ddcc <HAL_SPI_TxRxCpltCallback+0x2e8>)
 801dd60:	f993 3000 	ldrsb.w	r3, [r3]
 801dd64:	2b01      	cmp	r3, #1
 801dd66:	f000 814d 	beq.w	801e004 <HAL_SPI_TxRxCpltCallback+0x520>
						if(trak.state == PLAYING) {
 801dd6a:	4b12      	ldr	r3, [pc, #72]	; (801ddb4 <HAL_SPI_TxRxCpltCallback+0x2d0>)
 801dd6c:	781b      	ldrb	r3, [r3, #0]
 801dd6e:	2b00      	cmp	r3, #0
 801dd70:	f040 8159 	bne.w	801e026 <HAL_SPI_TxRxCpltCallback+0x542>
							pulses++;
 801dd74:	4a16      	ldr	r2, [pc, #88]	; (801ddd0 <HAL_SPI_TxRxCpltCallback+0x2ec>)
 801dd76:	6813      	ldr	r3, [r2, #0]
 801dd78:	3301      	adds	r3, #1
 801dd7a:	6013      	str	r3, [r2, #0]
 801dd7c:	e6e3      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(!(button_flag & (1 << 2))) {
 801dd7e:	4b17      	ldr	r3, [pc, #92]	; (801dddc <HAL_SPI_TxRxCpltCallback+0x2f8>)
 801dd80:	881b      	ldrh	r3, [r3, #0]
 801dd82:	075b      	lsls	r3, r3, #29
 801dd84:	f100 81ba 	bmi.w	801e0fc <HAL_SPI_TxRxCpltCallback+0x618>
				Track_number++;
 801dd88:	4a18      	ldr	r2, [pc, #96]	; (801ddec <HAL_SPI_TxRxCpltCallback+0x308>)
				bOutOfData = 1;
 801dd8a:	2001      	movs	r0, #1
 801dd8c:	4b18      	ldr	r3, [pc, #96]	; (801ddf0 <HAL_SPI_TxRxCpltCallback+0x30c>)
				unDmaBufMode = 3;
 801dd8e:	4919      	ldr	r1, [pc, #100]	; (801ddf4 <HAL_SPI_TxRxCpltCallback+0x310>)
				bOutOfData = 1;
 801dd90:	6018      	str	r0, [r3, #0]
				unDmaBufMode = 3;
 801dd92:	2003      	movs	r0, #3
				Track_number++;
 801dd94:	6813      	ldr	r3, [r2, #0]
				unDmaBufMode = 3;
 801dd96:	6008      	str	r0, [r1, #0]
				Track_number++;
 801dd98:	3301      	adds	r3, #1
 801dd9a:	6013      	str	r3, [r2, #0]
 801dd9c:	e6d3      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
 801dd9e:	bf00      	nop
 801dda0:	2000fa74 	.word	0x2000fa74
 801dda4:	20018c04 	.word	0x20018c04
 801dda8:	20000058 	.word	0x20000058
 801ddac:	20018a40 	.word	0x20018a40
 801ddb0:	20018b64 	.word	0x20018b64
 801ddb4:	2000fa7c 	.word	0x2000fa7c
 801ddb8:	467ffc00 	.word	0x467ffc00
 801ddbc:	38800000 	.word	0x38800000
 801ddc0:	20000068 	.word	0x20000068
 801ddc4:	20018934 	.word	0x20018934
 801ddc8:	20000074 	.word	0x20000074
 801ddcc:	20000c8c 	.word	0x20000c8c
 801ddd0:	20018b70 	.word	0x20018b70
 801ddd4:	20018cc4 	.word	0x20018cc4
 801ddd8:	20000c70 	.word	0x20000c70
 801dddc:	20018b62 	.word	0x20018b62
 801dde0:	20018c84 	.word	0x20018c84
 801dde4:	200154f0 	.word	0x200154f0
 801dde8:	46800000 	.word	0x46800000
 801ddec:	2000e9fc 	.word	0x2000e9fc
 801ddf0:	2000ec30 	.word	0x2000ec30
 801ddf4:	2000fab4 	.word	0x2000fab4
			if(!(button_flag & (1 << 2))) {
 801ddf8:	4ba9      	ldr	r3, [pc, #676]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
 801ddfa:	881b      	ldrh	r3, [r3, #0]
 801ddfc:	075a      	lsls	r2, r3, #29
 801ddfe:	f100 818c 	bmi.w	801e11a <HAL_SPI_TxRxCpltCallback+0x636>
				Track_number--;
 801de02:	4aa8      	ldr	r2, [pc, #672]	; (801e0a4 <HAL_SPI_TxRxCpltCallback+0x5c0>)
				bOutOfData = 1;
 801de04:	2001      	movs	r0, #1
 801de06:	4ba8      	ldr	r3, [pc, #672]	; (801e0a8 <HAL_SPI_TxRxCpltCallback+0x5c4>)
				unDmaBufMode = 3;
 801de08:	49a8      	ldr	r1, [pc, #672]	; (801e0ac <HAL_SPI_TxRxCpltCallback+0x5c8>)
				bOutOfData = 1;
 801de0a:	6018      	str	r0, [r3, #0]
				unDmaBufMode = 3;
 801de0c:	2003      	movs	r0, #3
				Track_number--;
 801de0e:	6813      	ldr	r3, [r2, #0]
				unDmaBufMode = 3;
 801de10:	6008      	str	r0, [r1, #0]
				Track_number--;
 801de12:	3b01      	subs	r3, #1
 801de14:	6013      	str	r3, [r2, #0]
 801de16:	e696      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(trak.state == PLAYING) {
 801de18:	4ea5      	ldr	r6, [pc, #660]	; (801e0b0 <HAL_SPI_TxRxCpltCallback+0x5cc>)
 801de1a:	7833      	ldrb	r3, [r6, #0]
 801de1c:	2b00      	cmp	r3, #0
 801de1e:	f040 8191 	bne.w	801e144 <HAL_SPI_TxRxCpltCallback+0x660>
				BSP_AUDIO_OUT_Pause();
 801de22:	f7fe ffd1 	bl	801cdc8 <BSP_AUDIO_OUT_Pause>
				if(!spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801de26:	4ba3      	ldr	r3, [pc, #652]	; (801e0b4 <HAL_SPI_TxRxCpltCallback+0x5d0>)
 801de28:	789a      	ldrb	r2, [r3, #2]
 801de2a:	2a00      	cmp	r2, #0
 801de2c:	f000 820e 	beq.w	801e24c <HAL_SPI_TxRxCpltCallback+0x768>
				else spi_tx[2] &= ~(1 << 1);
 801de30:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 801de34:	709a      	strb	r2, [r3, #2]
				HAL_TIM_Base_Start_IT(&htim8); //start blinking
 801de36:	48a0      	ldr	r0, [pc, #640]	; (801e0b8 <HAL_SPI_TxRxCpltCallback+0x5d4>)
 801de38:	f7e8 fc98 	bl	800676c <HAL_TIM_Base_Start_IT>
				if(file_pos_wide != rekordbox.cue_start_position[0]) {
 801de3c:	4a9f      	ldr	r2, [pc, #636]	; (801e0bc <HAL_SPI_TxRxCpltCallback+0x5d8>)
 801de3e:	4ba0      	ldr	r3, [pc, #640]	; (801e0c0 <HAL_SPI_TxRxCpltCallback+0x5dc>)
 801de40:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801de42:	681b      	ldr	r3, [r3, #0]
 801de44:	429a      	cmp	r2, r3
					trak.state = SETCUE;
 801de46:	bf14      	ite	ne
 801de48:	2302      	movne	r3, #2
					trak.state = STOPPED;
 801de4a:	2301      	moveq	r3, #1
 801de4c:	7033      	strb	r3, [r6, #0]
 801de4e:	e67a      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			button_flag ^= (1 << 3);
 801de50:	4a93      	ldr	r2, [pc, #588]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
			__HAL_TIM_CLEAR_IT(&htim9, TIM_IT_UPDATE);
 801de52:	f06f 0501 	mvn.w	r5, #1
 801de56:	489b      	ldr	r0, [pc, #620]	; (801e0c4 <HAL_SPI_TxRxCpltCallback+0x5e0>)
			__HAL_TIM_SET_COUNTER(&htim9, 0);
 801de58:	2100      	movs	r1, #0
			button_flag ^= (1 << 3);
 801de5a:	8813      	ldrh	r3, [r2, #0]
 801de5c:	f083 0308 	eor.w	r3, r3, #8
			button_flag ^= (1 << 1);
 801de60:	8013      	strh	r3, [r2, #0]
			__HAL_TIM_CLEAR_IT(&htim9, TIM_IT_UPDATE);
 801de62:	6803      	ldr	r3, [r0, #0]
 801de64:	611d      	str	r5, [r3, #16]
			__HAL_TIM_SET_COUNTER(&htim9, 0);
 801de66:	6259      	str	r1, [r3, #36]	; 0x24
			HAL_TIM_Base_Start_IT(&htim9);
 801de68:	f7e8 fc80 	bl	800676c <HAL_TIM_Base_Start_IT>
			break;
 801de6c:	e66b      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(!(button_flag & (1 << 2))) {
 801de6e:	4b8c      	ldr	r3, [pc, #560]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
 801de70:	881b      	ldrh	r3, [r3, #0]
 801de72:	f013 0504 	ands.w	r5, r3, #4
 801de76:	f040 818d 	bne.w	801e194 <HAL_SPI_TxRxCpltCallback+0x6b0>
				if(display.quantize == 1) {
 801de7a:	4b93      	ldr	r3, [pc, #588]	; (801e0c8 <HAL_SPI_TxRxCpltCallback+0x5e4>)
 801de7c:	7c58      	ldrb	r0, [r3, #17]
 801de7e:	2801      	cmp	r0, #1
 801de80:	f000 820e 	beq.w	801e2a0 <HAL_SPI_TxRxCpltCallback+0x7bc>
					GoToPosition((float)(f_tell(&MyFile) + 60000)
 801de84:	4e91      	ldr	r6, [pc, #580]	; (801e0cc <HAL_SPI_TxRxCpltCallback+0x5e8>)
 801de86:	f64e 2360 	movw	r3, #60000	; 0xea60
 801de8a:	6bb0      	ldr	r0, [r6, #56]	; 0x38
 801de8c:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 801de8e:	1818      	adds	r0, r3, r0
 801de90:	f141 0100 	adc.w	r1, r1, #0
					GoToPosition((float)(f_tell(&MyFile) - 120000)
 801de94:	f7e2 fec2 	bl	8000c1c <__aeabi_ul2f>
							/(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801de98:	4b8d      	ldr	r3, [pc, #564]	; (801e0d0 <HAL_SPI_TxRxCpltCallback+0x5ec>)
 801de9a:	4a8e      	ldr	r2, [pc, #568]	; (801e0d4 <HAL_SPI_TxRxCpltCallback+0x5f0>)
					GoToPosition((float)(f_tell(&MyFile) - 120000)
 801de9c:	ee08 0a10 	vmov	s16, r0
							/(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801dea0:	681b      	ldr	r3, [r3, #0]
 801dea2:	6812      	ldr	r2, [r2, #0]
 801dea4:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
 801dea8:	189b      	adds	r3, r3, r2
 801deaa:	416d      	adcs	r5, r5
 801deac:	1ac0      	subs	r0, r0, r3
 801deae:	eb61 0105 	sbc.w	r1, r1, r5
 801deb2:	f7e2 feb3 	bl	8000c1c <__aeabi_ul2f>
 801deb6:	ee07 0a90 	vmov	s15, r0
							*rekordbox.spectrum_size);
 801deba:	4b87      	ldr	r3, [pc, #540]	; (801e0d8 <HAL_SPI_TxRxCpltCallback+0x5f4>)
							/(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801debc:	eec8 7a27 	vdiv.f32	s15, s16, s15
							*rekordbox.spectrum_size);
 801dec0:	f603 238c 	addw	r3, r3, #2700	; 0xa8c
 801dec4:	ed93 7a00 	vldr	s14, [r3]
 801dec8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801decc:	ee67 7a87 	vmul.f32	s15, s15, s14
					GoToPosition((float)(f_tell(&MyFile) - 120000)
 801ded0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ded4:	ee17 0a90 	vmov	r0, s15
 801ded8:	f001 f81a 	bl	801ef10 <GoToPosition>
				if(trak.state == PLAYING) BSP_AUDIO_OUT_Resume();
 801dedc:	4e74      	ldr	r6, [pc, #464]	; (801e0b0 <HAL_SPI_TxRxCpltCallback+0x5cc>)
 801dede:	7833      	ldrb	r3, [r6, #0]
 801dee0:	2b00      	cmp	r3, #0
 801dee2:	f040 8147 	bne.w	801e174 <HAL_SPI_TxRxCpltCallback+0x690>
 801dee6:	f7fe ff77 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
 801deea:	e62c      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(display.quantize == 1) {
 801deec:	4d76      	ldr	r5, [pc, #472]	; (801e0c8 <HAL_SPI_TxRxCpltCallback+0x5e4>)
 801deee:	7c6b      	ldrb	r3, [r5, #17]
 801def0:	2b01      	cmp	r3, #1
 801def2:	f000 81c3 	beq.w	801e27c <HAL_SPI_TxRxCpltCallback+0x798>
				display.loopstart = file_pos_wide;
 801def6:	4b72      	ldr	r3, [pc, #456]	; (801e0c0 <HAL_SPI_TxRxCpltCallback+0x5dc>)
 801def8:	681b      	ldr	r3, [r3, #0]
 801defa:	60ab      	str	r3, [r5, #8]
 801defc:	e623      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			button_flag ^= (1 << 1);
 801defe:	4a68      	ldr	r2, [pc, #416]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
			__HAL_TIM_CLEAR_IT(&htim9, TIM_IT_UPDATE);
 801df00:	f06f 0501 	mvn.w	r5, #1
 801df04:	486f      	ldr	r0, [pc, #444]	; (801e0c4 <HAL_SPI_TxRxCpltCallback+0x5e0>)
			__HAL_TIM_SET_COUNTER(&htim9, 0);
 801df06:	2100      	movs	r1, #0
			button_flag ^= (1 << 1);
 801df08:	8813      	ldrh	r3, [r2, #0]
 801df0a:	f083 0302 	eor.w	r3, r3, #2
 801df0e:	e7a7      	b.n	801de60 <HAL_SPI_TxRxCpltCallback+0x37c>
			if(display.quantize == 1) {
 801df10:	4d6d      	ldr	r5, [pc, #436]	; (801e0c8 <HAL_SPI_TxRxCpltCallback+0x5e4>)
 801df12:	7c6b      	ldrb	r3, [r5, #17]
 801df14:	2b01      	cmp	r3, #1
 801df16:	f000 819b 	beq.w	801e250 <HAL_SPI_TxRxCpltCallback+0x76c>
				display.loopend = file_pos_wide;
 801df1a:	4b69      	ldr	r3, [pc, #420]	; (801e0c0 <HAL_SPI_TxRxCpltCallback+0x5dc>)
 801df1c:	681b      	ldr	r3, [r3, #0]
 801df1e:	60eb      	str	r3, [r5, #12]
			if(display.loop == 0) display.loop = 1;
 801df20:	7c2b      	ldrb	r3, [r5, #16]
 801df22:	b90b      	cbnz	r3, 801df28 <HAL_SPI_TxRxCpltCallback+0x444>
 801df24:	2301      	movs	r3, #1
 801df26:	742b      	strb	r3, [r5, #16]
			GoToPosition(display.loopstart);
 801df28:	68a8      	ldr	r0, [r5, #8]
 801df2a:	f000 fff1 	bl	801ef10 <GoToPosition>
			BSP_AUDIO_OUT_Resume();
 801df2e:	f7fe ff53 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
			break;
 801df32:	e608      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			if(menu_mode == 1) {
 801df34:	4b69      	ldr	r3, [pc, #420]	; (801e0dc <HAL_SPI_TxRxCpltCallback+0x5f8>)
 801df36:	f993 3000 	ldrsb.w	r3, [r3]
 801df3a:	2b01      	cmp	r3, #1
 801df3c:	f47f ae03 	bne.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				bOutOfData = 1;
 801df40:	4859      	ldr	r0, [pc, #356]	; (801e0a8 <HAL_SPI_TxRxCpltCallback+0x5c4>)
				unDmaBufMode = 3;
 801df42:	2103      	movs	r1, #3
 801df44:	4a59      	ldr	r2, [pc, #356]	; (801e0ac <HAL_SPI_TxRxCpltCallback+0x5c8>)
				bOutOfData = 1;
 801df46:	6003      	str	r3, [r0, #0]
				HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801df48:	2028      	movs	r0, #40	; 0x28
				unDmaBufMode = 3;
 801df4a:	6011      	str	r1, [r2, #0]
				HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 801df4c:	f7e3 f924 	bl	8001198 <HAL_NVIC_DisableIRQ>
				__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801df50:	4863      	ldr	r0, [pc, #396]	; (801e0e0 <HAL_SPI_TxRxCpltCallback+0x5fc>)
 801df52:	f06f 0101 	mvn.w	r1, #1
				__HAL_TIM_SET_COUNTER(&htim6, 0);
 801df56:	2200      	movs	r2, #0
				__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
 801df58:	6803      	ldr	r3, [r0, #0]
 801df5a:	6119      	str	r1, [r3, #16]
				__HAL_TIM_SET_COUNTER(&htim6, 0);
 801df5c:	625a      	str	r2, [r3, #36]	; 0x24
				HAL_TIM_Base_Start_IT(&htim6);
 801df5e:	f7e8 fc05 	bl	800676c <HAL_TIM_Base_Start_IT>
				Track_number = Mark_number + str_increment;
 801df62:	4b60      	ldr	r3, [pc, #384]	; (801e0e4 <HAL_SPI_TxRxCpltCallback+0x600>)
 801df64:	4960      	ldr	r1, [pc, #384]	; (801e0e8 <HAL_SPI_TxRxCpltCallback+0x604>)
				if(Track_number >= Total_tracks) Track_number = 0;
 801df66:	4a61      	ldr	r2, [pc, #388]	; (801e0ec <HAL_SPI_TxRxCpltCallback+0x608>)
				Track_number = Mark_number + str_increment;
 801df68:	6809      	ldr	r1, [r1, #0]
 801df6a:	681b      	ldr	r3, [r3, #0]
				if(Track_number >= Total_tracks) Track_number = 0;
 801df6c:	8812      	ldrh	r2, [r2, #0]
				Track_number = Mark_number + str_increment;
 801df6e:	440b      	add	r3, r1
 801df70:	484c      	ldr	r0, [pc, #304]	; (801e0a4 <HAL_SPI_TxRxCpltCallback+0x5c0>)
				String_number = -1;
 801df72:	f04f 31ff 	mov.w	r1, #4294967295
				if(Track_number >= Total_tracks) Track_number = 0;
 801df76:	4293      	cmp	r3, r2
 801df78:	bfa8      	it	ge
 801df7a:	2300      	movge	r3, #0
				String_number = -1;
 801df7c:	4a5c      	ldr	r2, [pc, #368]	; (801e0f0 <HAL_SPI_TxRxCpltCallback+0x60c>)
				if(Track_number >= Total_tracks) Track_number = 0;
 801df7e:	6003      	str	r3, [r0, #0]
				String_number = -1;
 801df80:	6011      	str	r1, [r2, #0]
 801df82:	e5e0      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			button_flag ^= (1 << 2);
 801df84:	4a46      	ldr	r2, [pc, #280]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
			__HAL_TIM_CLEAR_IT(&htim9, TIM_IT_UPDATE);
 801df86:	f06f 0501 	mvn.w	r5, #1
 801df8a:	484e      	ldr	r0, [pc, #312]	; (801e0c4 <HAL_SPI_TxRxCpltCallback+0x5e0>)
			__HAL_TIM_SET_COUNTER(&htim9, 0);
 801df8c:	2100      	movs	r1, #0
			button_flag ^= (1 << 2);
 801df8e:	8813      	ldrh	r3, [r2, #0]
 801df90:	f083 0304 	eor.w	r3, r3, #4
 801df94:	e764      	b.n	801de60 <HAL_SPI_TxRxCpltCallback+0x37c>
			if(!(button_flag & (1 << 2))) {
 801df96:	4b42      	ldr	r3, [pc, #264]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
 801df98:	881b      	ldrh	r3, [r3, #0]
 801df9a:	f013 0504 	ands.w	r5, r3, #4
 801df9e:	d14d      	bne.n	801e03c <HAL_SPI_TxRxCpltCallback+0x558>
				if(display.quantize == 1) {
 801dfa0:	4b49      	ldr	r3, [pc, #292]	; (801e0c8 <HAL_SPI_TxRxCpltCallback+0x5e4>)
 801dfa2:	7c5b      	ldrb	r3, [r3, #17]
 801dfa4:	2b01      	cmp	r3, #1
 801dfa6:	f000 8180 	beq.w	801e2aa <HAL_SPI_TxRxCpltCallback+0x7c6>
					GoToPosition((float)(f_tell(&MyFile) - 120000)
 801dfaa:	4e48      	ldr	r6, [pc, #288]	; (801e0cc <HAL_SPI_TxRxCpltCallback+0x5e8>)
 801dfac:	4851      	ldr	r0, [pc, #324]	; (801e0f4 <HAL_SPI_TxRxCpltCallback+0x610>)
 801dfae:	e9d6 310e 	ldrd	r3, r1, [r6, #56]	; 0x38
 801dfb2:	1818      	adds	r0, r3, r0
 801dfb4:	f161 0100 	sbc.w	r1, r1, #0
 801dfb8:	e76c      	b.n	801de94 <HAL_SPI_TxRxCpltCallback+0x3b0>
			if(trak.state == STOPPED) {
 801dfba:	4e3d      	ldr	r6, [pc, #244]	; (801e0b0 <HAL_SPI_TxRxCpltCallback+0x5cc>)
 801dfbc:	7833      	ldrb	r3, [r6, #0]
 801dfbe:	2b01      	cmp	r3, #1
 801dfc0:	f000 8161 	beq.w	801e286 <HAL_SPI_TxRxCpltCallback+0x7a2>
			else if(trak.state == SETCUE) {
 801dfc4:	2b02      	cmp	r3, #2
 801dfc6:	f47f adbe 	bne.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				if(display.quantize == 1) {
 801dfca:	4b3f      	ldr	r3, [pc, #252]	; (801e0c8 <HAL_SPI_TxRxCpltCallback+0x5e4>)
 801dfcc:	7c5b      	ldrb	r3, [r3, #17]
 801dfce:	2b01      	cmp	r3, #1
 801dfd0:	f000 8176 	beq.w	801e2c0 <HAL_SPI_TxRxCpltCallback+0x7dc>
					rekordbox.cue_start_position[0] = file_pos_wide;
 801dfd4:	4b3a      	ldr	r3, [pc, #232]	; (801e0c0 <HAL_SPI_TxRxCpltCallback+0x5dc>)
 801dfd6:	4d39      	ldr	r5, [pc, #228]	; (801e0bc <HAL_SPI_TxRxCpltCallback+0x5d8>)
 801dfd8:	681b      	ldr	r3, [r3, #0]
 801dfda:	64ab      	str	r3, [r5, #72]	; 0x48
				spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801dfdc:	4a35      	ldr	r2, [pc, #212]	; (801e0b4 <HAL_SPI_TxRxCpltCallback+0x5d0>)
				rekordbox.currentcue = 0;
 801dfde:	2300      	movs	r3, #0
				trak.state = STOPPED;
 801dfe0:	2101      	movs	r1, #1
				rekordbox.currentcue = 0;
 801dfe2:	f8c5 33d0 	str.w	r3, [r5, #976]	; 0x3d0
				spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801dfe6:	7893      	ldrb	r3, [r2, #2]
				trak.state = STOPPED;
 801dfe8:	7031      	strb	r1, [r6, #0]
				spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801dfea:	f023 0302 	bic.w	r3, r3, #2
 801dfee:	7093      	strb	r3, [r2, #2]
				trak.state = STOPPED;
 801dff0:	e5a9      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
			button_flag ^= (1 << 0);
 801dff2:	4a2b      	ldr	r2, [pc, #172]	; (801e0a0 <HAL_SPI_TxRxCpltCallback+0x5bc>)
			__HAL_TIM_CLEAR_IT(&htim9, TIM_IT_UPDATE);
 801dff4:	f06f 0501 	mvn.w	r5, #1
 801dff8:	4832      	ldr	r0, [pc, #200]	; (801e0c4 <HAL_SPI_TxRxCpltCallback+0x5e0>)
			__HAL_TIM_SET_COUNTER(&htim9, 0);
 801dffa:	2100      	movs	r1, #0
			button_flag ^= (1 << 0);
 801dffc:	8813      	ldrh	r3, [r2, #0]
 801dffe:	f083 0301 	eor.w	r3, r3, #1
 801e002:	e72d      	b.n	801de60 <HAL_SPI_TxRxCpltCallback+0x37c>
						String_number++;
 801e004:	493a      	ldr	r1, [pc, #232]	; (801e0f0 <HAL_SPI_TxRxCpltCallback+0x60c>)
						if(Total_tracks < 7) {
 801e006:	4a39      	ldr	r2, [pc, #228]	; (801e0ec <HAL_SPI_TxRxCpltCallback+0x608>)
						String_number++;
 801e008:	680b      	ldr	r3, [r1, #0]
						if(Total_tracks < 7) {
 801e00a:	8812      	ldrh	r2, [r2, #0]
						String_number++;
 801e00c:	3301      	adds	r3, #1
						Mark_number = String_number;
 801e00e:	4835      	ldr	r0, [pc, #212]	; (801e0e4 <HAL_SPI_TxRxCpltCallback+0x600>)
						if(Total_tracks < 7) {
 801e010:	2a06      	cmp	r2, #6
						String_number++;
 801e012:	600b      	str	r3, [r1, #0]
						Mark_number = String_number;
 801e014:	6003      	str	r3, [r0, #0]
						if(Total_tracks < 7) {
 801e016:	f200 8103 	bhi.w	801e220 <HAL_SPI_TxRxCpltCallback+0x73c>
							if(String_number + 1 > Total_tracks) {
 801e01a:	4293      	cmp	r3, r2
 801e01c:	f6ff ad93 	blt.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
								String_number = 0;
 801e020:	600d      	str	r5, [r1, #0]
								Mark_number = 0;
 801e022:	6005      	str	r5, [r0, #0]
 801e024:	e58f      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
						else if(trak.state == SETCUE) {
 801e026:	2b02      	cmp	r3, #2
 801e028:	f47f ad8d 	bne.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
							GoToPosition(file_pos_wide + 2);
 801e02c:	4b24      	ldr	r3, [pc, #144]	; (801e0c0 <HAL_SPI_TxRxCpltCallback+0x5dc>)
 801e02e:	6818      	ldr	r0, [r3, #0]
 801e030:	3002      	adds	r0, #2
 801e032:	f000 ff6d 	bl	801ef10 <GoToPosition>
							GetTrackTime();
 801e036:	f001 f819 	bl	801f06c <GetTrackTime>
 801e03a:	e584      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				rekordbox.currentcue++;
 801e03c:	4d1f      	ldr	r5, [pc, #124]	; (801e0bc <HAL_SPI_TxRxCpltCallback+0x5d8>)
 801e03e:	f8d5 33d0 	ldr.w	r3, [r5, #976]	; 0x3d0
				if(rekordbox.currentcue >= rekordbox.cues)
 801e042:	f5a5 5280 	sub.w	r2, r5, #4096	; 0x1000
				rekordbox.currentcue++;
 801e046:	3301      	adds	r3, #1
				if(rekordbox.currentcue >= rekordbox.cues)
 801e048:	f8d2 2b94 	ldr.w	r2, [r2, #2964]	; 0xb94
 801e04c:	4293      	cmp	r3, r2
				rekordbox.currentcue++;
 801e04e:	f8c5 33d0 	str.w	r3, [r5, #976]	; 0x3d0
				if(rekordbox.currentcue >= rekordbox.cues)
 801e052:	db03      	blt.n	801e05c <HAL_SPI_TxRxCpltCallback+0x578>
					rekordbox.currentcue = 0;
 801e054:	2200      	movs	r2, #0
 801e056:	4613      	mov	r3, r2
 801e058:	f8c5 23d0 	str.w	r2, [r5, #976]	; 0x3d0
				GoToPosition(rekordbox.cue_start_position[rekordbox.currentcue]);
 801e05c:	f603 4312 	addw	r3, r3, #3090	; 0xc12
 801e060:	4e25      	ldr	r6, [pc, #148]	; (801e0f8 <HAL_SPI_TxRxCpltCallback+0x614>)
				GoToPosition(rekordbox.cue_start_position[rekordbox.currentcue]);
 801e062:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 801e066:	f000 ff53 	bl	801ef10 <GoToPosition>
				if(trak.state == PLAYING) {
 801e06a:	4b11      	ldr	r3, [pc, #68]	; (801e0b0 <HAL_SPI_TxRxCpltCallback+0x5cc>)
 801e06c:	781b      	ldrb	r3, [r3, #0]
 801e06e:	2b00      	cmp	r3, #0
 801e070:	f040 80a4 	bne.w	801e1bc <HAL_SPI_TxRxCpltCallback+0x6d8>
					BSP_AUDIO_OUT_Resume();
 801e074:	f7fe feb0 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
					HAL_TIM_Base_Stop_IT(&htim8); //stop blinking
 801e078:	480f      	ldr	r0, [pc, #60]	; (801e0b8 <HAL_SPI_TxRxCpltCallback+0x5d4>)
 801e07a:	f7e8 fbf7 	bl	800686c <HAL_TIM_Base_Stop_IT>
					spi_tx[2] &= ~(1 << 0); //turn on PLAY led
 801e07e:	4b0d      	ldr	r3, [pc, #52]	; (801e0b4 <HAL_SPI_TxRxCpltCallback+0x5d0>)
 801e080:	789a      	ldrb	r2, [r3, #2]
 801e082:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
				if(rekordbox.cue_start_position[rekordbox.currentcue] != 0) {
 801e086:	f8d5 13d0 	ldr.w	r1, [r5, #976]	; 0x3d0
 801e08a:	f601 4112 	addw	r1, r1, #3090	; 0xc12
 801e08e:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 801e092:	2900      	cmp	r1, #0
 801e094:	d07a      	beq.n	801e18c <HAL_SPI_TxRxCpltCallback+0x6a8>
					spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801e096:	f022 0202 	bic.w	r2, r2, #2
 801e09a:	709a      	strb	r2, [r3, #2]
 801e09c:	e553      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
 801e09e:	bf00      	nop
 801e0a0:	20018b62 	.word	0x20018b62
 801e0a4:	2000e9fc 	.word	0x2000e9fc
 801e0a8:	2000ec30 	.word	0x2000ec30
 801e0ac:	2000fab4 	.word	0x2000fab4
 801e0b0:	2000fa7c 	.word	0x2000fa7c
 801e0b4:	20000058 	.word	0x20000058
 801e0b8:	20018c84 	.word	0x20018c84
 801e0bc:	200184f0 	.word	0x200184f0
 801e0c0:	2000ec8c 	.word	0x2000ec8c
 801e0c4:	20018cc4 	.word	0x20018cc4
 801e0c8:	20000c70 	.word	0x20000c70
 801e0cc:	20001e40 	.word	0x20001e40
 801e0d0:	200154c0 	.word	0x200154c0
 801e0d4:	20019818 	.word	0x20019818
 801e0d8:	200174f0 	.word	0x200174f0
 801e0dc:	20000c8c 	.word	0x20000c8c
 801e0e0:	20018c04 	.word	0x20018c04
 801e0e4:	20000064 	.word	0x20000064
 801e0e8:	20018b74 	.word	0x20018b74
 801e0ec:	200022c0 	.word	0x200022c0
 801e0f0:	2000006c 	.word	0x2000006c
 801e0f4:	fffe2b40 	.word	0xfffe2b40
 801e0f8:	200154f0 	.word	0x200154f0
				display.loopend = display.loopend*2-display.loopstart;
 801e0fc:	4b79      	ldr	r3, [pc, #484]	; (801e2e4 <HAL_SPI_TxRxCpltCallback+0x800>)
				if(display.loopend >= rekordbox.spectrum_size)
 801e0fe:	4a7a      	ldr	r2, [pc, #488]	; (801e2e8 <HAL_SPI_TxRxCpltCallback+0x804>)
				display.loopend = display.loopend*2-display.loopstart;
 801e100:	e9d3 1002 	ldrd	r1, r0, [r3, #8]
				if(display.loopend >= rekordbox.spectrum_size)
 801e104:	f8d2 2a8c 	ldr.w	r2, [r2, #2700]	; 0xa8c
				display.loopend = display.loopend*2-display.loopstart;
 801e108:	ebc1 0140 	rsb	r1, r1, r0, lsl #1
				if(display.loopend >= rekordbox.spectrum_size)
 801e10c:	4291      	cmp	r1, r2
				display.loopend = display.loopend*2-display.loopstart;
 801e10e:	60d9      	str	r1, [r3, #12]
				if(display.loopend >= rekordbox.spectrum_size)
 801e110:	f4ff ad19 	bcc.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					display.loopend = rekordbox.spectrum_size - 1;
 801e114:	3a01      	subs	r2, #1
 801e116:	60da      	str	r2, [r3, #12]
 801e118:	e515      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				display.loopend = (display.loopend+display.loopstart)/2;
 801e11a:	4a72      	ldr	r2, [pc, #456]	; (801e2e4 <HAL_SPI_TxRxCpltCallback+0x800>)
 801e11c:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
 801e120:	4401      	add	r1, r0
				if(display.loopend - display.loopstart < 1)
 801e122:	ebb0 0f51 	cmp.w	r0, r1, lsr #1
				display.loopend = (display.loopend+display.loopstart)/2;
 801e126:	ea4f 0351 	mov.w	r3, r1, lsr #1
					display.loopend = display.loopstart + 1;
 801e12a:	bf08      	it	eq
 801e12c:	1c43      	addeq	r3, r0, #1
 801e12e:	60d3      	str	r3, [r2, #12]
				if(file_pos_wide >= display.loopend) {
 801e130:	4a6e      	ldr	r2, [pc, #440]	; (801e2ec <HAL_SPI_TxRxCpltCallback+0x808>)
 801e132:	6812      	ldr	r2, [r2, #0]
 801e134:	429a      	cmp	r2, r3
 801e136:	f4ff ad06 	bcc.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					GoToPosition(display.loopstart);
 801e13a:	f000 fee9 	bl	801ef10 <GoToPosition>
					BSP_AUDIO_OUT_Resume();
 801e13e:	f7fe fe4b 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
 801e142:	e500      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				BSP_AUDIO_OUT_Resume();
 801e144:	f7fe fe48 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
				trak.state = PLAYING;
 801e148:	2300      	movs	r3, #0
				HAL_TIM_Base_Stop_IT(&htim8); //stop blinking
 801e14a:	4869      	ldr	r0, [pc, #420]	; (801e2f0 <HAL_SPI_TxRxCpltCallback+0x80c>)
				trak.state = PLAYING;
 801e14c:	7033      	strb	r3, [r6, #0]
				HAL_TIM_Base_Stop_IT(&htim8); //stop blinking
 801e14e:	f7e8 fb8d 	bl	800686c <HAL_TIM_Base_Stop_IT>
				if(rekordbox.cue_start_position[rekordbox.currentcue] != 0) {
 801e152:	4868      	ldr	r0, [pc, #416]	; (801e2f4 <HAL_SPI_TxRxCpltCallback+0x810>)
				spi_tx[2] &= ~(1 << 0); //turn on PLAY led
 801e154:	4a68      	ldr	r2, [pc, #416]	; (801e2f8 <HAL_SPI_TxRxCpltCallback+0x814>)
				if(rekordbox.cue_start_position[rekordbox.currentcue] != 0) {
 801e156:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
				spi_tx[2] &= ~(1 << 0); //turn on PLAY led
 801e15a:	7893      	ldrb	r3, [r2, #2]
				if(rekordbox.cue_start_position[rekordbox.currentcue] != 0) {
 801e15c:	f8d1 13d0 	ldr.w	r1, [r1, #976]	; 0x3d0
 801e160:	f601 4112 	addw	r1, r1, #3090	; 0xc12
 801e164:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 801e168:	2900      	cmp	r1, #0
 801e16a:	d067      	beq.n	801e23c <HAL_SPI_TxRxCpltCallback+0x758>
					spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801e16c:	f023 0303 	bic.w	r3, r3, #3
 801e170:	7093      	strb	r3, [r2, #2]
 801e172:	e4e8      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					GetTrackTime();
 801e174:	f000 ff7a 	bl	801f06c <GetTrackTime>
					if(!spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801e178:	4b5f      	ldr	r3, [pc, #380]	; (801e2f8 <HAL_SPI_TxRxCpltCallback+0x814>)
 801e17a:	789a      	ldrb	r2, [r3, #2]
 801e17c:	2a00      	cmp	r2, #0
 801e17e:	d063      	beq.n	801e248 <HAL_SPI_TxRxCpltCallback+0x764>
					else spi_tx[2] &= ~(1 << 1);
 801e180:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
					trak.state = SETCUE;
 801e184:	2102      	movs	r1, #2
 801e186:	709a      	strb	r2, [r3, #2]
 801e188:	7031      	strb	r1, [r6, #0]
 801e18a:	e4dc      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					spi_tx[2] |= (1 << 1); //turn off CUE led
 801e18c:	f042 0202 	orr.w	r2, r2, #2
 801e190:	709a      	strb	r2, [r3, #2]
 801e192:	e4d8      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				rekordbox.currentcue--;
 801e194:	4e57      	ldr	r6, [pc, #348]	; (801e2f4 <HAL_SPI_TxRxCpltCallback+0x810>)
 801e196:	f506 5540 	add.w	r5, r6, #12288	; 0x3000
 801e19a:	f8d5 33d0 	ldr.w	r3, [r5, #976]	; 0x3d0
 801e19e:	3b01      	subs	r3, #1
				if(rekordbox.currentcue < 0)
 801e1a0:	2b00      	cmp	r3, #0
				rekordbox.currentcue--;
 801e1a2:	f8c5 33d0 	str.w	r3, [r5, #976]	; 0x3d0
				if(rekordbox.currentcue < 0)
 801e1a6:	da06      	bge.n	801e1b6 <HAL_SPI_TxRxCpltCallback+0x6d2>
					rekordbox.currentcue = rekordbox.cues - 1;
 801e1a8:	f506 5300 	add.w	r3, r6, #8192	; 0x2000
 801e1ac:	f8d3 3b94 	ldr.w	r3, [r3, #2964]	; 0xb94
 801e1b0:	3b01      	subs	r3, #1
 801e1b2:	f8c5 33d0 	str.w	r3, [r5, #976]	; 0x3d0
				GoToPosition(rekordbox.cue_start_position[rekordbox.currentcue]);
 801e1b6:	f603 4312 	addw	r3, r3, #3090	; 0xc12
 801e1ba:	e752      	b.n	801e062 <HAL_SPI_TxRxCpltCallback+0x57e>
					GetTrackTime();
 801e1bc:	f000 ff56 	bl	801f06c <GetTrackTime>
					spi_tx[2] &= ~(1 << 1); //turn on CUE led
 801e1c0:	4b4d      	ldr	r3, [pc, #308]	; (801e2f8 <HAL_SPI_TxRxCpltCallback+0x814>)
 801e1c2:	789a      	ldrb	r2, [r3, #2]
 801e1c4:	e75f      	b.n	801e086 <HAL_SPI_TxRxCpltCallback+0x5a2>
						else if(trak.state == SETCUE) {
 801e1c6:	2b02      	cmp	r3, #2
 801e1c8:	f47f acbd 	bne.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
							GoToPosition(file_pos_wide - 2);
 801e1cc:	4b47      	ldr	r3, [pc, #284]	; (801e2ec <HAL_SPI_TxRxCpltCallback+0x808>)
 801e1ce:	6818      	ldr	r0, [r3, #0]
 801e1d0:	3802      	subs	r0, #2
 801e1d2:	f000 fe9d 	bl	801ef10 <GoToPosition>
							GetTrackTime();
 801e1d6:	f000 ff49 	bl	801f06c <GetTrackTime>
 801e1da:	e4b4      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
						String_number--;
 801e1dc:	4947      	ldr	r1, [pc, #284]	; (801e2fc <HAL_SPI_TxRxCpltCallback+0x818>)
						Mark_number = String_number;
 801e1de:	4848      	ldr	r0, [pc, #288]	; (801e300 <HAL_SPI_TxRxCpltCallback+0x81c>)
						String_number--;
 801e1e0:	680b      	ldr	r3, [r1, #0]
 801e1e2:	3b01      	subs	r3, #1
						if(String_number < 0) {
 801e1e4:	2b00      	cmp	r3, #0
						String_number--;
 801e1e6:	600b      	str	r3, [r1, #0]
						Mark_number = String_number;
 801e1e8:	6003      	str	r3, [r0, #0]
						if(String_number < 0) {
 801e1ea:	f6bf acac 	bge.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
							if(Total_tracks > 7) {
 801e1ee:	4b45      	ldr	r3, [pc, #276]	; (801e304 <HAL_SPI_TxRxCpltCallback+0x820>)
 801e1f0:	881a      	ldrh	r2, [r3, #0]
 801e1f2:	2a07      	cmp	r2, #7
 801e1f4:	d960      	bls.n	801e2b8 <HAL_SPI_TxRxCpltCallback+0x7d4>
								String_number = 6;
 801e1f6:	2306      	movs	r3, #6
 801e1f8:	600b      	str	r3, [r1, #0]
								str_increment -= 7;
 801e1fa:	4943      	ldr	r1, [pc, #268]	; (801e308 <HAL_SPI_TxRxCpltCallback+0x824>)
								Mark_number = 6;
 801e1fc:	6003      	str	r3, [r0, #0]
								str_increment -= 7;
 801e1fe:	6808      	ldr	r0, [r1, #0]
								if(str_increment == Total_tracks - 7)
 801e200:	4290      	cmp	r0, r2
								str_increment -= 7;
 801e202:	f1a0 0307 	sub.w	r3, r0, #7
								if(str_increment == Total_tracks - 7)
 801e206:	d104      	bne.n	801e212 <HAL_SPI_TxRxCpltCallback+0x72e>
									str_increment = (str_increment / 7) * 7;
 801e208:	2207      	movs	r2, #7
 801e20a:	fb93 f3f2 	sdiv	r3, r3, r2
 801e20e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
								if(str_increment <= 0)
 801e212:	2b00      	cmp	r3, #0
									str_increment = (str_increment / 7) * 7;
 801e214:	600b      	str	r3, [r1, #0]
								if(str_increment <= 0)
 801e216:	f73f ac96 	bgt.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
									str_increment = 0;
 801e21a:	2300      	movs	r3, #0
 801e21c:	600b      	str	r3, [r1, #0]
 801e21e:	e492      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
							if(String_number > 6) {
 801e220:	2b06      	cmp	r3, #6
 801e222:	f77f ac90 	ble.w	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
								String_number = 0;
 801e226:	600d      	str	r5, [r1, #0]
								if(str_increment >= Total_tracks - 7)
 801e228:	3a07      	subs	r2, #7
								str_increment += 7;
 801e22a:	4937      	ldr	r1, [pc, #220]	; (801e308 <HAL_SPI_TxRxCpltCallback+0x824>)
								Mark_number = 0;
 801e22c:	6005      	str	r5, [r0, #0]
								str_increment += 7;
 801e22e:	680b      	ldr	r3, [r1, #0]
 801e230:	3307      	adds	r3, #7
 801e232:	4293      	cmp	r3, r2
 801e234:	bfa8      	it	ge
 801e236:	4613      	movge	r3, r2
 801e238:	600b      	str	r3, [r1, #0]
 801e23a:	e484      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				spi_tx[2] &= ~(1 << 0); //turn on PLAY led
 801e23c:	f023 0301 	bic.w	r3, r3, #1
					spi_tx[2] |= (1 << 1); //turn off CUE led
 801e240:	f043 0302 	orr.w	r3, r3, #2
 801e244:	7093      	strb	r3, [r2, #2]
 801e246:	e47e      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					if(!spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801e248:	2202      	movs	r2, #2
 801e24a:	e79b      	b.n	801e184 <HAL_SPI_TxRxCpltCallback+0x6a0>
				if(!spi_tx[2] & (1 << 0)) spi_tx[2] |= (1 << 1);
 801e24c:	2202      	movs	r2, #2
 801e24e:	e5f1      	b.n	801de34 <HAL_SPI_TxRxCpltCallback+0x350>
				display.loopend = QuantizePosition(0);
 801e250:	2000      	movs	r0, #0
 801e252:	f7fb fc49 	bl	8019ae8 <QuantizePosition>
 801e256:	60e8      	str	r0, [r5, #12]
 801e258:	e662      	b.n	801df20 <HAL_SPI_TxRxCpltCallback+0x43c>
					if(display.pitchmode == 0) scale_pitch = 1; //wide
 801e25a:	2b00      	cmp	r3, #0
 801e25c:	f43f ad54 	beq.w	801dd08 <HAL_SPI_TxRxCpltCallback+0x224>
					else if(display.pitchmode == 1) scale_pitch = 0.16; //16%
 801e260:	2b01      	cmp	r3, #1
 801e262:	d033      	beq.n	801e2cc <HAL_SPI_TxRxCpltCallback+0x7e8>
					else if(display.pitchmode == 2) scale_pitch = 0.1; //10%
 801e264:	2b02      	cmp	r3, #2
 801e266:	4b29      	ldr	r3, [pc, #164]	; (801e30c <HAL_SPI_TxRxCpltCallback+0x828>)
 801e268:	d036      	beq.n	801e2d8 <HAL_SPI_TxRxCpltCallback+0x7f4>
					else if(display.pitchmode == 3) scale_pitch = 0.06; //6%
 801e26a:	4a29      	ldr	r2, [pc, #164]	; (801e310 <HAL_SPI_TxRxCpltCallback+0x82c>)
 801e26c:	eddf 6a29 	vldr	s13, [pc, #164]	; 801e314 <HAL_SPI_TxRxCpltCallback+0x830>
 801e270:	601a      	str	r2, [r3, #0]
 801e272:	e54f      	b.n	801dd14 <HAL_SPI_TxRxCpltCallback+0x230>
						display.timemode = 0;
 801e274:	2200      	movs	r2, #0
 801e276:	701a      	strb	r2, [r3, #0]
						display.trackbarmode = 0;
 801e278:	711a      	strb	r2, [r3, #4]
 801e27a:	e464      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				display.loopstart = QuantizePosition(0);
 801e27c:	2000      	movs	r0, #0
 801e27e:	f7fb fc33 	bl	8019ae8 <QuantizePosition>
 801e282:	60a8      	str	r0, [r5, #8]
 801e284:	e45f      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
				BSP_AUDIO_OUT_Resume();
 801e286:	f7fe fda7 	bl	801cdd8 <BSP_AUDIO_OUT_Resume>
				trak.state = PLAYING;
 801e28a:	2300      	movs	r3, #0
				HAL_TIM_Base_Stop_IT(&htim8); //stop blinking
 801e28c:	4818      	ldr	r0, [pc, #96]	; (801e2f0 <HAL_SPI_TxRxCpltCallback+0x80c>)
				trak.state = PLAYING;
 801e28e:	7033      	strb	r3, [r6, #0]
				HAL_TIM_Base_Stop_IT(&htim8); //stop blinking
 801e290:	f7e8 faec 	bl	800686c <HAL_TIM_Base_Stop_IT>
				spi_tx[2] &= ~(1 << 0); //turn on PLAY led
 801e294:	4a18      	ldr	r2, [pc, #96]	; (801e2f8 <HAL_SPI_TxRxCpltCallback+0x814>)
 801e296:	7893      	ldrb	r3, [r2, #2]
 801e298:	f023 0301 	bic.w	r3, r3, #1
 801e29c:	7093      	strb	r3, [r2, #2]
 801e29e:	e452      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					GoToPosition(QuantizePosition(1));
 801e2a0:	f7fb fc22 	bl	8019ae8 <QuantizePosition>
 801e2a4:	f000 fe34 	bl	801ef10 <GoToPosition>
 801e2a8:	e618      	b.n	801dedc <HAL_SPI_TxRxCpltCallback+0x3f8>
					GoToPosition(QuantizePosition(-1));
 801e2aa:	f04f 30ff 	mov.w	r0, #4294967295
 801e2ae:	f7fb fc1b 	bl	8019ae8 <QuantizePosition>
 801e2b2:	f000 fe2d 	bl	801ef10 <GoToPosition>
 801e2b6:	e611      	b.n	801dedc <HAL_SPI_TxRxCpltCallback+0x3f8>
								String_number = Total_tracks - 1;
 801e2b8:	3a01      	subs	r2, #1
 801e2ba:	600a      	str	r2, [r1, #0]
								Mark_number = Total_tracks - 1;;
 801e2bc:	6002      	str	r2, [r0, #0]
 801e2be:	e442      	b.n	801db46 <HAL_SPI_TxRxCpltCallback+0x62>
					rekordbox.cue_start_position[0] = QuantizePosition(0);
 801e2c0:	4d15      	ldr	r5, [pc, #84]	; (801e318 <HAL_SPI_TxRxCpltCallback+0x834>)
 801e2c2:	2000      	movs	r0, #0
 801e2c4:	f7fb fc10 	bl	8019ae8 <QuantizePosition>
 801e2c8:	64a8      	str	r0, [r5, #72]	; 0x48
 801e2ca:	e687      	b.n	801dfdc <HAL_SPI_TxRxCpltCallback+0x4f8>
					else if(display.pitchmode == 1) scale_pitch = 0.16; //16%
 801e2cc:	4b0f      	ldr	r3, [pc, #60]	; (801e30c <HAL_SPI_TxRxCpltCallback+0x828>)
 801e2ce:	4a13      	ldr	r2, [pc, #76]	; (801e31c <HAL_SPI_TxRxCpltCallback+0x838>)
 801e2d0:	eddf 6a13 	vldr	s13, [pc, #76]	; 801e320 <HAL_SPI_TxRxCpltCallback+0x83c>
 801e2d4:	601a      	str	r2, [r3, #0]
 801e2d6:	e51d      	b.n	801dd14 <HAL_SPI_TxRxCpltCallback+0x230>
					else if(display.pitchmode == 2) scale_pitch = 0.1; //10%
 801e2d8:	4a12      	ldr	r2, [pc, #72]	; (801e324 <HAL_SPI_TxRxCpltCallback+0x840>)
 801e2da:	eddf 6a13 	vldr	s13, [pc, #76]	; 801e328 <HAL_SPI_TxRxCpltCallback+0x844>
 801e2de:	601a      	str	r2, [r3, #0]
 801e2e0:	e518      	b.n	801dd14 <HAL_SPI_TxRxCpltCallback+0x230>
 801e2e2:	bf00      	nop
 801e2e4:	20000c70 	.word	0x20000c70
 801e2e8:	200174f0 	.word	0x200174f0
 801e2ec:	2000ec8c 	.word	0x2000ec8c
 801e2f0:	20018c84 	.word	0x20018c84
 801e2f4:	200154f0 	.word	0x200154f0
 801e2f8:	20000058 	.word	0x20000058
 801e2fc:	2000006c 	.word	0x2000006c
 801e300:	20000064 	.word	0x20000064
 801e304:	200022c0 	.word	0x200022c0
 801e308:	20018b74 	.word	0x20018b74
 801e30c:	20000074 	.word	0x20000074
 801e310:	3d75c28f 	.word	0x3d75c28f
 801e314:	3675c28f 	.word	0x3675c28f
 801e318:	200184f0 	.word	0x200184f0
 801e31c:	3e23d70a 	.word	0x3e23d70a
 801e320:	3723d70a 	.word	0x3723d70a
 801e324:	3dcccccd 	.word	0x3dcccccd
 801e328:	36cccccd 	.word	0x36cccccd

0801e32c <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 801e32c:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 801e32e:	1e16      	subs	r6, r2, #0
 801e330:	dd07      	ble.n	801e342 <_read+0x16>
 801e332:	460c      	mov	r4, r1
 801e334:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 801e336:	f3af 8000 	nop.w
 801e33a:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 801e33e:	42a5      	cmp	r5, r4
 801e340:	d1f9      	bne.n	801e336 <_read+0xa>
	}

return len;
}
 801e342:	4630      	mov	r0, r6
 801e344:	bd70      	pop	{r4, r5, r6, pc}
 801e346:	bf00      	nop

0801e348 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 801e348:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 801e34a:	1e16      	subs	r6, r2, #0
 801e34c:	dd07      	ble.n	801e35e <_write+0x16>
 801e34e:	460c      	mov	r4, r1
 801e350:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 801e352:	f814 0b01 	ldrb.w	r0, [r4], #1
 801e356:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 801e35a:	42ac      	cmp	r4, r5
 801e35c:	d1f9      	bne.n	801e352 <_write+0xa>
	}
	return len;
}
 801e35e:	4630      	mov	r0, r6
 801e360:	bd70      	pop	{r4, r5, r6, pc}
 801e362:	bf00      	nop

0801e364 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 801e364:	490d      	ldr	r1, [pc, #52]	; (801e39c <_sbrk+0x38>)
 801e366:	680a      	ldr	r2, [r1, #0]
{
 801e368:	b508      	push	{r3, lr}
 801e36a:	4603      	mov	r3, r0
	if (heap_end == 0)
 801e36c:	b132      	cbz	r2, 801e37c <_sbrk+0x18>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 801e36e:	4413      	add	r3, r2
 801e370:	4668      	mov	r0, sp
 801e372:	4283      	cmp	r3, r0
 801e374:	d809      	bhi.n	801e38a <_sbrk+0x26>
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 801e376:	4610      	mov	r0, r2
	heap_end += incr;
 801e378:	600b      	str	r3, [r1, #0]
}
 801e37a:	bd08      	pop	{r3, pc}
		heap_end = &end;
 801e37c:	4808      	ldr	r0, [pc, #32]	; (801e3a0 <_sbrk+0x3c>)
 801e37e:	4602      	mov	r2, r0
 801e380:	6008      	str	r0, [r1, #0]
	if (heap_end + incr > stack_ptr)
 801e382:	4668      	mov	r0, sp
 801e384:	4413      	add	r3, r2
 801e386:	4283      	cmp	r3, r0
 801e388:	d9f5      	bls.n	801e376 <_sbrk+0x12>
		errno = ENOMEM;
 801e38a:	f001 fe45 	bl	8020018 <__errno>
 801e38e:	230c      	movs	r3, #12
		return (caddr_t) -1;
 801e390:	f04f 32ff 	mov.w	r2, #4294967295
		errno = ENOMEM;
 801e394:	6003      	str	r3, [r0, #0]
}
 801e396:	4610      	mov	r0, r2
 801e398:	bd08      	pop	{r3, pc}
 801e39a:	bf00      	nop
 801e39c:	20018b80 	.word	0x20018b80
 801e3a0:	20019838 	.word	0x20019838

0801e3a4 <_close>:

int _close(int file)
{
	return -1;
}
 801e3a4:	f04f 30ff 	mov.w	r0, #4294967295
 801e3a8:	4770      	bx	lr
 801e3aa:	bf00      	nop

0801e3ac <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 801e3ac:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 801e3b0:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 801e3b2:	604b      	str	r3, [r1, #4]
}
 801e3b4:	4770      	bx	lr
 801e3b6:	bf00      	nop

0801e3b8 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 801e3b8:	2001      	movs	r0, #1
 801e3ba:	4770      	bx	lr

0801e3bc <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 801e3bc:	2000      	movs	r0, #0
 801e3be:	4770      	bx	lr

0801e3c0 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801e3c0:	4a0f      	ldr	r2, [pc, #60]	; (801e400 <SystemInit+0x40>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 801e3c2:	4b10      	ldr	r3, [pc, #64]	; (801e404 <SystemInit+0x44>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801e3c4:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 801e3c8:	490f      	ldr	r1, [pc, #60]	; (801e408 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801e3ca:	f440 0070 	orr.w	r0, r0, #15728640	; 0xf00000
{
 801e3ce:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801e3d0:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
  RCC->CFGR = 0x00000000;
 801e3d4:	2400      	movs	r4, #0
  RCC->CR |= (uint32_t)0x00000001;
 801e3d6:	6818      	ldr	r0, [r3, #0]
 801e3d8:	f040 0001 	orr.w	r0, r0, #1
 801e3dc:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0x00000000;
 801e3de:	609c      	str	r4, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 801e3e0:	6818      	ldr	r0, [r3, #0]
 801e3e2:	4001      	ands	r1, r0

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 801e3e4:	4809      	ldr	r0, [pc, #36]	; (801e40c <SystemInit+0x4c>)
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 801e3e6:	6019      	str	r1, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 801e3e8:	6058      	str	r0, [r3, #4]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 801e3ea:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 801e3ee:	6819      	ldr	r1, [r3, #0]
 801e3f0:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 801e3f4:	6019      	str	r1, [r3, #0]
  RCC->CIR = 0x00000000;
 801e3f6:	60dc      	str	r4, [r3, #12]
#endif
}
 801e3f8:	f85d 4b04 	ldr.w	r4, [sp], #4
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 801e3fc:	6090      	str	r0, [r2, #8]
}
 801e3fe:	4770      	bx	lr
 801e400:	e000ed00 	.word	0xe000ed00
 801e404:	40023800 	.word	0x40023800
 801e408:	fef6ffff 	.word	0xfef6ffff
 801e40c:	24003010 	.word	0x24003010

0801e410 <MX_TIM4_Init>:
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim9;

/* TIM4 init function */
void MX_TIM4_Init(void)
{
 801e410:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e412:	2300      	movs	r3, #0
{
 801e414:	b088      	sub	sp, #32
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
 801e416:	4819      	ldr	r0, [pc, #100]	; (801e47c <MX_TIM4_Init+0x6c>)
  htim4.Init.Prescaler = 9999;
 801e418:	f242 710f 	movw	r1, #9999	; 0x270f
  htim4.Instance = TIM4;
 801e41c:	4c18      	ldr	r4, [pc, #96]	; (801e480 <MX_TIM4_Init+0x70>)
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 399;
 801e41e:	f240 128f 	movw	r2, #399	; 0x18f
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e422:	9304      	str	r3, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e424:	9301      	str	r3, [sp, #4]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801e426:	6103      	str	r3, [r0, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e428:	6183      	str	r3, [r0, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e42a:	9307      	str	r3, [sp, #28]
  htim4.Init.Prescaler = 9999;
 801e42c:	e9c0 4100 	strd	r4, r1, [r0]
  htim4.Init.Period = 399;
 801e430:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e434:	e9cd 3305 	strd	r3, r3, [sp, #20]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e438:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 801e43c:	f7e8 f862 	bl	8006504 <HAL_TIM_Base_Init>
 801e440:	b988      	cbnz	r0, 801e466 <MX_TIM4_Init+0x56>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e442:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801e446:	a904      	add	r1, sp, #16
 801e448:	480c      	ldr	r0, [pc, #48]	; (801e47c <MX_TIM4_Init+0x6c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e44a:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801e44c:	f7e8 fa8e 	bl	800696c <HAL_TIM_ConfigClockSource>
 801e450:	b980      	cbnz	r0, 801e474 <MX_TIM4_Init+0x64>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e452:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801e454:	a901      	add	r1, sp, #4
 801e456:	4809      	ldr	r0, [pc, #36]	; (801e47c <MX_TIM4_Init+0x6c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e458:	9301      	str	r3, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e45a:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801e45c:	f7e8 fe1a 	bl	8007094 <HAL_TIMEx_MasterConfigSynchronization>
 801e460:	b920      	cbnz	r0, 801e46c <MX_TIM4_Init+0x5c>
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}
 801e462:	b008      	add	sp, #32
 801e464:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e466:	f7fc fd1b 	bl	801aea0 <Error_Handler>
 801e46a:	e7ea      	b.n	801e442 <MX_TIM4_Init+0x32>
    Error_Handler();
 801e46c:	f7fc fd18 	bl	801aea0 <Error_Handler>
}
 801e470:	b008      	add	sp, #32
 801e472:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e474:	f7fc fd14 	bl	801aea0 <Error_Handler>
 801e478:	e7eb      	b.n	801e452 <MX_TIM4_Init+0x42>
 801e47a:	bf00      	nop
 801e47c:	20018b84 	.word	0x20018b84
 801e480:	40000800 	.word	0x40000800

0801e484 <MX_TIM5_Init>:
/* TIM5 init function */
void MX_TIM5_Init(void)
{
 801e484:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e486:	2300      	movs	r3, #0
{
 801e488:	b088      	sub	sp, #32
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
 801e48a:	4819      	ldr	r0, [pc, #100]	; (801e4f0 <MX_TIM5_Init+0x6c>)
  htim5.Init.Prescaler = 19199;
 801e48c:	f644 21ff 	movw	r1, #19199	; 0x4aff
  htim5.Instance = TIM5;
 801e490:	4c18      	ldr	r4, [pc, #96]	; (801e4f4 <MX_TIM5_Init+0x70>)
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 1999;
 801e492:	f240 72cf 	movw	r2, #1999	; 0x7cf
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e496:	9304      	str	r3, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e498:	9301      	str	r3, [sp, #4]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801e49a:	6103      	str	r3, [r0, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e49c:	6183      	str	r3, [r0, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e49e:	9307      	str	r3, [sp, #28]
  htim5.Init.Prescaler = 19199;
 801e4a0:	e9c0 4100 	strd	r4, r1, [r0]
  htim5.Init.Period = 1999;
 801e4a4:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e4a8:	e9cd 3305 	strd	r3, r3, [sp, #20]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e4ac:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 801e4b0:	f7e8 f828 	bl	8006504 <HAL_TIM_Base_Init>
 801e4b4:	b988      	cbnz	r0, 801e4da <MX_TIM5_Init+0x56>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e4b6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 801e4ba:	a904      	add	r1, sp, #16
 801e4bc:	480c      	ldr	r0, [pc, #48]	; (801e4f0 <MX_TIM5_Init+0x6c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e4be:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 801e4c0:	f7e8 fa54 	bl	800696c <HAL_TIM_ConfigClockSource>
 801e4c4:	b980      	cbnz	r0, 801e4e8 <MX_TIM5_Init+0x64>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e4c6:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 801e4c8:	a901      	add	r1, sp, #4
 801e4ca:	4809      	ldr	r0, [pc, #36]	; (801e4f0 <MX_TIM5_Init+0x6c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e4cc:	9301      	str	r3, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e4ce:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 801e4d0:	f7e8 fde0 	bl	8007094 <HAL_TIMEx_MasterConfigSynchronization>
 801e4d4:	b920      	cbnz	r0, 801e4e0 <MX_TIM5_Init+0x5c>
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */

}
 801e4d6:	b008      	add	sp, #32
 801e4d8:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e4da:	f7fc fce1 	bl	801aea0 <Error_Handler>
 801e4de:	e7ea      	b.n	801e4b6 <MX_TIM5_Init+0x32>
    Error_Handler();
 801e4e0:	f7fc fcde 	bl	801aea0 <Error_Handler>
}
 801e4e4:	b008      	add	sp, #32
 801e4e6:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e4e8:	f7fc fcda 	bl	801aea0 <Error_Handler>
 801e4ec:	e7eb      	b.n	801e4c6 <MX_TIM5_Init+0x42>
 801e4ee:	bf00      	nop
 801e4f0:	20018bc4 	.word	0x20018bc4
 801e4f4:	40000c00 	.word	0x40000c00

0801e4f8 <MX_TIM6_Init>:
/* TIM6 init function */
void MX_TIM6_Init(void)
{
 801e4f8:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM6_Init 0 */

  /* USER CODE END TIM6_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e4fa:	2300      	movs	r3, #0
{
 801e4fc:	b084      	sub	sp, #16

  /* USER CODE BEGIN TIM6_Init 1 */

  /* USER CODE END TIM6_Init 1 */
  htim6.Instance = TIM6;
 801e4fe:	4811      	ldr	r0, [pc, #68]	; (801e544 <MX_TIM6_Init+0x4c>)
  htim6.Init.Prescaler = 9999;
 801e500:	f242 710f 	movw	r1, #9999	; 0x270f
  htim6.Instance = TIM6;
 801e504:	4c10      	ldr	r4, [pc, #64]	; (801e548 <MX_TIM6_Init+0x50>)
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.Period = 999;
 801e506:	f240 32e7 	movw	r2, #999	; 0x3e7
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e50a:	9301      	str	r3, [sp, #4]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e50c:	6183      	str	r3, [r0, #24]
  htim6.Init.Prescaler = 9999;
 801e50e:	e9c0 4100 	strd	r4, r1, [r0]
  htim6.Init.Period = 999;
 801e512:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e516:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 801e51a:	f7e7 fff3 	bl	8006504 <HAL_TIM_Base_Init>
 801e51e:	b948      	cbnz	r0, 801e534 <MX_TIM6_Init+0x3c>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e520:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 801e522:	a901      	add	r1, sp, #4
 801e524:	4807      	ldr	r0, [pc, #28]	; (801e544 <MX_TIM6_Init+0x4c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e526:	9301      	str	r3, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e528:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 801e52a:	f7e8 fdb3 	bl	8007094 <HAL_TIMEx_MasterConfigSynchronization>
 801e52e:	b920      	cbnz	r0, 801e53a <MX_TIM6_Init+0x42>
  }
  /* USER CODE BEGIN TIM6_Init 2 */

  /* USER CODE END TIM6_Init 2 */

}
 801e530:	b004      	add	sp, #16
 801e532:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e534:	f7fc fcb4 	bl	801aea0 <Error_Handler>
 801e538:	e7f2      	b.n	801e520 <MX_TIM6_Init+0x28>
    Error_Handler();
 801e53a:	f7fc fcb1 	bl	801aea0 <Error_Handler>
}
 801e53e:	b004      	add	sp, #16
 801e540:	bd10      	pop	{r4, pc}
 801e542:	bf00      	nop
 801e544:	20018c04 	.word	0x20018c04
 801e548:	40001000 	.word	0x40001000

0801e54c <MX_TIM7_Init>:
/* TIM7 init function */
void MX_TIM7_Init(void)
{
 801e54c:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM7_Init 0 */

  /* USER CODE END TIM7_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e54e:	2300      	movs	r3, #0
{
 801e550:	b084      	sub	sp, #16

  /* USER CODE BEGIN TIM7_Init 1 */

  /* USER CODE END TIM7_Init 1 */
  htim7.Instance = TIM7;
 801e552:	4811      	ldr	r0, [pc, #68]	; (801e598 <MX_TIM7_Init+0x4c>)
  htim7.Init.Prescaler = 9999;
 801e554:	f242 710f 	movw	r1, #9999	; 0x270f
  htim7.Instance = TIM7;
 801e558:	4c10      	ldr	r4, [pc, #64]	; (801e59c <MX_TIM7_Init+0x50>)
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim7.Init.Period = 4999;
 801e55a:	f241 3287 	movw	r2, #4999	; 0x1387
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e55e:	9301      	str	r3, [sp, #4]
  htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e560:	6183      	str	r3, [r0, #24]
  htim7.Init.Prescaler = 9999;
 801e562:	e9c0 4100 	strd	r4, r1, [r0]
  htim7.Init.Period = 4999;
 801e566:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e56a:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 801e56e:	f7e7 ffc9 	bl	8006504 <HAL_TIM_Base_Init>
 801e572:	b948      	cbnz	r0, 801e588 <MX_TIM7_Init+0x3c>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e574:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 801e576:	a901      	add	r1, sp, #4
 801e578:	4807      	ldr	r0, [pc, #28]	; (801e598 <MX_TIM7_Init+0x4c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e57a:	9301      	str	r3, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e57c:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 801e57e:	f7e8 fd89 	bl	8007094 <HAL_TIMEx_MasterConfigSynchronization>
 801e582:	b920      	cbnz	r0, 801e58e <MX_TIM7_Init+0x42>
  }
  /* USER CODE BEGIN TIM7_Init 2 */

  /* USER CODE END TIM7_Init 2 */

}
 801e584:	b004      	add	sp, #16
 801e586:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e588:	f7fc fc8a 	bl	801aea0 <Error_Handler>
 801e58c:	e7f2      	b.n	801e574 <MX_TIM7_Init+0x28>
    Error_Handler();
 801e58e:	f7fc fc87 	bl	801aea0 <Error_Handler>
}
 801e592:	b004      	add	sp, #16
 801e594:	bd10      	pop	{r4, pc}
 801e596:	bf00      	nop
 801e598:	20018c44 	.word	0x20018c44
 801e59c:	40001400 	.word	0x40001400

0801e5a0 <MX_TIM8_Init>:
/* TIM8 init function */
void MX_TIM8_Init(void)
{
 801e5a0:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM8_Init 0 */

  /* USER CODE END TIM8_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e5a2:	2300      	movs	r3, #0
{
 801e5a4:	b088      	sub	sp, #32
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM8_Init 1 */

  /* USER CODE END TIM8_Init 1 */
  htim8.Instance = TIM8;
 801e5a6:	481e      	ldr	r0, [pc, #120]	; (801e620 <MX_TIM8_Init+0x80>)
  htim8.Init.Prescaler = 9599;
 801e5a8:	f242 517f 	movw	r1, #9599	; 0x257f
  htim8.Instance = TIM8;
 801e5ac:	4c1d      	ldr	r4, [pc, #116]	; (801e624 <MX_TIM8_Init+0x84>)
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim8.Init.Period = 9999;
 801e5ae:	f242 720f 	movw	r2, #9999	; 0x270f
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e5b2:	9304      	str	r3, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e5b4:	9300      	str	r3, [sp, #0]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim8.Init.RepetitionCounter = 0;
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e5b6:	6183      	str	r3, [r0, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e5b8:	9307      	str	r3, [sp, #28]
  htim8.Init.Prescaler = 9599;
 801e5ba:	e9c0 4100 	strd	r4, r1, [r0]
  htim8.Init.Period = 9999;
 801e5be:	e9c0 3202 	strd	r3, r2, [r0, #8]
  htim8.Init.RepetitionCounter = 0;
 801e5c2:	e9c0 3304 	strd	r3, r3, [r0, #16]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e5c6:	e9cd 3305 	strd	r3, r3, [sp, #20]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801e5ca:	e9cd 3301 	strd	r3, r3, [sp, #4]
  if (HAL_TIM_Base_Init(&htim8) != HAL_OK)
 801e5ce:	f7e7 ff99 	bl	8006504 <HAL_TIM_Base_Init>
 801e5d2:	b9a0      	cbnz	r0, 801e5fe <MX_TIM8_Init+0x5e>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e5d4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK)
 801e5d8:	a904      	add	r1, sp, #16
 801e5da:	4811      	ldr	r0, [pc, #68]	; (801e620 <MX_TIM8_Init+0x80>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e5dc:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK)
 801e5de:	f7e8 f9c5 	bl	800696c <HAL_TIM_ConfigClockSource>
 801e5e2:	b998      	cbnz	r0, 801e60c <MX_TIM8_Init+0x6c>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e5e4:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 801e5e6:	4669      	mov	r1, sp
 801e5e8:	480d      	ldr	r0, [pc, #52]	; (801e620 <MX_TIM8_Init+0x80>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801e5ea:	9302      	str	r3, [sp, #8]
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801e5ec:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 801e618 <MX_TIM8_Init+0x78>
 801e5f0:	ed8d 7b00 	vstr	d7, [sp]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 801e5f4:	f7e8 fd4e 	bl	8007094 <HAL_TIMEx_MasterConfigSynchronization>
 801e5f8:	b920      	cbnz	r0, 801e604 <MX_TIM8_Init+0x64>
  }
  /* USER CODE BEGIN TIM8_Init 2 */

  /* USER CODE END TIM8_Init 2 */

}
 801e5fa:	b008      	add	sp, #32
 801e5fc:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e5fe:	f7fc fc4f 	bl	801aea0 <Error_Handler>
 801e602:	e7e7      	b.n	801e5d4 <MX_TIM8_Init+0x34>
    Error_Handler();
 801e604:	f7fc fc4c 	bl	801aea0 <Error_Handler>
}
 801e608:	b008      	add	sp, #32
 801e60a:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e60c:	f7fc fc48 	bl	801aea0 <Error_Handler>
 801e610:	e7e8      	b.n	801e5e4 <MX_TIM8_Init+0x44>
 801e612:	bf00      	nop
 801e614:	f3af 8000 	nop.w
	...
 801e620:	20018c84 	.word	0x20018c84
 801e624:	40010400 	.word	0x40010400

0801e628 <MX_TIM9_Init>:
/* TIM9 init function */
void MX_TIM9_Init(void)
{
 801e628:	b510      	push	{r4, lr}

  /* USER CODE BEGIN TIM9_Init 0 */

  /* USER CODE END TIM9_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e62a:	2300      	movs	r3, #0
{
 801e62c:	b084      	sub	sp, #16

  /* USER CODE BEGIN TIM9_Init 1 */

  /* USER CODE END TIM9_Init 1 */
  htim9.Instance = TIM9;
 801e62e:	4812      	ldr	r0, [pc, #72]	; (801e678 <MX_TIM9_Init+0x50>)
  htim9.Init.Prescaler = 9599;
 801e630:	f242 517f 	movw	r1, #9599	; 0x257f
  htim9.Instance = TIM9;
 801e634:	4c11      	ldr	r4, [pc, #68]	; (801e67c <MX_TIM9_Init+0x54>)
  htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim9.Init.Period = 19999;
 801e636:	f644 621f 	movw	r2, #19999	; 0x4e1f
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e63a:	9300      	str	r3, [sp, #0]
  htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801e63c:	6103      	str	r3, [r0, #16]
  htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801e63e:	6183      	str	r3, [r0, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e640:	9303      	str	r3, [sp, #12]
  htim9.Init.Prescaler = 9599;
 801e642:	e9c0 4100 	strd	r4, r1, [r0]
  htim9.Init.Period = 19999;
 801e646:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801e64a:	e9cd 3301 	strd	r3, r3, [sp, #4]
  if (HAL_TIM_Base_Init(&htim9) != HAL_OK)
 801e64e:	f7e7 ff59 	bl	8006504 <HAL_TIM_Base_Init>
 801e652:	b948      	cbnz	r0, 801e668 <MX_TIM9_Init+0x40>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e654:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim9, &sClockSourceConfig) != HAL_OK)
 801e658:	4669      	mov	r1, sp
 801e65a:	4807      	ldr	r0, [pc, #28]	; (801e678 <MX_TIM9_Init+0x50>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801e65c:	9300      	str	r3, [sp, #0]
  if (HAL_TIM_ConfigClockSource(&htim9, &sClockSourceConfig) != HAL_OK)
 801e65e:	f7e8 f985 	bl	800696c <HAL_TIM_ConfigClockSource>
 801e662:	b920      	cbnz	r0, 801e66e <MX_TIM9_Init+0x46>
  }
  /* USER CODE BEGIN TIM9_Init 2 */

  /* USER CODE END TIM9_Init 2 */

}
 801e664:	b004      	add	sp, #16
 801e666:	bd10      	pop	{r4, pc}
    Error_Handler();
 801e668:	f7fc fc1a 	bl	801aea0 <Error_Handler>
 801e66c:	e7f2      	b.n	801e654 <MX_TIM9_Init+0x2c>
    Error_Handler();
 801e66e:	f7fc fc17 	bl	801aea0 <Error_Handler>
}
 801e672:	b004      	add	sp, #16
 801e674:	bd10      	pop	{r4, pc}
 801e676:	bf00      	nop
 801e678:	20018cc4 	.word	0x20018cc4
 801e67c:	40014000 	.word	0x40014000

0801e680 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM4)
 801e680:	4a58      	ldr	r2, [pc, #352]	; (801e7e4 <HAL_TIM_Base_MspInit+0x164>)
 801e682:	6803      	ldr	r3, [r0, #0]
 801e684:	4293      	cmp	r3, r2
{
 801e686:	b510      	push	{r4, lr}
 801e688:	b086      	sub	sp, #24
  if(tim_baseHandle->Instance==TIM4)
 801e68a:	d026      	beq.n	801e6da <HAL_TIM_Base_MspInit+0x5a>
    HAL_NVIC_EnableIRQ(TIM4_IRQn);
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
 801e68c:	4a56      	ldr	r2, [pc, #344]	; (801e7e8 <HAL_TIM_Base_MspInit+0x168>)
 801e68e:	4293      	cmp	r3, r2
 801e690:	d05c      	beq.n	801e74c <HAL_TIM_Base_MspInit+0xcc>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM6)
 801e692:	4a56      	ldr	r2, [pc, #344]	; (801e7ec <HAL_TIM_Base_MspInit+0x16c>)
 801e694:	4293      	cmp	r3, r2
 801e696:	d06e      	beq.n	801e776 <HAL_TIM_Base_MspInit+0xf6>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM7)
 801e698:	4a55      	ldr	r2, [pc, #340]	; (801e7f0 <HAL_TIM_Base_MspInit+0x170>)
 801e69a:	4293      	cmp	r3, r2
 801e69c:	d008      	beq.n	801e6b0 <HAL_TIM_Base_MspInit+0x30>
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM8)
 801e69e:	4a55      	ldr	r2, [pc, #340]	; (801e7f4 <HAL_TIM_Base_MspInit+0x174>)
 801e6a0:	4293      	cmp	r3, r2
 801e6a2:	d07d      	beq.n	801e7a0 <HAL_TIM_Base_MspInit+0x120>
    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM9)
 801e6a4:	4a54      	ldr	r2, [pc, #336]	; (801e7f8 <HAL_TIM_Base_MspInit+0x178>)
 801e6a6:	4293      	cmp	r3, r2
 801e6a8:	f000 808b 	beq.w	801e7c2 <HAL_TIM_Base_MspInit+0x142>
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
  /* USER CODE BEGIN TIM9_MspInit 1 */

  /* USER CODE END TIM9_MspInit 1 */
  }
}
 801e6ac:	b006      	add	sp, #24
 801e6ae:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM7_CLK_ENABLE();
 801e6b0:	4b52      	ldr	r3, [pc, #328]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
    HAL_NVIC_SetPriority(TIM7_IRQn, 4, 0);
 801e6b2:	2037      	movs	r0, #55	; 0x37
 801e6b4:	2200      	movs	r2, #0
 801e6b6:	2104      	movs	r1, #4
    __HAL_RCC_TIM7_CLK_ENABLE();
 801e6b8:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801e6ba:	f044 0420 	orr.w	r4, r4, #32
 801e6be:	641c      	str	r4, [r3, #64]	; 0x40
 801e6c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801e6c2:	f003 0320 	and.w	r3, r3, #32
 801e6c6:	9303      	str	r3, [sp, #12]
 801e6c8:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM7_IRQn, 4, 0);
 801e6ca:	f7e2 fd07 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
 801e6ce:	2037      	movs	r0, #55	; 0x37
}
 801e6d0:	b006      	add	sp, #24
 801e6d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 801e6d6:	f7e2 bd4b 	b.w	8001170 <HAL_NVIC_EnableIRQ>
	  __HAL_TIM_CLEAR_FLAG(&htim4, TIM_IT_UPDATE);
 801e6da:	4849      	ldr	r0, [pc, #292]	; (801e800 <HAL_TIM_Base_MspInit+0x180>)
	  __HAL_TIM_CLEAR_FLAG(&htim5, TIM_IT_UPDATE);
 801e6dc:	4949      	ldr	r1, [pc, #292]	; (801e804 <HAL_TIM_Base_MspInit+0x184>)
	  __HAL_TIM_CLEAR_FLAG(&htim6, TIM_IT_UPDATE);
 801e6de:	4a4a      	ldr	r2, [pc, #296]	; (801e808 <HAL_TIM_Base_MspInit+0x188>)
	  __HAL_TIM_CLEAR_FLAG(&htim7, TIM_IT_UPDATE);
 801e6e0:	4b4a      	ldr	r3, [pc, #296]	; (801e80c <HAL_TIM_Base_MspInit+0x18c>)
	  __HAL_TIM_CLEAR_FLAG(&htim4, TIM_IT_UPDATE);
 801e6e2:	6804      	ldr	r4, [r0, #0]
	  __HAL_TIM_CLEAR_FLAG(&htim5, TIM_IT_UPDATE);
 801e6e4:	6808      	ldr	r0, [r1, #0]
	  __HAL_TIM_CLEAR_FLAG(&htim6, TIM_IT_UPDATE);
 801e6e6:	6811      	ldr	r1, [r2, #0]
	  __HAL_TIM_CLEAR_FLAG(&htim7, TIM_IT_UPDATE);
 801e6e8:	681a      	ldr	r2, [r3, #0]
	  __HAL_TIM_CLEAR_FLAG(&htim4, TIM_IT_UPDATE);
 801e6ea:	f06f 0301 	mvn.w	r3, #1
 801e6ee:	6123      	str	r3, [r4, #16]
	  __HAL_TIM_CLEAR_FLAG(&htim5, TIM_IT_UPDATE);
 801e6f0:	6103      	str	r3, [r0, #16]
	  __HAL_TIM_CLEAR_FLAG(&htim6, TIM_IT_UPDATE);
 801e6f2:	610b      	str	r3, [r1, #16]
	  __HAL_TIM_CLEAR_FLAG(&htim7, TIM_IT_UPDATE);
 801e6f4:	6113      	str	r3, [r2, #16]
	  __HAL_TIM_ENABLE_IT(&htim4, TIM_IT_UPDATE);
 801e6f6:	68e3      	ldr	r3, [r4, #12]
 801e6f8:	f043 0301 	orr.w	r3, r3, #1
 801e6fc:	60e3      	str	r3, [r4, #12]
	  __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_UPDATE);
 801e6fe:	68c3      	ldr	r3, [r0, #12]
	  __HAL_TIM_ENABLE_IT(&htim9, TIM_IT_UPDATE);
 801e700:	4c43      	ldr	r4, [pc, #268]	; (801e810 <HAL_TIM_Base_MspInit+0x190>)
	  __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_UPDATE);
 801e702:	f043 0301 	orr.w	r3, r3, #1
	  __HAL_TIM_ENABLE_IT(&htim9, TIM_IT_UPDATE);
 801e706:	6824      	ldr	r4, [r4, #0]
	  __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_UPDATE);
 801e708:	60c3      	str	r3, [r0, #12]
    HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);
 801e70a:	201e      	movs	r0, #30
	  __HAL_TIM_ENABLE_IT(&htim6, TIM_IT_UPDATE);
 801e70c:	68cb      	ldr	r3, [r1, #12]
 801e70e:	f043 0301 	orr.w	r3, r3, #1
 801e712:	60cb      	str	r3, [r1, #12]
	  __HAL_TIM_ENABLE_IT(&htim7, TIM_IT_UPDATE);
 801e714:	68d1      	ldr	r1, [r2, #12]
    __HAL_RCC_TIM4_CLK_ENABLE();
 801e716:	4b39      	ldr	r3, [pc, #228]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
	  __HAL_TIM_ENABLE_IT(&htim7, TIM_IT_UPDATE);
 801e718:	f041 0101 	orr.w	r1, r1, #1
 801e71c:	60d1      	str	r1, [r2, #12]
    HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);
 801e71e:	2101      	movs	r1, #1
	  __HAL_TIM_ENABLE_IT(&htim9, TIM_IT_UPDATE);
 801e720:	68e2      	ldr	r2, [r4, #12]
 801e722:	f042 0201 	orr.w	r2, r2, #1
 801e726:	60e2      	str	r2, [r4, #12]
    HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);
 801e728:	2200      	movs	r2, #0
    __HAL_RCC_TIM4_CLK_ENABLE();
 801e72a:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801e72c:	f044 0404 	orr.w	r4, r4, #4
 801e730:	641c      	str	r4, [r3, #64]	; 0x40
 801e732:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801e734:	f003 0304 	and.w	r3, r3, #4
 801e738:	9300      	str	r3, [sp, #0]
 801e73a:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);
 801e73c:	f7e2 fcce 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM4_IRQn);
 801e740:	201e      	movs	r0, #30
}
 801e742:	b006      	add	sp, #24
 801e744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 801e748:	f7e2 bd12 	b.w	8001170 <HAL_NVIC_EnableIRQ>
    __HAL_RCC_TIM5_CLK_ENABLE();
 801e74c:	4b2b      	ldr	r3, [pc, #172]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
    HAL_NVIC_SetPriority(TIM5_IRQn, 3, 0);
 801e74e:	2032      	movs	r0, #50	; 0x32
 801e750:	2200      	movs	r2, #0
 801e752:	2103      	movs	r1, #3
    __HAL_RCC_TIM5_CLK_ENABLE();
 801e754:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801e756:	f044 0408 	orr.w	r4, r4, #8
 801e75a:	641c      	str	r4, [r3, #64]	; 0x40
 801e75c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801e75e:	f003 0308 	and.w	r3, r3, #8
 801e762:	9301      	str	r3, [sp, #4]
 801e764:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM5_IRQn, 3, 0);
 801e766:	f7e2 fcb9 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 801e76a:	2032      	movs	r0, #50	; 0x32
}
 801e76c:	b006      	add	sp, #24
 801e76e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 801e772:	f7e2 bcfd 	b.w	8001170 <HAL_NVIC_EnableIRQ>
    __HAL_RCC_TIM6_CLK_ENABLE();
 801e776:	4b21      	ldr	r3, [pc, #132]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 1, 0);
 801e778:	2036      	movs	r0, #54	; 0x36
 801e77a:	2200      	movs	r2, #0
 801e77c:	2101      	movs	r1, #1
    __HAL_RCC_TIM6_CLK_ENABLE();
 801e77e:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801e780:	f044 0410 	orr.w	r4, r4, #16
 801e784:	641c      	str	r4, [r3, #64]	; 0x40
 801e786:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801e788:	f003 0310 	and.w	r3, r3, #16
 801e78c:	9302      	str	r3, [sp, #8]
 801e78e:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 1, 0);
 801e790:	f7e2 fca4 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 801e794:	2036      	movs	r0, #54	; 0x36
}
 801e796:	b006      	add	sp, #24
 801e798:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 801e79c:	f7e2 bce8 	b.w	8001170 <HAL_NVIC_EnableIRQ>
    __HAL_RCC_TIM8_CLK_ENABLE();
 801e7a0:	4b16      	ldr	r3, [pc, #88]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 1, 0);
 801e7a2:	202c      	movs	r0, #44	; 0x2c
 801e7a4:	2200      	movs	r2, #0
 801e7a6:	2101      	movs	r1, #1
    __HAL_RCC_TIM8_CLK_ENABLE();
 801e7a8:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 801e7aa:	f044 0402 	orr.w	r4, r4, #2
 801e7ae:	645c      	str	r4, [r3, #68]	; 0x44
 801e7b0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e7b2:	f003 0302 	and.w	r3, r3, #2
 801e7b6:	9304      	str	r3, [sp, #16]
 801e7b8:	9b04      	ldr	r3, [sp, #16]
    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 1, 0);
 801e7ba:	f7e2 fc8f 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
 801e7be:	202c      	movs	r0, #44	; 0x2c
 801e7c0:	e786      	b.n	801e6d0 <HAL_TIM_Base_MspInit+0x50>
    __HAL_RCC_TIM9_CLK_ENABLE();
 801e7c2:	4b0e      	ldr	r3, [pc, #56]	; (801e7fc <HAL_TIM_Base_MspInit+0x17c>)
    HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 2, 0);
 801e7c4:	2018      	movs	r0, #24
 801e7c6:	2200      	movs	r2, #0
 801e7c8:	2102      	movs	r1, #2
    __HAL_RCC_TIM9_CLK_ENABLE();
 801e7ca:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 801e7cc:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
 801e7d0:	645c      	str	r4, [r3, #68]	; 0x44
 801e7d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e7d4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801e7d8:	9305      	str	r3, [sp, #20]
 801e7da:	9b05      	ldr	r3, [sp, #20]
    HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 2, 0);
 801e7dc:	f7e2 fc7e 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 801e7e0:	2018      	movs	r0, #24
 801e7e2:	e775      	b.n	801e6d0 <HAL_TIM_Base_MspInit+0x50>
 801e7e4:	40000800 	.word	0x40000800
 801e7e8:	40000c00 	.word	0x40000c00
 801e7ec:	40001000 	.word	0x40001000
 801e7f0:	40001400 	.word	0x40001400
 801e7f4:	40010400 	.word	0x40010400
 801e7f8:	40014000 	.word	0x40014000
 801e7fc:	40023800 	.word	0x40023800
 801e800:	20018b84 	.word	0x20018b84
 801e804:	20018bc4 	.word	0x20018bc4
 801e808:	20018c04 	.word	0x20018c04
 801e80c:	20018c44 	.word	0x20018c44
 801e810:	20018cc4 	.word	0x20018cc4

0801e814 <USBH_UserProcess2>:

static void USBH_UserProcess2  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_21 */
	//dbgAddText("userProc2");
  switch(id)
 801e814:	2904      	cmp	r1, #4
 801e816:	d004      	beq.n	801e822 <USBH_UserProcess2+0xe>
 801e818:	2905      	cmp	r1, #5
 801e81a:	d00d      	beq.n	801e838 <USBH_UserProcess2+0x24>
 801e81c:	2902      	cmp	r1, #2
 801e81e:	d006      	beq.n	801e82e <USBH_UserProcess2+0x1a>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_21 */
}
 801e820:	4770      	bx	lr
  Appli_FS_state = APPLICATION_START;
 801e822:	4b08      	ldr	r3, [pc, #32]	; (801e844 <USBH_UserProcess2+0x30>)
 801e824:	2201      	movs	r2, #1
  dbgAddText("userPrStart");
 801e826:	4808      	ldr	r0, [pc, #32]	; (801e848 <USBH_UserProcess2+0x34>)
  Appli_FS_state = APPLICATION_START;
 801e828:	701a      	strb	r2, [r3, #0]
  dbgAddText("userPrStart");
 801e82a:	f7fb b941 	b.w	8019ab0 <dbgAddText>
  Appli_FS_state = APPLICATION_READY;
 801e82e:	4b05      	ldr	r3, [pc, #20]	; (801e844 <USBH_UserProcess2+0x30>)
  dbgAddText("userPrRDY");
 801e830:	4806      	ldr	r0, [pc, #24]	; (801e84c <USBH_UserProcess2+0x38>)
  Appli_FS_state = APPLICATION_READY;
 801e832:	7019      	strb	r1, [r3, #0]
  dbgAddText("userPrRDY");
 801e834:	f7fb b93c 	b.w	8019ab0 <dbgAddText>
  Appli_FS_state = APPLICATION_DISCONNECT;
 801e838:	4b02      	ldr	r3, [pc, #8]	; (801e844 <USBH_UserProcess2+0x30>)
 801e83a:	2203      	movs	r2, #3
  dbgAddText("userPrDisconn");
 801e83c:	4804      	ldr	r0, [pc, #16]	; (801e850 <USBH_UserProcess2+0x3c>)
  Appli_FS_state = APPLICATION_DISCONNECT;
 801e83e:	701a      	strb	r2, [r3, #0]
  dbgAddText("userPrDisconn");
 801e840:	f7fb b936 	b.w	8019ab0 <dbgAddText>
 801e844:	20018d04 	.word	0x20018d04
 801e848:	08026f34 	.word	0x08026f34
 801e84c:	08026f28 	.word	0x08026f28
 801e850:	08026f18 	.word	0x08026f18

0801e854 <MX_USB_HOST_Init>:
{
 801e854:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess2, 0) != USBH_OK)
 801e856:	2200      	movs	r2, #0
 801e858:	4915      	ldr	r1, [pc, #84]	; (801e8b0 <MX_USB_HOST_Init+0x5c>)
 801e85a:	4816      	ldr	r0, [pc, #88]	; (801e8b4 <MX_USB_HOST_Init+0x60>)
 801e85c:	f7ea fb08 	bl	8008e70 <USBH_Init>
 801e860:	b948      	cbnz	r0, 801e876 <MX_USB_HOST_Init+0x22>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MSC_CLASS) != USBH_OK)
 801e862:	4915      	ldr	r1, [pc, #84]	; (801e8b8 <MX_USB_HOST_Init+0x64>)
 801e864:	4813      	ldr	r0, [pc, #76]	; (801e8b4 <MX_USB_HOST_Init+0x60>)
 801e866:	f7ea fb61 	bl	8008f2c <USBH_RegisterClass>
 801e86a:	b978      	cbnz	r0, 801e88c <MX_USB_HOST_Init+0x38>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 801e86c:	4811      	ldr	r0, [pc, #68]	; (801e8b4 <MX_USB_HOST_Init+0x60>)
 801e86e:	f7ea fbfb 	bl	8009068 <USBH_Start>
 801e872:	b9a8      	cbnz	r0, 801e8a0 <MX_USB_HOST_Init+0x4c>
}
 801e874:	bd08      	pop	{r3, pc}
	  dbgAddText("fs init");
 801e876:	4811      	ldr	r0, [pc, #68]	; (801e8bc <MX_USB_HOST_Init+0x68>)
 801e878:	f7fb f91a 	bl	8019ab0 <dbgAddText>
    Error_Handler();
 801e87c:	f7fc fb10 	bl	801aea0 <Error_Handler>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MSC_CLASS) != USBH_OK)
 801e880:	490d      	ldr	r1, [pc, #52]	; (801e8b8 <MX_USB_HOST_Init+0x64>)
 801e882:	480c      	ldr	r0, [pc, #48]	; (801e8b4 <MX_USB_HOST_Init+0x60>)
 801e884:	f7ea fb52 	bl	8008f2c <USBH_RegisterClass>
 801e888:	2800      	cmp	r0, #0
 801e88a:	d0ef      	beq.n	801e86c <MX_USB_HOST_Init+0x18>
	  dbgAddText("fs reg err");
 801e88c:	480c      	ldr	r0, [pc, #48]	; (801e8c0 <MX_USB_HOST_Init+0x6c>)
 801e88e:	f7fb f90f 	bl	8019ab0 <dbgAddText>
    Error_Handler();
 801e892:	f7fc fb05 	bl	801aea0 <Error_Handler>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 801e896:	4807      	ldr	r0, [pc, #28]	; (801e8b4 <MX_USB_HOST_Init+0x60>)
 801e898:	f7ea fbe6 	bl	8009068 <USBH_Start>
 801e89c:	2800      	cmp	r0, #0
 801e89e:	d0e9      	beq.n	801e874 <MX_USB_HOST_Init+0x20>
	  dbgAddText("fs start err");
 801e8a0:	4808      	ldr	r0, [pc, #32]	; (801e8c4 <MX_USB_HOST_Init+0x70>)
 801e8a2:	f7fb f905 	bl	8019ab0 <dbgAddText>
}
 801e8a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 801e8aa:	f7fc baf9 	b.w	801aea0 <Error_Handler>
 801e8ae:	bf00      	nop
 801e8b0:	0801e815 	.word	0x0801e815
 801e8b4:	20018d08 	.word	0x20018d08
 801e8b8:	20000008 	.word	0x20000008
 801e8bc:	08026f40 	.word	0x08026f40
 801e8c0:	08026f48 	.word	0x08026f48
 801e8c4:	08026f54 	.word	0x08026f54

0801e8c8 <MX_USB_HOST_Process>:
{
 801e8c8:	b538      	push	{r3, r4, r5, lr}
	  ((hUsbHostFS.gState != HOST_CLASS) && (hUsbHostFS.gState != HOST_DEV_DISCONNECTED)
 801e8ca:	4c13      	ldr	r4, [pc, #76]	; (801e918 <MX_USB_HOST_Process+0x50>)
 801e8cc:	7823      	ldrb	r3, [r4, #0]
 801e8ce:	2b0b      	cmp	r3, #11
 801e8d0:	d108      	bne.n	801e8e4 <MX_USB_HOST_Process+0x1c>
 801e8d2:	e00b      	b.n	801e8ec <MX_USB_HOST_Process+0x24>
		  && (hUsbHostFS.gState != HOST_ABORT_STATE) )
 801e8d4:	7823      	ldrb	r3, [r4, #0]
 801e8d6:	2b0d      	cmp	r3, #13
 801e8d8:	d008      	beq.n	801e8ec <MX_USB_HOST_Process+0x24>
	  USBH_Process(&hUsbHostFS);
 801e8da:	f7ea fbcf 	bl	800907c <USBH_Process>
	  ((hUsbHostFS.gState != HOST_CLASS) && (hUsbHostFS.gState != HOST_DEV_DISCONNECTED)
 801e8de:	7823      	ldrb	r3, [r4, #0]
 801e8e0:	2b0b      	cmp	r3, #11
 801e8e2:	d003      	beq.n	801e8ec <MX_USB_HOST_Process+0x24>
 801e8e4:	7823      	ldrb	r3, [r4, #0]
	  USBH_Process(&hUsbHostFS);
 801e8e6:	4620      	mov	r0, r4
	  ((hUsbHostFS.gState != HOST_CLASS) && (hUsbHostFS.gState != HOST_DEV_DISCONNECTED)
 801e8e8:	2b03      	cmp	r3, #3
 801e8ea:	d1f3      	bne.n	801e8d4 <MX_USB_HOST_Process+0xc>
  if (hUsbHostFS.gState == HOST_CLASS){
 801e8ec:	7823      	ldrb	r3, [r4, #0]
 801e8ee:	2b0b      	cmp	r3, #11
 801e8f0:	d000      	beq.n	801e8f4 <MX_USB_HOST_Process+0x2c>
}
 801e8f2:	bd38      	pop	{r3, r4, r5, pc}
	  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) hUsbHostFS.pActiveClass->pData;
 801e8f4:	f8d4 347c 	ldr.w	r3, [r4, #1148]	; 0x47c
 801e8f8:	69dc      	ldr	r4, [r3, #28]
	  while((MSC_Handle->state != MSC_IDLE) && (MSC_Handle->state != MSC_UNRECOVERED_ERROR))
 801e8fa:	7b23      	ldrb	r3, [r4, #12]
 801e8fc:	2b01      	cmp	r3, #1
 801e8fe:	d0f8      	beq.n	801e8f2 <MX_USB_HOST_Process+0x2a>
 801e900:	2b08      	cmp	r3, #8
 801e902:	d0f6      	beq.n	801e8f2 <MX_USB_HOST_Process+0x2a>
		  USBH_Process(&hUsbHostFS);
 801e904:	4d04      	ldr	r5, [pc, #16]	; (801e918 <MX_USB_HOST_Process+0x50>)
 801e906:	4628      	mov	r0, r5
 801e908:	f7ea fbb8 	bl	800907c <USBH_Process>
	  while((MSC_Handle->state != MSC_IDLE) && (MSC_Handle->state != MSC_UNRECOVERED_ERROR))
 801e90c:	7b23      	ldrb	r3, [r4, #12]
 801e90e:	2b01      	cmp	r3, #1
 801e910:	d0ef      	beq.n	801e8f2 <MX_USB_HOST_Process+0x2a>
 801e912:	2b08      	cmp	r3, #8
 801e914:	d1f7      	bne.n	801e906 <MX_USB_HOST_Process+0x3e>
}
 801e916:	bd38      	pop	{r3, r4, r5, pc}
 801e918:	20018d08 	.word	0x20018d08

0801e91c <HAL_HCD_MspInit>:
  */
void HAL_HCD_MspInit(HCD_HandleTypeDef * hhcd)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  if (hhcd->Instance == USB_OTG_FS)
 801e91c:	6803      	ldr	r3, [r0, #0]
 801e91e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
{
 801e922:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 801e926:	b090      	sub	sp, #64	; 0x40
  if (hhcd->Instance == USB_OTG_FS)
 801e928:	d005      	beq.n	801e936 <HAL_HCD_MspInit+0x1a>
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);

    /* Enable USBFS Interrupt */
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  }
  else if (hhcd->Instance == USB_OTG_HS)
 801e92a:	4a71      	ldr	r2, [pc, #452]	; (801eaf0 <HAL_HCD_MspInit+0x1d4>)
 801e92c:	4293      	cmp	r3, r2
 801e92e:	d057      	beq.n	801e9e0 <HAL_HCD_MspInit+0xc4>
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);

    /* Enable USBHS Interrupt */
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
  }
}
 801e930:	b010      	add	sp, #64	; 0x40
 801e932:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e936:	4c6f      	ldr	r4, [pc, #444]	; (801eaf4 <HAL_HCD_MspInit+0x1d8>)
    GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
 801e938:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 801e93c:	2102      	movs	r1, #2
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 801e93e:	250a      	movs	r5, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e940:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
 801e942:	2200      	movs	r2, #0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801e944:	2600      	movs	r6, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e946:	f043 0301 	orr.w	r3, r3, #1
 801e94a:	6323      	str	r3, [r4, #48]	; 0x30
 801e94c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801e94e:	f003 0301 	and.w	r3, r3, #1
 801e952:	9300      	str	r3, [sp, #0]
 801e954:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801e956:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801e958:	f043 0308 	orr.w	r3, r3, #8
 801e95c:	6323      	str	r3, [r4, #48]	; 0x30
 801e95e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 801e960:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801e962:	f003 0308 	and.w	r3, r3, #8
 801e966:	9301      	str	r3, [sp, #4]
 801e968:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
 801e96a:	2303      	movs	r3, #3
 801e96c:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e970:	a90a      	add	r1, sp, #40	; 0x28
 801e972:	4861      	ldr	r0, [pc, #388]	; (801eaf8 <HAL_HCD_MspInit+0x1dc>)
    GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
 801e974:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e978:	f7e3 fa38 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 801e97c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801e980:	2312      	movs	r3, #18
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e982:	a90a      	add	r1, sp, #40	; 0x28
 801e984:	485c      	ldr	r0, [pc, #368]	; (801eaf8 <HAL_HCD_MspInit+0x1dc>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 801e986:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 801e988:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 801e98c:	2301      	movs	r3, #1
 801e98e:	930c      	str	r3, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e990:	f7e3 fa2c 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801e994:	2220      	movs	r2, #32
 801e996:	2301      	movs	r3, #1
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801e998:	a90a      	add	r1, sp, #40	; 0x28
 801e99a:	4858      	ldr	r0, [pc, #352]	; (801eafc <HAL_HCD_MspInit+0x1e0>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801e99c:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801e99e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801e9a2:	f7e3 fa23 	bl	8001dec <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801e9a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 801e9a8:	4632      	mov	r2, r6
 801e9aa:	2106      	movs	r1, #6
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801e9ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 801e9b0:	2043      	movs	r0, #67	; 0x43
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801e9b2:	6363      	str	r3, [r4, #52]	; 0x34
 801e9b4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801e9b6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801e9ba:	9302      	str	r3, [sp, #8]
 801e9bc:	9b02      	ldr	r3, [sp, #8]
 801e9be:	6c63      	ldr	r3, [r4, #68]	; 0x44
 801e9c0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 801e9c4:	6463      	str	r3, [r4, #68]	; 0x44
 801e9c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 801e9c8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801e9cc:	9303      	str	r3, [sp, #12]
 801e9ce:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 801e9d0:	f7e2 fb84 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 801e9d4:	2043      	movs	r0, #67	; 0x43
 801e9d6:	f7e2 fbcb 	bl	8001170 <HAL_NVIC_EnableIRQ>
}
 801e9da:	b010      	add	sp, #64	; 0x40
 801e9dc:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e9e0:	4c44      	ldr	r4, [pc, #272]	; (801eaf4 <HAL_HCD_MspInit+0x1d8>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801e9e2:	250a      	movs	r5, #10
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801e9e4:	f04f 0800 	mov.w	r8, #0
 801e9e8:	f04f 0903 	mov.w	r9, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e9ec:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801e9ee:	2220      	movs	r2, #32
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e9f0:	a90a      	add	r1, sp, #40	; 0x28
 801e9f2:	4841      	ldr	r0, [pc, #260]	; (801eaf8 <HAL_HCD_MspInit+0x1dc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e9f4:	f043 0301 	orr.w	r3, r3, #1
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801e9f8:	2600      	movs	r6, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e9fa:	6323      	str	r3, [r4, #48]	; 0x30
 801e9fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801e9fe:	f003 0301 	and.w	r3, r3, #1
 801ea02:	9304      	str	r3, [sp, #16]
 801ea04:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801ea06:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ea08:	f043 0302 	orr.w	r3, r3, #2
 801ea0c:	6323      	str	r3, [r4, #48]	; 0x30
 801ea0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ea10:	f003 0302 	and.w	r3, r3, #2
 801ea14:	9305      	str	r3, [sp, #20]
 801ea16:	9b05      	ldr	r3, [sp, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 801ea18:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ea1a:	f043 0304 	orr.w	r3, r3, #4
 801ea1e:	6323      	str	r3, [r4, #48]	; 0x30
 801ea20:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ea22:	f003 0304 	and.w	r3, r3, #4
 801ea26:	9306      	str	r3, [sp, #24]
 801ea28:	9b06      	ldr	r3, [sp, #24]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801ea2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ea2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801ea30:	6323      	str	r3, [r4, #48]	; 0x30
 801ea32:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801ea34:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801ea36:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801ea3a:	9307      	str	r3, [sp, #28]
 801ea3c:	9b07      	ldr	r3, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801ea3e:	2302      	movs	r3, #2
 801ea40:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
 801ea44:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801ea48:	f7e3 f9d0 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 801ea4c:	2208      	movs	r2, #8
 801ea4e:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801ea50:	a90a      	add	r1, sp, #40	; 0x28
 801ea52:	4829      	ldr	r0, [pc, #164]	; (801eaf8 <HAL_HCD_MspInit+0x1dc>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801ea54:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 801ea56:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 801ea5a:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801ea5e:	f7e3 f9c5 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_5 |
 801ea62:	f643 4223 	movw	r2, #15395	; 0x3c23
 801ea66:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801ea68:	a90a      	add	r1, sp, #40	; 0x28
 801ea6a:	4825      	ldr	r0, [pc, #148]	; (801eb00 <HAL_HCD_MspInit+0x1e4>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801ea6c:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801ea6e:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_5 |
 801ea70:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801ea74:	f7e3 f9ba 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 801ea78:	2201      	movs	r2, #1
 801ea7a:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801ea7c:	a90a      	add	r1, sp, #40	; 0x28
 801ea7e:	4821      	ldr	r0, [pc, #132]	; (801eb04 <HAL_HCD_MspInit+0x1e8>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801ea80:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801ea82:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 801ea84:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801ea88:	f7e3 f9b0 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801ea8c:	2210      	movs	r2, #16
 801ea8e:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801ea90:	a90a      	add	r1, sp, #40	; 0x28
 801ea92:	481d      	ldr	r0, [pc, #116]	; (801eb08 <HAL_HCD_MspInit+0x1ec>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801ea94:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801ea96:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 801ea98:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801ea9c:	f7e3 f9a6 	bl	8001dec <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 801eaa0:	2204      	movs	r2, #4
 801eaa2:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801eaa4:	a90a      	add	r1, sp, #40	; 0x28
 801eaa6:	4817      	ldr	r0, [pc, #92]	; (801eb04 <HAL_HCD_MspInit+0x1e8>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 801eaa8:	950e      	str	r5, [sp, #56]	; 0x38
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801eaaa:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 801eaac:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801eab0:	f7e3 f99c 	bl	8001dec <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 801eab4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
 801eab6:	4632      	mov	r2, r6
 801eab8:	2106      	movs	r1, #6
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 801eaba:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
 801eabe:	204d      	movs	r0, #77	; 0x4d
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 801eac0:	6323      	str	r3, [r4, #48]	; 0x30
 801eac2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801eac4:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 801eac8:	9308      	str	r3, [sp, #32]
 801eaca:	9b08      	ldr	r3, [sp, #32]
    __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
 801eacc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801eace:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 801ead2:	6323      	str	r3, [r4, #48]	; 0x30
 801ead4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801ead6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 801eada:	9309      	str	r3, [sp, #36]	; 0x24
 801eadc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
 801eade:	f7e2 fafd 	bl	80010dc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 801eae2:	204d      	movs	r0, #77	; 0x4d
 801eae4:	f7e2 fb44 	bl	8001170 <HAL_NVIC_EnableIRQ>
}
 801eae8:	b010      	add	sp, #64	; 0x40
 801eaea:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
 801eaee:	bf00      	nop
 801eaf0:	40040000 	.word	0x40040000
 801eaf4:	40023800 	.word	0x40023800
 801eaf8:	40020000 	.word	0x40020000
 801eafc:	40020c00 	.word	0x40020c00
 801eb00:	40020400 	.word	0x40020400
 801eb04:	40020800 	.word	0x40020800
 801eb08:	40021c00 	.word	0x40021c00

0801eb0c <HAL_HCD_SOF_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef * hhcd)
{
  USBH_LL_IncTimer(hhcd->pData);
 801eb0c:	f8d0 0300 	ldr.w	r0, [r0, #768]	; 0x300
 801eb10:	f7ea be40 	b.w	8009794 <USBH_LL_IncTimer>

0801eb14 <HAL_HCD_Connect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Connect(hhcd->pData);
 801eb14:	f8d0 0300 	ldr.w	r0, [r0, #768]	; 0x300
 801eb18:	f7ea be54 	b.w	80097c4 <USBH_LL_Connect>

0801eb1c <HAL_HCD_Disconnect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Disconnect(hhcd->pData);
 801eb1c:	f8d0 0300 	ldr.w	r0, [r0, #768]	; 0x300
 801eb20:	f7ea be5c 	b.w	80097dc <USBH_LL_Disconnect>

0801eb24 <HAL_HCD_PortEnabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortEnabled(hhcd->pData);
 801eb24:	f8d0 0300 	ldr.w	r0, [r0, #768]	; 0x300
 801eb28:	f7ea be44 	b.w	80097b4 <USBH_LL_PortEnabled>

0801eb2c <HAL_HCD_PortDisabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortDisabled(hhcd->pData);
 801eb2c:	f8d0 0300 	ldr.w	r0, [r0, #768]	; 0x300
 801eb30:	f7ea be44 	b.w	80097bc <USBH_LL_PortDisabled>

0801eb34 <HAL_HCD_HC_NotifyURBChange_Callback>:
void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef * hhcd,
                                         uint8_t chnum,
                                         HCD_URBStateTypeDef urb_state)
{
  /* To be used with OS to sync URB state with the global state machine */
}
 801eb34:	4770      	bx	lr
 801eb36:	bf00      	nop

0801eb38 <USBH_LL_Init>:
  *         Initialize the Low Level portion of the Host driver.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef * phost)
{
 801eb38:	b510      	push	{r4, lr}
  if (phost->id == 0)
 801eb3a:	f890 34cc 	ldrb.w	r3, [r0, #1228]	; 0x4cc
{
 801eb3e:	4604      	mov	r4, r0
  if (phost->id == 0)
 801eb40:	bb23      	cbnz	r3, 801eb8c <USBH_LL_Init+0x54>
  {
    /* Set the LL Driver parameters */
    hhcd_FS.Instance = USB_OTG_FS;
 801eb42:	4821      	ldr	r0, [pc, #132]	; (801ebc8 <USBH_LL_Init+0x90>)
 801eb44:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    hhcd_FS.Init.Host_channels = 11;
    hhcd_FS.Init.dma_enable = 0;
    hhcd_FS.Init.low_power_enable = 0;
    hhcd_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 801eb48:	2202      	movs	r2, #2
    hhcd_FS.Init.vbus_sensing_enable = 0;
    hhcd_FS.Init.lpm_enable = 0;

    /* Link the driver to the stack */
    hhcd_FS.pData = phost;
    phost->pData = &hhcd_FS;
 801eb4a:	f8c4 04d0 	str.w	r0, [r4, #1232]	; 0x4d0
    hhcd_FS.Instance = USB_OTG_FS;
 801eb4e:	6001      	str	r1, [r0, #0]
    hhcd_FS.Init.dma_enable = 0;
 801eb50:	6103      	str	r3, [r0, #16]
    hhcd_FS.Init.low_power_enable = 0;
 801eb52:	6203      	str	r3, [r0, #32]
    hhcd_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 801eb54:	6182      	str	r2, [r0, #24]
    hhcd_FS.Init.Sof_enable = 0;
 801eb56:	61c3      	str	r3, [r0, #28]
    hhcd_FS.Init.vbus_sensing_enable = 0;
 801eb58:	62c3      	str	r3, [r0, #44]	; 0x2c
    hhcd_FS.Init.lpm_enable = 0;
 801eb5a:	6243      	str	r3, [r0, #36]	; 0x24
    hhcd_FS.pData = phost;
 801eb5c:	f8c0 4300 	str.w	r4, [r0, #768]	; 0x300
    hhcd_FS.Init.Host_channels = 11;
 801eb60:	ed9f 7b17 	vldr	d7, [pc, #92]	; 801ebc0 <USBH_LL_Init+0x88>
 801eb64:	ed80 7b02 	vstr	d7, [r0, #8]

    /* Initialize the LL Driver */
    HAL_HCD_Init(&hhcd_FS);
 801eb68:	f7e3 fb64 	bl	8002234 <HAL_HCD_Init>
    phost->pData = &hhcd_HS;

    /* Initialize the LL driver */
    HAL_HCD_Init(&hhcd_HS);
  }
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_HS));
 801eb6c:	4817      	ldr	r0, [pc, #92]	; (801ebcc <USBH_LL_Init+0x94>)
 801eb6e:	f7e4 f8f3 	bl	8002d58 <HAL_HCD_GetCurrentFrame>
 801eb72:	4601      	mov	r1, r0
 801eb74:	4620      	mov	r0, r4
 801eb76:	f7ea fe09 	bl	800978c <USBH_LL_SetTimer>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_FS));
 801eb7a:	4813      	ldr	r0, [pc, #76]	; (801ebc8 <USBH_LL_Init+0x90>)
 801eb7c:	f7e4 f8ec 	bl	8002d58 <HAL_HCD_GetCurrentFrame>
 801eb80:	4601      	mov	r1, r0
 801eb82:	4620      	mov	r0, r4
 801eb84:	f7ea fe02 	bl	800978c <USBH_LL_SetTimer>

  return USBH_OK;
}
 801eb88:	2000      	movs	r0, #0
 801eb8a:	bd10      	pop	{r4, pc}
    hhcd_HS.Instance = USB_OTG_HS;
 801eb8c:	480f      	ldr	r0, [pc, #60]	; (801ebcc <USBH_LL_Init+0x94>)
    hhcd_HS.Init.low_power_enable = 0;
 801eb8e:	2300      	movs	r3, #0
    hhcd_HS.Init.dma_enable = 1;
 801eb90:	2201      	movs	r2, #1
    hhcd_HS.Instance = USB_OTG_HS;
 801eb92:	490f      	ldr	r1, [pc, #60]	; (801ebd0 <USBH_LL_Init+0x98>)
    hhcd_HS.Init.low_power_enable = 0;
 801eb94:	6203      	str	r3, [r0, #32]
    hhcd_HS.Init.dma_enable = 1;
 801eb96:	6102      	str	r2, [r0, #16]
    hhcd_HS.Init.phy_itface = HCD_PHY_ULPI;
 801eb98:	6182      	str	r2, [r0, #24]
    hhcd_HS.Init.use_external_vbus = 1;
 801eb9a:	6342      	str	r2, [r0, #52]	; 0x34
    hhcd_HS.Init.Host_channels = 11;
 801eb9c:	220b      	movs	r2, #11
    hhcd_HS.Init.Sof_enable = 0;
 801eb9e:	61c3      	str	r3, [r0, #28]
    hhcd_HS.Init.vbus_sensing_enable = 0;
 801eba0:	62c3      	str	r3, [r0, #44]	; 0x2c
    hhcd_HS.Init.lpm_enable = 0;
 801eba2:	6243      	str	r3, [r0, #36]	; 0x24
    hhcd_HS.Init.Host_channels = 11;
 801eba4:	2300      	movs	r3, #0
    phost->pData = &hhcd_HS;
 801eba6:	f8c4 04d0 	str.w	r0, [r4, #1232]	; 0x4d0
    hhcd_HS.Instance = USB_OTG_HS;
 801ebaa:	6001      	str	r1, [r0, #0]
    hhcd_HS.pData = phost;
 801ebac:	f8c0 4300 	str.w	r4, [r0, #768]	; 0x300
    hhcd_HS.Init.Host_channels = 11;
 801ebb0:	e9c0 2302 	strd	r2, r3, [r0, #8]
    HAL_HCD_Init(&hhcd_HS);
 801ebb4:	f7e3 fb3e 	bl	8002234 <HAL_HCD_Init>
 801ebb8:	e7d8      	b.n	801eb6c <USBH_LL_Init+0x34>
 801ebba:	bf00      	nop
 801ebbc:	f3af 8000 	nop.w
 801ebc0:	0000000b 	.word	0x0000000b
 801ebc4:	00000001 	.word	0x00000001
 801ebc8:	200191e0 	.word	0x200191e0
 801ebcc:	200194e8 	.word	0x200194e8
 801ebd0:	40040000 	.word	0x40040000

0801ebd4 <USBH_LL_Start>:
  * @brief  Starts the Low Level portion of the Host driver.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef * phost)
{
 801ebd4:	b508      	push	{r3, lr}
  HAL_HCD_Start(phost->pData);
 801ebd6:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ebda:	f7e4 f881 	bl	8002ce0 <HAL_HCD_Start>
  return USBH_OK;
}
 801ebde:	2000      	movs	r0, #0
 801ebe0:	bd08      	pop	{r3, pc}
 801ebe2:	bf00      	nop

0801ebe4 <USBH_LL_Stop>:
  * @brief  Stops the Low Level portion of the Host driver.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef * phost)
{
 801ebe4:	b508      	push	{r3, lr}
  HAL_HCD_Stop(phost->pData);
 801ebe6:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ebea:	f7e4 f891 	bl	8002d10 <HAL_HCD_Stop>
  return USBH_OK;
}
 801ebee:	2000      	movs	r0, #0
 801ebf0:	bd08      	pop	{r3, pc}
 801ebf2:	bf00      	nop

0801ebf4 <USBH_LL_GetSpeed>:
  * @brief  Returns the USB Host Speed from the Low Level Driver.
  * @param  phost: Host handle
  * @retval USBH Speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef * phost)
{
 801ebf4:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 801ebf6:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ebfa:	f7e4 f8b1 	bl	8002d60 <HAL_HCD_GetCurrentSpeed>
 801ebfe:	2803      	cmp	r0, #3
 801ec00:	bf28      	it	cs
 801ec02:	2001      	movcs	r0, #1
  default:
    speed = USBH_SPEED_FULL;
    break;
  }
  return speed;
}
 801ec04:	b2c0      	uxtb	r0, r0
 801ec06:	bd08      	pop	{r3, pc}

0801ec08 <USBH_LL_ResetPort>:
  * @brief  Resets the Host Port of the Low Level Driver.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef * phost)
{
 801ec08:	b508      	push	{r3, lr}
  HAL_HCD_ResetPort(phost->pData);
 801ec0a:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ec0e:	f7e4 f893 	bl	8002d38 <HAL_HCD_ResetPort>
  return USBH_OK;
}
 801ec12:	2000      	movs	r0, #0
 801ec14:	bd08      	pop	{r3, pc}
 801ec16:	bf00      	nop

0801ec18 <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet Size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef * phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 801ec18:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ec1c:	f7e4 b896 	b.w	8002d4c <HAL_HCD_HC_GetXferCount>

0801ec20 <USBH_LL_OpenPipe>:
                                    uint8_t pipe,
                                    uint8_t epnum,
                                    uint8_t dev_address,
                                    uint8_t speed,
                                    uint8_t ep_type, uint16_t mps)
{
 801ec20:	b510      	push	{r4, lr}
 801ec22:	b084      	sub	sp, #16
  HAL_HCD_HC_Init(phost->pData, pipe, epnum, dev_address, speed, ep_type, mps);
 801ec24:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
{
 801ec28:	f89d 4018 	ldrb.w	r4, [sp, #24]
  HAL_HCD_HC_Init(phost->pData, pipe, epnum, dev_address, speed, ep_type, mps);
 801ec2c:	9400      	str	r4, [sp, #0]
{
 801ec2e:	f89d 401c 	ldrb.w	r4, [sp, #28]
  HAL_HCD_HC_Init(phost->pData, pipe, epnum, dev_address, speed, ep_type, mps);
 801ec32:	9401      	str	r4, [sp, #4]
{
 801ec34:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  HAL_HCD_HC_Init(phost->pData, pipe, epnum, dev_address, speed, ep_type, mps);
 801ec38:	9402      	str	r4, [sp, #8]
 801ec3a:	f7e3 faad 	bl	8002198 <HAL_HCD_HC_Init>
  return USBH_OK;
}
 801ec3e:	2000      	movs	r0, #0
 801ec40:	b004      	add	sp, #16
 801ec42:	bd10      	pop	{r4, pc}

0801ec44 <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef * phost, uint8_t pipe)
{
 801ec44:	b508      	push	{r3, lr}
  HAL_HCD_HC_Halt(phost->pData, pipe);
 801ec46:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ec4a:	f7e3 fadf 	bl	800220c <HAL_HCD_HC_Halt>
  return USBH_OK;
}
 801ec4e:	2000      	movs	r0, #0
 801ec50:	bd08      	pop	{r3, pc}
 801ec52:	bf00      	nop

0801ec54 <USBH_LL_SubmitURB>:
                                     uint8_t direction,
                                     uint8_t ep_type,
                                     uint8_t token,
                                     uint8_t * pbuff,
                                     uint16_t length, uint8_t do_ping)
{
 801ec54:	b510      	push	{r4, lr}
 801ec56:	b084      	sub	sp, #16
  HAL_HCD_HC_SubmitRequest(phost->pData,
 801ec58:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
{
 801ec5c:	f89d 4018 	ldrb.w	r4, [sp, #24]
  HAL_HCD_HC_SubmitRequest(phost->pData,
 801ec60:	9400      	str	r4, [sp, #0]
{
 801ec62:	9c07      	ldr	r4, [sp, #28]
  HAL_HCD_HC_SubmitRequest(phost->pData,
 801ec64:	9401      	str	r4, [sp, #4]
{
 801ec66:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  HAL_HCD_HC_SubmitRequest(phost->pData,
 801ec6a:	9402      	str	r4, [sp, #8]
{
 801ec6c:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
  HAL_HCD_HC_SubmitRequest(phost->pData,
 801ec70:	9403      	str	r4, [sp, #12]
 801ec72:	f7e3 fb47 	bl	8002304 <HAL_HCD_HC_SubmitRequest>
                           pipe,
                           direction, ep_type, token, pbuff, length, do_ping);
  return USBH_OK;
}
 801ec76:	2000      	movs	r0, #0
 801ec78:	b004      	add	sp, #16
 801ec7a:	bd10      	pop	{r4, pc}

0801ec7c <USBH_LL_GetURBState>:
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef * phost,
                                         uint8_t pipe)
{
  return (USBH_URBStateTypeDef) HAL_HCD_HC_GetURBState(phost->pData, pipe);
 801ec7c:	f8d0 04d0 	ldr.w	r0, [r0, #1232]	; 0x4d0
 801ec80:	f7e4 b85e 	b.w	8002d40 <HAL_HCD_HC_GetURBState>

0801ec84 <USBH_LL_DriverVBUS>:
  }

  HAL_Delay(200);
#endif                          /* USE_USB_FS */
  return USBH_OK;
}
 801ec84:	2000      	movs	r0, #0
 801ec86:	4770      	bx	lr

0801ec88 <USBH_LL_SetToggle>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef * phost, uint8_t pipe,
                                     uint8_t toggle)
{
  if (phost->id == 0)
 801ec88:	f890 34cc 	ldrb.w	r3, [r0, #1228]	; 0x4cc
 801ec8c:	b953      	cbnz	r3, 801eca4 <USBH_LL_SetToggle+0x1c>
  {
    if (hhcd_FS.hc[pipe].ep_is_in)
 801ec8e:	4b0b      	ldr	r3, [pc, #44]	; (801ecbc <USBH_LL_SetToggle+0x34>)
 801ec90:	202c      	movs	r0, #44	; 0x2c
 801ec92:	fb00 3101 	mla	r1, r0, r1, r3
 801ec96:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 801ec9a:	b95b      	cbnz	r3, 801ecb4 <USBH_LL_SetToggle+0x2c>
    {
      hhcd_HS.hc[pipe].toggle_out = toggle;
    }
  }
  return USBH_OK;
}
 801ec9c:	2000      	movs	r0, #0
      hhcd_HS.hc[pipe].toggle_out = toggle;
 801ec9e:	f881 2055 	strb.w	r2, [r1, #85]	; 0x55
}
 801eca2:	4770      	bx	lr
    if (hhcd_HS.hc[pipe].ep_is_in)
 801eca4:	4b06      	ldr	r3, [pc, #24]	; (801ecc0 <USBH_LL_SetToggle+0x38>)
 801eca6:	202c      	movs	r0, #44	; 0x2c
 801eca8:	fb00 3101 	mla	r1, r0, r1, r3
 801ecac:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 801ecb0:	2b00      	cmp	r3, #0
 801ecb2:	d0f3      	beq.n	801ec9c <USBH_LL_SetToggle+0x14>
}
 801ecb4:	2000      	movs	r0, #0
      hhcd_HS.hc[pipe].toggle_in = toggle;
 801ecb6:	f881 2054 	strb.w	r2, [r1, #84]	; 0x54
}
 801ecba:	4770      	bx	lr
 801ecbc:	200191e0 	.word	0x200191e0
 801ecc0:	200194e8 	.word	0x200194e8

0801ecc4 <USBH_LL_GetToggle>:
  * @retval toggle (0/1)
  */
uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef * phost, uint8_t pipe)
{
  uint8_t toggle = 0;
  if (phost->id == 0)
 801ecc4:	f890 34cc 	ldrb.w	r3, [r0, #1228]	; 0x4cc
 801ecc8:	b94b      	cbnz	r3, 801ecde <USBH_LL_GetToggle+0x1a>
  {
    if (hhcd_FS.hc[pipe].ep_is_in)
 801ecca:	4b0a      	ldr	r3, [pc, #40]	; (801ecf4 <USBH_LL_GetToggle+0x30>)
 801eccc:	222c      	movs	r2, #44	; 0x2c
 801ecce:	fb02 3101 	mla	r1, r2, r1, r3
 801ecd2:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 801ecd6:	b153      	cbz	r3, 801ecee <USBH_LL_GetToggle+0x2a>
  }
  else
  {
    if (hhcd_HS.hc[pipe].ep_is_in)
    {
      toggle = hhcd_HS.hc[pipe].toggle_in;
 801ecd8:	f891 0054 	ldrb.w	r0, [r1, #84]	; 0x54
 801ecdc:	4770      	bx	lr
    if (hhcd_HS.hc[pipe].ep_is_in)
 801ecde:	4b06      	ldr	r3, [pc, #24]	; (801ecf8 <USBH_LL_GetToggle+0x34>)
 801ece0:	222c      	movs	r2, #44	; 0x2c
 801ece2:	fb02 3101 	mla	r1, r2, r1, r3
 801ece6:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 801ecea:	2b00      	cmp	r3, #0
 801ecec:	d1f4      	bne.n	801ecd8 <USBH_LL_GetToggle+0x14>
    }
    else
    {
      toggle = hhcd_HS.hc[pipe].toggle_out;
 801ecee:	f891 0055 	ldrb.w	r0, [r1, #85]	; 0x55
    }
  }
  return toggle;
}
 801ecf2:	4770      	bx	lr
 801ecf4:	200191e0 	.word	0x200191e0
 801ecf8:	200194e8 	.word	0x200194e8

0801ecfc <USBH_Delay>:
void USBH_Delay(uint32_t Delay)
{
#if (USBH_USE_OS == 1)
  osDelay(Delay);
#else
  HAL_Delay(Delay);
 801ecfc:	f7e2 b9be 	b.w	800107c <HAL_Delay>

0801ed00 <USBH_initialize>:
DSTATUS USBH_initialize(BYTE lun)
{
  /* CAUTION : USB Host library has to be initialized in the application */

  return RES_OK;
}
 801ed00:	2000      	movs	r0, #0
 801ed02:	4770      	bx	lr

0801ed04 <USBH_status>:
  * @brief  Gets Disk Status
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_status(BYTE lun)
{
 801ed04:	4601      	mov	r1, r0
  DRESULT res = RES_ERROR;

  if(USBH_MSC_UnitIsReady(&hUSB_Host, lun))
 801ed06:	4804      	ldr	r0, [pc, #16]	; (801ed18 <USBH_status+0x14>)
{
 801ed08:	b508      	push	{r3, lr}
  if(USBH_MSC_UnitIsReady(&hUSB_Host, lun))
 801ed0a:	f7e9 fc55 	bl	80085b8 <USBH_MSC_UnitIsReady>
  {
    res = RES_ERROR;
  }

  return res;
}
 801ed0e:	fab0 f080 	clz	r0, r0
 801ed12:	0940      	lsrs	r0, r0, #5
 801ed14:	bd08      	pop	{r3, pc}
 801ed16:	bf00      	nop
 801ed18:	20018d08 	.word	0x20018d08

0801ed1c <USBH_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USBH_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 801ed1c:	b510      	push	{r4, lr}
 801ed1e:	4614      	mov	r4, r2
 801ed20:	b08e      	sub	sp, #56	; 0x38
  DRESULT res = RES_ERROR;
  MSC_LUNTypeDef info;

  switch (cmd)
 801ed22:	2903      	cmp	r1, #3
 801ed24:	d82a      	bhi.n	801ed7c <USBH_ioctl+0x60>
 801ed26:	e8df f001 	tbb	[pc, r1]
 801ed2a:	1c02      	.short	0x1c02
 801ed2c:	0511      	.short	0x0511
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC:
    res = RES_OK;
 801ed2e:	4608      	mov	r0, r1
  default:
    res = RES_PARERR;
  }

  return res;
}
 801ed30:	b00e      	add	sp, #56	; 0x38
 801ed32:	bd10      	pop	{r4, pc}
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 801ed34:	4601      	mov	r1, r0
 801ed36:	aa01      	add	r2, sp, #4
 801ed38:	4811      	ldr	r0, [pc, #68]	; (801ed80 <USBH_ioctl+0x64>)
 801ed3a:	f7e9 fc4f 	bl	80085dc <USBH_MSC_GetLUNInfo>
 801ed3e:	b9d0      	cbnz	r0, 801ed76 <USBH_ioctl+0x5a>
      *(DWORD*)buff = info.capacity.block_size / USB_DEFAULT_BLOCK_SIZE;
 801ed40:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801ed44:	0a5b      	lsrs	r3, r3, #9
 801ed46:	6023      	str	r3, [r4, #0]
}
 801ed48:	b00e      	add	sp, #56	; 0x38
 801ed4a:	bd10      	pop	{r4, pc}
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 801ed4c:	4601      	mov	r1, r0
 801ed4e:	aa01      	add	r2, sp, #4
 801ed50:	480b      	ldr	r0, [pc, #44]	; (801ed80 <USBH_ioctl+0x64>)
 801ed52:	f7e9 fc43 	bl	80085dc <USBH_MSC_GetLUNInfo>
 801ed56:	b970      	cbnz	r0, 801ed76 <USBH_ioctl+0x5a>
      *(DWORD*)buff = info.capacity.block_size;
 801ed58:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801ed5c:	6023      	str	r3, [r4, #0]
}
 801ed5e:	b00e      	add	sp, #56	; 0x38
 801ed60:	bd10      	pop	{r4, pc}
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 801ed62:	4601      	mov	r1, r0
 801ed64:	aa01      	add	r2, sp, #4
 801ed66:	4806      	ldr	r0, [pc, #24]	; (801ed80 <USBH_ioctl+0x64>)
 801ed68:	f7e9 fc38 	bl	80085dc <USBH_MSC_GetLUNInfo>
 801ed6c:	b918      	cbnz	r0, 801ed76 <USBH_ioctl+0x5a>
      *(DWORD*)buff = info.capacity.block_nbr;
 801ed6e:	9b02      	ldr	r3, [sp, #8]
 801ed70:	6023      	str	r3, [r4, #0]
}
 801ed72:	b00e      	add	sp, #56	; 0x38
 801ed74:	bd10      	pop	{r4, pc}
      res = RES_ERROR;
 801ed76:	2001      	movs	r0, #1
}
 801ed78:	b00e      	add	sp, #56	; 0x38
 801ed7a:	bd10      	pop	{r4, pc}
  switch (cmd)
 801ed7c:	2004      	movs	r0, #4
 801ed7e:	e7d7      	b.n	801ed30 <USBH_ioctl+0x14>
 801ed80:	20018d08 	.word	0x20018d08

0801ed84 <USBH_read>:
{
 801ed84:	b530      	push	{r4, r5, lr}
 801ed86:	4604      	mov	r4, r0
 801ed88:	b091      	sub	sp, #68	; 0x44
 801ed8a:	461d      	mov	r5, r3
  if(USBH_MSC_Read(&hUSB_Host, lun, sector, buff, count) == USBH_OK)
 801ed8c:	4811      	ldr	r0, [pc, #68]	; (801edd4 <USBH_read+0x50>)
 801ed8e:	460b      	mov	r3, r1
 801ed90:	4621      	mov	r1, r4
 801ed92:	9500      	str	r5, [sp, #0]
 801ed94:	f7e9 fc4a 	bl	800862c <USBH_MSC_Read>
 801ed98:	b908      	cbnz	r0, 801ed9e <USBH_read+0x1a>
}
 801ed9a:	b011      	add	sp, #68	; 0x44
 801ed9c:	bd30      	pop	{r4, r5, pc}
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 801ed9e:	aa03      	add	r2, sp, #12
 801eda0:	4621      	mov	r1, r4
 801eda2:	480c      	ldr	r0, [pc, #48]	; (801edd4 <USBH_read+0x50>)
 801eda4:	f7e9 fc1a 	bl	80085dc <USBH_MSC_GetLUNInfo>
    switch (info.sense.asc)
 801eda8:	f89d 3019 	ldrb.w	r3, [sp, #25]
 801edac:	2b28      	cmp	r3, #40	; 0x28
 801edae:	d006      	beq.n	801edbe <USBH_read+0x3a>
 801edb0:	2b3a      	cmp	r3, #58	; 0x3a
 801edb2:	d004      	beq.n	801edbe <USBH_read+0x3a>
 801edb4:	2b04      	cmp	r3, #4
 801edb6:	d002      	beq.n	801edbe <USBH_read+0x3a>
 801edb8:	2001      	movs	r0, #1
}
 801edba:	b011      	add	sp, #68	; 0x44
 801edbc:	bd30      	pop	{r4, r5, pc}
      USBH_ErrLog ("USB Disk is not ready!");
 801edbe:	4806      	ldr	r0, [pc, #24]	; (801edd8 <USBH_read+0x54>)
 801edc0:	f001 fa8a 	bl	80202d8 <iprintf>
 801edc4:	4805      	ldr	r0, [pc, #20]	; (801eddc <USBH_read+0x58>)
 801edc6:	f001 fa87 	bl	80202d8 <iprintf>
 801edca:	200a      	movs	r0, #10
 801edcc:	f001 fa9c 	bl	8020308 <putchar>
 801edd0:	2003      	movs	r0, #3
 801edd2:	e7e2      	b.n	801ed9a <USBH_read+0x16>
 801edd4:	20018d08 	.word	0x20018d08
 801edd8:	08021984 	.word	0x08021984
 801eddc:	08026f64 	.word	0x08026f64

0801ede0 <USBH_write>:
{
 801ede0:	b530      	push	{r4, r5, lr}
 801ede2:	4604      	mov	r4, r0
 801ede4:	b091      	sub	sp, #68	; 0x44
 801ede6:	461d      	mov	r5, r3
  if(USBH_MSC_Write(&hUSB_Host, lun, sector, (BYTE *)buff, count) == USBH_OK)
 801ede8:	4819      	ldr	r0, [pc, #100]	; (801ee50 <USBH_write+0x70>)
 801edea:	460b      	mov	r3, r1
 801edec:	4621      	mov	r1, r4
 801edee:	9500      	str	r5, [sp, #0]
 801edf0:	f7e9 fcd0 	bl	8008794 <USBH_MSC_Write>
 801edf4:	b908      	cbnz	r0, 801edfa <USBH_write+0x1a>
}
 801edf6:	b011      	add	sp, #68	; 0x44
 801edf8:	bd30      	pop	{r4, r5, pc}
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 801edfa:	aa03      	add	r2, sp, #12
 801edfc:	4621      	mov	r1, r4
 801edfe:	4814      	ldr	r0, [pc, #80]	; (801ee50 <USBH_write+0x70>)
 801ee00:	f7e9 fbec 	bl	80085dc <USBH_MSC_GetLUNInfo>
    switch (info.sense.asc)
 801ee04:	f89d 3019 	ldrb.w	r3, [sp, #25]
 801ee08:	2b27      	cmp	r3, #39	; 0x27
 801ee0a:	d015      	beq.n	801ee38 <USBH_write+0x58>
 801ee0c:	d90f      	bls.n	801ee2e <USBH_write+0x4e>
 801ee0e:	2b28      	cmp	r3, #40	; 0x28
 801ee10:	d001      	beq.n	801ee16 <USBH_write+0x36>
 801ee12:	2b3a      	cmp	r3, #58	; 0x3a
 801ee14:	d10d      	bne.n	801ee32 <USBH_write+0x52>
      USBH_ErrLog ("USB Disk is not ready!");
 801ee16:	480f      	ldr	r0, [pc, #60]	; (801ee54 <USBH_write+0x74>)
 801ee18:	f001 fa5e 	bl	80202d8 <iprintf>
 801ee1c:	480e      	ldr	r0, [pc, #56]	; (801ee58 <USBH_write+0x78>)
 801ee1e:	f001 fa5b 	bl	80202d8 <iprintf>
 801ee22:	200a      	movs	r0, #10
 801ee24:	f001 fa70 	bl	8020308 <putchar>
 801ee28:	2003      	movs	r0, #3
}
 801ee2a:	b011      	add	sp, #68	; 0x44
 801ee2c:	bd30      	pop	{r4, r5, pc}
    switch (info.sense.asc)
 801ee2e:	2b04      	cmp	r3, #4
 801ee30:	d0f1      	beq.n	801ee16 <USBH_write+0x36>
 801ee32:	2001      	movs	r0, #1
}
 801ee34:	b011      	add	sp, #68	; 0x44
 801ee36:	bd30      	pop	{r4, r5, pc}
      USBH_ErrLog("USB Disk is Write protected!");
 801ee38:	4806      	ldr	r0, [pc, #24]	; (801ee54 <USBH_write+0x74>)
 801ee3a:	f001 fa4d 	bl	80202d8 <iprintf>
 801ee3e:	4807      	ldr	r0, [pc, #28]	; (801ee5c <USBH_write+0x7c>)
 801ee40:	f001 fa4a 	bl	80202d8 <iprintf>
 801ee44:	200a      	movs	r0, #10
 801ee46:	f001 fa5f 	bl	8020308 <putchar>
      res = RES_WRPRT;
 801ee4a:	2002      	movs	r0, #2
}
 801ee4c:	b011      	add	sp, #68	; 0x44
 801ee4e:	bd30      	pop	{r4, r5, pc}
 801ee50:	20018d08 	.word	0x20018d08
 801ee54:	08021984 	.word	0x08021984
 801ee58:	08026f64 	.word	0x08026f64
 801ee5c:	08026f7c 	.word	0x08026f7c

0801ee60 <TrackTime>:
			}
		}
	}
}

void TrackTime() {
 801ee60:	b570      	push	{r4, r5, r6, lr}
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801ee62:	4b21      	ldr	r3, [pc, #132]	; (801eee8 <TrackTime+0x88>)
 801ee64:	f242 3e28 	movw	lr, #9000	; 0x2328
 801ee68:	4c20      	ldr	r4, [pc, #128]	; (801eeec <TrackTime+0x8c>)
 801ee6a:	6818      	ldr	r0, [r3, #0]
 801ee6c:	f8d4 1a8c 	ldr.w	r1, [r4, #2700]	; 0xa8c
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801ee70:	f8d4 3a8c 	ldr.w	r3, [r4, #2700]	; 0xa8c
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801ee74:	f8d4 4a8c 	ldr.w	r4, [r4, #2700]	; 0xa8c
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801ee78:	1a09      	subs	r1, r1, r0
 801ee7a:	4a1d      	ldr	r2, [pc, #116]	; (801eef0 <TrackTime+0x90>)
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801ee7c:	1a1b      	subs	r3, r3, r0
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801ee7e:	eba4 0c00 	sub.w	ip, r4, r0
 801ee82:	fba2 4c0c 	umull	r4, ip, r2, ip
	fr = ((file_pos_wide) % 9000) % 150;
 801ee86:	fba2 5400 	umull	r5, r4, r2, r0
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801ee8a:	fba2 6501 	umull	r6, r5, r2, r1
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801ee8e:	ea4f 3c5c 	mov.w	ip, ip, lsr #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801ee92:	fba2 6203 	umull	r6, r2, r2, r3
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801ee96:	0b6d      	lsrs	r5, r5, #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801ee98:	0b52      	lsrs	r2, r2, #13
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801ee9a:	fb0e 1115 	mls	r1, lr, r5, r1
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801ee9e:	fb0e 3312 	mls	r3, lr, r2, r3
	fr = ((file_pos_wide) % 9000) % 150;
 801eea2:	0b62      	lsrs	r2, r4, #13
	sec = ((file_pos_wide) % 9000) / 150;
	min = (file_pos_wide) / 9000;
 801eea4:	0b64      	lsrs	r4, r4, #13
	fr = ((file_pos_wide) % 9000) % 150;
 801eea6:	fb0e 0212 	mls	r2, lr, r2, r0
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801eeaa:	4812      	ldr	r0, [pc, #72]	; (801eef4 <TrackTime+0x94>)
 801eeac:	fba0 5e01 	umull	r5, lr, r0, r1
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801eeb0:	fba0 5303 	umull	r5, r3, r0, r3
	fr = ((file_pos_wide) % 9000) % 150;
 801eeb4:	fba0 5002 	umull	r5, r0, r0, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801eeb8:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
 801eebc:	2596      	movs	r5, #150	; 0x96
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801eebe:	091b      	lsrs	r3, r3, #4
	fr = ((file_pos_wide) % 9000) % 150;
 801eec0:	0900      	lsrs	r0, r0, #4
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801eec2:	fb05 111e 	mls	r1, r5, lr, r1
	fr = ((file_pos_wide) % 9000) % 150;
 801eec6:	fb05 2210 	mls	r2, r5, r0, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801eeca:	4d0b      	ldr	r5, [pc, #44]	; (801eef8 <TrackTime+0x98>)
 801eecc:	8029      	strh	r1, [r5, #0]
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801eece:	490b      	ldr	r1, [pc, #44]	; (801eefc <TrackTime+0x9c>)
 801eed0:	700b      	strb	r3, [r1, #0]
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801eed2:	4b0b      	ldr	r3, [pc, #44]	; (801ef00 <TrackTime+0xa0>)
 801eed4:	f883 c000 	strb.w	ip, [r3]
	fr = ((file_pos_wide) % 9000) % 150;
 801eed8:	4b0a      	ldr	r3, [pc, #40]	; (801ef04 <TrackTime+0xa4>)
 801eeda:	801a      	strh	r2, [r3, #0]
	sec = ((file_pos_wide) % 9000) / 150;
 801eedc:	4a0a      	ldr	r2, [pc, #40]	; (801ef08 <TrackTime+0xa8>)
	min = (file_pos_wide) / 9000;
 801eede:	4b0b      	ldr	r3, [pc, #44]	; (801ef0c <TrackTime+0xac>)
	sec = ((file_pos_wide) % 9000) / 150;
 801eee0:	7010      	strb	r0, [r2, #0]
	min = (file_pos_wide) / 9000;
 801eee2:	701c      	strb	r4, [r3, #0]
}
 801eee4:	bd70      	pop	{r4, r5, r6, pc}
 801eee6:	bf00      	nop
 801eee8:	2000ec8c 	.word	0x2000ec8c
 801eeec:	200174f0 	.word	0x200174f0
 801eef0:	e90452d5 	.word	0xe90452d5
 801eef4:	1b4e81b5 	.word	0x1b4e81b5
 801eef8:	2000fa6e 	.word	0x2000fa6e
 801eefc:	2000fa71 	.word	0x2000fa71
 801ef00:	2000fa70 	.word	0x2000fa70
 801ef04:	2000f0d8 	.word	0x2000f0d8
 801ef08:	2000fa72 	.word	0x2000fa72
 801ef0c:	2000f270 	.word	0x2000f270

0801ef10 <GoToPosition>:
	tim7_flag = 0;
	if(display.timemode == 0) display.trackbarmode = 0;
	else display.trackbarmode = 1;
}

void GoToPosition(uint32_t position) {
 801ef10:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BSP_AUDIO_OUT_Pause();
	file_pos_wide = position;
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef14:	4f4a      	ldr	r7, [pc, #296]	; (801f040 <GoToPosition+0x130>)
void GoToPosition(uint32_t position) {
 801ef16:	4604      	mov	r4, r0
			rekordbox.lowp_spectrum_size;
	if(BufferCtl.filetype == 0)	{
 801ef18:	f8df 814c 	ldr.w	r8, [pc, #332]	; 801f068 <GoToPosition+0x158>
void GoToPosition(uint32_t position) {
 801ef1c:	ed2d 8b02 	vpush	{d8}
	BSP_AUDIO_OUT_Pause();
 801ef20:	f7fd ff52 	bl	801cdc8 <BSP_AUDIO_OUT_Pause>
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef24:	f607 238c 	addw	r3, r7, #2700	; 0xa8c
 801ef28:	ee07 4a90 	vmov	s15, r4
	if(BufferCtl.filetype == 0)	{
 801ef2c:	f508 5b80 	add.w	fp, r8, #4096	; 0x1000
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef30:	edd3 6a00 	vldr	s13, [r3]
			rekordbox.lowp_spectrum_size;
 801ef34:	f607 2388 	addw	r3, r7, #2696	; 0xa88
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef38:	eef8 8a67 	vcvt.f32.u32	s17, s15
	if(BufferCtl.filetype == 0)	{
 801ef3c:	f89b 5008 	ldrb.w	r5, [fp, #8]
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef40:	eef8 6a66 	vcvt.f32.u32	s13, s13
			rekordbox.lowp_spectrum_size;
 801ef44:	ed93 7a00 	vldr	s14, [r3]
	file_pos_wide = position;
 801ef48:	4b3e      	ldr	r3, [pc, #248]	; (801f044 <GoToPosition+0x134>)
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef4a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801ef4e:	eec8 7aa6 	vdiv.f32	s15, s17, s13
	file_pos_wide = position;
 801ef52:	601c      	str	r4, [r3, #0]
	file_pos = (float)position / (float)rekordbox.spectrum_size *
 801ef54:	4b3c      	ldr	r3, [pc, #240]	; (801f048 <GoToPosition+0x138>)
 801ef56:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ef5a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ef5e:	edc3 7a00 	vstr	s15, [r3]
	if(BufferCtl.filetype == 0)	{
 801ef62:	2d00      	cmp	r5, #0
 801ef64:	d146      	bne.n	801eff4 <GoToPosition+0xe4>
 801ef66:	4c39      	ldr	r4, [pc, #228]	; (801f04c <GoToPosition+0x13c>)
		uint16_t i = 0;
		do {
			f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801ef68:	462e      	mov	r6, r5
 801ef6a:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 801f064 <GoToPosition+0x154>
 801ef6e:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 801f060 <GoToPosition+0x150>
 801ef72:	f8d9 1000 	ldr.w	r1, [r9]
 801ef76:	f8da 3000 	ldr.w	r3, [sl]
 801ef7a:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
 801ef7e:	185b      	adds	r3, r3, r1
				/rekordbox.spectrum_size + i));
 801ef80:	f607 218c 	addw	r1, r7, #2700	; 0xa8c
 801ef84:	ed91 8a00 	vldr	s16, [r1]
			f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801ef88:	eb46 0106 	adc.w	r1, r6, r6
 801ef8c:	1ac0      	subs	r0, r0, r3
				/rekordbox.spectrum_size + i));
 801ef8e:	eeb8 8a48 	vcvt.f32.u32	s16, s16
			f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801ef92:	eb62 0101 	sbc.w	r1, r2, r1
 801ef96:	f7e1 fe41 	bl	8000c1c <__aeabi_ul2f>
 801ef9a:	ee07 0a90 	vmov	s15, r0
				/rekordbox.spectrum_size + i));
 801ef9e:	b2ab      	uxth	r3, r5
 801efa0:	3501      	adds	r5, #1
			f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801efa2:	ee27 7aa8 	vmul.f32	s14, s15, s17
				/rekordbox.spectrum_size + i));
 801efa6:	ee07 3a90 	vmov	s15, r3
 801efaa:	eec7 6a08 	vdiv.f32	s13, s14, s16
 801efae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801efb2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801efb6:	ee17 0a90 	vmov	r0, s15
 801efba:	f7e1 fe8d 	bl	8000cd8 <__aeabi_f2ulz>
 801efbe:	4602      	mov	r2, r0
 801efc0:	460b      	mov	r3, r1
 801efc2:	4620      	mov	r0, r4
 801efc4:	f7ed f9c2 	bl	800c34c <f_lseek>
			i++;
		}
		while(((UINT)BufferCtl.buff & 1) != (f_tell(&MyFile) & 1));
 801efc8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801efca:	ea88 0303 	eor.w	r3, r8, r3
 801efce:	07db      	lsls	r3, r3, #31
 801efd0:	d4cf      	bmi.n	801ef72 <GoToPosition+0x62>
	}
	else {
		f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
						/rekordbox.spectrum_size));
	}
	if(BufferCtl.filetype == 1) {
 801efd2:	f89b 3008 	ldrb.w	r3, [fp, #8]
 801efd6:	2b01      	cmp	r3, #1
 801efd8:	d108      	bne.n	801efec <GoToPosition+0xdc>
		unInDataLeft = 0;
 801efda:	2300      	movs	r3, #0
 801efdc:	4c1c      	ldr	r4, [pc, #112]	; (801f050 <GoToPosition+0x140>)
		unDmaBufferSpace = 0;
 801efde:	481d      	ldr	r0, [pc, #116]	; (801f054 <GoToPosition+0x144>)
		unFramesDecoded = 0;
 801efe0:	491d      	ldr	r1, [pc, #116]	; (801f058 <GoToPosition+0x148>)
		unDmaBufMode = 0;
 801efe2:	4a1e      	ldr	r2, [pc, #120]	; (801f05c <GoToPosition+0x14c>)
		unInDataLeft = 0;
 801efe4:	6023      	str	r3, [r4, #0]
		unDmaBufferSpace = 0;
 801efe6:	6003      	str	r3, [r0, #0]
		unFramesDecoded = 0;
 801efe8:	600b      	str	r3, [r1, #0]
		unDmaBufMode = 0;
 801efea:	6013      	str	r3, [r2, #0]
	}
}
 801efec:	ecbd 8b02 	vpop	{d8}
 801eff0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801eff4:	4a1a      	ldr	r2, [pc, #104]	; (801f060 <GoToPosition+0x150>)
 801eff6:	2100      	movs	r1, #0
 801eff8:	4b1a      	ldr	r3, [pc, #104]	; (801f064 <GoToPosition+0x154>)
 801effa:	6810      	ldr	r0, [r2, #0]
 801effc:	4c13      	ldr	r4, [pc, #76]	; (801f04c <GoToPosition+0x13c>)
 801effe:	681b      	ldr	r3, [r3, #0]
						/rekordbox.spectrum_size));
 801f000:	f8d7 5a8c 	ldr.w	r5, [r7, #2700]	; 0xa8c
		f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f004:	181b      	adds	r3, r3, r0
 801f006:	6920      	ldr	r0, [r4, #16]
 801f008:	4149      	adcs	r1, r1
 801f00a:	1ac0      	subs	r0, r0, r3
 801f00c:	6963      	ldr	r3, [r4, #20]
 801f00e:	eb63 0101 	sbc.w	r1, r3, r1
 801f012:	f7e1 fe03 	bl	8000c1c <__aeabi_ul2f>
						/rekordbox.spectrum_size));
 801f016:	ee07 5a90 	vmov	s15, r5
		f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f01a:	ee07 0a10 	vmov	s14, r0
						/rekordbox.spectrum_size));
 801f01e:	eef8 7a67 	vcvt.f32.u32	s15, s15
		f_lseek(&MyFile, (position*(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f022:	ee67 8a28 	vmul.f32	s17, s14, s17
 801f026:	eec8 7aa7 	vdiv.f32	s15, s17, s15
 801f02a:	ee17 0a90 	vmov	r0, s15
 801f02e:	f7e1 fe53 	bl	8000cd8 <__aeabi_f2ulz>
 801f032:	4602      	mov	r2, r0
 801f034:	460b      	mov	r3, r1
 801f036:	4620      	mov	r0, r4
 801f038:	f7ed f988 	bl	800c34c <f_lseek>
 801f03c:	e7c9      	b.n	801efd2 <GoToPosition+0xc2>
 801f03e:	bf00      	nop
 801f040:	200174f0 	.word	0x200174f0
 801f044:	2000ec8c 	.word	0x2000ec8c
 801f048:	2000ec88 	.word	0x2000ec88
 801f04c:	20001e40 	.word	0x20001e40
 801f050:	200154ec 	.word	0x200154ec
 801f054:	200154e4 	.word	0x200154e4
 801f058:	200154e8 	.word	0x200154e8
 801f05c:	2000fab4 	.word	0x2000fab4
 801f060:	20019818 	.word	0x20019818
 801f064:	200154c0 	.word	0x200154c0
 801f068:	20000e30 	.word	0x20000e30

0801f06c <GetTrackTime>:
void GetTrackTime() {
 801f06c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f070:	4b4a      	ldr	r3, [pc, #296]	; (801f19c <GetTrackTime+0x130>)
 801f072:	2400      	movs	r4, #0
 801f074:	4d4a      	ldr	r5, [pc, #296]	; (801f1a0 <GetTrackTime+0x134>)
 801f076:	681f      	ldr	r7, [r3, #0]
 801f078:	6ba8      	ldr	r0, [r5, #56]	; 0x38
			*rekordbox.spectrum_size;
 801f07a:	4e4a      	ldr	r6, [pc, #296]	; (801f1a4 <GetTrackTime+0x138>)
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f07c:	1bc0      	subs	r0, r0, r7
 801f07e:	6be9      	ldr	r1, [r5, #60]	; 0x3c
			*rekordbox.spectrum_size;
 801f080:	f606 238c 	addw	r3, r6, #2700	; 0xa8c
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f084:	f161 0100 	sbc.w	r1, r1, #0
void GetTrackTime() {
 801f088:	ed2d 8b02 	vpush	{d8}
			*rekordbox.spectrum_size;
 801f08c:	ed93 8a00 	vldr	s16, [r3]
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f090:	f7e1 fdc4 	bl	8000c1c <__aeabi_ul2f>
			(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f094:	4b44      	ldr	r3, [pc, #272]	; (801f1a8 <GetTrackTime+0x13c>)
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f096:	ee08 0a90 	vmov	s17, r0
			(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f09a:	6969      	ldr	r1, [r5, #20]
			*rekordbox.spectrum_size;
 801f09c:	eeb8 8a48 	vcvt.f32.u32	s16, s16
			(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f0a0:	6818      	ldr	r0, [r3, #0]
 801f0a2:	692b      	ldr	r3, [r5, #16]
 801f0a4:	19c0      	adds	r0, r0, r7
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f0a6:	4d41      	ldr	r5, [pc, #260]	; (801f1ac <GetTrackTime+0x140>)
			(float)(f_size(&MyFile)-id3tagsize-wavtagsize)
 801f0a8:	4164      	adcs	r4, r4
 801f0aa:	1a18      	subs	r0, r3, r0
 801f0ac:	eb61 0104 	sbc.w	r1, r1, r4
 801f0b0:	f7e1 fdb4 	bl	8000c1c <__aeabi_ul2f>
	float track_lenght = (float)(f_tell(&MyFile)-id3tagsize)/
 801f0b4:	ee07 0a90 	vmov	s15, r0
 801f0b8:	eec8 7aa7 	vdiv.f32	s15, s17, s15
	file_pos_wide = (track_lenght + 0.5);
 801f0bc:	ee67 7a88 	vmul.f32	s15, s15, s16
 801f0c0:	ee17 0a90 	vmov	r0, s15
 801f0c4:	f7e1 fb92 	bl	80007ec <__aeabi_f2d>
 801f0c8:	2200      	movs	r2, #0
 801f0ca:	4b39      	ldr	r3, [pc, #228]	; (801f1b0 <GetTrackTime+0x144>)
 801f0cc:	f7e1 fa30 	bl	8000530 <__adddf3>
 801f0d0:	f7e1 fc6c 	bl	80009ac <__aeabi_d2uiz>
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f0d4:	f8d6 4a88 	ldr.w	r4, [r6, #2696]	; 0xa88
	file_pos_wide = (track_lenght + 0.5);
 801f0d8:	4936      	ldr	r1, [pc, #216]	; (801f1b4 <GetTrackTime+0x148>)
			rekordbox.spectrum_size);
 801f0da:	f8d6 2a8c 	ldr.w	r2, [r6, #2700]	; 0xa8c
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f0de:	fb00 f404 	mul.w	r4, r0, r4
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f0e2:	f8d6 3a8c 	ldr.w	r3, [r6, #2700]	; 0xa8c
	file_pos_wide = (track_lenght + 0.5);
 801f0e6:	6008      	str	r0, [r1, #0]
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f0e8:	eba3 0e00 	sub.w	lr, r3, r0
 801f0ec:	4b32      	ldr	r3, [pc, #200]	; (801f1b8 <GetTrackTime+0x14c>)
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f0ee:	fbb4 f4f2 	udiv	r4, r4, r2
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f0f2:	f8d6 2a8c 	ldr.w	r2, [r6, #2700]	; 0xa8c
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f0f6:	b2a4      	uxth	r4, r4
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f0f8:	f8d6 1a8c 	ldr.w	r1, [r6, #2700]	; 0xa8c
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f0fc:	1a12      	subs	r2, r2, r0
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f0fe:	eba1 0c00 	sub.w	ip, r1, r0
	fr = ((file_pos_wide) % 9000) % 150;
 801f102:	fba3 1600 	umull	r1, r6, r3, r0
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f106:	fba3 170e 	umull	r1, r7, r3, lr
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f10a:	fba3 1c0c 	umull	r1, ip, r3, ip
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f10e:	fba3 1302 	umull	r1, r3, r3, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f112:	f242 3128 	movw	r1, #9000	; 0x2328
 801f116:	0b7f      	lsrs	r7, r7, #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f118:	0b5b      	lsrs	r3, r3, #13
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f11a:	fb01 ee17 	mls	lr, r1, r7, lr
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f11e:	ea4f 3c5c 	mov.w	ip, ip, lsr #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f122:	fb01 2313 	mls	r3, r1, r3, r2
	fr = ((file_pos_wide) % 9000) % 150;
 801f126:	0b72      	lsrs	r2, r6, #13
	min = (file_pos_wide) / 9000;
 801f128:	0b76      	lsrs	r6, r6, #13
	fr = ((file_pos_wide) % 9000) % 150;
 801f12a:	fb01 0212 	mls	r2, r1, r2, r0
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f12e:	4923      	ldr	r1, [pc, #140]	; (801f1bc <GetTrackTime+0x150>)
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f130:	fba1 7303 	umull	r7, r3, r1, r3
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f134:	fba1 870e 	umull	r8, r7, r1, lr
	fr = ((file_pos_wide) % 9000) % 150;
 801f138:	fba1 8102 	umull	r8, r1, r1, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f13c:	f04f 0896 	mov.w	r8, #150	; 0x96
 801f140:	093f      	lsrs	r7, r7, #4
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f142:	091b      	lsrs	r3, r3, #4
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f144:	fb08 ee17 	mls	lr, r8, r7, lr
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f148:	4f1d      	ldr	r7, [pc, #116]	; (801f1c0 <GetTrackTime+0x154>)
	fr = ((file_pos_wide) % 9000) % 150;
 801f14a:	0909      	lsrs	r1, r1, #4
	file_pos = (uint16_t)(rekordbox.lowp_spectrum_size*file_pos_wide/
 801f14c:	603c      	str	r4, [r7, #0]
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f14e:	4c1d      	ldr	r4, [pc, #116]	; (801f1c4 <GetTrackTime+0x158>)
	fr = ((file_pos_wide) % 9000) % 150;
 801f150:	fb08 2211 	mls	r2, r8, r1, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f154:	f8a5 e000 	strh.w	lr, [r5]
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f158:	7023      	strb	r3, [r4, #0]
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f15a:	4b1b      	ldr	r3, [pc, #108]	; (801f1c8 <GetTrackTime+0x15c>)
	if(display.loop == 1) {
 801f15c:	4d1b      	ldr	r5, [pc, #108]	; (801f1cc <GetTrackTime+0x160>)
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f15e:	f883 c000 	strb.w	ip, [r3]
	fr = ((file_pos_wide) % 9000) % 150;
 801f162:	4b1b      	ldr	r3, [pc, #108]	; (801f1d0 <GetTrackTime+0x164>)
 801f164:	801a      	strh	r2, [r3, #0]
	sec = ((file_pos_wide) % 9000) / 150;
 801f166:	4b1b      	ldr	r3, [pc, #108]	; (801f1d4 <GetTrackTime+0x168>)
	min = (file_pos_wide) / 9000;
 801f168:	4a1b      	ldr	r2, [pc, #108]	; (801f1d8 <GetTrackTime+0x16c>)
	sec = ((file_pos_wide) % 9000) / 150;
 801f16a:	7019      	strb	r1, [r3, #0]
	if(display.loop == 1) {
 801f16c:	7c2b      	ldrb	r3, [r5, #16]
	min = (file_pos_wide) / 9000;
 801f16e:	7016      	strb	r6, [r2, #0]
	if(display.loop == 1) {
 801f170:	2b01      	cmp	r3, #1
 801f172:	d003      	beq.n	801f17c <GetTrackTime+0x110>
}
 801f174:	ecbd 8b02 	vpop	{d8}
 801f178:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if(trak.state == PLAYING) {
 801f17c:	4b17      	ldr	r3, [pc, #92]	; (801f1dc <GetTrackTime+0x170>)
 801f17e:	781b      	ldrb	r3, [r3, #0]
 801f180:	2b00      	cmp	r3, #0
 801f182:	d1f7      	bne.n	801f174 <GetTrackTime+0x108>
			if(file_pos_wide >= display.loopend) {
 801f184:	68eb      	ldr	r3, [r5, #12]
 801f186:	4298      	cmp	r0, r3
 801f188:	d3f4      	bcc.n	801f174 <GetTrackTime+0x108>
				GoToPosition(display.loopstart);
 801f18a:	68a8      	ldr	r0, [r5, #8]
 801f18c:	f7ff fec0 	bl	801ef10 <GoToPosition>
}
 801f190:	ecbd 8b02 	vpop	{d8}
 801f194:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				BSP_AUDIO_OUT_Resume();
 801f198:	f7fd be1e 	b.w	801cdd8 <BSP_AUDIO_OUT_Resume>
 801f19c:	200154c0 	.word	0x200154c0
 801f1a0:	20001e40 	.word	0x20001e40
 801f1a4:	200174f0 	.word	0x200174f0
 801f1a8:	20019818 	.word	0x20019818
 801f1ac:	2000fa6e 	.word	0x2000fa6e
 801f1b0:	3fe00000 	.word	0x3fe00000
 801f1b4:	2000ec8c 	.word	0x2000ec8c
 801f1b8:	e90452d5 	.word	0xe90452d5
 801f1bc:	1b4e81b5 	.word	0x1b4e81b5
 801f1c0:	2000ec88 	.word	0x2000ec88
 801f1c4:	2000fa71 	.word	0x2000fa71
 801f1c8:	2000fa70 	.word	0x2000fa70
 801f1cc:	20000c70 	.word	0x20000c70
 801f1d0:	2000f0d8 	.word	0x2000f0d8
 801f1d4:	2000fa72 	.word	0x2000fa72
 801f1d8:	2000f270 	.word	0x2000f270
 801f1dc:	2000fa7c 	.word	0x2000fa7c

0801f1e0 <PlayWavFile>:
void PlayWavFile() {
 801f1e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	wavtagsize = 0;
 801f1e4:	2400      	movs	r4, #0
	BufferCtl.filetype = 0;
 801f1e6:	4fb0      	ldr	r7, [pc, #704]	; (801f4a8 <PlayWavFile+0x2c8>)
void PlayWavFile() {
 801f1e8:	b085      	sub	sp, #20
	res = f_read(&MyFile, waveformat, sizeof(wavfile), (void*)&bytesread);
 801f1ea:	4db0      	ldr	r5, [pc, #704]	; (801f4ac <PlayWavFile+0x2cc>)
	wavtagsize = 0;
 801f1ec:	4bb0      	ldr	r3, [pc, #704]	; (801f4b0 <PlayWavFile+0x2d0>)
	memset(BufferCtl.buff, 0, AUDIO_OUT_BUFFER_SIZE);
 801f1ee:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801f1f2:	4621      	mov	r1, r4
 801f1f4:	f5a7 5080 	sub.w	r0, r7, #4096	; 0x1000
	bOutOfData = 0;
 801f1f8:	4eae      	ldr	r6, [pc, #696]	; (801f4b4 <PlayWavFile+0x2d4>)
	wavtagsize = 0;
 801f1fa:	601c      	str	r4, [r3, #0]
	BufferCtl.filetype = 0;
 801f1fc:	723c      	strb	r4, [r7, #8]
	memset(BufferCtl.buff, 0, AUDIO_OUT_BUFFER_SIZE);
 801f1fe:	f000 ff6d 	bl	80200dc <memset>
	res = f_read(&MyFile, waveformat, sizeof(wavfile), (void*)&bytesread);
 801f202:	ab03      	add	r3, sp, #12
 801f204:	222c      	movs	r2, #44	; 0x2c
 801f206:	4629      	mov	r1, r5
 801f208:	48ab      	ldr	r0, [pc, #684]	; (801f4b8 <PlayWavFile+0x2d8>)
	uint16_t bytesread = 0;
 801f20a:	f8ad 400a 	strh.w	r4, [sp, #10]
	bOutOfData = 0;
 801f20e:	6034      	str	r4, [r6, #0]
	res = f_read(&MyFile, waveformat, sizeof(wavfile), (void*)&bytesread);
 801f210:	f7ec ff70 	bl	800c0f4 <f_read>
	wavtagsize = wavfile.FileSize - wavfile.SubChunk2Size;
 801f214:	686b      	ldr	r3, [r5, #4]
 801f216:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 801f218:	49a5      	ldr	r1, [pc, #660]	; (801f4b0 <PlayWavFile+0x2d0>)
 801f21a:	1a9a      	subs	r2, r3, r2
	if(wavfile.SampleRate > 0) trak.bitrate = wavfile.SampleRate;
 801f21c:	69ab      	ldr	r3, [r5, #24]
	wavtagsize = wavfile.FileSize - wavfile.SubChunk2Size;
 801f21e:	600a      	str	r2, [r1, #0]
	if(wavfile.SampleRate > 0) trak.bitrate = wavfile.SampleRate;
 801f220:	2b00      	cmp	r3, #0
 801f222:	f000 80b5 	beq.w	801f390 <PlayWavFile+0x1b0>
 801f226:	b29a      	uxth	r2, r3
	BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, (uint32_t)(trak.bitrate / 2)*(1 + trak.percent), NULL);
 801f228:	f3c3 034e 	ubfx	r3, r3, #1, #15
 801f22c:	ee07 3a90 	vmov	s15, r3
 801f230:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801f234:	f8df 82cc 	ldr.w	r8, [pc, #716]	; 801f504 <PlayWavFile+0x324>
 801f238:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801f23c:	489f      	ldr	r0, [pc, #636]	; (801f4bc <PlayWavFile+0x2dc>)
 801f23e:	edd8 7a01 	vldr	s15, [r8, #4]
 801f242:	f8a8 2008 	strh.w	r2, [r8, #8]
 801f246:	2200      	movs	r2, #0
 801f248:	ee77 7aa6 	vadd.f32	s15, s15, s13
	while(f_read(&MyFile, &BufferCtl.buff[0], 2048, (void *)&bytesread) != FR_OK);
 801f24c:	4d9c      	ldr	r5, [pc, #624]	; (801f4c0 <PlayWavFile+0x2e0>)
 801f24e:	4c9a      	ldr	r4, [pc, #616]	; (801f4b8 <PlayWavFile+0x2d8>)
	BSP_AUDIO_OUT_ClockConfig(&hsai_BlockA2, (uint32_t)(trak.bitrate / 2)*(1 + trak.percent), NULL);
 801f250:	ee67 7a87 	vmul.f32	s15, s15, s14
 801f254:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801f258:	ee17 1a90 	vmov	r1, s15
 801f25c:	f7fd fe84 	bl	801cf68 <BSP_AUDIO_OUT_ClockConfig>
	while(f_read(&MyFile, &BufferCtl.buff[0], 2048, (void *)&bytesread) != FR_OK);
 801f260:	f10d 030a 	add.w	r3, sp, #10
 801f264:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801f268:	4629      	mov	r1, r5
 801f26a:	4620      	mov	r0, r4
 801f26c:	f7ec ff42 	bl	800c0f4 <f_read>
 801f270:	2800      	cmp	r0, #0
 801f272:	d1f5      	bne.n	801f260 <PlayWavFile+0x80>
	if(bytesread != 0) {
 801f274:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 801f278:	2b00      	cmp	r3, #0
 801f27a:	f040 8102 	bne.w	801f482 <PlayWavFile+0x2a2>
	if((rekordbox.autocue == 2) && (trak.state == PLAYING)) {
 801f27e:	4d91      	ldr	r5, [pc, #580]	; (801f4c4 <PlayWavFile+0x2e4>)
 801f280:	f895 33cc 	ldrb.w	r3, [r5, #972]	; 0x3cc
 801f284:	2b02      	cmp	r3, #2
 801f286:	f000 80ab 	beq.w	801f3e0 <PlayWavFile+0x200>
	while((!bOutOfData) && (file_pos_wide < rekordbox.spectrum_size)) {
 801f28a:	6833      	ldr	r3, [r6, #0]
 801f28c:	2b00      	cmp	r3, #0
 801f28e:	f040 8105 	bne.w	801f49c <PlayWavFile+0x2bc>
 801f292:	f8df 9244 	ldr.w	r9, [pc, #580]	; 801f4d8 <PlayWavFile+0x2f8>
 801f296:	4d8c      	ldr	r5, [pc, #560]	; (801f4c8 <PlayWavFile+0x2e8>)
 801f298:	4f8c      	ldr	r7, [pc, #560]	; (801f4cc <PlayWavFile+0x2ec>)
					HAL_TIM_Base_Stop_IT(&htim7);
 801f29a:	46ca      	mov	sl, r9
 801f29c:	4c8c      	ldr	r4, [pc, #560]	; (801f4d0 <PlayWavFile+0x2f0>)
 801f29e:	f8df 8268 	ldr.w	r8, [pc, #616]	; 801f508 <PlayWavFile+0x328>
			if((rmin == 0) && (rsec < 30) && (rsec > 10)) {
 801f2a2:	f8df b24c 	ldr.w	fp, [pc, #588]	; 801f4f0 <PlayWavFile+0x310>
 801f2a6:	e011      	b.n	801f2cc <PlayWavFile+0xec>
 801f2a8:	4a8a      	ldr	r2, [pc, #552]	; (801f4d4 <PlayWavFile+0x2f4>)
 801f2aa:	f992 c000 	ldrsb.w	ip, [r2]
 801f2ae:	f1ac 000b 	sub.w	r0, ip, #11
 801f2b2:	b2c0      	uxtb	r0, r0
 801f2b4:	2812      	cmp	r0, #18
 801f2b6:	d943      	bls.n	801f340 <PlayWavFile+0x160>
			else if((rmin == 0) && (rsec <= 10)) {
 801f2b8:	f1bc 0f0a 	cmp.w	ip, #10
 801f2bc:	dc0f      	bgt.n	801f2de <PlayWavFile+0xfe>
				if(tim7_flag == 0) {
 801f2be:	7820      	ldrb	r0, [r4, #0]
 801f2c0:	2800      	cmp	r0, #0
 801f2c2:	d058      	beq.n	801f376 <PlayWavFile+0x196>
				if(tim7_flag == 1) {
 801f2c4:	2801      	cmp	r0, #1
 801f2c6:	d068      	beq.n	801f39a <PlayWavFile+0x1ba>
	while((!bOutOfData) && (file_pos_wide < rekordbox.spectrum_size)) {
 801f2c8:	6833      	ldr	r3, [r6, #0]
 801f2ca:	b9fb      	cbnz	r3, 801f30c <PlayWavFile+0x12c>
 801f2cc:	f8d5 0a8c 	ldr.w	r0, [r5, #2700]	; 0xa8c
 801f2d0:	683b      	ldr	r3, [r7, #0]
 801f2d2:	4298      	cmp	r0, r3
 801f2d4:	d91a      	bls.n	801f30c <PlayWavFile+0x12c>
			if((rmin == 0) && (rsec < 30) && (rsec > 10)) {
 801f2d6:	f99b 3000 	ldrsb.w	r3, [fp]
 801f2da:	2b00      	cmp	r3, #0
 801f2dc:	d0e4      	beq.n	801f2a8 <PlayWavFile+0xc8>
				if(tim7_flag > 0) {
 801f2de:	7823      	ldrb	r3, [r4, #0]
 801f2e0:	2b00      	cmp	r3, #0
 801f2e2:	d0f1      	beq.n	801f2c8 <PlayWavFile+0xe8>
					HAL_TIM_Base_Stop_IT(&htim7);
 801f2e4:	4650      	mov	r0, sl
 801f2e6:	f7e7 fac1 	bl	800686c <HAL_TIM_Base_Stop_IT>
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f2ea:	f8d9 3000 	ldr.w	r3, [r9]
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f2ee:	2000      	movs	r0, #0
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f2f0:	f06f 0201 	mvn.w	r2, #1
 801f2f4:	611a      	str	r2, [r3, #16]
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f2f6:	6258      	str	r0, [r3, #36]	; 0x24
					if(display.timemode == 0) {
 801f2f8:	f898 3000 	ldrb.w	r3, [r8]
					tim7_flag = 0;
 801f2fc:	7020      	strb	r0, [r4, #0]
					if(display.timemode == 0) {
 801f2fe:	b103      	cbz	r3, 801f302 <PlayWavFile+0x122>
						display.trackbarmode = 1;
 801f300:	2301      	movs	r3, #1
 801f302:	f888 3004 	strb.w	r3, [r8, #4]
	while((!bOutOfData) && (file_pos_wide < rekordbox.spectrum_size)) {
 801f306:	6833      	ldr	r3, [r6, #0]
 801f308:	2b00      	cmp	r3, #0
 801f30a:	d0df      	beq.n	801f2cc <PlayWavFile+0xec>
	BSP_AUDIO_OUT_SetVolume(0);
 801f30c:	2000      	movs	r0, #0
	wavtagsize = 0;
 801f30e:	2500      	movs	r5, #0
	BSP_AUDIO_OUT_SetVolume(0);
 801f310:	f7fd fd86 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
	wavtagsize = 0;
 801f314:	4b66      	ldr	r3, [pc, #408]	; (801f4b0 <PlayWavFile+0x2d0>)
	HAL_TIM_Base_Stop_IT(&htim7);
 801f316:	4870      	ldr	r0, [pc, #448]	; (801f4d8 <PlayWavFile+0x2f8>)
	wavtagsize = 0;
 801f318:	601d      	str	r5, [r3, #0]
	HAL_TIM_Base_Stop_IT(&htim7);
 801f31a:	f7e7 faa7 	bl	800686c <HAL_TIM_Base_Stop_IT>
	if(display.timemode == 0) display.trackbarmode = 0;
 801f31e:	f898 3000 	ldrb.w	r3, [r8]
	__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f322:	f06f 0101 	mvn.w	r1, #1
 801f326:	f8d9 2000 	ldr.w	r2, [r9]
	if(display.timemode == 0) display.trackbarmode = 0;
 801f32a:	1b5b      	subs	r3, r3, r5
	tim7_flag = 0;
 801f32c:	7025      	strb	r5, [r4, #0]
	__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f32e:	6111      	str	r1, [r2, #16]
	if(display.timemode == 0) display.trackbarmode = 0;
 801f330:	bf18      	it	ne
 801f332:	2301      	movne	r3, #1
	__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f334:	6255      	str	r5, [r2, #36]	; 0x24
	if(display.timemode == 0) display.trackbarmode = 0;
 801f336:	f888 3004 	strb.w	r3, [r8, #4]
}
 801f33a:	b005      	add	sp, #20
 801f33c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if(tim7_flag == 0) {
 801f340:	7820      	ldrb	r0, [r4, #0]
 801f342:	2800      	cmp	r0, #0
 801f344:	d03f      	beq.n	801f3c6 <PlayWavFile+0x1e6>
				if(tim7_flag == 2) {
 801f346:	2802      	cmp	r0, #2
 801f348:	d1be      	bne.n	801f2c8 <PlayWavFile+0xe8>
					HAL_TIM_Base_Stop_IT(&htim7);
 801f34a:	4650      	mov	r0, sl
 801f34c:	9301      	str	r3, [sp, #4]
 801f34e:	f7e7 fa8d 	bl	800686c <HAL_TIM_Base_Stop_IT>
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f352:	f8d9 0000 	ldr.w	r0, [r9]
					__HAL_TIM_SET_AUTORELOAD(&htim7, 4999);
 801f356:	f241 3287 	movw	r2, #4999	; 0x1387
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f35a:	9b01      	ldr	r3, [sp, #4]
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f35c:	f06f 0101 	mvn.w	r1, #1
					__HAL_TIM_SET_AUTORELOAD(&htim7, 4999);
 801f360:	f8c9 200c 	str.w	r2, [r9, #12]
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f364:	6101      	str	r1, [r0, #16]
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f366:	6243      	str	r3, [r0, #36]	; 0x24
					__HAL_TIM_SET_AUTORELOAD(&htim7, 4999);
 801f368:	62c2      	str	r2, [r0, #44]	; 0x2c
					HAL_TIM_Base_Start_IT(&htim7);
 801f36a:	4650      	mov	r0, sl
 801f36c:	f7e7 f9fe 	bl	800676c <HAL_TIM_Base_Start_IT>
					tim7_flag = 1;
 801f370:	2301      	movs	r3, #1
 801f372:	7023      	strb	r3, [r4, #0]
 801f374:	e7a8      	b.n	801f2c8 <PlayWavFile+0xe8>
					__HAL_TIM_SET_AUTORELOAD(&htim7, 1999);
 801f376:	f8d9 3000 	ldr.w	r3, [r9]
 801f37a:	f240 70cf 	movw	r0, #1999	; 0x7cf
 801f37e:	62d8      	str	r0, [r3, #44]	; 0x2c
 801f380:	f8c9 000c 	str.w	r0, [r9, #12]
					HAL_TIM_Base_Start_IT(&htim7);
 801f384:	4650      	mov	r0, sl
 801f386:	f7e7 f9f1 	bl	800676c <HAL_TIM_Base_Start_IT>
					tim7_flag =  2;
 801f38a:	2302      	movs	r3, #2
 801f38c:	7023      	strb	r3, [r4, #0]
				if(tim7_flag == 1) {
 801f38e:	e79b      	b.n	801f2c8 <PlayWavFile+0xe8>
 801f390:	f64a 4244 	movw	r2, #44100	; 0xac44
 801f394:	ed9f 7a51 	vldr	s14, [pc, #324]	; 801f4dc <PlayWavFile+0x2fc>
 801f398:	e74c      	b.n	801f234 <PlayWavFile+0x54>
					HAL_TIM_Base_Stop_IT(&htim7);
 801f39a:	4650      	mov	r0, sl
 801f39c:	9301      	str	r3, [sp, #4]
 801f39e:	f7e7 fa65 	bl	800686c <HAL_TIM_Base_Stop_IT>
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f3a2:	f8d9 0000 	ldr.w	r0, [r9]
					__HAL_TIM_SET_AUTORELOAD(&htim7, 1999);
 801f3a6:	f240 72cf 	movw	r2, #1999	; 0x7cf
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f3aa:	9b01      	ldr	r3, [sp, #4]
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f3ac:	f06f 0101 	mvn.w	r1, #1
					__HAL_TIM_SET_AUTORELOAD(&htim7, 1999);
 801f3b0:	f8c9 200c 	str.w	r2, [r9, #12]
					__HAL_TIM_CLEAR_IT(&htim7, TIM_IT_UPDATE);
 801f3b4:	6101      	str	r1, [r0, #16]
					__HAL_TIM_SET_COUNTER(&htim7, 0);
 801f3b6:	6243      	str	r3, [r0, #36]	; 0x24
					__HAL_TIM_SET_AUTORELOAD(&htim7, 1999);
 801f3b8:	62c2      	str	r2, [r0, #44]	; 0x2c
					HAL_TIM_Base_Start_IT(&htim7);
 801f3ba:	4650      	mov	r0, sl
 801f3bc:	f7e7 f9d6 	bl	800676c <HAL_TIM_Base_Start_IT>
					tim7_flag = 2;
 801f3c0:	2302      	movs	r3, #2
 801f3c2:	7023      	strb	r3, [r4, #0]
 801f3c4:	e780      	b.n	801f2c8 <PlayWavFile+0xe8>
					__HAL_TIM_SET_AUTORELOAD(&htim7, 4999);
 801f3c6:	f8d9 3000 	ldr.w	r3, [r9]
 801f3ca:	f241 3087 	movw	r0, #4999	; 0x1387
 801f3ce:	62d8      	str	r0, [r3, #44]	; 0x2c
 801f3d0:	f8c9 000c 	str.w	r0, [r9, #12]
					HAL_TIM_Base_Start_IT(&htim7);
 801f3d4:	4650      	mov	r0, sl
 801f3d6:	f7e7 f9c9 	bl	800676c <HAL_TIM_Base_Start_IT>
					tim7_flag =  1;
 801f3da:	2301      	movs	r3, #1
 801f3dc:	7023      	strb	r3, [r4, #0]
				if(tim7_flag == 2) {
 801f3de:	e773      	b.n	801f2c8 <PlayWavFile+0xe8>
	if((rekordbox.autocue == 2) && (trak.state == PLAYING)) {
 801f3e0:	f898 3000 	ldrb.w	r3, [r8]
 801f3e4:	2b00      	cmp	r3, #0
 801f3e6:	f47f af50 	bne.w	801f28a <PlayWavFile+0xaa>
		BSP_AUDIO_OUT_Pause();
 801f3ea:	f7fd fced 	bl	801cdc8 <BSP_AUDIO_OUT_Pause>
		trak.state = STOPPED;
 801f3ee:	2301      	movs	r3, #1
		HAL_TIM_Base_Start_IT(&htim8);
 801f3f0:	483b      	ldr	r0, [pc, #236]	; (801f4e0 <PlayWavFile+0x300>)
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f3f2:	4f36      	ldr	r7, [pc, #216]	; (801f4cc <PlayWavFile+0x2ec>)
		trak.state = STOPPED;
 801f3f4:	f888 3000 	strb.w	r3, [r8]
		HAL_TIM_Base_Start_IT(&htim8);
 801f3f8:	f7e7 f9b8 	bl	800676c <HAL_TIM_Base_Start_IT>
		GoToPosition(rekordbox.cue_start_position[0]);
 801f3fc:	6ca8      	ldr	r0, [r5, #72]	; 0x48
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f3fe:	f5a5 5580 	sub.w	r5, r5, #4096	; 0x1000
		GoToPosition(rekordbox.cue_start_position[0]);
 801f402:	f7ff fd85 	bl	801ef10 <GoToPosition>
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f406:	6839      	ldr	r1, [r7, #0]
 801f408:	f8d5 4a8c 	ldr.w	r4, [r5, #2700]	; 0xa8c
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f40c:	f8d5 3a8c 	ldr.w	r3, [r5, #2700]	; 0xa8c
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f410:	f8d5 0a8c 	ldr.w	r0, [r5, #2700]	; 0xa8c
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f414:	1a64      	subs	r4, r4, r1
 801f416:	4a33      	ldr	r2, [pc, #204]	; (801f4e4 <PlayWavFile+0x304>)
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f418:	1a5b      	subs	r3, r3, r1
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f41a:	1a40      	subs	r0, r0, r1
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f41c:	fba2 7c04 	umull	r7, ip, r2, r4
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f420:	fba2 5000 	umull	r5, r0, r2, r0
	fr = ((file_pos_wide) % 9000) % 150;
 801f424:	fba2 7501 	umull	r7, r5, r2, r1
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f428:	ea4f 3c5c 	mov.w	ip, ip, lsr #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f42c:	fba2 7203 	umull	r7, r2, r2, r3
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f430:	f242 3728 	movw	r7, #9000	; 0x2328
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f434:	0b40      	lsrs	r0, r0, #13
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f436:	0b52      	lsrs	r2, r2, #13
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f438:	fb07 441c 	mls	r4, r7, ip, r4
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f43c:	fb07 3212 	mls	r2, r7, r2, r3
	fr = ((file_pos_wide) % 9000) % 150;
 801f440:	0b6b      	lsrs	r3, r5, #13
	min = (file_pos_wide) / 9000;
 801f442:	0b6d      	lsrs	r5, r5, #13
	fr = ((file_pos_wide) % 9000) % 150;
 801f444:	fb07 1313 	mls	r3, r7, r3, r1
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f448:	4927      	ldr	r1, [pc, #156]	; (801f4e8 <PlayWavFile+0x308>)
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f44a:	fba1 7202 	umull	r7, r2, r1, r2
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f44e:	fba1 c704 	umull	ip, r7, r1, r4
	fr = ((file_pos_wide) % 9000) % 150;
 801f452:	fba1 c103 	umull	ip, r1, r1, r3
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f456:	f04f 0c96 	mov.w	ip, #150	; 0x96
 801f45a:	093f      	lsrs	r7, r7, #4
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f45c:	0912      	lsrs	r2, r2, #4
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f45e:	fb0c 4417 	mls	r4, ip, r7, r4
 801f462:	4f22      	ldr	r7, [pc, #136]	; (801f4ec <PlayWavFile+0x30c>)
	fr = ((file_pos_wide) % 9000) % 150;
 801f464:	0909      	lsrs	r1, r1, #4
	rfr = ((rekordbox.spectrum_size-file_pos_wide) % 9000) % 150;
 801f466:	803c      	strh	r4, [r7, #0]
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f468:	4c1a      	ldr	r4, [pc, #104]	; (801f4d4 <PlayWavFile+0x2f4>)
	fr = ((file_pos_wide) % 9000) % 150;
 801f46a:	fb0c 3311 	mls	r3, ip, r1, r3
	rsec = ((rekordbox.spectrum_size-file_pos_wide) % 9000) / 150;
 801f46e:	7022      	strb	r2, [r4, #0]
	rmin = (rekordbox.spectrum_size-file_pos_wide) / 9000;
 801f470:	4a1f      	ldr	r2, [pc, #124]	; (801f4f0 <PlayWavFile+0x310>)
 801f472:	7010      	strb	r0, [r2, #0]
	fr = ((file_pos_wide) % 9000) % 150;
 801f474:	4a1f      	ldr	r2, [pc, #124]	; (801f4f4 <PlayWavFile+0x314>)
 801f476:	8013      	strh	r3, [r2, #0]
	sec = ((file_pos_wide) % 9000) / 150;
 801f478:	4b1f      	ldr	r3, [pc, #124]	; (801f4f8 <PlayWavFile+0x318>)
 801f47a:	7019      	strb	r1, [r3, #0]
	min = (file_pos_wide) / 9000;
 801f47c:	4b1f      	ldr	r3, [pc, #124]	; (801f4fc <PlayWavFile+0x31c>)
 801f47e:	701d      	strb	r5, [r3, #0]
}
 801f480:	e703      	b.n	801f28a <PlayWavFile+0xaa>
		BSP_AUDIO_OUT_Play((uint16_t*)&BufferCtl.buff[0], AUDIO_OUT_BUFFER_SIZE);
 801f482:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801f486:	480e      	ldr	r0, [pc, #56]	; (801f4c0 <PlayWavFile+0x2e0>)
 801f488:	f7fd fc7c 	bl	801cd84 <BSP_AUDIO_OUT_Play>
		BufferCtl.fptr = bytesread;
 801f48c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 801f490:	607b      	str	r3, [r7, #4]
		BSP_AUDIO_OUT_SetVolume(volume);
 801f492:	4b1b      	ldr	r3, [pc, #108]	; (801f500 <PlayWavFile+0x320>)
 801f494:	7818      	ldrb	r0, [r3, #0]
 801f496:	f7fd fcc3 	bl	801ce20 <BSP_AUDIO_OUT_SetVolume>
 801f49a:	e6f0      	b.n	801f27e <PlayWavFile+0x9e>
 801f49c:	4c0c      	ldr	r4, [pc, #48]	; (801f4d0 <PlayWavFile+0x2f0>)
 801f49e:	f8df 9038 	ldr.w	r9, [pc, #56]	; 801f4d8 <PlayWavFile+0x2f8>
 801f4a2:	f8df 8064 	ldr.w	r8, [pc, #100]	; 801f508 <PlayWavFile+0x328>
 801f4a6:	e731      	b.n	801f30c <PlayWavFile+0x12c>
 801f4a8:	20001e30 	.word	0x20001e30
 801f4ac:	200197ec 	.word	0x200197ec
 801f4b0:	20019818 	.word	0x20019818
 801f4b4:	2000ec30 	.word	0x2000ec30
 801f4b8:	20001e40 	.word	0x20001e40
 801f4bc:	20018934 	.word	0x20018934
 801f4c0:	20000e30 	.word	0x20000e30
 801f4c4:	200184f0 	.word	0x200184f0
 801f4c8:	200174f0 	.word	0x200174f0
 801f4cc:	2000ec8c 	.word	0x2000ec8c
 801f4d0:	2000fa78 	.word	0x2000fa78
 801f4d4:	2000fa71 	.word	0x2000fa71
 801f4d8:	20018c44 	.word	0x20018c44
 801f4dc:	46ac4400 	.word	0x46ac4400
 801f4e0:	20018c84 	.word	0x20018c84
 801f4e4:	e90452d5 	.word	0xe90452d5
 801f4e8:	1b4e81b5 	.word	0x1b4e81b5
 801f4ec:	2000fa6e 	.word	0x2000fa6e
 801f4f0:	2000fa70 	.word	0x2000fa70
 801f4f4:	2000f0d8 	.word	0x2000f0d8
 801f4f8:	2000fa72 	.word	0x2000fa72
 801f4fc:	2000f270 	.word	0x2000f270
 801f500:	2000005c 	.word	0x2000005c
 801f504:	2000fa7c 	.word	0x2000fa7c
 801f508:	20000c70 	.word	0x20000c70

0801f50c <wm8994_SetOutputMode>:
  */
uint32_t wm8994_SetOutputMode(uint16_t DeviceAddr, uint8_t Output)
{
  uint32_t counter = 0; 
  
  switch (Output) 
 801f50c:	2901      	cmp	r1, #1
{
 801f50e:	b500      	push	{lr}
 801f510:	b083      	sub	sp, #12
  switch (Output) 
 801f512:	d024      	beq.n	801f55e <wm8994_SetOutputMode+0x52>
 801f514:	2903      	cmp	r1, #3
 801f516:	d045      	beq.n	801f5a4 <wm8994_SetOutputMode+0x98>
    break;
    
  case OUTPUT_DEVICE_HEADPHONE:
    /* Disable DAC1 (Left), Disable DAC1 (Right), 
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303);
 801f518:	b2c0      	uxtb	r0, r0
  */
static uint8_t CODEC_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
  uint32_t result = 0;
  
 AUDIO_IO_Write(Addr, Reg, Value);
 801f51a:	f240 3203 	movw	r2, #771	; 0x303
 801f51e:	2105      	movs	r1, #5
 801f520:	9001      	str	r0, [sp, #4]
 801f522:	f7fd fd65 	bl	801cff0 <AUDIO_IO_Write>
 801f526:	9801      	ldr	r0, [sp, #4]
 801f528:	2201      	movs	r2, #1
 801f52a:	f240 6101 	movw	r1, #1537	; 0x601
 801f52e:	f7fd fd5f 	bl	801cff0 <AUDIO_IO_Write>
 801f532:	9801      	ldr	r0, [sp, #4]
 801f534:	2201      	movs	r2, #1
 801f536:	f240 6102 	movw	r1, #1538	; 0x602
 801f53a:	f7fd fd59 	bl	801cff0 <AUDIO_IO_Write>
 801f53e:	9801      	ldr	r0, [sp, #4]
 801f540:	2200      	movs	r2, #0
 801f542:	f240 6104 	movw	r1, #1540	; 0x604
 801f546:	f7fd fd53 	bl	801cff0 <AUDIO_IO_Write>
 801f54a:	9801      	ldr	r0, [sp, #4]
 801f54c:	2200      	movs	r2, #0
 801f54e:	f240 6105 	movw	r1, #1541	; 0x605
 801f552:	f7fd fd4d 	bl	801cff0 <AUDIO_IO_Write>
}
 801f556:	2000      	movs	r0, #0
 801f558:	b003      	add	sp, #12
 801f55a:	f85d fb04 	ldr.w	pc, [sp], #4
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0C0C);
 801f55e:	b2c0      	uxtb	r0, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 801f560:	f640 420c 	movw	r2, #3084	; 0xc0c
 801f564:	2105      	movs	r1, #5
 801f566:	9001      	str	r0, [sp, #4]
 801f568:	f7fd fd42 	bl	801cff0 <AUDIO_IO_Write>
 801f56c:	9801      	ldr	r0, [sp, #4]
 801f56e:	2200      	movs	r2, #0
 801f570:	f240 6101 	movw	r1, #1537	; 0x601
 801f574:	f7fd fd3c 	bl	801cff0 <AUDIO_IO_Write>
 801f578:	9801      	ldr	r0, [sp, #4]
 801f57a:	2200      	movs	r2, #0
 801f57c:	f240 6102 	movw	r1, #1538	; 0x602
 801f580:	f7fd fd36 	bl	801cff0 <AUDIO_IO_Write>
 801f584:	9801      	ldr	r0, [sp, #4]
 801f586:	2202      	movs	r2, #2
 801f588:	f240 6104 	movw	r1, #1540	; 0x604
 801f58c:	f7fd fd30 	bl	801cff0 <AUDIO_IO_Write>
 801f590:	9801      	ldr	r0, [sp, #4]
 801f592:	2202      	movs	r2, #2
 801f594:	f240 6105 	movw	r1, #1541	; 0x605
 801f598:	f7fd fd2a 	bl	801cff0 <AUDIO_IO_Write>
}
 801f59c:	2000      	movs	r0, #0
 801f59e:	b003      	add	sp, #12
 801f5a0:	f85d fb04 	ldr.w	pc, [sp], #4
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303 | 0x0C0C);
 801f5a4:	b2c0      	uxtb	r0, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 801f5a6:	f640 720f 	movw	r2, #3855	; 0xf0f
 801f5aa:	2105      	movs	r1, #5
 801f5ac:	9001      	str	r0, [sp, #4]
 801f5ae:	f7fd fd1f 	bl	801cff0 <AUDIO_IO_Write>
 801f5b2:	2201      	movs	r2, #1
 801f5b4:	f240 6101 	movw	r1, #1537	; 0x601
 801f5b8:	9801      	ldr	r0, [sp, #4]
 801f5ba:	f7fd fd19 	bl	801cff0 <AUDIO_IO_Write>
 801f5be:	2201      	movs	r2, #1
 801f5c0:	f240 6102 	movw	r1, #1538	; 0x602
 801f5c4:	9801      	ldr	r0, [sp, #4]
 801f5c6:	f7fd fd13 	bl	801cff0 <AUDIO_IO_Write>
 801f5ca:	2202      	movs	r2, #2
 801f5cc:	f240 6104 	movw	r1, #1540	; 0x604
 801f5d0:	9801      	ldr	r0, [sp, #4]
 801f5d2:	e7db      	b.n	801f58c <wm8994_SetOutputMode+0x80>

0801f5d4 <wm8994_SetFrequency>:
{
 801f5d4:	b508      	push	{r3, lr}
  switch (AudioFreq)
 801f5d6:	f245 6322 	movw	r3, #22050	; 0x5622
 801f5da:	4299      	cmp	r1, r3
 801f5dc:	d039      	beq.n	801f652 <wm8994_SetFrequency+0x7e>
 801f5de:	d80e      	bhi.n	801f5fe <wm8994_SetFrequency+0x2a>
 801f5e0:	f642 3311 	movw	r3, #11025	; 0x2b11
 801f5e4:	4299      	cmp	r1, r3
 801f5e6:	d03c      	beq.n	801f662 <wm8994_SetFrequency+0x8e>
 801f5e8:	f5b1 5f7a 	cmp.w	r1, #16000	; 0x3e80
 801f5ec:	d116      	bne.n	801f61c <wm8994_SetFrequency+0x48>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f5ee:	2233      	movs	r2, #51	; 0x33
 801f5f0:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f5f4:	b2c0      	uxtb	r0, r0
 801f5f6:	f7fd fcfb 	bl	801cff0 <AUDIO_IO_Write>
}
 801f5fa:	2000      	movs	r0, #0
 801f5fc:	bd08      	pop	{r3, pc}
  switch (AudioFreq)
 801f5fe:	f64a 4344 	movw	r3, #44100	; 0xac44
 801f602:	4299      	cmp	r1, r3
 801f604:	d01d      	beq.n	801f642 <wm8994_SetFrequency+0x6e>
 801f606:	4b1b      	ldr	r3, [pc, #108]	; (801f674 <wm8994_SetFrequency+0xa0>)
 801f608:	4299      	cmp	r1, r3
 801f60a:	d112      	bne.n	801f632 <wm8994_SetFrequency+0x5e>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f60c:	22a3      	movs	r2, #163	; 0xa3
 801f60e:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f612:	b2c0      	uxtb	r0, r0
 801f614:	f7fd fcec 	bl	801cff0 <AUDIO_IO_Write>
}
 801f618:	2000      	movs	r0, #0
 801f61a:	bd08      	pop	{r3, pc}
  switch (AudioFreq)
 801f61c:	f5b1 5ffa 	cmp.w	r1, #8000	; 0x1f40
 801f620:	d107      	bne.n	801f632 <wm8994_SetFrequency+0x5e>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f622:	2203      	movs	r2, #3
 801f624:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f628:	b2c0      	uxtb	r0, r0
 801f62a:	f7fd fce1 	bl	801cff0 <AUDIO_IO_Write>
}
 801f62e:	2000      	movs	r0, #0
 801f630:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f632:	2283      	movs	r2, #131	; 0x83
 801f634:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f638:	b2c0      	uxtb	r0, r0
 801f63a:	f7fd fcd9 	bl	801cff0 <AUDIO_IO_Write>
}
 801f63e:	2000      	movs	r0, #0
 801f640:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f642:	2273      	movs	r2, #115	; 0x73
 801f644:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f648:	b2c0      	uxtb	r0, r0
 801f64a:	f7fd fcd1 	bl	801cff0 <AUDIO_IO_Write>
}
 801f64e:	2000      	movs	r0, #0
 801f650:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f652:	2243      	movs	r2, #67	; 0x43
 801f654:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f658:	b2c0      	uxtb	r0, r0
 801f65a:	f7fd fcc9 	bl	801cff0 <AUDIO_IO_Write>
}
 801f65e:	2000      	movs	r0, #0
 801f660:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f662:	2213      	movs	r2, #19
 801f664:	f44f 7104 	mov.w	r1, #528	; 0x210
 801f668:	b2c0      	uxtb	r0, r0
 801f66a:	f7fd fcc1 	bl	801cff0 <AUDIO_IO_Write>
}
 801f66e:	2000      	movs	r0, #0
 801f670:	bd08      	pop	{r3, pc}
 801f672:	bf00      	nop
 801f674:	00017700 	.word	0x00017700

0801f678 <wm8994_Reset>:
 AUDIO_IO_Write(Addr, Reg, Value);
 801f678:	2200      	movs	r2, #0
 801f67a:	b2c0      	uxtb	r0, r0
 801f67c:	4611      	mov	r1, r2
{
 801f67e:	b508      	push	{r3, lr}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f680:	f7fd fcb6 	bl	801cff0 <AUDIO_IO_Write>
  outputEnabled = 0;
 801f684:	2000      	movs	r0, #0
 801f686:	4a02      	ldr	r2, [pc, #8]	; (801f690 <wm8994_Reset+0x18>)
  inputEnabled=0;
 801f688:	4b02      	ldr	r3, [pc, #8]	; (801f694 <wm8994_Reset+0x1c>)
  outputEnabled = 0;
 801f68a:	6010      	str	r0, [r2, #0]
  inputEnabled=0;
 801f68c:	6018      	str	r0, [r3, #0]
}
 801f68e:	bd08      	pop	{r3, pc}
 801f690:	20019820 	.word	0x20019820
 801f694:	2001981c 	.word	0x2001981c

0801f698 <wm8994_DeInit>:
  /* Deinitialize Audio Codec interface */  AUDIO_IO_DeInit();
 801f698:	f7fd bca8 	b.w	801cfec <AUDIO_IO_DeInit>

0801f69c <wm8994_ReadID>:
{
 801f69c:	b510      	push	{r4, lr}
 801f69e:	4604      	mov	r4, r0
  AUDIO_IO_Init();
 801f6a0:	f7fd fc9e 	bl	801cfe0 <AUDIO_IO_Init>
  return ((uint32_t)AUDIO_IO_Read(DeviceAddr, WM8994_CHIPID_ADDR));
 801f6a4:	2100      	movs	r1, #0
 801f6a6:	b2e0      	uxtb	r0, r4
 801f6a8:	f7fd fcba 	bl	801d020 <AUDIO_IO_Read>
}
 801f6ac:	bd10      	pop	{r4, pc}
 801f6ae:	bf00      	nop

0801f6b0 <wm8994_Pause>:
  if (outputEnabled != 0)
 801f6b0:	4b0e      	ldr	r3, [pc, #56]	; (801f6ec <wm8994_Pause+0x3c>)
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f6b2:	b2c0      	uxtb	r0, r0
  if (outputEnabled != 0)
 801f6b4:	681b      	ldr	r3, [r3, #0]
{  
 801f6b6:	b500      	push	{lr}
 801f6b8:	b083      	sub	sp, #12
  if (outputEnabled != 0)
 801f6ba:	b173      	cbz	r3, 801f6da <wm8994_Pause+0x2a>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f6bc:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f6c0:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f6c4:	9001      	str	r0, [sp, #4]
 801f6c6:	f7fd fc93 	bl	801cff0 <AUDIO_IO_Write>
 801f6ca:	9801      	ldr	r0, [sp, #4]
 801f6cc:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f6d0:	f240 4122 	movw	r1, #1058	; 0x422
 801f6d4:	f7fd fc8c 	bl	801cff0 <AUDIO_IO_Write>
 801f6d8:	9801      	ldr	r0, [sp, #4]
 801f6da:	2201      	movs	r2, #1
 801f6dc:	2102      	movs	r1, #2
 801f6de:	f7fd fc87 	bl	801cff0 <AUDIO_IO_Write>
}
 801f6e2:	2000      	movs	r0, #0
 801f6e4:	b003      	add	sp, #12
 801f6e6:	f85d fb04 	ldr.w	pc, [sp], #4
 801f6ea:	bf00      	nop
 801f6ec:	20019820 	.word	0x20019820

0801f6f0 <wm8994_Play>:
  if (outputEnabled != 0)
 801f6f0:	4b0b      	ldr	r3, [pc, #44]	; (801f720 <wm8994_Play+0x30>)
 801f6f2:	681b      	ldr	r3, [r3, #0]
 801f6f4:	b193      	cbz	r3, 801f71c <wm8994_Play+0x2c>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0000);
 801f6f6:	b2c0      	uxtb	r0, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 801f6f8:	2200      	movs	r2, #0
 801f6fa:	f44f 6184 	mov.w	r1, #1056	; 0x420
{
 801f6fe:	b500      	push	{lr}
 801f700:	b083      	sub	sp, #12
 AUDIO_IO_Write(Addr, Reg, Value);
 801f702:	9001      	str	r0, [sp, #4]
 801f704:	f7fd fc74 	bl	801cff0 <AUDIO_IO_Write>
 801f708:	9801      	ldr	r0, [sp, #4]
 801f70a:	2200      	movs	r2, #0
 801f70c:	f240 4122 	movw	r1, #1058	; 0x422
 801f710:	f7fd fc6e 	bl	801cff0 <AUDIO_IO_Write>
}
 801f714:	2000      	movs	r0, #0
 801f716:	b003      	add	sp, #12
 801f718:	f85d fb04 	ldr.w	pc, [sp], #4
 801f71c:	2000      	movs	r0, #0
 801f71e:	4770      	bx	lr
 801f720:	20019820 	.word	0x20019820

0801f724 <wm8994_Resume>:
  if (outputEnabled != 0)
 801f724:	4b0b      	ldr	r3, [pc, #44]	; (801f754 <wm8994_Resume+0x30>)
 801f726:	681b      	ldr	r3, [r3, #0]
 801f728:	b193      	cbz	r3, 801f750 <wm8994_Resume+0x2c>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0000);
 801f72a:	b2c0      	uxtb	r0, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 801f72c:	2200      	movs	r2, #0
 801f72e:	f44f 6184 	mov.w	r1, #1056	; 0x420
{
 801f732:	b500      	push	{lr}
 801f734:	b083      	sub	sp, #12
 AUDIO_IO_Write(Addr, Reg, Value);
 801f736:	9001      	str	r0, [sp, #4]
 801f738:	f7fd fc5a 	bl	801cff0 <AUDIO_IO_Write>
 801f73c:	9801      	ldr	r0, [sp, #4]
 801f73e:	2200      	movs	r2, #0
 801f740:	f240 4122 	movw	r1, #1058	; 0x422
 801f744:	f7fd fc54 	bl	801cff0 <AUDIO_IO_Write>
}
 801f748:	2000      	movs	r0, #0
 801f74a:	b003      	add	sp, #12
 801f74c:	f85d fb04 	ldr.w	pc, [sp], #4
 801f750:	2000      	movs	r0, #0
 801f752:	4770      	bx	lr
 801f754:	20019820 	.word	0x20019820

0801f758 <wm8994_Stop>:
{
 801f758:	b570      	push	{r4, r5, r6, lr}
  if (outputEnabled != 0)
 801f75a:	4e1e      	ldr	r6, [pc, #120]	; (801f7d4 <wm8994_Stop+0x7c>)
 801f75c:	6833      	ldr	r3, [r6, #0]
 801f75e:	b90b      	cbnz	r3, 801f764 <wm8994_Stop+0xc>
}
 801f760:	2000      	movs	r0, #0
 801f762:	bd70      	pop	{r4, r5, r6, pc}
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f764:	b2c4      	uxtb	r4, r0
 801f766:	460d      	mov	r5, r1
 AUDIO_IO_Write(Addr, Reg, Value);
 801f768:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f76c:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f770:	4620      	mov	r0, r4
 801f772:	f7fd fc3d 	bl	801cff0 <AUDIO_IO_Write>
 801f776:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f77a:	f240 4122 	movw	r1, #1058	; 0x422
 801f77e:	4620      	mov	r0, r4
 801f780:	f7fd fc36 	bl	801cff0 <AUDIO_IO_Write>
    if (CodecPdwnMode == CODEC_PDWN_SW)
 801f784:	2d02      	cmp	r5, #2
 801f786:	d0eb      	beq.n	801f760 <wm8994_Stop+0x8>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f788:	4620      	mov	r0, r4
 801f78a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f78e:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f792:	f7fd fc2d 	bl	801cff0 <AUDIO_IO_Write>
 801f796:	4620      	mov	r0, r4
 801f798:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f79c:	f240 4122 	movw	r1, #1058	; 0x422
 801f7a0:	f7fd fc26 	bl	801cff0 <AUDIO_IO_Write>
 801f7a4:	4620      	mov	r0, r4
 801f7a6:	2200      	movs	r2, #0
 801f7a8:	212d      	movs	r1, #45	; 0x2d
 801f7aa:	f7fd fc21 	bl	801cff0 <AUDIO_IO_Write>
 801f7ae:	4620      	mov	r0, r4
 801f7b0:	2200      	movs	r2, #0
 801f7b2:	212e      	movs	r1, #46	; 0x2e
 801f7b4:	f7fd fc1c 	bl	801cff0 <AUDIO_IO_Write>
 801f7b8:	4620      	mov	r0, r4
 801f7ba:	2200      	movs	r2, #0
 801f7bc:	2105      	movs	r1, #5
 801f7be:	f7fd fc17 	bl	801cff0 <AUDIO_IO_Write>
 801f7c2:	2200      	movs	r2, #0
 801f7c4:	4620      	mov	r0, r4
 801f7c6:	4611      	mov	r1, r2
 801f7c8:	f7fd fc12 	bl	801cff0 <AUDIO_IO_Write>
      outputEnabled = 0;
 801f7cc:	2300      	movs	r3, #0
}
 801f7ce:	2000      	movs	r0, #0
      outputEnabled = 0;
 801f7d0:	6033      	str	r3, [r6, #0]
}
 801f7d2:	bd70      	pop	{r4, r5, r6, pc}
 801f7d4:	20019820 	.word	0x20019820

0801f7d8 <wm8994_SetMute>:
  if (outputEnabled != 0)
 801f7d8:	4b15      	ldr	r3, [pc, #84]	; (801f830 <wm8994_SetMute+0x58>)
 801f7da:	681b      	ldr	r3, [r3, #0]
 801f7dc:	b1a3      	cbz	r3, 801f808 <wm8994_SetMute+0x30>
    if(Cmd == AUDIO_MUTE_ON)
 801f7de:	2901      	cmp	r1, #1
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f7e0:	b2c0      	uxtb	r0, r0
{
 801f7e2:	b500      	push	{lr}
 801f7e4:	b083      	sub	sp, #12
    if(Cmd == AUDIO_MUTE_ON)
 801f7e6:	d011      	beq.n	801f80c <wm8994_SetMute+0x34>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f7e8:	2200      	movs	r2, #0
 801f7ea:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f7ee:	9001      	str	r0, [sp, #4]
 801f7f0:	f7fd fbfe 	bl	801cff0 <AUDIO_IO_Write>
 801f7f4:	9801      	ldr	r0, [sp, #4]
 801f7f6:	2200      	movs	r2, #0
 801f7f8:	f240 4122 	movw	r1, #1058	; 0x422
 801f7fc:	f7fd fbf8 	bl	801cff0 <AUDIO_IO_Write>
}
 801f800:	2000      	movs	r0, #0
 801f802:	b003      	add	sp, #12
 801f804:	f85d fb04 	ldr.w	pc, [sp], #4
 801f808:	2000      	movs	r0, #0
 801f80a:	4770      	bx	lr
 AUDIO_IO_Write(Addr, Reg, Value);
 801f80c:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f810:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f814:	9001      	str	r0, [sp, #4]
 801f816:	f7fd fbeb 	bl	801cff0 <AUDIO_IO_Write>
 801f81a:	9801      	ldr	r0, [sp, #4]
 801f81c:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f820:	f240 4122 	movw	r1, #1058	; 0x422
 801f824:	f7fd fbe4 	bl	801cff0 <AUDIO_IO_Write>
}
 801f828:	2000      	movs	r0, #0
 801f82a:	b003      	add	sp, #12
 801f82c:	f85d fb04 	ldr.w	pc, [sp], #4
 801f830:	20019820 	.word	0x20019820

0801f834 <wm8994_SetVolume>:
  if (outputEnabled != 0)
 801f834:	4b55      	ldr	r3, [pc, #340]	; (801f98c <wm8994_SetVolume+0x158>)
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 801f836:	2964      	cmp	r1, #100	; 0x64
{
 801f838:	b570      	push	{r4, r5, r6, lr}
  if (outputEnabled != 0)
 801f83a:	681b      	ldr	r3, [r3, #0]
{
 801f83c:	b084      	sub	sp, #16
 801f83e:	460c      	mov	r4, r1
 801f840:	4606      	mov	r6, r0
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 801f842:	d92e      	bls.n	801f8a2 <wm8994_SetVolume+0x6e>
  if (outputEnabled != 0)
 801f844:	2b00      	cmp	r3, #0
 801f846:	d056      	beq.n	801f8f6 <wm8994_SetVolume+0xc2>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0000);
 801f848:	b2f0      	uxtb	r0, r6
 AUDIO_IO_Write(Addr, Reg, Value);
 801f84a:	2200      	movs	r2, #0
 801f84c:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f850:	9001      	str	r0, [sp, #4]
 801f852:	f7fd fbcd 	bl	801cff0 <AUDIO_IO_Write>
 801f856:	2200      	movs	r2, #0
 801f858:	f240 4122 	movw	r1, #1058	; 0x422
 801f85c:	9801      	ldr	r0, [sp, #4]
 801f85e:	f7fd fbc7 	bl	801cff0 <AUDIO_IO_Write>
 801f862:	f240 127f 	movw	r2, #383	; 0x17f
 801f866:	211c      	movs	r1, #28
 801f868:	9801      	ldr	r0, [sp, #4]
 801f86a:	f7fd fbc1 	bl	801cff0 <AUDIO_IO_Write>
 801f86e:	f240 127f 	movw	r2, #383	; 0x17f
 801f872:	211d      	movs	r1, #29
 801f874:	9801      	ldr	r0, [sp, #4]
 801f876:	f7fd fbbb 	bl	801cff0 <AUDIO_IO_Write>
 801f87a:	f240 127f 	movw	r2, #383	; 0x17f
 801f87e:	2126      	movs	r1, #38	; 0x26
 801f880:	9801      	ldr	r0, [sp, #4]
 801f882:	f7fd fbb5 	bl	801cff0 <AUDIO_IO_Write>
 801f886:	f240 127f 	movw	r2, #383	; 0x17f
 801f88a:	2127      	movs	r1, #39	; 0x27
 801f88c:	9801      	ldr	r0, [sp, #4]
 801f88e:	f7fd fbaf 	bl	801cff0 <AUDIO_IO_Write>
  if (inputEnabled != 0)
 801f892:	4b3f      	ldr	r3, [pc, #252]	; (801f990 <wm8994_SetVolume+0x15c>)
 801f894:	681b      	ldr	r3, [r3, #0]
 801f896:	2b00      	cmp	r3, #0
 801f898:	d04d      	beq.n	801f936 <wm8994_SetVolume+0x102>
    convertedvol = VOLUME_IN_CONVERT(Volume);
 801f89a:	2c63      	cmp	r4, #99	; 0x63
 801f89c:	d82e      	bhi.n	801f8fc <wm8994_SetVolume+0xc8>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f89e:	b2f0      	uxtb	r0, r6
 801f8a0:	e01e      	b.n	801f8e0 <wm8994_SetVolume+0xac>
  if (outputEnabled != 0)
 801f8a2:	2b00      	cmp	r3, #0
 801f8a4:	d0f5      	beq.n	801f892 <wm8994_SetVolume+0x5e>
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 801f8a6:	ebc1 1581 	rsb	r5, r1, r1, lsl #6
 801f8aa:	4a3a      	ldr	r2, [pc, #232]	; (801f994 <wm8994_SetVolume+0x160>)
 801f8ac:	fba2 3505 	umull	r3, r5, r2, r5
 801f8b0:	096d      	lsrs	r5, r5, #5
    if(convertedvol > 0x3E)
 801f8b2:	2d3f      	cmp	r5, #63	; 0x3f
 801f8b4:	d0c8      	beq.n	801f848 <wm8994_SetVolume+0x14>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f8b6:	b2c0      	uxtb	r0, r0
    else if (Volume == 0)
 801f8b8:	2900      	cmp	r1, #0
 801f8ba:	d13f      	bne.n	801f93c <wm8994_SetVolume+0x108>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f8bc:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f8c0:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f8c4:	9001      	str	r0, [sp, #4]
 801f8c6:	f7fd fb93 	bl	801cff0 <AUDIO_IO_Write>
 801f8ca:	9801      	ldr	r0, [sp, #4]
 801f8cc:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f8d0:	f240 4122 	movw	r1, #1058	; 0x422
 801f8d4:	f7fd fb8c 	bl	801cff0 <AUDIO_IO_Write>
  if (inputEnabled != 0)
 801f8d8:	4b2d      	ldr	r3, [pc, #180]	; (801f990 <wm8994_SetVolume+0x15c>)
 801f8da:	9801      	ldr	r0, [sp, #4]
 801f8dc:	681b      	ldr	r3, [r3, #0]
 801f8de:	b353      	cbz	r3, 801f936 <wm8994_SetVolume+0x102>
    convertedvol = VOLUME_IN_CONVERT(Volume);
 801f8e0:	ebc4 1204 	rsb	r2, r4, r4, lsl #4
 801f8e4:	4c2b      	ldr	r4, [pc, #172]	; (801f994 <wm8994_SetVolume+0x160>)
 801f8e6:	0112      	lsls	r2, r2, #4
 801f8e8:	fba4 3202 	umull	r3, r2, r4, r2
    counter += CODEC_IO_Write(DeviceAddr, 0x400, convertedvol | 0x100);
 801f8ec:	f3c2 124f 	ubfx	r2, r2, #5, #16
 801f8f0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 801f8f4:	e005      	b.n	801f902 <wm8994_SetVolume+0xce>
  if (inputEnabled != 0)
 801f8f6:	4b26      	ldr	r3, [pc, #152]	; (801f990 <wm8994_SetVolume+0x15c>)
 801f8f8:	681b      	ldr	r3, [r3, #0]
 801f8fa:	b1e3      	cbz	r3, 801f936 <wm8994_SetVolume+0x102>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 801f8fc:	b2f0      	uxtb	r0, r6
 801f8fe:	f240 12ef 	movw	r2, #495	; 0x1ef
 AUDIO_IO_Write(Addr, Reg, Value);
 801f902:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801f906:	9003      	str	r0, [sp, #12]
 801f908:	9201      	str	r2, [sp, #4]
 801f90a:	f7fd fb71 	bl	801cff0 <AUDIO_IO_Write>
 801f90e:	9a01      	ldr	r2, [sp, #4]
 801f910:	f240 4101 	movw	r1, #1025	; 0x401
 801f914:	9803      	ldr	r0, [sp, #12]
 801f916:	9202      	str	r2, [sp, #8]
 801f918:	9001      	str	r0, [sp, #4]
 801f91a:	f7fd fb69 	bl	801cff0 <AUDIO_IO_Write>
 801f91e:	f240 4104 	movw	r1, #1028	; 0x404
 801f922:	e9dd 0201 	ldrd	r0, r2, [sp, #4]
 801f926:	f7fd fb63 	bl	801cff0 <AUDIO_IO_Write>
 801f92a:	9a02      	ldr	r2, [sp, #8]
 801f92c:	f240 4105 	movw	r1, #1029	; 0x405
 801f930:	9801      	ldr	r0, [sp, #4]
 801f932:	f7fd fb5d 	bl	801cff0 <AUDIO_IO_Write>
}
 801f936:	2000      	movs	r0, #0
 801f938:	b004      	add	sp, #16
 801f93a:	bd70      	pop	{r4, r5, r6, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 801f93c:	2200      	movs	r2, #0
 801f93e:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801f942:	9001      	str	r0, [sp, #4]
 801f944:	f7fd fb54 	bl	801cff0 <AUDIO_IO_Write>
 801f948:	2200      	movs	r2, #0
 801f94a:	f240 4122 	movw	r1, #1058	; 0x422
 801f94e:	9801      	ldr	r0, [sp, #4]
 801f950:	f7fd fb4e 	bl	801cff0 <AUDIO_IO_Write>
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, convertedvol | 0x140);
 801f954:	f445 72a0 	orr.w	r2, r5, #320	; 0x140
 AUDIO_IO_Write(Addr, Reg, Value);
 801f958:	211c      	movs	r1, #28
 801f95a:	9801      	ldr	r0, [sp, #4]
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, convertedvol | 0x140);
 801f95c:	b292      	uxth	r2, r2
 AUDIO_IO_Write(Addr, Reg, Value);
 801f95e:	9202      	str	r2, [sp, #8]
 801f960:	f7fd fb46 	bl	801cff0 <AUDIO_IO_Write>
 801f964:	9a02      	ldr	r2, [sp, #8]
 801f966:	211d      	movs	r1, #29
 801f968:	9801      	ldr	r0, [sp, #4]
 801f96a:	f7fd fb41 	bl	801cff0 <AUDIO_IO_Write>
 801f96e:	9a02      	ldr	r2, [sp, #8]
 801f970:	2126      	movs	r1, #38	; 0x26
 801f972:	9801      	ldr	r0, [sp, #4]
 801f974:	f7fd fb3c 	bl	801cff0 <AUDIO_IO_Write>
 801f978:	9a02      	ldr	r2, [sp, #8]
 801f97a:	2127      	movs	r1, #39	; 0x27
 801f97c:	9801      	ldr	r0, [sp, #4]
 801f97e:	f7fd fb37 	bl	801cff0 <AUDIO_IO_Write>
  if (inputEnabled != 0)
 801f982:	4b03      	ldr	r3, [pc, #12]	; (801f990 <wm8994_SetVolume+0x15c>)
 801f984:	681b      	ldr	r3, [r3, #0]
 801f986:	2b00      	cmp	r3, #0
 801f988:	d0d5      	beq.n	801f936 <wm8994_SetVolume+0x102>
 801f98a:	e786      	b.n	801f89a <wm8994_SetVolume+0x66>
 801f98c:	20019820 	.word	0x20019820
 801f990:	2001981c 	.word	0x2001981c
 801f994:	51eb851f 	.word	0x51eb851f

0801f998 <wm8994_Init>:
{
 801f998:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801f99c:	4680      	mov	r8, r0
 801f99e:	461e      	mov	r6, r3
  uint16_t input_device = OutputInputDevice & 0xFF00;
 801f9a0:	f401 457f 	and.w	r5, r1, #65280	; 0xff00
{
 801f9a4:	4691      	mov	r9, r2
  counter += CODEC_IO_Write(DeviceAddr, 0x102, 0x0003);
 801f9a6:	fa5f f488 	uxtb.w	r4, r8
  uint16_t output_device = OutputInputDevice & 0xFF;
 801f9aa:	b2cf      	uxtb	r7, r1
  AUDIO_IO_Init();
 801f9ac:	f7fd fb18 	bl	801cfe0 <AUDIO_IO_Init>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f9b0:	2203      	movs	r2, #3
 801f9b2:	f44f 7181 	mov.w	r1, #258	; 0x102
 801f9b6:	4620      	mov	r0, r4
 801f9b8:	f7fd fb1a 	bl	801cff0 <AUDIO_IO_Write>
 801f9bc:	2200      	movs	r2, #0
 801f9be:	f640 0117 	movw	r1, #2071	; 0x817
 801f9c2:	4620      	mov	r0, r4
 801f9c4:	f7fd fb14 	bl	801cff0 <AUDIO_IO_Write>
 801f9c8:	2200      	movs	r2, #0
 801f9ca:	f44f 7181 	mov.w	r1, #258	; 0x102
 801f9ce:	4620      	mov	r0, r4
 801f9d0:	f7fd fb0e 	bl	801cff0 <AUDIO_IO_Write>
 801f9d4:	226c      	movs	r2, #108	; 0x6c
 801f9d6:	2139      	movs	r1, #57	; 0x39
 801f9d8:	4620      	mov	r0, r4
 801f9da:	f7fd fb09 	bl	801cff0 <AUDIO_IO_Write>
  if (input_device > 0)
 801f9de:	2d00      	cmp	r5, #0
 801f9e0:	f000 8132 	beq.w	801fc48 <wm8994_Init+0x2b0>
 AUDIO_IO_Write(Addr, Reg, Value);
 801f9e4:	2213      	movs	r2, #19
 801f9e6:	2101      	movs	r1, #1
 801f9e8:	4620      	mov	r0, r4
 801f9ea:	f7fd fb01 	bl	801cff0 <AUDIO_IO_Write>
  AUDIO_IO_Delay(50);
 801f9ee:	2032      	movs	r0, #50	; 0x32
 801f9f0:	f7fd fb30 	bl	801d054 <AUDIO_IO_Delay>
    outputEnabled = 1;
 801f9f4:	4bca      	ldr	r3, [pc, #808]	; (801fd20 <wm8994_Init+0x388>)
  if (output_device > 0)
 801f9f6:	2f00      	cmp	r7, #0
 801f9f8:	f000 8114 	beq.w	801fc24 <wm8994_Init+0x28c>
    outputEnabled = 1;
 801f9fc:	f04f 0a01 	mov.w	sl, #1
    switch (output_device)
 801fa00:	2f02      	cmp	r7, #2
    outputEnabled = 1;
 801fa02:	f8c3 a000 	str.w	sl, [r3]
    switch (output_device)
 801fa06:	f000 820e 	beq.w	801fe26 <wm8994_Init+0x48e>
 801fa0a:	2f03      	cmp	r7, #3
 801fa0c:	f000 8243 	beq.w	801fe96 <wm8994_Init+0x4fe>
 801fa10:	4557      	cmp	r7, sl
 AUDIO_IO_Write(Addr, Reg, Value);
 801fa12:	4620      	mov	r0, r4
    switch (output_device)
 801fa14:	f000 8221 	beq.w	801fe5a <wm8994_Init+0x4c2>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fa18:	2105      	movs	r1, #5
 801fa1a:	f240 3203 	movw	r2, #771	; 0x303
 801fa1e:	f7fd fae7 	bl	801cff0 <AUDIO_IO_Write>
 801fa22:	4652      	mov	r2, sl
 801fa24:	4620      	mov	r0, r4
 801fa26:	f240 6101 	movw	r1, #1537	; 0x601
 801fa2a:	f7fd fae1 	bl	801cff0 <AUDIO_IO_Write>
 801fa2e:	4652      	mov	r2, sl
 801fa30:	4620      	mov	r0, r4
 801fa32:	f240 6102 	movw	r1, #1538	; 0x602
 801fa36:	f7fd fadb 	bl	801cff0 <AUDIO_IO_Write>
 801fa3a:	4620      	mov	r0, r4
 801fa3c:	2200      	movs	r2, #0
 801fa3e:	f240 6104 	movw	r1, #1540	; 0x604
 801fa42:	f7fd fad5 	bl	801cff0 <AUDIO_IO_Write>
 801fa46:	2200      	movs	r2, #0
 801fa48:	f240 6105 	movw	r1, #1541	; 0x605
 801fa4c:	4620      	mov	r0, r4
 801fa4e:	f7fd facf 	bl	801cff0 <AUDIO_IO_Write>
  if (input_device > 0)
 801fa52:	2d00      	cmp	r5, #0
 801fa54:	f000 80ea 	beq.w	801fc2c <wm8994_Init+0x294>
    inputEnabled = 1;
 801fa58:	4ab2      	ldr	r2, [pc, #712]	; (801fd24 <wm8994_Init+0x38c>)
 801fa5a:	2301      	movs	r3, #1
    switch (input_device)
 801fa5c:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
    inputEnabled = 1;
 801fa60:	6013      	str	r3, [r2, #0]
    switch (input_device)
 801fa62:	f000 825b 	beq.w	801ff1c <wm8994_Init+0x584>
 801fa66:	f240 8127 	bls.w	801fcb8 <wm8994_Init+0x320>
 801fa6a:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 801fa6e:	f040 80f1 	bne.w	801fc54 <wm8994_Init+0x2bc>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fa72:	2211      	movs	r2, #17
 801fa74:	2128      	movs	r1, #40	; 0x28
 801fa76:	4620      	mov	r0, r4
 801fa78:	f7fd faba 	bl	801cff0 <AUDIO_IO_Write>
 801fa7c:	2235      	movs	r2, #53	; 0x35
 801fa7e:	2129      	movs	r1, #41	; 0x29
 801fa80:	4620      	mov	r0, r4
 801fa82:	f7fd fab5 	bl	801cff0 <AUDIO_IO_Write>
 801fa86:	2235      	movs	r2, #53	; 0x35
 801fa88:	212a      	movs	r1, #42	; 0x2a
 801fa8a:	4620      	mov	r0, r4
 801fa8c:	f7fd fab0 	bl	801cff0 <AUDIO_IO_Write>
 801fa90:	f240 3203 	movw	r2, #771	; 0x303
 801fa94:	2104      	movs	r1, #4
 801fa96:	4620      	mov	r0, r4
 801fa98:	f7fd faaa 	bl	801cff0 <AUDIO_IO_Write>
 801fa9c:	22db      	movs	r2, #219	; 0xdb
 801fa9e:	f44f 6188 	mov.w	r1, #1088	; 0x440
 801faa2:	4620      	mov	r0, r4
 801faa4:	f7fd faa4 	bl	801cff0 <AUDIO_IO_Write>
 801faa8:	f246 3250 	movw	r2, #25424	; 0x6350
 801faac:	2102      	movs	r1, #2
 801faae:	4620      	mov	r0, r4
 801fab0:	f7fd fa9e 	bl	801cff0 <AUDIO_IO_Write>
 801fab4:	2202      	movs	r2, #2
 801fab6:	f240 6106 	movw	r1, #1542	; 0x606
 801faba:	4620      	mov	r0, r4
 801fabc:	f7fd fa98 	bl	801cff0 <AUDIO_IO_Write>
 801fac0:	2202      	movs	r2, #2
 801fac2:	f240 6107 	movw	r1, #1543	; 0x607
 801fac6:	4620      	mov	r0, r4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
 801fac8:	f04f 0a00 	mov.w	sl, #0
 AUDIO_IO_Write(Addr, Reg, Value);
 801facc:	f7fd fa90 	bl	801cff0 <AUDIO_IO_Write>
 801fad0:	220d      	movs	r2, #13
 801fad2:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 801fad6:	4620      	mov	r0, r4
 801fad8:	f7fd fa8a 	bl	801cff0 <AUDIO_IO_Write>
  switch (AudioFreq)
 801fadc:	f5b6 4ffa 	cmp.w	r6, #32000	; 0x7d00
 801fae0:	f000 80ab 	beq.w	801fc3a <wm8994_Init+0x2a2>
 801fae4:	f200 8084 	bhi.w	801fbf0 <wm8994_Init+0x258>
 801fae8:	f5b6 5f7a 	cmp.w	r6, #16000	; 0x3e80
 801faec:	f000 8208 	beq.w	801ff00 <wm8994_Init+0x568>
 801faf0:	d834      	bhi.n	801fb5c <wm8994_Init+0x1c4>
 801faf2:	f5b6 5ffa 	cmp.w	r6, #8000	; 0x1f40
 801faf6:	f000 820a 	beq.w	801ff0e <wm8994_Init+0x576>
 801fafa:	f642 3311 	movw	r3, #11025	; 0x2b11
 801fafe:	429e      	cmp	r6, r3
 801fb00:	f040 8106 	bne.w	801fd10 <wm8994_Init+0x378>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fb04:	2213      	movs	r2, #19
 801fb06:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fb0a:	4620      	mov	r0, r4
 801fb0c:	f7fd fa70 	bl	801cff0 <AUDIO_IO_Write>
  if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 801fb10:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 801fb14:	d030      	beq.n	801fb78 <wm8994_Init+0x1e0>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fb16:	f244 0210 	movw	r2, #16400	; 0x4010
 801fb1a:	f44f 7140 	mov.w	r1, #768	; 0x300
 801fb1e:	4620      	mov	r0, r4
 801fb20:	f7fd fa66 	bl	801cff0 <AUDIO_IO_Write>
 801fb24:	2200      	movs	r2, #0
 801fb26:	f240 3102 	movw	r1, #770	; 0x302
 801fb2a:	4620      	mov	r0, r4
 801fb2c:	f7fd fa60 	bl	801cff0 <AUDIO_IO_Write>
 801fb30:	220a      	movs	r2, #10
 801fb32:	f44f 7102 	mov.w	r1, #520	; 0x208
 801fb36:	4620      	mov	r0, r4
 801fb38:	f7fd fa5a 	bl	801cff0 <AUDIO_IO_Write>
 801fb3c:	2201      	movs	r2, #1
 801fb3e:	f44f 7100 	mov.w	r1, #512	; 0x200
 801fb42:	4620      	mov	r0, r4
 801fb44:	f7fd fa54 	bl	801cff0 <AUDIO_IO_Write>
  if (output_device > 0)  /* Audio output selected */
 801fb48:	2f00      	cmp	r7, #0
 801fb4a:	f040 80ef 	bne.w	801fd2c <wm8994_Init+0x394>
 801fb4e:	2213      	movs	r2, #19
  if (input_device > 0) /* Audio input selected */
 801fb50:	2d00      	cmp	r5, #0
 801fb52:	f040 80b8 	bne.w	801fcc6 <wm8994_Init+0x32e>
}
 801fb56:	4650      	mov	r0, sl
 801fb58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  switch (AudioFreq)
 801fb5c:	f245 6322 	movw	r3, #22050	; 0x5622
 801fb60:	429e      	cmp	r6, r3
 801fb62:	f040 80d5 	bne.w	801fd10 <wm8994_Init+0x378>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fb66:	2243      	movs	r2, #67	; 0x43
 801fb68:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fb6c:	4620      	mov	r0, r4
 801fb6e:	f7fd fa3f 	bl	801cff0 <AUDIO_IO_Write>
  if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 801fb72:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 801fb76:	d1ce      	bne.n	801fb16 <wm8994_Init+0x17e>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fb78:	f244 0218 	movw	r2, #16408	; 0x4018
 801fb7c:	f44f 7140 	mov.w	r1, #768	; 0x300
 801fb80:	4620      	mov	r0, r4
 801fb82:	f7fd fa35 	bl	801cff0 <AUDIO_IO_Write>
 801fb86:	2200      	movs	r2, #0
 801fb88:	f240 3102 	movw	r1, #770	; 0x302
 801fb8c:	4620      	mov	r0, r4
 801fb8e:	f7fd fa2f 	bl	801cff0 <AUDIO_IO_Write>
 801fb92:	220a      	movs	r2, #10
 801fb94:	f44f 7102 	mov.w	r1, #520	; 0x208
 801fb98:	4620      	mov	r0, r4
 801fb9a:	f7fd fa29 	bl	801cff0 <AUDIO_IO_Write>
 801fb9e:	2201      	movs	r2, #1
 801fba0:	f44f 7100 	mov.w	r1, #512	; 0x200
 801fba4:	4620      	mov	r0, r4
 801fba6:	f7fd fa23 	bl	801cff0 <AUDIO_IO_Write>
  if (output_device > 0)  /* Audio output selected */
 801fbaa:	2f00      	cmp	r7, #0
 801fbac:	f040 8185 	bne.w	801feba <wm8994_Init+0x522>
 801fbb0:	2213      	movs	r2, #19
 AUDIO_IO_Write(Addr, Reg, Value);
 801fbb2:	4620      	mov	r0, r4
 801fbb4:	2101      	movs	r1, #1
 801fbb6:	f7fd fa1b 	bl	801cff0 <AUDIO_IO_Write>
 801fbba:	2202      	movs	r2, #2
 801fbbc:	4620      	mov	r0, r4
 801fbbe:	f44f 61c4 	mov.w	r1, #1568	; 0x620
 801fbc2:	f7fd fa15 	bl	801cff0 <AUDIO_IO_Write>
 801fbc6:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 801fbca:	4620      	mov	r0, r4
 801fbcc:	f44f 6182 	mov.w	r1, #1040	; 0x410
 801fbd0:	f7fd fa0e 	bl	801cff0 <AUDIO_IO_Write>
 801fbd4:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 801fbd8:	4620      	mov	r0, r4
 801fbda:	f240 4111 	movw	r1, #1041	; 0x411
 801fbde:	f7fd fa07 	bl	801cff0 <AUDIO_IO_Write>
    wm8994_SetVolume(DeviceAddr, Volume);
 801fbe2:	4649      	mov	r1, r9
 801fbe4:	4640      	mov	r0, r8
 801fbe6:	f7ff fe25 	bl	801f834 <wm8994_SetVolume>
}
 801fbea:	4650      	mov	r0, sl
 801fbec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  switch (AudioFreq)
 801fbf0:	f64b 3380 	movw	r3, #48000	; 0xbb80
 801fbf4:	429e      	cmp	r6, r3
 801fbf6:	f000 808b 	beq.w	801fd10 <wm8994_Init+0x378>
 801fbfa:	4b4b      	ldr	r3, [pc, #300]	; (801fd28 <wm8994_Init+0x390>)
 801fbfc:	429e      	cmp	r6, r3
 801fbfe:	d106      	bne.n	801fc0e <wm8994_Init+0x276>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fc00:	22a3      	movs	r2, #163	; 0xa3
 801fc02:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fc06:	4620      	mov	r0, r4
 801fc08:	f7fd f9f2 	bl	801cff0 <AUDIO_IO_Write>
    break;
 801fc0c:	e780      	b.n	801fb10 <wm8994_Init+0x178>
  switch (AudioFreq)
 801fc0e:	f64a 4344 	movw	r3, #44100	; 0xac44
 801fc12:	429e      	cmp	r6, r3
 801fc14:	d17c      	bne.n	801fd10 <wm8994_Init+0x378>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fc16:	2273      	movs	r2, #115	; 0x73
 801fc18:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fc1c:	4620      	mov	r0, r4
 801fc1e:	f7fd f9e7 	bl	801cff0 <AUDIO_IO_Write>
    break; 
 801fc22:	e775      	b.n	801fb10 <wm8994_Init+0x178>
    outputEnabled = 0;
 801fc24:	601f      	str	r7, [r3, #0]
  if (input_device > 0)
 801fc26:	2d00      	cmp	r5, #0
 801fc28:	f47f af16 	bne.w	801fa58 <wm8994_Init+0xc0>
    inputEnabled = 0;
 801fc2c:	4b3d      	ldr	r3, [pc, #244]	; (801fd24 <wm8994_Init+0x38c>)
  switch (AudioFreq)
 801fc2e:	f5b6 4ffa 	cmp.w	r6, #32000	; 0x7d00
    inputEnabled = 0;
 801fc32:	46aa      	mov	sl, r5
 801fc34:	601d      	str	r5, [r3, #0]
  switch (AudioFreq)
 801fc36:	f47f af55 	bne.w	801fae4 <wm8994_Init+0x14c>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fc3a:	2263      	movs	r2, #99	; 0x63
 801fc3c:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fc40:	4620      	mov	r0, r4
 801fc42:	f7fd f9d5 	bl	801cff0 <AUDIO_IO_Write>
    break;
 801fc46:	e763      	b.n	801fb10 <wm8994_Init+0x178>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fc48:	2203      	movs	r2, #3
 801fc4a:	2101      	movs	r1, #1
 801fc4c:	4620      	mov	r0, r4
 801fc4e:	f7fd f9cf 	bl	801cff0 <AUDIO_IO_Write>
#ifdef VERIFY_WRITTENDATA
  /* Verify that the data has been correctly written */
  result = (AUDIO_IO_Read(Addr, Reg) == Value)? 0:1;
#endif /* VERIFY_WRITTENDATA */
  
  return result;
 801fc52:	e6cc      	b.n	801f9ee <wm8994_Init+0x56>
    switch (input_device)
 801fc54:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 801fc58:	f040 80fd 	bne.w	801fe56 <wm8994_Init+0x4be>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fc5c:	f640 723c 	movw	r2, #3900	; 0xf3c
 801fc60:	2104      	movs	r1, #4
 801fc62:	4620      	mov	r0, r4
 801fc64:	f7fd f9c4 	bl	801cff0 <AUDIO_IO_Write>
 801fc68:	22db      	movs	r2, #219	; 0xdb
 801fc6a:	f44f 618a 	mov.w	r1, #1104	; 0x450
 801fc6e:	4620      	mov	r0, r4
 801fc70:	f7fd f9be 	bl	801cff0 <AUDIO_IO_Write>
 801fc74:	22db      	movs	r2, #219	; 0xdb
 801fc76:	f44f 6188 	mov.w	r1, #1088	; 0x440
 801fc7a:	4620      	mov	r0, r4
 801fc7c:	f7fd f9b8 	bl	801cff0 <AUDIO_IO_Write>
 801fc80:	f246 32a0 	movw	r2, #25504	; 0x63a0
 801fc84:	2102      	movs	r1, #2
 801fc86:	4620      	mov	r0, r4
 801fc88:	f7fd f9b2 	bl	801cff0 <AUDIO_IO_Write>
 801fc8c:	2202      	movs	r2, #2
 801fc8e:	f240 6106 	movw	r1, #1542	; 0x606
 801fc92:	4620      	mov	r0, r4
 801fc94:	f7fd f9ac 	bl	801cff0 <AUDIO_IO_Write>
 801fc98:	2202      	movs	r2, #2
 801fc9a:	f240 6107 	movw	r1, #1543	; 0x607
 801fc9e:	4620      	mov	r0, r4
 801fca0:	f7fd f9a6 	bl	801cff0 <AUDIO_IO_Write>
 801fca4:	2202      	movs	r2, #2
 801fca6:	f44f 61c1 	mov.w	r1, #1544	; 0x608
 801fcaa:	4620      	mov	r0, r4
 801fcac:	f7fd f9a0 	bl	801cff0 <AUDIO_IO_Write>
 801fcb0:	2202      	movs	r2, #2
 801fcb2:	f240 6109 	movw	r1, #1545	; 0x609
 801fcb6:	e706      	b.n	801fac6 <wm8994_Init+0x12e>
    switch (input_device)
 801fcb8:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 801fcbc:	f040 80cb 	bne.w	801fe56 <wm8994_Init+0x4be>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fcc0:	f44f 7243 	mov.w	r2, #780	; 0x30c
 801fcc4:	e6e6      	b.n	801fa94 <wm8994_Init+0xfc>
    if ((input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_1) || (input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_2))
 801fcc6:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 801fcca:	f000 80ae 	beq.w	801fe2a <wm8994_Init+0x492>
 801fcce:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 801fcd2:	f000 80aa 	beq.w	801fe2a <wm8994_Init+0x492>
    else if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 801fcd6:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 801fcda:	f43f af6a 	beq.w	801fbb2 <wm8994_Init+0x21a>
    else if ((input_device == INPUT_DEVICE_INPUT_LINE_1) || (input_device == INPUT_DEVICE_INPUT_LINE_2))
 801fcde:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 801fce2:	d003      	beq.n	801fcec <wm8994_Init+0x354>
 801fce4:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 801fce8:	f47f af7b 	bne.w	801fbe2 <wm8994_Init+0x24a>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fcec:	4620      	mov	r0, r4
 801fcee:	220b      	movs	r2, #11
 801fcf0:	2118      	movs	r1, #24
 801fcf2:	f7fd f97d 	bl	801cff0 <AUDIO_IO_Write>
 801fcf6:	4620      	mov	r0, r4
 801fcf8:	220b      	movs	r2, #11
 801fcfa:	211a      	movs	r1, #26
 801fcfc:	f7fd f978 	bl	801cff0 <AUDIO_IO_Write>
 801fd00:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 801fd04:	4620      	mov	r0, r4
 801fd06:	f44f 6182 	mov.w	r1, #1040	; 0x410
 801fd0a:	f7fd f971 	bl	801cff0 <AUDIO_IO_Write>
  return result;
 801fd0e:	e768      	b.n	801fbe2 <wm8994_Init+0x24a>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fd10:	2283      	movs	r2, #131	; 0x83
 801fd12:	f44f 7104 	mov.w	r1, #528	; 0x210
 801fd16:	4620      	mov	r0, r4
 801fd18:	f7fd f96a 	bl	801cff0 <AUDIO_IO_Write>
    break; 
 801fd1c:	e6f8      	b.n	801fb10 <wm8994_Init+0x178>
 801fd1e:	bf00      	nop
 801fd20:	20019820 	.word	0x20019820
 801fd24:	2001981c 	.word	0x2001981c
 801fd28:	00017700 	.word	0x00017700
 AUDIO_IO_Write(Addr, Reg, Value);
 801fd2c:	4620      	mov	r0, r4
 801fd2e:	f44f 7240 	mov.w	r2, #768	; 0x300
 801fd32:	2103      	movs	r1, #3
 801fd34:	f7fd f95c 	bl	801cff0 <AUDIO_IO_Write>
 801fd38:	4620      	mov	r0, r4
 801fd3a:	2200      	movs	r2, #0
 801fd3c:	2122      	movs	r1, #34	; 0x22
 801fd3e:	f7fd f957 	bl	801cff0 <AUDIO_IO_Write>
 801fd42:	4620      	mov	r0, r4
 801fd44:	2200      	movs	r2, #0
 801fd46:	2123      	movs	r1, #35	; 0x23
 801fd48:	f7fd f952 	bl	801cff0 <AUDIO_IO_Write>
 801fd4c:	4620      	mov	r0, r4
 801fd4e:	f44f 7240 	mov.w	r2, #768	; 0x300
 801fd52:	2136      	movs	r1, #54	; 0x36
 801fd54:	f7fd f94c 	bl	801cff0 <AUDIO_IO_Write>
 801fd58:	4620      	mov	r0, r4
 801fd5a:	f243 0203 	movw	r2, #12291	; 0x3003
 801fd5e:	2101      	movs	r1, #1
 801fd60:	f7fd f946 	bl	801cff0 <AUDIO_IO_Write>
 801fd64:	2205      	movs	r2, #5
 801fd66:	2151      	movs	r1, #81	; 0x51
 801fd68:	4620      	mov	r0, r4
 801fd6a:	f7fd f941 	bl	801cff0 <AUDIO_IO_Write>
 801fd6e:	f243 3203 	movw	r2, #13059	; 0x3303
 801fd72:	2101      	movs	r1, #1
 801fd74:	4620      	mov	r0, r4
 801fd76:	f7fd f93b 	bl	801cff0 <AUDIO_IO_Write>
 801fd7a:	2222      	movs	r2, #34	; 0x22
 801fd7c:	2160      	movs	r1, #96	; 0x60
 801fd7e:	4620      	mov	r0, r4
 801fd80:	f7fd f936 	bl	801cff0 <AUDIO_IO_Write>
 801fd84:	f649 7225 	movw	r2, #40741	; 0x9f25
 801fd88:	214c      	movs	r1, #76	; 0x4c
 801fd8a:	4620      	mov	r0, r4
 801fd8c:	f7fd f930 	bl	801cff0 <AUDIO_IO_Write>
    AUDIO_IO_Delay(15);
 801fd90:	200f      	movs	r0, #15
 801fd92:	f7fd f95f 	bl	801d054 <AUDIO_IO_Delay>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fd96:	2201      	movs	r2, #1
 801fd98:	212d      	movs	r1, #45	; 0x2d
 801fd9a:	4620      	mov	r0, r4
 801fd9c:	f7fd f928 	bl	801cff0 <AUDIO_IO_Write>
 801fda0:	2201      	movs	r2, #1
 801fda2:	212e      	movs	r1, #46	; 0x2e
 801fda4:	4620      	mov	r0, r4
 801fda6:	f7fd f923 	bl	801cff0 <AUDIO_IO_Write>
 801fdaa:	f44f 724c 	mov.w	r2, #816	; 0x330
 801fdae:	2103      	movs	r1, #3
 801fdb0:	4620      	mov	r0, r4
 801fdb2:	f7fd f91d 	bl	801cff0 <AUDIO_IO_Write>
 801fdb6:	2233      	movs	r2, #51	; 0x33
 801fdb8:	2154      	movs	r1, #84	; 0x54
 801fdba:	4620      	mov	r0, r4
 801fdbc:	f7fd f918 	bl	801cff0 <AUDIO_IO_Write>
    AUDIO_IO_Delay(250);
 801fdc0:	20fa      	movs	r0, #250	; 0xfa
 801fdc2:	f7fd f947 	bl	801d054 <AUDIO_IO_Delay>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fdc6:	22ee      	movs	r2, #238	; 0xee
 801fdc8:	2160      	movs	r1, #96	; 0x60
 801fdca:	4620      	mov	r0, r4
 801fdcc:	f7fd f910 	bl	801cff0 <AUDIO_IO_Write>
 801fdd0:	22c0      	movs	r2, #192	; 0xc0
 801fdd2:	f44f 61c2 	mov.w	r1, #1552	; 0x610
 801fdd6:	4620      	mov	r0, r4
 801fdd8:	f7fd f90a 	bl	801cff0 <AUDIO_IO_Write>
 801fddc:	22c0      	movs	r2, #192	; 0xc0
 801fdde:	f240 6111 	movw	r1, #1553	; 0x611
 801fde2:	4620      	mov	r0, r4
 801fde4:	f7fd f904 	bl	801cff0 <AUDIO_IO_Write>
 801fde8:	2200      	movs	r2, #0
 801fdea:	f44f 6184 	mov.w	r1, #1056	; 0x420
 801fdee:	4620      	mov	r0, r4
 801fdf0:	f7fd f8fe 	bl	801cff0 <AUDIO_IO_Write>
 801fdf4:	22c0      	movs	r2, #192	; 0xc0
 801fdf6:	f240 6112 	movw	r1, #1554	; 0x612
 801fdfa:	4620      	mov	r0, r4
 801fdfc:	f7fd f8f8 	bl	801cff0 <AUDIO_IO_Write>
 801fe00:	22c0      	movs	r2, #192	; 0xc0
 801fe02:	f240 6113 	movw	r1, #1555	; 0x613
 801fe06:	4620      	mov	r0, r4
 801fe08:	f7fd f8f2 	bl	801cff0 <AUDIO_IO_Write>
 801fe0c:	2200      	movs	r2, #0
 801fe0e:	f240 4122 	movw	r1, #1058	; 0x422
 801fe12:	4620      	mov	r0, r4
 801fe14:	f7fd f8ec 	bl	801cff0 <AUDIO_IO_Write>
    wm8994_SetVolume(DeviceAddr, Volume);
 801fe18:	4649      	mov	r1, r9
 801fe1a:	4640      	mov	r0, r8
 801fe1c:	f7ff fd0a 	bl	801f834 <wm8994_SetVolume>
 801fe20:	f243 3213 	movw	r2, #13075	; 0x3313
 801fe24:	e694      	b.n	801fb50 <wm8994_Init+0x1b8>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fe26:	4620      	mov	r0, r4
 801fe28:	e5f6      	b.n	801fa18 <wm8994_Init+0x80>
 801fe2a:	4620      	mov	r0, r4
 801fe2c:	2101      	movs	r1, #1
 801fe2e:	f7fd f8df 	bl	801cff0 <AUDIO_IO_Write>
 801fe32:	4620      	mov	r0, r4
 801fe34:	2202      	movs	r2, #2
 801fe36:	f44f 61c4 	mov.w	r1, #1568	; 0x620
 801fe3a:	f7fd f8d9 	bl	801cff0 <AUDIO_IO_Write>
 801fe3e:	4620      	mov	r0, r4
 801fe40:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 801fe44:	f240 4111 	movw	r1, #1041	; 0x411
 801fe48:	f7fd f8d2 	bl	801cff0 <AUDIO_IO_Write>
    wm8994_SetVolume(DeviceAddr, Volume);
 801fe4c:	4649      	mov	r1, r9
 801fe4e:	4640      	mov	r0, r8
 801fe50:	f7ff fcf0 	bl	801f834 <wm8994_SetVolume>
  return counter;  
 801fe54:	e6c9      	b.n	801fbea <wm8994_Init+0x252>
    switch (input_device)
 801fe56:	469a      	mov	sl, r3
 801fe58:	e640      	b.n	801fadc <wm8994_Init+0x144>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fe5a:	f640 420c 	movw	r2, #3084	; 0xc0c
 801fe5e:	2105      	movs	r1, #5
 801fe60:	f7fd f8c6 	bl	801cff0 <AUDIO_IO_Write>
 801fe64:	4620      	mov	r0, r4
 801fe66:	2200      	movs	r2, #0
 801fe68:	f240 6101 	movw	r1, #1537	; 0x601
 801fe6c:	f7fd f8c0 	bl	801cff0 <AUDIO_IO_Write>
 801fe70:	4620      	mov	r0, r4
 801fe72:	2200      	movs	r2, #0
 801fe74:	f240 6102 	movw	r1, #1538	; 0x602
 801fe78:	f7fd f8ba 	bl	801cff0 <AUDIO_IO_Write>
 801fe7c:	4620      	mov	r0, r4
 801fe7e:	2202      	movs	r2, #2
 801fe80:	f240 6104 	movw	r1, #1540	; 0x604
 801fe84:	f7fd f8b4 	bl	801cff0 <AUDIO_IO_Write>
 801fe88:	2202      	movs	r2, #2
 801fe8a:	f240 6105 	movw	r1, #1541	; 0x605
 801fe8e:	4620      	mov	r0, r4
 801fe90:	f7fd f8ae 	bl	801cff0 <AUDIO_IO_Write>
  return result;
 801fe94:	e5dd      	b.n	801fa52 <wm8994_Init+0xba>
      if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 801fe96:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 801fe9a:	d066      	beq.n	801ff6a <wm8994_Init+0x5d2>
 AUDIO_IO_Write(Addr, Reg, Value);
 801fe9c:	4620      	mov	r0, r4
 801fe9e:	2105      	movs	r1, #5
 801fea0:	f640 720f 	movw	r2, #3855	; 0xf0f
 801fea4:	f7fd f8a4 	bl	801cff0 <AUDIO_IO_Write>
 801fea8:	4652      	mov	r2, sl
 801feaa:	4620      	mov	r0, r4
 801feac:	f240 6101 	movw	r1, #1537	; 0x601
 801feb0:	f7fd f89e 	bl	801cff0 <AUDIO_IO_Write>
 801feb4:	4652      	mov	r2, sl
 801feb6:	4620      	mov	r0, r4
 801feb8:	e7dc      	b.n	801fe74 <wm8994_Init+0x4dc>
 801feba:	4620      	mov	r0, r4
 801febc:	f44f 7240 	mov.w	r2, #768	; 0x300
 801fec0:	2103      	movs	r1, #3
 801fec2:	f7fd f895 	bl	801cff0 <AUDIO_IO_Write>
 801fec6:	4620      	mov	r0, r4
 801fec8:	2200      	movs	r2, #0
 801feca:	2122      	movs	r1, #34	; 0x22
 801fecc:	f7fd f890 	bl	801cff0 <AUDIO_IO_Write>
 801fed0:	4620      	mov	r0, r4
 801fed2:	2200      	movs	r2, #0
 801fed4:	2123      	movs	r1, #35	; 0x23
 801fed6:	f7fd f88b 	bl	801cff0 <AUDIO_IO_Write>
 801feda:	4620      	mov	r0, r4
 801fedc:	f44f 7240 	mov.w	r2, #768	; 0x300
 801fee0:	2136      	movs	r1, #54	; 0x36
 801fee2:	f7fd f885 	bl	801cff0 <AUDIO_IO_Write>
 801fee6:	4620      	mov	r0, r4
 801fee8:	f243 0203 	movw	r2, #12291	; 0x3003
 801feec:	2101      	movs	r1, #1
 801feee:	f7fd f87f 	bl	801cff0 <AUDIO_IO_Write>
 801fef2:	f240 2205 	movw	r2, #517	; 0x205
 801fef6:	2151      	movs	r1, #81	; 0x51
 801fef8:	4620      	mov	r0, r4
 801fefa:	f7fd f879 	bl	801cff0 <AUDIO_IO_Write>
  return result;
 801fefe:	e736      	b.n	801fd6e <wm8994_Init+0x3d6>
 AUDIO_IO_Write(Addr, Reg, Value);
 801ff00:	2233      	movs	r2, #51	; 0x33
 801ff02:	f44f 7104 	mov.w	r1, #528	; 0x210
 801ff06:	4620      	mov	r0, r4
 801ff08:	f7fd f872 	bl	801cff0 <AUDIO_IO_Write>
    break;
 801ff0c:	e600      	b.n	801fb10 <wm8994_Init+0x178>
 AUDIO_IO_Write(Addr, Reg, Value);
 801ff0e:	2203      	movs	r2, #3
 801ff10:	f44f 7104 	mov.w	r1, #528	; 0x210
 801ff14:	4620      	mov	r0, r4
 801ff16:	f7fd f86b 	bl	801cff0 <AUDIO_IO_Write>
    break;
 801ff1a:	e5f9      	b.n	801fb10 <wm8994_Init+0x178>
 AUDIO_IO_Write(Addr, Reg, Value);
 801ff1c:	f44f 6243 	mov.w	r2, #3120	; 0xc30
 801ff20:	2104      	movs	r1, #4
 801ff22:	4620      	mov	r0, r4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000E);
 801ff24:	f04f 0a00 	mov.w	sl, #0
 AUDIO_IO_Write(Addr, Reg, Value);
 801ff28:	f7fd f862 	bl	801cff0 <AUDIO_IO_Write>
 801ff2c:	22db      	movs	r2, #219	; 0xdb
 801ff2e:	f44f 618a 	mov.w	r1, #1104	; 0x450
 801ff32:	4620      	mov	r0, r4
 801ff34:	f7fd f85c 	bl	801cff0 <AUDIO_IO_Write>
 801ff38:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 801ff3c:	2102      	movs	r1, #2
 801ff3e:	4620      	mov	r0, r4
 801ff40:	f7fd f856 	bl	801cff0 <AUDIO_IO_Write>
 801ff44:	2202      	movs	r2, #2
 801ff46:	f44f 61c1 	mov.w	r1, #1544	; 0x608
 801ff4a:	4620      	mov	r0, r4
 801ff4c:	f7fd f850 	bl	801cff0 <AUDIO_IO_Write>
 801ff50:	2202      	movs	r2, #2
 801ff52:	f240 6109 	movw	r1, #1545	; 0x609
 801ff56:	4620      	mov	r0, r4
 801ff58:	f7fd f84a 	bl	801cff0 <AUDIO_IO_Write>
 801ff5c:	220e      	movs	r2, #14
 801ff5e:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 801ff62:	4620      	mov	r0, r4
 801ff64:	f7fd f844 	bl	801cff0 <AUDIO_IO_Write>
      break;
 801ff68:	e5b8      	b.n	801fadc <wm8994_Init+0x144>
 AUDIO_IO_Write(Addr, Reg, Value);
 801ff6a:	2105      	movs	r1, #5
 801ff6c:	4620      	mov	r0, r4
 801ff6e:	f640 720f 	movw	r2, #3855	; 0xf0f
 801ff72:	f7fd f83d 	bl	801cff0 <AUDIO_IO_Write>
 801ff76:	463a      	mov	r2, r7
 801ff78:	f240 6101 	movw	r1, #1537	; 0x601
 801ff7c:	4620      	mov	r0, r4
 801ff7e:	f7fd f837 	bl	801cff0 <AUDIO_IO_Write>
 801ff82:	463a      	mov	r2, r7
 801ff84:	f240 6102 	movw	r1, #1538	; 0x602
 801ff88:	4620      	mov	r0, r4
 801ff8a:	f7fd f831 	bl	801cff0 <AUDIO_IO_Write>
 801ff8e:	463a      	mov	r2, r7
 801ff90:	f240 6104 	movw	r1, #1540	; 0x604
 801ff94:	4620      	mov	r0, r4
 801ff96:	f7fd f82b 	bl	801cff0 <AUDIO_IO_Write>
 801ff9a:	463a      	mov	r2, r7
 801ff9c:	f240 6105 	movw	r1, #1541	; 0x605
 801ffa0:	4620      	mov	r0, r4
 801ffa2:	f7fd f825 	bl	801cff0 <AUDIO_IO_Write>
    inputEnabled = 1;
 801ffa6:	4b02      	ldr	r3, [pc, #8]	; (801ffb0 <wm8994_Init+0x618>)
 801ffa8:	f8c3 a000 	str.w	sl, [r3]
    switch (input_device)
 801ffac:	e656      	b.n	801fc5c <wm8994_Init+0x2c4>
 801ffae:	bf00      	nop
 801ffb0:	2001981c 	.word	0x2001981c

0801ffb4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 801ffb4:	f8df d034 	ldr.w	sp, [pc, #52]	; 801ffec <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 801ffb8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 801ffba:	e003      	b.n	801ffc4 <LoopCopyDataInit>

0801ffbc <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 801ffbc:	4b0c      	ldr	r3, [pc, #48]	; (801fff0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 801ffbe:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 801ffc0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 801ffc2:	3104      	adds	r1, #4

0801ffc4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 801ffc4:	480b      	ldr	r0, [pc, #44]	; (801fff4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 801ffc6:	4b0c      	ldr	r3, [pc, #48]	; (801fff8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 801ffc8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 801ffca:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 801ffcc:	d3f6      	bcc.n	801ffbc <CopyDataInit>
  ldr  r2, =_sbss
 801ffce:	4a0b      	ldr	r2, [pc, #44]	; (801fffc <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 801ffd0:	e002      	b.n	801ffd8 <LoopFillZerobss>

0801ffd2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 801ffd2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 801ffd4:	f842 3b04 	str.w	r3, [r2], #4

0801ffd8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 801ffd8:	4b09      	ldr	r3, [pc, #36]	; (8020000 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 801ffda:	429a      	cmp	r2, r3
  bcc  FillZerobss
 801ffdc:	d3f9      	bcc.n	801ffd2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 801ffde:	f7fe f9ef 	bl	801e3c0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 801ffe2:	f000 f81f 	bl	8020024 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 801ffe6:	f7fa fd1f 	bl	801aa28 <main>
  bx  lr    
 801ffea:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 801ffec:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
 801fff0:	08027058 	.word	0x08027058
  ldr  r0, =_sdata
 801fff4:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 801fff8:	20000110 	.word	0x20000110
  ldr  r2, =_sbss
 801fffc:	20000110 	.word	0x20000110
  ldr  r3, = _ebss
 8020000:	20019834 	.word	0x20019834

08020004 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8020004:	e7fe      	b.n	8020004 <ADC_IRQHandler>
	...

08020008 <calloc>:
 8020008:	4b02      	ldr	r3, [pc, #8]	; (8020014 <calloc+0xc>)
 802000a:	460a      	mov	r2, r1
 802000c:	4601      	mov	r1, r0
 802000e:	6818      	ldr	r0, [r3, #0]
 8020010:	f000 b86c 	b.w	80200ec <_calloc_r>
 8020014:	200000ac 	.word	0x200000ac

08020018 <__errno>:
 8020018:	4b01      	ldr	r3, [pc, #4]	; (8020020 <__errno+0x8>)
 802001a:	6818      	ldr	r0, [r3, #0]
 802001c:	4770      	bx	lr
 802001e:	bf00      	nop
 8020020:	200000ac 	.word	0x200000ac

08020024 <__libc_init_array>:
 8020024:	b570      	push	{r4, r5, r6, lr}
 8020026:	4d0d      	ldr	r5, [pc, #52]	; (802005c <__libc_init_array+0x38>)
 8020028:	4c0d      	ldr	r4, [pc, #52]	; (8020060 <__libc_init_array+0x3c>)
 802002a:	1b64      	subs	r4, r4, r5
 802002c:	10a4      	asrs	r4, r4, #2
 802002e:	2600      	movs	r6, #0
 8020030:	42a6      	cmp	r6, r4
 8020032:	d109      	bne.n	8020048 <__libc_init_array+0x24>
 8020034:	4d0b      	ldr	r5, [pc, #44]	; (8020064 <__libc_init_array+0x40>)
 8020036:	4c0c      	ldr	r4, [pc, #48]	; (8020068 <__libc_init_array+0x44>)
 8020038:	f001 fa42 	bl	80214c0 <_init>
 802003c:	1b64      	subs	r4, r4, r5
 802003e:	10a4      	asrs	r4, r4, #2
 8020040:	2600      	movs	r6, #0
 8020042:	42a6      	cmp	r6, r4
 8020044:	d105      	bne.n	8020052 <__libc_init_array+0x2e>
 8020046:	bd70      	pop	{r4, r5, r6, pc}
 8020048:	f855 3b04 	ldr.w	r3, [r5], #4
 802004c:	4798      	blx	r3
 802004e:	3601      	adds	r6, #1
 8020050:	e7ee      	b.n	8020030 <__libc_init_array+0xc>
 8020052:	f855 3b04 	ldr.w	r3, [r5], #4
 8020056:	4798      	blx	r3
 8020058:	3601      	adds	r6, #1
 802005a:	e7f2      	b.n	8020042 <__libc_init_array+0x1e>
 802005c:	08027050 	.word	0x08027050
 8020060:	08027050 	.word	0x08027050
 8020064:	08027050 	.word	0x08027050
 8020068:	08027054 	.word	0x08027054

0802006c <malloc>:
 802006c:	4b02      	ldr	r3, [pc, #8]	; (8020078 <malloc+0xc>)
 802006e:	4601      	mov	r1, r0
 8020070:	6818      	ldr	r0, [r3, #0]
 8020072:	f000 b8bd 	b.w	80201f0 <_malloc_r>
 8020076:	bf00      	nop
 8020078:	200000ac 	.word	0x200000ac

0802007c <free>:
 802007c:	4b02      	ldr	r3, [pc, #8]	; (8020088 <free+0xc>)
 802007e:	4601      	mov	r1, r0
 8020080:	6818      	ldr	r0, [r3, #0]
 8020082:	f000 b849 	b.w	8020118 <_free_r>
 8020086:	bf00      	nop
 8020088:	200000ac 	.word	0x200000ac

0802008c <memcpy>:
 802008c:	440a      	add	r2, r1
 802008e:	4291      	cmp	r1, r2
 8020090:	f100 33ff 	add.w	r3, r0, #4294967295
 8020094:	d100      	bne.n	8020098 <memcpy+0xc>
 8020096:	4770      	bx	lr
 8020098:	b510      	push	{r4, lr}
 802009a:	f811 4b01 	ldrb.w	r4, [r1], #1
 802009e:	f803 4f01 	strb.w	r4, [r3, #1]!
 80200a2:	4291      	cmp	r1, r2
 80200a4:	d1f9      	bne.n	802009a <memcpy+0xe>
 80200a6:	bd10      	pop	{r4, pc}

080200a8 <memmove>:
 80200a8:	4288      	cmp	r0, r1
 80200aa:	b510      	push	{r4, lr}
 80200ac:	eb01 0402 	add.w	r4, r1, r2
 80200b0:	d902      	bls.n	80200b8 <memmove+0x10>
 80200b2:	4284      	cmp	r4, r0
 80200b4:	4623      	mov	r3, r4
 80200b6:	d807      	bhi.n	80200c8 <memmove+0x20>
 80200b8:	1e43      	subs	r3, r0, #1
 80200ba:	42a1      	cmp	r1, r4
 80200bc:	d008      	beq.n	80200d0 <memmove+0x28>
 80200be:	f811 2b01 	ldrb.w	r2, [r1], #1
 80200c2:	f803 2f01 	strb.w	r2, [r3, #1]!
 80200c6:	e7f8      	b.n	80200ba <memmove+0x12>
 80200c8:	4402      	add	r2, r0
 80200ca:	4601      	mov	r1, r0
 80200cc:	428a      	cmp	r2, r1
 80200ce:	d100      	bne.n	80200d2 <memmove+0x2a>
 80200d0:	bd10      	pop	{r4, pc}
 80200d2:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80200d6:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80200da:	e7f7      	b.n	80200cc <memmove+0x24>

080200dc <memset>:
 80200dc:	4402      	add	r2, r0
 80200de:	4603      	mov	r3, r0
 80200e0:	4293      	cmp	r3, r2
 80200e2:	d100      	bne.n	80200e6 <memset+0xa>
 80200e4:	4770      	bx	lr
 80200e6:	f803 1b01 	strb.w	r1, [r3], #1
 80200ea:	e7f9      	b.n	80200e0 <memset+0x4>

080200ec <_calloc_r>:
 80200ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80200ee:	fba1 2402 	umull	r2, r4, r1, r2
 80200f2:	b94c      	cbnz	r4, 8020108 <_calloc_r+0x1c>
 80200f4:	4611      	mov	r1, r2
 80200f6:	9201      	str	r2, [sp, #4]
 80200f8:	f000 f87a 	bl	80201f0 <_malloc_r>
 80200fc:	9a01      	ldr	r2, [sp, #4]
 80200fe:	4605      	mov	r5, r0
 8020100:	b930      	cbnz	r0, 8020110 <_calloc_r+0x24>
 8020102:	4628      	mov	r0, r5
 8020104:	b003      	add	sp, #12
 8020106:	bd30      	pop	{r4, r5, pc}
 8020108:	220c      	movs	r2, #12
 802010a:	6002      	str	r2, [r0, #0]
 802010c:	2500      	movs	r5, #0
 802010e:	e7f8      	b.n	8020102 <_calloc_r+0x16>
 8020110:	4621      	mov	r1, r4
 8020112:	f7ff ffe3 	bl	80200dc <memset>
 8020116:	e7f4      	b.n	8020102 <_calloc_r+0x16>

08020118 <_free_r>:
 8020118:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802011a:	2900      	cmp	r1, #0
 802011c:	d044      	beq.n	80201a8 <_free_r+0x90>
 802011e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8020122:	9001      	str	r0, [sp, #4]
 8020124:	2b00      	cmp	r3, #0
 8020126:	f1a1 0404 	sub.w	r4, r1, #4
 802012a:	bfb8      	it	lt
 802012c:	18e4      	addlt	r4, r4, r3
 802012e:	f000 fa5d 	bl	80205ec <__malloc_lock>
 8020132:	4a1e      	ldr	r2, [pc, #120]	; (80201ac <_free_r+0x94>)
 8020134:	9801      	ldr	r0, [sp, #4]
 8020136:	6813      	ldr	r3, [r2, #0]
 8020138:	b933      	cbnz	r3, 8020148 <_free_r+0x30>
 802013a:	6063      	str	r3, [r4, #4]
 802013c:	6014      	str	r4, [r2, #0]
 802013e:	b003      	add	sp, #12
 8020140:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8020144:	f000 ba58 	b.w	80205f8 <__malloc_unlock>
 8020148:	42a3      	cmp	r3, r4
 802014a:	d908      	bls.n	802015e <_free_r+0x46>
 802014c:	6825      	ldr	r5, [r4, #0]
 802014e:	1961      	adds	r1, r4, r5
 8020150:	428b      	cmp	r3, r1
 8020152:	bf01      	itttt	eq
 8020154:	6819      	ldreq	r1, [r3, #0]
 8020156:	685b      	ldreq	r3, [r3, #4]
 8020158:	1949      	addeq	r1, r1, r5
 802015a:	6021      	streq	r1, [r4, #0]
 802015c:	e7ed      	b.n	802013a <_free_r+0x22>
 802015e:	461a      	mov	r2, r3
 8020160:	685b      	ldr	r3, [r3, #4]
 8020162:	b10b      	cbz	r3, 8020168 <_free_r+0x50>
 8020164:	42a3      	cmp	r3, r4
 8020166:	d9fa      	bls.n	802015e <_free_r+0x46>
 8020168:	6811      	ldr	r1, [r2, #0]
 802016a:	1855      	adds	r5, r2, r1
 802016c:	42a5      	cmp	r5, r4
 802016e:	d10b      	bne.n	8020188 <_free_r+0x70>
 8020170:	6824      	ldr	r4, [r4, #0]
 8020172:	4421      	add	r1, r4
 8020174:	1854      	adds	r4, r2, r1
 8020176:	42a3      	cmp	r3, r4
 8020178:	6011      	str	r1, [r2, #0]
 802017a:	d1e0      	bne.n	802013e <_free_r+0x26>
 802017c:	681c      	ldr	r4, [r3, #0]
 802017e:	685b      	ldr	r3, [r3, #4]
 8020180:	6053      	str	r3, [r2, #4]
 8020182:	4421      	add	r1, r4
 8020184:	6011      	str	r1, [r2, #0]
 8020186:	e7da      	b.n	802013e <_free_r+0x26>
 8020188:	d902      	bls.n	8020190 <_free_r+0x78>
 802018a:	230c      	movs	r3, #12
 802018c:	6003      	str	r3, [r0, #0]
 802018e:	e7d6      	b.n	802013e <_free_r+0x26>
 8020190:	6825      	ldr	r5, [r4, #0]
 8020192:	1961      	adds	r1, r4, r5
 8020194:	428b      	cmp	r3, r1
 8020196:	bf04      	itt	eq
 8020198:	6819      	ldreq	r1, [r3, #0]
 802019a:	685b      	ldreq	r3, [r3, #4]
 802019c:	6063      	str	r3, [r4, #4]
 802019e:	bf04      	itt	eq
 80201a0:	1949      	addeq	r1, r1, r5
 80201a2:	6021      	streq	r1, [r4, #0]
 80201a4:	6054      	str	r4, [r2, #4]
 80201a6:	e7ca      	b.n	802013e <_free_r+0x26>
 80201a8:	b003      	add	sp, #12
 80201aa:	bd30      	pop	{r4, r5, pc}
 80201ac:	20019824 	.word	0x20019824

080201b0 <sbrk_aligned>:
 80201b0:	b570      	push	{r4, r5, r6, lr}
 80201b2:	4e0e      	ldr	r6, [pc, #56]	; (80201ec <sbrk_aligned+0x3c>)
 80201b4:	460c      	mov	r4, r1
 80201b6:	6831      	ldr	r1, [r6, #0]
 80201b8:	4605      	mov	r5, r0
 80201ba:	b911      	cbnz	r1, 80201c2 <sbrk_aligned+0x12>
 80201bc:	f000 f8ba 	bl	8020334 <_sbrk_r>
 80201c0:	6030      	str	r0, [r6, #0]
 80201c2:	4621      	mov	r1, r4
 80201c4:	4628      	mov	r0, r5
 80201c6:	f000 f8b5 	bl	8020334 <_sbrk_r>
 80201ca:	1c43      	adds	r3, r0, #1
 80201cc:	d00a      	beq.n	80201e4 <sbrk_aligned+0x34>
 80201ce:	1cc4      	adds	r4, r0, #3
 80201d0:	f024 0403 	bic.w	r4, r4, #3
 80201d4:	42a0      	cmp	r0, r4
 80201d6:	d007      	beq.n	80201e8 <sbrk_aligned+0x38>
 80201d8:	1a21      	subs	r1, r4, r0
 80201da:	4628      	mov	r0, r5
 80201dc:	f000 f8aa 	bl	8020334 <_sbrk_r>
 80201e0:	3001      	adds	r0, #1
 80201e2:	d101      	bne.n	80201e8 <sbrk_aligned+0x38>
 80201e4:	f04f 34ff 	mov.w	r4, #4294967295
 80201e8:	4620      	mov	r0, r4
 80201ea:	bd70      	pop	{r4, r5, r6, pc}
 80201ec:	20019828 	.word	0x20019828

080201f0 <_malloc_r>:
 80201f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80201f4:	1ccd      	adds	r5, r1, #3
 80201f6:	f025 0503 	bic.w	r5, r5, #3
 80201fa:	3508      	adds	r5, #8
 80201fc:	2d0c      	cmp	r5, #12
 80201fe:	bf38      	it	cc
 8020200:	250c      	movcc	r5, #12
 8020202:	2d00      	cmp	r5, #0
 8020204:	4607      	mov	r7, r0
 8020206:	db01      	blt.n	802020c <_malloc_r+0x1c>
 8020208:	42a9      	cmp	r1, r5
 802020a:	d905      	bls.n	8020218 <_malloc_r+0x28>
 802020c:	230c      	movs	r3, #12
 802020e:	603b      	str	r3, [r7, #0]
 8020210:	2600      	movs	r6, #0
 8020212:	4630      	mov	r0, r6
 8020214:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020218:	4e2e      	ldr	r6, [pc, #184]	; (80202d4 <_malloc_r+0xe4>)
 802021a:	f000 f9e7 	bl	80205ec <__malloc_lock>
 802021e:	6833      	ldr	r3, [r6, #0]
 8020220:	461c      	mov	r4, r3
 8020222:	bb34      	cbnz	r4, 8020272 <_malloc_r+0x82>
 8020224:	4629      	mov	r1, r5
 8020226:	4638      	mov	r0, r7
 8020228:	f7ff ffc2 	bl	80201b0 <sbrk_aligned>
 802022c:	1c43      	adds	r3, r0, #1
 802022e:	4604      	mov	r4, r0
 8020230:	d14d      	bne.n	80202ce <_malloc_r+0xde>
 8020232:	6834      	ldr	r4, [r6, #0]
 8020234:	4626      	mov	r6, r4
 8020236:	2e00      	cmp	r6, #0
 8020238:	d140      	bne.n	80202bc <_malloc_r+0xcc>
 802023a:	6823      	ldr	r3, [r4, #0]
 802023c:	4631      	mov	r1, r6
 802023e:	4638      	mov	r0, r7
 8020240:	eb04 0803 	add.w	r8, r4, r3
 8020244:	f000 f876 	bl	8020334 <_sbrk_r>
 8020248:	4580      	cmp	r8, r0
 802024a:	d13a      	bne.n	80202c2 <_malloc_r+0xd2>
 802024c:	6821      	ldr	r1, [r4, #0]
 802024e:	3503      	adds	r5, #3
 8020250:	1a6d      	subs	r5, r5, r1
 8020252:	f025 0503 	bic.w	r5, r5, #3
 8020256:	3508      	adds	r5, #8
 8020258:	2d0c      	cmp	r5, #12
 802025a:	bf38      	it	cc
 802025c:	250c      	movcc	r5, #12
 802025e:	4629      	mov	r1, r5
 8020260:	4638      	mov	r0, r7
 8020262:	f7ff ffa5 	bl	80201b0 <sbrk_aligned>
 8020266:	3001      	adds	r0, #1
 8020268:	d02b      	beq.n	80202c2 <_malloc_r+0xd2>
 802026a:	6823      	ldr	r3, [r4, #0]
 802026c:	442b      	add	r3, r5
 802026e:	6023      	str	r3, [r4, #0]
 8020270:	e00e      	b.n	8020290 <_malloc_r+0xa0>
 8020272:	6822      	ldr	r2, [r4, #0]
 8020274:	1b52      	subs	r2, r2, r5
 8020276:	d41e      	bmi.n	80202b6 <_malloc_r+0xc6>
 8020278:	2a0b      	cmp	r2, #11
 802027a:	d916      	bls.n	80202aa <_malloc_r+0xba>
 802027c:	1961      	adds	r1, r4, r5
 802027e:	42a3      	cmp	r3, r4
 8020280:	6025      	str	r5, [r4, #0]
 8020282:	bf18      	it	ne
 8020284:	6059      	strne	r1, [r3, #4]
 8020286:	6863      	ldr	r3, [r4, #4]
 8020288:	bf08      	it	eq
 802028a:	6031      	streq	r1, [r6, #0]
 802028c:	5162      	str	r2, [r4, r5]
 802028e:	604b      	str	r3, [r1, #4]
 8020290:	4638      	mov	r0, r7
 8020292:	f104 060b 	add.w	r6, r4, #11
 8020296:	f000 f9af 	bl	80205f8 <__malloc_unlock>
 802029a:	f026 0607 	bic.w	r6, r6, #7
 802029e:	1d23      	adds	r3, r4, #4
 80202a0:	1af2      	subs	r2, r6, r3
 80202a2:	d0b6      	beq.n	8020212 <_malloc_r+0x22>
 80202a4:	1b9b      	subs	r3, r3, r6
 80202a6:	50a3      	str	r3, [r4, r2]
 80202a8:	e7b3      	b.n	8020212 <_malloc_r+0x22>
 80202aa:	6862      	ldr	r2, [r4, #4]
 80202ac:	42a3      	cmp	r3, r4
 80202ae:	bf0c      	ite	eq
 80202b0:	6032      	streq	r2, [r6, #0]
 80202b2:	605a      	strne	r2, [r3, #4]
 80202b4:	e7ec      	b.n	8020290 <_malloc_r+0xa0>
 80202b6:	4623      	mov	r3, r4
 80202b8:	6864      	ldr	r4, [r4, #4]
 80202ba:	e7b2      	b.n	8020222 <_malloc_r+0x32>
 80202bc:	4634      	mov	r4, r6
 80202be:	6876      	ldr	r6, [r6, #4]
 80202c0:	e7b9      	b.n	8020236 <_malloc_r+0x46>
 80202c2:	230c      	movs	r3, #12
 80202c4:	603b      	str	r3, [r7, #0]
 80202c6:	4638      	mov	r0, r7
 80202c8:	f000 f996 	bl	80205f8 <__malloc_unlock>
 80202cc:	e7a1      	b.n	8020212 <_malloc_r+0x22>
 80202ce:	6025      	str	r5, [r4, #0]
 80202d0:	e7de      	b.n	8020290 <_malloc_r+0xa0>
 80202d2:	bf00      	nop
 80202d4:	20019824 	.word	0x20019824

080202d8 <iprintf>:
 80202d8:	b40f      	push	{r0, r1, r2, r3}
 80202da:	4b0a      	ldr	r3, [pc, #40]	; (8020304 <iprintf+0x2c>)
 80202dc:	b513      	push	{r0, r1, r4, lr}
 80202de:	681c      	ldr	r4, [r3, #0]
 80202e0:	b124      	cbz	r4, 80202ec <iprintf+0x14>
 80202e2:	69a3      	ldr	r3, [r4, #24]
 80202e4:	b913      	cbnz	r3, 80202ec <iprintf+0x14>
 80202e6:	4620      	mov	r0, r4
 80202e8:	f000 f8e0 	bl	80204ac <__sinit>
 80202ec:	ab05      	add	r3, sp, #20
 80202ee:	9a04      	ldr	r2, [sp, #16]
 80202f0:	68a1      	ldr	r1, [r4, #8]
 80202f2:	9301      	str	r3, [sp, #4]
 80202f4:	4620      	mov	r0, r4
 80202f6:	f000 fb0b 	bl	8020910 <_vfiprintf_r>
 80202fa:	b002      	add	sp, #8
 80202fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8020300:	b004      	add	sp, #16
 8020302:	4770      	bx	lr
 8020304:	200000ac 	.word	0x200000ac

08020308 <putchar>:
 8020308:	4b09      	ldr	r3, [pc, #36]	; (8020330 <putchar+0x28>)
 802030a:	b513      	push	{r0, r1, r4, lr}
 802030c:	681c      	ldr	r4, [r3, #0]
 802030e:	4601      	mov	r1, r0
 8020310:	b134      	cbz	r4, 8020320 <putchar+0x18>
 8020312:	69a3      	ldr	r3, [r4, #24]
 8020314:	b923      	cbnz	r3, 8020320 <putchar+0x18>
 8020316:	9001      	str	r0, [sp, #4]
 8020318:	4620      	mov	r0, r4
 802031a:	f000 f8c7 	bl	80204ac <__sinit>
 802031e:	9901      	ldr	r1, [sp, #4]
 8020320:	68a2      	ldr	r2, [r4, #8]
 8020322:	4620      	mov	r0, r4
 8020324:	b002      	add	sp, #8
 8020326:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802032a:	f000 bdb5 	b.w	8020e98 <_putc_r>
 802032e:	bf00      	nop
 8020330:	200000ac 	.word	0x200000ac

08020334 <_sbrk_r>:
 8020334:	b538      	push	{r3, r4, r5, lr}
 8020336:	4d06      	ldr	r5, [pc, #24]	; (8020350 <_sbrk_r+0x1c>)
 8020338:	2300      	movs	r3, #0
 802033a:	4604      	mov	r4, r0
 802033c:	4608      	mov	r0, r1
 802033e:	602b      	str	r3, [r5, #0]
 8020340:	f7fe f810 	bl	801e364 <_sbrk>
 8020344:	1c43      	adds	r3, r0, #1
 8020346:	d102      	bne.n	802034e <_sbrk_r+0x1a>
 8020348:	682b      	ldr	r3, [r5, #0]
 802034a:	b103      	cbz	r3, 802034e <_sbrk_r+0x1a>
 802034c:	6023      	str	r3, [r4, #0]
 802034e:	bd38      	pop	{r3, r4, r5, pc}
 8020350:	20019830 	.word	0x20019830

08020354 <siprintf>:
 8020354:	b40e      	push	{r1, r2, r3}
 8020356:	b500      	push	{lr}
 8020358:	b09c      	sub	sp, #112	; 0x70
 802035a:	ab1d      	add	r3, sp, #116	; 0x74
 802035c:	9002      	str	r0, [sp, #8]
 802035e:	9006      	str	r0, [sp, #24]
 8020360:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8020364:	4809      	ldr	r0, [pc, #36]	; (802038c <siprintf+0x38>)
 8020366:	9107      	str	r1, [sp, #28]
 8020368:	9104      	str	r1, [sp, #16]
 802036a:	4909      	ldr	r1, [pc, #36]	; (8020390 <siprintf+0x3c>)
 802036c:	f853 2b04 	ldr.w	r2, [r3], #4
 8020370:	9105      	str	r1, [sp, #20]
 8020372:	6800      	ldr	r0, [r0, #0]
 8020374:	9301      	str	r3, [sp, #4]
 8020376:	a902      	add	r1, sp, #8
 8020378:	f000 f9a0 	bl	80206bc <_svfiprintf_r>
 802037c:	9b02      	ldr	r3, [sp, #8]
 802037e:	2200      	movs	r2, #0
 8020380:	701a      	strb	r2, [r3, #0]
 8020382:	b01c      	add	sp, #112	; 0x70
 8020384:	f85d eb04 	ldr.w	lr, [sp], #4
 8020388:	b003      	add	sp, #12
 802038a:	4770      	bx	lr
 802038c:	200000ac 	.word	0x200000ac
 8020390:	ffff0208 	.word	0xffff0208

08020394 <strcat>:
 8020394:	b510      	push	{r4, lr}
 8020396:	4602      	mov	r2, r0
 8020398:	7814      	ldrb	r4, [r2, #0]
 802039a:	4613      	mov	r3, r2
 802039c:	3201      	adds	r2, #1
 802039e:	2c00      	cmp	r4, #0
 80203a0:	d1fa      	bne.n	8020398 <strcat+0x4>
 80203a2:	3b01      	subs	r3, #1
 80203a4:	f811 2b01 	ldrb.w	r2, [r1], #1
 80203a8:	f803 2f01 	strb.w	r2, [r3, #1]!
 80203ac:	2a00      	cmp	r2, #0
 80203ae:	d1f9      	bne.n	80203a4 <strcat+0x10>
 80203b0:	bd10      	pop	{r4, pc}

080203b2 <strcpy>:
 80203b2:	4603      	mov	r3, r0
 80203b4:	f811 2b01 	ldrb.w	r2, [r1], #1
 80203b8:	f803 2b01 	strb.w	r2, [r3], #1
 80203bc:	2a00      	cmp	r2, #0
 80203be:	d1f9      	bne.n	80203b4 <strcpy+0x2>
 80203c0:	4770      	bx	lr

080203c2 <wcscat>:
 80203c2:	b510      	push	{r4, lr}
 80203c4:	4602      	mov	r2, r0
 80203c6:	4613      	mov	r3, r2
 80203c8:	f852 4b04 	ldr.w	r4, [r2], #4
 80203cc:	2c00      	cmp	r4, #0
 80203ce:	d1fa      	bne.n	80203c6 <wcscat+0x4>
 80203d0:	3904      	subs	r1, #4
 80203d2:	f851 2f04 	ldr.w	r2, [r1, #4]!
 80203d6:	b90a      	cbnz	r2, 80203dc <wcscat+0x1a>
 80203d8:	601a      	str	r2, [r3, #0]
 80203da:	bd10      	pop	{r4, pc}
 80203dc:	f843 2b04 	str.w	r2, [r3], #4
 80203e0:	e7f7      	b.n	80203d2 <wcscat+0x10>

080203e2 <wcscpy>:
 80203e2:	2300      	movs	r3, #0
 80203e4:	6003      	str	r3, [r0, #0]
 80203e6:	3904      	subs	r1, #4
 80203e8:	4603      	mov	r3, r0
 80203ea:	f851 2f04 	ldr.w	r2, [r1, #4]!
 80203ee:	b90a      	cbnz	r2, 80203f4 <wcscpy+0x12>
 80203f0:	601a      	str	r2, [r3, #0]
 80203f2:	4770      	bx	lr
 80203f4:	f843 2b04 	str.w	r2, [r3], #4
 80203f8:	e7f7      	b.n	80203ea <wcscpy+0x8>
	...

080203fc <std>:
 80203fc:	2300      	movs	r3, #0
 80203fe:	b510      	push	{r4, lr}
 8020400:	4604      	mov	r4, r0
 8020402:	e9c0 3300 	strd	r3, r3, [r0]
 8020406:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802040a:	6083      	str	r3, [r0, #8]
 802040c:	8181      	strh	r1, [r0, #12]
 802040e:	6643      	str	r3, [r0, #100]	; 0x64
 8020410:	81c2      	strh	r2, [r0, #14]
 8020412:	6183      	str	r3, [r0, #24]
 8020414:	4619      	mov	r1, r3
 8020416:	2208      	movs	r2, #8
 8020418:	305c      	adds	r0, #92	; 0x5c
 802041a:	f7ff fe5f 	bl	80200dc <memset>
 802041e:	4b05      	ldr	r3, [pc, #20]	; (8020434 <std+0x38>)
 8020420:	6263      	str	r3, [r4, #36]	; 0x24
 8020422:	4b05      	ldr	r3, [pc, #20]	; (8020438 <std+0x3c>)
 8020424:	62a3      	str	r3, [r4, #40]	; 0x28
 8020426:	4b05      	ldr	r3, [pc, #20]	; (802043c <std+0x40>)
 8020428:	62e3      	str	r3, [r4, #44]	; 0x2c
 802042a:	4b05      	ldr	r3, [pc, #20]	; (8020440 <std+0x44>)
 802042c:	6224      	str	r4, [r4, #32]
 802042e:	6323      	str	r3, [r4, #48]	; 0x30
 8020430:	bd10      	pop	{r4, pc}
 8020432:	bf00      	nop
 8020434:	08020f29 	.word	0x08020f29
 8020438:	08020f4b 	.word	0x08020f4b
 802043c:	08020f83 	.word	0x08020f83
 8020440:	08020fa7 	.word	0x08020fa7

08020444 <_cleanup_r>:
 8020444:	4901      	ldr	r1, [pc, #4]	; (802044c <_cleanup_r+0x8>)
 8020446:	f000 b8af 	b.w	80205a8 <_fwalk_reent>
 802044a:	bf00      	nop
 802044c:	08021281 	.word	0x08021281

08020450 <__sfmoreglue>:
 8020450:	b570      	push	{r4, r5, r6, lr}
 8020452:	2268      	movs	r2, #104	; 0x68
 8020454:	1e4d      	subs	r5, r1, #1
 8020456:	4355      	muls	r5, r2
 8020458:	460e      	mov	r6, r1
 802045a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802045e:	f7ff fec7 	bl	80201f0 <_malloc_r>
 8020462:	4604      	mov	r4, r0
 8020464:	b140      	cbz	r0, 8020478 <__sfmoreglue+0x28>
 8020466:	2100      	movs	r1, #0
 8020468:	e9c0 1600 	strd	r1, r6, [r0]
 802046c:	300c      	adds	r0, #12
 802046e:	60a0      	str	r0, [r4, #8]
 8020470:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8020474:	f7ff fe32 	bl	80200dc <memset>
 8020478:	4620      	mov	r0, r4
 802047a:	bd70      	pop	{r4, r5, r6, pc}

0802047c <__sfp_lock_acquire>:
 802047c:	4801      	ldr	r0, [pc, #4]	; (8020484 <__sfp_lock_acquire+0x8>)
 802047e:	f000 b8b3 	b.w	80205e8 <__retarget_lock_acquire_recursive>
 8020482:	bf00      	nop
 8020484:	2001982d 	.word	0x2001982d

08020488 <__sfp_lock_release>:
 8020488:	4801      	ldr	r0, [pc, #4]	; (8020490 <__sfp_lock_release+0x8>)
 802048a:	f000 b8ae 	b.w	80205ea <__retarget_lock_release_recursive>
 802048e:	bf00      	nop
 8020490:	2001982d 	.word	0x2001982d

08020494 <__sinit_lock_acquire>:
 8020494:	4801      	ldr	r0, [pc, #4]	; (802049c <__sinit_lock_acquire+0x8>)
 8020496:	f000 b8a7 	b.w	80205e8 <__retarget_lock_acquire_recursive>
 802049a:	bf00      	nop
 802049c:	2001982e 	.word	0x2001982e

080204a0 <__sinit_lock_release>:
 80204a0:	4801      	ldr	r0, [pc, #4]	; (80204a8 <__sinit_lock_release+0x8>)
 80204a2:	f000 b8a2 	b.w	80205ea <__retarget_lock_release_recursive>
 80204a6:	bf00      	nop
 80204a8:	2001982e 	.word	0x2001982e

080204ac <__sinit>:
 80204ac:	b510      	push	{r4, lr}
 80204ae:	4604      	mov	r4, r0
 80204b0:	f7ff fff0 	bl	8020494 <__sinit_lock_acquire>
 80204b4:	69a3      	ldr	r3, [r4, #24]
 80204b6:	b11b      	cbz	r3, 80204c0 <__sinit+0x14>
 80204b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80204bc:	f7ff bff0 	b.w	80204a0 <__sinit_lock_release>
 80204c0:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 80204c4:	6523      	str	r3, [r4, #80]	; 0x50
 80204c6:	4b13      	ldr	r3, [pc, #76]	; (8020514 <__sinit+0x68>)
 80204c8:	4a13      	ldr	r2, [pc, #76]	; (8020518 <__sinit+0x6c>)
 80204ca:	681b      	ldr	r3, [r3, #0]
 80204cc:	62a2      	str	r2, [r4, #40]	; 0x28
 80204ce:	42a3      	cmp	r3, r4
 80204d0:	bf04      	itt	eq
 80204d2:	2301      	moveq	r3, #1
 80204d4:	61a3      	streq	r3, [r4, #24]
 80204d6:	4620      	mov	r0, r4
 80204d8:	f000 f820 	bl	802051c <__sfp>
 80204dc:	6060      	str	r0, [r4, #4]
 80204de:	4620      	mov	r0, r4
 80204e0:	f000 f81c 	bl	802051c <__sfp>
 80204e4:	60a0      	str	r0, [r4, #8]
 80204e6:	4620      	mov	r0, r4
 80204e8:	f000 f818 	bl	802051c <__sfp>
 80204ec:	2200      	movs	r2, #0
 80204ee:	60e0      	str	r0, [r4, #12]
 80204f0:	2104      	movs	r1, #4
 80204f2:	6860      	ldr	r0, [r4, #4]
 80204f4:	f7ff ff82 	bl	80203fc <std>
 80204f8:	68a0      	ldr	r0, [r4, #8]
 80204fa:	2201      	movs	r2, #1
 80204fc:	2109      	movs	r1, #9
 80204fe:	f7ff ff7d 	bl	80203fc <std>
 8020502:	68e0      	ldr	r0, [r4, #12]
 8020504:	2202      	movs	r2, #2
 8020506:	2112      	movs	r1, #18
 8020508:	f7ff ff78 	bl	80203fc <std>
 802050c:	2301      	movs	r3, #1
 802050e:	61a3      	str	r3, [r4, #24]
 8020510:	e7d2      	b.n	80204b8 <__sinit+0xc>
 8020512:	bf00      	nop
 8020514:	08026fb0 	.word	0x08026fb0
 8020518:	08020445 	.word	0x08020445

0802051c <__sfp>:
 802051c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802051e:	4607      	mov	r7, r0
 8020520:	f7ff ffac 	bl	802047c <__sfp_lock_acquire>
 8020524:	4b1e      	ldr	r3, [pc, #120]	; (80205a0 <__sfp+0x84>)
 8020526:	681e      	ldr	r6, [r3, #0]
 8020528:	69b3      	ldr	r3, [r6, #24]
 802052a:	b913      	cbnz	r3, 8020532 <__sfp+0x16>
 802052c:	4630      	mov	r0, r6
 802052e:	f7ff ffbd 	bl	80204ac <__sinit>
 8020532:	3648      	adds	r6, #72	; 0x48
 8020534:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8020538:	3b01      	subs	r3, #1
 802053a:	d503      	bpl.n	8020544 <__sfp+0x28>
 802053c:	6833      	ldr	r3, [r6, #0]
 802053e:	b30b      	cbz	r3, 8020584 <__sfp+0x68>
 8020540:	6836      	ldr	r6, [r6, #0]
 8020542:	e7f7      	b.n	8020534 <__sfp+0x18>
 8020544:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8020548:	b9d5      	cbnz	r5, 8020580 <__sfp+0x64>
 802054a:	4b16      	ldr	r3, [pc, #88]	; (80205a4 <__sfp+0x88>)
 802054c:	60e3      	str	r3, [r4, #12]
 802054e:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8020552:	6665      	str	r5, [r4, #100]	; 0x64
 8020554:	f000 f847 	bl	80205e6 <__retarget_lock_init_recursive>
 8020558:	f7ff ff96 	bl	8020488 <__sfp_lock_release>
 802055c:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8020560:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8020564:	6025      	str	r5, [r4, #0]
 8020566:	61a5      	str	r5, [r4, #24]
 8020568:	2208      	movs	r2, #8
 802056a:	4629      	mov	r1, r5
 802056c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8020570:	f7ff fdb4 	bl	80200dc <memset>
 8020574:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8020578:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 802057c:	4620      	mov	r0, r4
 802057e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020580:	3468      	adds	r4, #104	; 0x68
 8020582:	e7d9      	b.n	8020538 <__sfp+0x1c>
 8020584:	2104      	movs	r1, #4
 8020586:	4638      	mov	r0, r7
 8020588:	f7ff ff62 	bl	8020450 <__sfmoreglue>
 802058c:	4604      	mov	r4, r0
 802058e:	6030      	str	r0, [r6, #0]
 8020590:	2800      	cmp	r0, #0
 8020592:	d1d5      	bne.n	8020540 <__sfp+0x24>
 8020594:	f7ff ff78 	bl	8020488 <__sfp_lock_release>
 8020598:	230c      	movs	r3, #12
 802059a:	603b      	str	r3, [r7, #0]
 802059c:	e7ee      	b.n	802057c <__sfp+0x60>
 802059e:	bf00      	nop
 80205a0:	08026fb0 	.word	0x08026fb0
 80205a4:	ffff0001 	.word	0xffff0001

080205a8 <_fwalk_reent>:
 80205a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80205ac:	4606      	mov	r6, r0
 80205ae:	4688      	mov	r8, r1
 80205b0:	f100 0448 	add.w	r4, r0, #72	; 0x48
 80205b4:	2700      	movs	r7, #0
 80205b6:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80205ba:	f1b9 0901 	subs.w	r9, r9, #1
 80205be:	d505      	bpl.n	80205cc <_fwalk_reent+0x24>
 80205c0:	6824      	ldr	r4, [r4, #0]
 80205c2:	2c00      	cmp	r4, #0
 80205c4:	d1f7      	bne.n	80205b6 <_fwalk_reent+0xe>
 80205c6:	4638      	mov	r0, r7
 80205c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80205cc:	89ab      	ldrh	r3, [r5, #12]
 80205ce:	2b01      	cmp	r3, #1
 80205d0:	d907      	bls.n	80205e2 <_fwalk_reent+0x3a>
 80205d2:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80205d6:	3301      	adds	r3, #1
 80205d8:	d003      	beq.n	80205e2 <_fwalk_reent+0x3a>
 80205da:	4629      	mov	r1, r5
 80205dc:	4630      	mov	r0, r6
 80205de:	47c0      	blx	r8
 80205e0:	4307      	orrs	r7, r0
 80205e2:	3568      	adds	r5, #104	; 0x68
 80205e4:	e7e9      	b.n	80205ba <_fwalk_reent+0x12>

080205e6 <__retarget_lock_init_recursive>:
 80205e6:	4770      	bx	lr

080205e8 <__retarget_lock_acquire_recursive>:
 80205e8:	4770      	bx	lr

080205ea <__retarget_lock_release_recursive>:
 80205ea:	4770      	bx	lr

080205ec <__malloc_lock>:
 80205ec:	4801      	ldr	r0, [pc, #4]	; (80205f4 <__malloc_lock+0x8>)
 80205ee:	f7ff bffb 	b.w	80205e8 <__retarget_lock_acquire_recursive>
 80205f2:	bf00      	nop
 80205f4:	2001982c 	.word	0x2001982c

080205f8 <__malloc_unlock>:
 80205f8:	4801      	ldr	r0, [pc, #4]	; (8020600 <__malloc_unlock+0x8>)
 80205fa:	f7ff bff6 	b.w	80205ea <__retarget_lock_release_recursive>
 80205fe:	bf00      	nop
 8020600:	2001982c 	.word	0x2001982c

08020604 <__ssputs_r>:
 8020604:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020608:	688e      	ldr	r6, [r1, #8]
 802060a:	429e      	cmp	r6, r3
 802060c:	4682      	mov	sl, r0
 802060e:	460c      	mov	r4, r1
 8020610:	4690      	mov	r8, r2
 8020612:	461f      	mov	r7, r3
 8020614:	d838      	bhi.n	8020688 <__ssputs_r+0x84>
 8020616:	898a      	ldrh	r2, [r1, #12]
 8020618:	f412 6f90 	tst.w	r2, #1152	; 0x480
 802061c:	d032      	beq.n	8020684 <__ssputs_r+0x80>
 802061e:	6825      	ldr	r5, [r4, #0]
 8020620:	6909      	ldr	r1, [r1, #16]
 8020622:	eba5 0901 	sub.w	r9, r5, r1
 8020626:	6965      	ldr	r5, [r4, #20]
 8020628:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802062c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8020630:	3301      	adds	r3, #1
 8020632:	444b      	add	r3, r9
 8020634:	106d      	asrs	r5, r5, #1
 8020636:	429d      	cmp	r5, r3
 8020638:	bf38      	it	cc
 802063a:	461d      	movcc	r5, r3
 802063c:	0553      	lsls	r3, r2, #21
 802063e:	d531      	bpl.n	80206a4 <__ssputs_r+0xa0>
 8020640:	4629      	mov	r1, r5
 8020642:	f7ff fdd5 	bl	80201f0 <_malloc_r>
 8020646:	4606      	mov	r6, r0
 8020648:	b950      	cbnz	r0, 8020660 <__ssputs_r+0x5c>
 802064a:	230c      	movs	r3, #12
 802064c:	f8ca 3000 	str.w	r3, [sl]
 8020650:	89a3      	ldrh	r3, [r4, #12]
 8020652:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020656:	81a3      	strh	r3, [r4, #12]
 8020658:	f04f 30ff 	mov.w	r0, #4294967295
 802065c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020660:	6921      	ldr	r1, [r4, #16]
 8020662:	464a      	mov	r2, r9
 8020664:	f7ff fd12 	bl	802008c <memcpy>
 8020668:	89a3      	ldrh	r3, [r4, #12]
 802066a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 802066e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8020672:	81a3      	strh	r3, [r4, #12]
 8020674:	6126      	str	r6, [r4, #16]
 8020676:	6165      	str	r5, [r4, #20]
 8020678:	444e      	add	r6, r9
 802067a:	eba5 0509 	sub.w	r5, r5, r9
 802067e:	6026      	str	r6, [r4, #0]
 8020680:	60a5      	str	r5, [r4, #8]
 8020682:	463e      	mov	r6, r7
 8020684:	42be      	cmp	r6, r7
 8020686:	d900      	bls.n	802068a <__ssputs_r+0x86>
 8020688:	463e      	mov	r6, r7
 802068a:	6820      	ldr	r0, [r4, #0]
 802068c:	4632      	mov	r2, r6
 802068e:	4641      	mov	r1, r8
 8020690:	f7ff fd0a 	bl	80200a8 <memmove>
 8020694:	68a3      	ldr	r3, [r4, #8]
 8020696:	1b9b      	subs	r3, r3, r6
 8020698:	60a3      	str	r3, [r4, #8]
 802069a:	6823      	ldr	r3, [r4, #0]
 802069c:	4433      	add	r3, r6
 802069e:	6023      	str	r3, [r4, #0]
 80206a0:	2000      	movs	r0, #0
 80206a2:	e7db      	b.n	802065c <__ssputs_r+0x58>
 80206a4:	462a      	mov	r2, r5
 80206a6:	f000 fe9f 	bl	80213e8 <_realloc_r>
 80206aa:	4606      	mov	r6, r0
 80206ac:	2800      	cmp	r0, #0
 80206ae:	d1e1      	bne.n	8020674 <__ssputs_r+0x70>
 80206b0:	6921      	ldr	r1, [r4, #16]
 80206b2:	4650      	mov	r0, sl
 80206b4:	f7ff fd30 	bl	8020118 <_free_r>
 80206b8:	e7c7      	b.n	802064a <__ssputs_r+0x46>
	...

080206bc <_svfiprintf_r>:
 80206bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80206c0:	4698      	mov	r8, r3
 80206c2:	898b      	ldrh	r3, [r1, #12]
 80206c4:	061b      	lsls	r3, r3, #24
 80206c6:	b09d      	sub	sp, #116	; 0x74
 80206c8:	4607      	mov	r7, r0
 80206ca:	460d      	mov	r5, r1
 80206cc:	4614      	mov	r4, r2
 80206ce:	d50e      	bpl.n	80206ee <_svfiprintf_r+0x32>
 80206d0:	690b      	ldr	r3, [r1, #16]
 80206d2:	b963      	cbnz	r3, 80206ee <_svfiprintf_r+0x32>
 80206d4:	2140      	movs	r1, #64	; 0x40
 80206d6:	f7ff fd8b 	bl	80201f0 <_malloc_r>
 80206da:	6028      	str	r0, [r5, #0]
 80206dc:	6128      	str	r0, [r5, #16]
 80206de:	b920      	cbnz	r0, 80206ea <_svfiprintf_r+0x2e>
 80206e0:	230c      	movs	r3, #12
 80206e2:	603b      	str	r3, [r7, #0]
 80206e4:	f04f 30ff 	mov.w	r0, #4294967295
 80206e8:	e0d1      	b.n	802088e <_svfiprintf_r+0x1d2>
 80206ea:	2340      	movs	r3, #64	; 0x40
 80206ec:	616b      	str	r3, [r5, #20]
 80206ee:	2300      	movs	r3, #0
 80206f0:	9309      	str	r3, [sp, #36]	; 0x24
 80206f2:	2320      	movs	r3, #32
 80206f4:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80206f8:	f8cd 800c 	str.w	r8, [sp, #12]
 80206fc:	2330      	movs	r3, #48	; 0x30
 80206fe:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 80208a8 <_svfiprintf_r+0x1ec>
 8020702:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8020706:	f04f 0901 	mov.w	r9, #1
 802070a:	4623      	mov	r3, r4
 802070c:	469a      	mov	sl, r3
 802070e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8020712:	b10a      	cbz	r2, 8020718 <_svfiprintf_r+0x5c>
 8020714:	2a25      	cmp	r2, #37	; 0x25
 8020716:	d1f9      	bne.n	802070c <_svfiprintf_r+0x50>
 8020718:	ebba 0b04 	subs.w	fp, sl, r4
 802071c:	d00b      	beq.n	8020736 <_svfiprintf_r+0x7a>
 802071e:	465b      	mov	r3, fp
 8020720:	4622      	mov	r2, r4
 8020722:	4629      	mov	r1, r5
 8020724:	4638      	mov	r0, r7
 8020726:	f7ff ff6d 	bl	8020604 <__ssputs_r>
 802072a:	3001      	adds	r0, #1
 802072c:	f000 80aa 	beq.w	8020884 <_svfiprintf_r+0x1c8>
 8020730:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8020732:	445a      	add	r2, fp
 8020734:	9209      	str	r2, [sp, #36]	; 0x24
 8020736:	f89a 3000 	ldrb.w	r3, [sl]
 802073a:	2b00      	cmp	r3, #0
 802073c:	f000 80a2 	beq.w	8020884 <_svfiprintf_r+0x1c8>
 8020740:	2300      	movs	r3, #0
 8020742:	f04f 32ff 	mov.w	r2, #4294967295
 8020746:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802074a:	f10a 0a01 	add.w	sl, sl, #1
 802074e:	9304      	str	r3, [sp, #16]
 8020750:	9307      	str	r3, [sp, #28]
 8020752:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8020756:	931a      	str	r3, [sp, #104]	; 0x68
 8020758:	4654      	mov	r4, sl
 802075a:	2205      	movs	r2, #5
 802075c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020760:	4851      	ldr	r0, [pc, #324]	; (80208a8 <_svfiprintf_r+0x1ec>)
 8020762:	f7df fd65 	bl	8000230 <memchr>
 8020766:	9a04      	ldr	r2, [sp, #16]
 8020768:	b9d8      	cbnz	r0, 80207a2 <_svfiprintf_r+0xe6>
 802076a:	06d0      	lsls	r0, r2, #27
 802076c:	bf44      	itt	mi
 802076e:	2320      	movmi	r3, #32
 8020770:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8020774:	0711      	lsls	r1, r2, #28
 8020776:	bf44      	itt	mi
 8020778:	232b      	movmi	r3, #43	; 0x2b
 802077a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 802077e:	f89a 3000 	ldrb.w	r3, [sl]
 8020782:	2b2a      	cmp	r3, #42	; 0x2a
 8020784:	d015      	beq.n	80207b2 <_svfiprintf_r+0xf6>
 8020786:	9a07      	ldr	r2, [sp, #28]
 8020788:	4654      	mov	r4, sl
 802078a:	2000      	movs	r0, #0
 802078c:	f04f 0c0a 	mov.w	ip, #10
 8020790:	4621      	mov	r1, r4
 8020792:	f811 3b01 	ldrb.w	r3, [r1], #1
 8020796:	3b30      	subs	r3, #48	; 0x30
 8020798:	2b09      	cmp	r3, #9
 802079a:	d94e      	bls.n	802083a <_svfiprintf_r+0x17e>
 802079c:	b1b0      	cbz	r0, 80207cc <_svfiprintf_r+0x110>
 802079e:	9207      	str	r2, [sp, #28]
 80207a0:	e014      	b.n	80207cc <_svfiprintf_r+0x110>
 80207a2:	eba0 0308 	sub.w	r3, r0, r8
 80207a6:	fa09 f303 	lsl.w	r3, r9, r3
 80207aa:	4313      	orrs	r3, r2
 80207ac:	9304      	str	r3, [sp, #16]
 80207ae:	46a2      	mov	sl, r4
 80207b0:	e7d2      	b.n	8020758 <_svfiprintf_r+0x9c>
 80207b2:	9b03      	ldr	r3, [sp, #12]
 80207b4:	1d19      	adds	r1, r3, #4
 80207b6:	681b      	ldr	r3, [r3, #0]
 80207b8:	9103      	str	r1, [sp, #12]
 80207ba:	2b00      	cmp	r3, #0
 80207bc:	bfbb      	ittet	lt
 80207be:	425b      	neglt	r3, r3
 80207c0:	f042 0202 	orrlt.w	r2, r2, #2
 80207c4:	9307      	strge	r3, [sp, #28]
 80207c6:	9307      	strlt	r3, [sp, #28]
 80207c8:	bfb8      	it	lt
 80207ca:	9204      	strlt	r2, [sp, #16]
 80207cc:	7823      	ldrb	r3, [r4, #0]
 80207ce:	2b2e      	cmp	r3, #46	; 0x2e
 80207d0:	d10c      	bne.n	80207ec <_svfiprintf_r+0x130>
 80207d2:	7863      	ldrb	r3, [r4, #1]
 80207d4:	2b2a      	cmp	r3, #42	; 0x2a
 80207d6:	d135      	bne.n	8020844 <_svfiprintf_r+0x188>
 80207d8:	9b03      	ldr	r3, [sp, #12]
 80207da:	1d1a      	adds	r2, r3, #4
 80207dc:	681b      	ldr	r3, [r3, #0]
 80207de:	9203      	str	r2, [sp, #12]
 80207e0:	2b00      	cmp	r3, #0
 80207e2:	bfb8      	it	lt
 80207e4:	f04f 33ff 	movlt.w	r3, #4294967295
 80207e8:	3402      	adds	r4, #2
 80207ea:	9305      	str	r3, [sp, #20]
 80207ec:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 80208b8 <_svfiprintf_r+0x1fc>
 80207f0:	7821      	ldrb	r1, [r4, #0]
 80207f2:	2203      	movs	r2, #3
 80207f4:	4650      	mov	r0, sl
 80207f6:	f7df fd1b 	bl	8000230 <memchr>
 80207fa:	b140      	cbz	r0, 802080e <_svfiprintf_r+0x152>
 80207fc:	2340      	movs	r3, #64	; 0x40
 80207fe:	eba0 000a 	sub.w	r0, r0, sl
 8020802:	fa03 f000 	lsl.w	r0, r3, r0
 8020806:	9b04      	ldr	r3, [sp, #16]
 8020808:	4303      	orrs	r3, r0
 802080a:	3401      	adds	r4, #1
 802080c:	9304      	str	r3, [sp, #16]
 802080e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020812:	4826      	ldr	r0, [pc, #152]	; (80208ac <_svfiprintf_r+0x1f0>)
 8020814:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8020818:	2206      	movs	r2, #6
 802081a:	f7df fd09 	bl	8000230 <memchr>
 802081e:	2800      	cmp	r0, #0
 8020820:	d038      	beq.n	8020894 <_svfiprintf_r+0x1d8>
 8020822:	4b23      	ldr	r3, [pc, #140]	; (80208b0 <_svfiprintf_r+0x1f4>)
 8020824:	bb1b      	cbnz	r3, 802086e <_svfiprintf_r+0x1b2>
 8020826:	9b03      	ldr	r3, [sp, #12]
 8020828:	3307      	adds	r3, #7
 802082a:	f023 0307 	bic.w	r3, r3, #7
 802082e:	3308      	adds	r3, #8
 8020830:	9303      	str	r3, [sp, #12]
 8020832:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020834:	4433      	add	r3, r6
 8020836:	9309      	str	r3, [sp, #36]	; 0x24
 8020838:	e767      	b.n	802070a <_svfiprintf_r+0x4e>
 802083a:	fb0c 3202 	mla	r2, ip, r2, r3
 802083e:	460c      	mov	r4, r1
 8020840:	2001      	movs	r0, #1
 8020842:	e7a5      	b.n	8020790 <_svfiprintf_r+0xd4>
 8020844:	2300      	movs	r3, #0
 8020846:	3401      	adds	r4, #1
 8020848:	9305      	str	r3, [sp, #20]
 802084a:	4619      	mov	r1, r3
 802084c:	f04f 0c0a 	mov.w	ip, #10
 8020850:	4620      	mov	r0, r4
 8020852:	f810 2b01 	ldrb.w	r2, [r0], #1
 8020856:	3a30      	subs	r2, #48	; 0x30
 8020858:	2a09      	cmp	r2, #9
 802085a:	d903      	bls.n	8020864 <_svfiprintf_r+0x1a8>
 802085c:	2b00      	cmp	r3, #0
 802085e:	d0c5      	beq.n	80207ec <_svfiprintf_r+0x130>
 8020860:	9105      	str	r1, [sp, #20]
 8020862:	e7c3      	b.n	80207ec <_svfiprintf_r+0x130>
 8020864:	fb0c 2101 	mla	r1, ip, r1, r2
 8020868:	4604      	mov	r4, r0
 802086a:	2301      	movs	r3, #1
 802086c:	e7f0      	b.n	8020850 <_svfiprintf_r+0x194>
 802086e:	ab03      	add	r3, sp, #12
 8020870:	9300      	str	r3, [sp, #0]
 8020872:	462a      	mov	r2, r5
 8020874:	4b0f      	ldr	r3, [pc, #60]	; (80208b4 <_svfiprintf_r+0x1f8>)
 8020876:	a904      	add	r1, sp, #16
 8020878:	4638      	mov	r0, r7
 802087a:	f3af 8000 	nop.w
 802087e:	1c42      	adds	r2, r0, #1
 8020880:	4606      	mov	r6, r0
 8020882:	d1d6      	bne.n	8020832 <_svfiprintf_r+0x176>
 8020884:	89ab      	ldrh	r3, [r5, #12]
 8020886:	065b      	lsls	r3, r3, #25
 8020888:	f53f af2c 	bmi.w	80206e4 <_svfiprintf_r+0x28>
 802088c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802088e:	b01d      	add	sp, #116	; 0x74
 8020890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020894:	ab03      	add	r3, sp, #12
 8020896:	9300      	str	r3, [sp, #0]
 8020898:	462a      	mov	r2, r5
 802089a:	4b06      	ldr	r3, [pc, #24]	; (80208b4 <_svfiprintf_r+0x1f8>)
 802089c:	a904      	add	r1, sp, #16
 802089e:	4638      	mov	r0, r7
 80208a0:	f000 f9d4 	bl	8020c4c <_printf_i>
 80208a4:	e7eb      	b.n	802087e <_svfiprintf_r+0x1c2>
 80208a6:	bf00      	nop
 80208a8:	08027014 	.word	0x08027014
 80208ac:	0802701e 	.word	0x0802701e
 80208b0:	00000000 	.word	0x00000000
 80208b4:	08020605 	.word	0x08020605
 80208b8:	0802701a 	.word	0x0802701a

080208bc <__sfputc_r>:
 80208bc:	6893      	ldr	r3, [r2, #8]
 80208be:	3b01      	subs	r3, #1
 80208c0:	2b00      	cmp	r3, #0
 80208c2:	b410      	push	{r4}
 80208c4:	6093      	str	r3, [r2, #8]
 80208c6:	da08      	bge.n	80208da <__sfputc_r+0x1e>
 80208c8:	6994      	ldr	r4, [r2, #24]
 80208ca:	42a3      	cmp	r3, r4
 80208cc:	db01      	blt.n	80208d2 <__sfputc_r+0x16>
 80208ce:	290a      	cmp	r1, #10
 80208d0:	d103      	bne.n	80208da <__sfputc_r+0x1e>
 80208d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80208d6:	f000 bb6b 	b.w	8020fb0 <__swbuf_r>
 80208da:	6813      	ldr	r3, [r2, #0]
 80208dc:	1c58      	adds	r0, r3, #1
 80208de:	6010      	str	r0, [r2, #0]
 80208e0:	7019      	strb	r1, [r3, #0]
 80208e2:	4608      	mov	r0, r1
 80208e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80208e8:	4770      	bx	lr

080208ea <__sfputs_r>:
 80208ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80208ec:	4606      	mov	r6, r0
 80208ee:	460f      	mov	r7, r1
 80208f0:	4614      	mov	r4, r2
 80208f2:	18d5      	adds	r5, r2, r3
 80208f4:	42ac      	cmp	r4, r5
 80208f6:	d101      	bne.n	80208fc <__sfputs_r+0x12>
 80208f8:	2000      	movs	r0, #0
 80208fa:	e007      	b.n	802090c <__sfputs_r+0x22>
 80208fc:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020900:	463a      	mov	r2, r7
 8020902:	4630      	mov	r0, r6
 8020904:	f7ff ffda 	bl	80208bc <__sfputc_r>
 8020908:	1c43      	adds	r3, r0, #1
 802090a:	d1f3      	bne.n	80208f4 <__sfputs_r+0xa>
 802090c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08020910 <_vfiprintf_r>:
 8020910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020914:	460d      	mov	r5, r1
 8020916:	b09d      	sub	sp, #116	; 0x74
 8020918:	4614      	mov	r4, r2
 802091a:	4698      	mov	r8, r3
 802091c:	4606      	mov	r6, r0
 802091e:	b118      	cbz	r0, 8020928 <_vfiprintf_r+0x18>
 8020920:	6983      	ldr	r3, [r0, #24]
 8020922:	b90b      	cbnz	r3, 8020928 <_vfiprintf_r+0x18>
 8020924:	f7ff fdc2 	bl	80204ac <__sinit>
 8020928:	4b89      	ldr	r3, [pc, #548]	; (8020b50 <_vfiprintf_r+0x240>)
 802092a:	429d      	cmp	r5, r3
 802092c:	d11b      	bne.n	8020966 <_vfiprintf_r+0x56>
 802092e:	6875      	ldr	r5, [r6, #4]
 8020930:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8020932:	07d9      	lsls	r1, r3, #31
 8020934:	d405      	bmi.n	8020942 <_vfiprintf_r+0x32>
 8020936:	89ab      	ldrh	r3, [r5, #12]
 8020938:	059a      	lsls	r2, r3, #22
 802093a:	d402      	bmi.n	8020942 <_vfiprintf_r+0x32>
 802093c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 802093e:	f7ff fe53 	bl	80205e8 <__retarget_lock_acquire_recursive>
 8020942:	89ab      	ldrh	r3, [r5, #12]
 8020944:	071b      	lsls	r3, r3, #28
 8020946:	d501      	bpl.n	802094c <_vfiprintf_r+0x3c>
 8020948:	692b      	ldr	r3, [r5, #16]
 802094a:	b9eb      	cbnz	r3, 8020988 <_vfiprintf_r+0x78>
 802094c:	4629      	mov	r1, r5
 802094e:	4630      	mov	r0, r6
 8020950:	f000 fb92 	bl	8021078 <__swsetup_r>
 8020954:	b1c0      	cbz	r0, 8020988 <_vfiprintf_r+0x78>
 8020956:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8020958:	07dc      	lsls	r4, r3, #31
 802095a:	d50e      	bpl.n	802097a <_vfiprintf_r+0x6a>
 802095c:	f04f 30ff 	mov.w	r0, #4294967295
 8020960:	b01d      	add	sp, #116	; 0x74
 8020962:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020966:	4b7b      	ldr	r3, [pc, #492]	; (8020b54 <_vfiprintf_r+0x244>)
 8020968:	429d      	cmp	r5, r3
 802096a:	d101      	bne.n	8020970 <_vfiprintf_r+0x60>
 802096c:	68b5      	ldr	r5, [r6, #8]
 802096e:	e7df      	b.n	8020930 <_vfiprintf_r+0x20>
 8020970:	4b79      	ldr	r3, [pc, #484]	; (8020b58 <_vfiprintf_r+0x248>)
 8020972:	429d      	cmp	r5, r3
 8020974:	bf08      	it	eq
 8020976:	68f5      	ldreq	r5, [r6, #12]
 8020978:	e7da      	b.n	8020930 <_vfiprintf_r+0x20>
 802097a:	89ab      	ldrh	r3, [r5, #12]
 802097c:	0598      	lsls	r0, r3, #22
 802097e:	d4ed      	bmi.n	802095c <_vfiprintf_r+0x4c>
 8020980:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8020982:	f7ff fe32 	bl	80205ea <__retarget_lock_release_recursive>
 8020986:	e7e9      	b.n	802095c <_vfiprintf_r+0x4c>
 8020988:	2300      	movs	r3, #0
 802098a:	9309      	str	r3, [sp, #36]	; 0x24
 802098c:	2320      	movs	r3, #32
 802098e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8020992:	f8cd 800c 	str.w	r8, [sp, #12]
 8020996:	2330      	movs	r3, #48	; 0x30
 8020998:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8020b5c <_vfiprintf_r+0x24c>
 802099c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80209a0:	f04f 0901 	mov.w	r9, #1
 80209a4:	4623      	mov	r3, r4
 80209a6:	469a      	mov	sl, r3
 80209a8:	f813 2b01 	ldrb.w	r2, [r3], #1
 80209ac:	b10a      	cbz	r2, 80209b2 <_vfiprintf_r+0xa2>
 80209ae:	2a25      	cmp	r2, #37	; 0x25
 80209b0:	d1f9      	bne.n	80209a6 <_vfiprintf_r+0x96>
 80209b2:	ebba 0b04 	subs.w	fp, sl, r4
 80209b6:	d00b      	beq.n	80209d0 <_vfiprintf_r+0xc0>
 80209b8:	465b      	mov	r3, fp
 80209ba:	4622      	mov	r2, r4
 80209bc:	4629      	mov	r1, r5
 80209be:	4630      	mov	r0, r6
 80209c0:	f7ff ff93 	bl	80208ea <__sfputs_r>
 80209c4:	3001      	adds	r0, #1
 80209c6:	f000 80aa 	beq.w	8020b1e <_vfiprintf_r+0x20e>
 80209ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80209cc:	445a      	add	r2, fp
 80209ce:	9209      	str	r2, [sp, #36]	; 0x24
 80209d0:	f89a 3000 	ldrb.w	r3, [sl]
 80209d4:	2b00      	cmp	r3, #0
 80209d6:	f000 80a2 	beq.w	8020b1e <_vfiprintf_r+0x20e>
 80209da:	2300      	movs	r3, #0
 80209dc:	f04f 32ff 	mov.w	r2, #4294967295
 80209e0:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80209e4:	f10a 0a01 	add.w	sl, sl, #1
 80209e8:	9304      	str	r3, [sp, #16]
 80209ea:	9307      	str	r3, [sp, #28]
 80209ec:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80209f0:	931a      	str	r3, [sp, #104]	; 0x68
 80209f2:	4654      	mov	r4, sl
 80209f4:	2205      	movs	r2, #5
 80209f6:	f814 1b01 	ldrb.w	r1, [r4], #1
 80209fa:	4858      	ldr	r0, [pc, #352]	; (8020b5c <_vfiprintf_r+0x24c>)
 80209fc:	f7df fc18 	bl	8000230 <memchr>
 8020a00:	9a04      	ldr	r2, [sp, #16]
 8020a02:	b9d8      	cbnz	r0, 8020a3c <_vfiprintf_r+0x12c>
 8020a04:	06d1      	lsls	r1, r2, #27
 8020a06:	bf44      	itt	mi
 8020a08:	2320      	movmi	r3, #32
 8020a0a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8020a0e:	0713      	lsls	r3, r2, #28
 8020a10:	bf44      	itt	mi
 8020a12:	232b      	movmi	r3, #43	; 0x2b
 8020a14:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8020a18:	f89a 3000 	ldrb.w	r3, [sl]
 8020a1c:	2b2a      	cmp	r3, #42	; 0x2a
 8020a1e:	d015      	beq.n	8020a4c <_vfiprintf_r+0x13c>
 8020a20:	9a07      	ldr	r2, [sp, #28]
 8020a22:	4654      	mov	r4, sl
 8020a24:	2000      	movs	r0, #0
 8020a26:	f04f 0c0a 	mov.w	ip, #10
 8020a2a:	4621      	mov	r1, r4
 8020a2c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8020a30:	3b30      	subs	r3, #48	; 0x30
 8020a32:	2b09      	cmp	r3, #9
 8020a34:	d94e      	bls.n	8020ad4 <_vfiprintf_r+0x1c4>
 8020a36:	b1b0      	cbz	r0, 8020a66 <_vfiprintf_r+0x156>
 8020a38:	9207      	str	r2, [sp, #28]
 8020a3a:	e014      	b.n	8020a66 <_vfiprintf_r+0x156>
 8020a3c:	eba0 0308 	sub.w	r3, r0, r8
 8020a40:	fa09 f303 	lsl.w	r3, r9, r3
 8020a44:	4313      	orrs	r3, r2
 8020a46:	9304      	str	r3, [sp, #16]
 8020a48:	46a2      	mov	sl, r4
 8020a4a:	e7d2      	b.n	80209f2 <_vfiprintf_r+0xe2>
 8020a4c:	9b03      	ldr	r3, [sp, #12]
 8020a4e:	1d19      	adds	r1, r3, #4
 8020a50:	681b      	ldr	r3, [r3, #0]
 8020a52:	9103      	str	r1, [sp, #12]
 8020a54:	2b00      	cmp	r3, #0
 8020a56:	bfbb      	ittet	lt
 8020a58:	425b      	neglt	r3, r3
 8020a5a:	f042 0202 	orrlt.w	r2, r2, #2
 8020a5e:	9307      	strge	r3, [sp, #28]
 8020a60:	9307      	strlt	r3, [sp, #28]
 8020a62:	bfb8      	it	lt
 8020a64:	9204      	strlt	r2, [sp, #16]
 8020a66:	7823      	ldrb	r3, [r4, #0]
 8020a68:	2b2e      	cmp	r3, #46	; 0x2e
 8020a6a:	d10c      	bne.n	8020a86 <_vfiprintf_r+0x176>
 8020a6c:	7863      	ldrb	r3, [r4, #1]
 8020a6e:	2b2a      	cmp	r3, #42	; 0x2a
 8020a70:	d135      	bne.n	8020ade <_vfiprintf_r+0x1ce>
 8020a72:	9b03      	ldr	r3, [sp, #12]
 8020a74:	1d1a      	adds	r2, r3, #4
 8020a76:	681b      	ldr	r3, [r3, #0]
 8020a78:	9203      	str	r2, [sp, #12]
 8020a7a:	2b00      	cmp	r3, #0
 8020a7c:	bfb8      	it	lt
 8020a7e:	f04f 33ff 	movlt.w	r3, #4294967295
 8020a82:	3402      	adds	r4, #2
 8020a84:	9305      	str	r3, [sp, #20]
 8020a86:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8020b6c <_vfiprintf_r+0x25c>
 8020a8a:	7821      	ldrb	r1, [r4, #0]
 8020a8c:	2203      	movs	r2, #3
 8020a8e:	4650      	mov	r0, sl
 8020a90:	f7df fbce 	bl	8000230 <memchr>
 8020a94:	b140      	cbz	r0, 8020aa8 <_vfiprintf_r+0x198>
 8020a96:	2340      	movs	r3, #64	; 0x40
 8020a98:	eba0 000a 	sub.w	r0, r0, sl
 8020a9c:	fa03 f000 	lsl.w	r0, r3, r0
 8020aa0:	9b04      	ldr	r3, [sp, #16]
 8020aa2:	4303      	orrs	r3, r0
 8020aa4:	3401      	adds	r4, #1
 8020aa6:	9304      	str	r3, [sp, #16]
 8020aa8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8020aac:	482c      	ldr	r0, [pc, #176]	; (8020b60 <_vfiprintf_r+0x250>)
 8020aae:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8020ab2:	2206      	movs	r2, #6
 8020ab4:	f7df fbbc 	bl	8000230 <memchr>
 8020ab8:	2800      	cmp	r0, #0
 8020aba:	d03f      	beq.n	8020b3c <_vfiprintf_r+0x22c>
 8020abc:	4b29      	ldr	r3, [pc, #164]	; (8020b64 <_vfiprintf_r+0x254>)
 8020abe:	bb1b      	cbnz	r3, 8020b08 <_vfiprintf_r+0x1f8>
 8020ac0:	9b03      	ldr	r3, [sp, #12]
 8020ac2:	3307      	adds	r3, #7
 8020ac4:	f023 0307 	bic.w	r3, r3, #7
 8020ac8:	3308      	adds	r3, #8
 8020aca:	9303      	str	r3, [sp, #12]
 8020acc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020ace:	443b      	add	r3, r7
 8020ad0:	9309      	str	r3, [sp, #36]	; 0x24
 8020ad2:	e767      	b.n	80209a4 <_vfiprintf_r+0x94>
 8020ad4:	fb0c 3202 	mla	r2, ip, r2, r3
 8020ad8:	460c      	mov	r4, r1
 8020ada:	2001      	movs	r0, #1
 8020adc:	e7a5      	b.n	8020a2a <_vfiprintf_r+0x11a>
 8020ade:	2300      	movs	r3, #0
 8020ae0:	3401      	adds	r4, #1
 8020ae2:	9305      	str	r3, [sp, #20]
 8020ae4:	4619      	mov	r1, r3
 8020ae6:	f04f 0c0a 	mov.w	ip, #10
 8020aea:	4620      	mov	r0, r4
 8020aec:	f810 2b01 	ldrb.w	r2, [r0], #1
 8020af0:	3a30      	subs	r2, #48	; 0x30
 8020af2:	2a09      	cmp	r2, #9
 8020af4:	d903      	bls.n	8020afe <_vfiprintf_r+0x1ee>
 8020af6:	2b00      	cmp	r3, #0
 8020af8:	d0c5      	beq.n	8020a86 <_vfiprintf_r+0x176>
 8020afa:	9105      	str	r1, [sp, #20]
 8020afc:	e7c3      	b.n	8020a86 <_vfiprintf_r+0x176>
 8020afe:	fb0c 2101 	mla	r1, ip, r1, r2
 8020b02:	4604      	mov	r4, r0
 8020b04:	2301      	movs	r3, #1
 8020b06:	e7f0      	b.n	8020aea <_vfiprintf_r+0x1da>
 8020b08:	ab03      	add	r3, sp, #12
 8020b0a:	9300      	str	r3, [sp, #0]
 8020b0c:	462a      	mov	r2, r5
 8020b0e:	4b16      	ldr	r3, [pc, #88]	; (8020b68 <_vfiprintf_r+0x258>)
 8020b10:	a904      	add	r1, sp, #16
 8020b12:	4630      	mov	r0, r6
 8020b14:	f3af 8000 	nop.w
 8020b18:	4607      	mov	r7, r0
 8020b1a:	1c78      	adds	r0, r7, #1
 8020b1c:	d1d6      	bne.n	8020acc <_vfiprintf_r+0x1bc>
 8020b1e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8020b20:	07d9      	lsls	r1, r3, #31
 8020b22:	d405      	bmi.n	8020b30 <_vfiprintf_r+0x220>
 8020b24:	89ab      	ldrh	r3, [r5, #12]
 8020b26:	059a      	lsls	r2, r3, #22
 8020b28:	d402      	bmi.n	8020b30 <_vfiprintf_r+0x220>
 8020b2a:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8020b2c:	f7ff fd5d 	bl	80205ea <__retarget_lock_release_recursive>
 8020b30:	89ab      	ldrh	r3, [r5, #12]
 8020b32:	065b      	lsls	r3, r3, #25
 8020b34:	f53f af12 	bmi.w	802095c <_vfiprintf_r+0x4c>
 8020b38:	9809      	ldr	r0, [sp, #36]	; 0x24
 8020b3a:	e711      	b.n	8020960 <_vfiprintf_r+0x50>
 8020b3c:	ab03      	add	r3, sp, #12
 8020b3e:	9300      	str	r3, [sp, #0]
 8020b40:	462a      	mov	r2, r5
 8020b42:	4b09      	ldr	r3, [pc, #36]	; (8020b68 <_vfiprintf_r+0x258>)
 8020b44:	a904      	add	r1, sp, #16
 8020b46:	4630      	mov	r0, r6
 8020b48:	f000 f880 	bl	8020c4c <_printf_i>
 8020b4c:	e7e4      	b.n	8020b18 <_vfiprintf_r+0x208>
 8020b4e:	bf00      	nop
 8020b50:	08026fd4 	.word	0x08026fd4
 8020b54:	08026ff4 	.word	0x08026ff4
 8020b58:	08026fb4 	.word	0x08026fb4
 8020b5c:	08027014 	.word	0x08027014
 8020b60:	0802701e 	.word	0x0802701e
 8020b64:	00000000 	.word	0x00000000
 8020b68:	080208eb 	.word	0x080208eb
 8020b6c:	0802701a 	.word	0x0802701a

08020b70 <_printf_common>:
 8020b70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020b74:	4616      	mov	r6, r2
 8020b76:	4699      	mov	r9, r3
 8020b78:	688a      	ldr	r2, [r1, #8]
 8020b7a:	690b      	ldr	r3, [r1, #16]
 8020b7c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8020b80:	4293      	cmp	r3, r2
 8020b82:	bfb8      	it	lt
 8020b84:	4613      	movlt	r3, r2
 8020b86:	6033      	str	r3, [r6, #0]
 8020b88:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8020b8c:	4607      	mov	r7, r0
 8020b8e:	460c      	mov	r4, r1
 8020b90:	b10a      	cbz	r2, 8020b96 <_printf_common+0x26>
 8020b92:	3301      	adds	r3, #1
 8020b94:	6033      	str	r3, [r6, #0]
 8020b96:	6823      	ldr	r3, [r4, #0]
 8020b98:	0699      	lsls	r1, r3, #26
 8020b9a:	bf42      	ittt	mi
 8020b9c:	6833      	ldrmi	r3, [r6, #0]
 8020b9e:	3302      	addmi	r3, #2
 8020ba0:	6033      	strmi	r3, [r6, #0]
 8020ba2:	6825      	ldr	r5, [r4, #0]
 8020ba4:	f015 0506 	ands.w	r5, r5, #6
 8020ba8:	d106      	bne.n	8020bb8 <_printf_common+0x48>
 8020baa:	f104 0a19 	add.w	sl, r4, #25
 8020bae:	68e3      	ldr	r3, [r4, #12]
 8020bb0:	6832      	ldr	r2, [r6, #0]
 8020bb2:	1a9b      	subs	r3, r3, r2
 8020bb4:	42ab      	cmp	r3, r5
 8020bb6:	dc26      	bgt.n	8020c06 <_printf_common+0x96>
 8020bb8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8020bbc:	1e13      	subs	r3, r2, #0
 8020bbe:	6822      	ldr	r2, [r4, #0]
 8020bc0:	bf18      	it	ne
 8020bc2:	2301      	movne	r3, #1
 8020bc4:	0692      	lsls	r2, r2, #26
 8020bc6:	d42b      	bmi.n	8020c20 <_printf_common+0xb0>
 8020bc8:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8020bcc:	4649      	mov	r1, r9
 8020bce:	4638      	mov	r0, r7
 8020bd0:	47c0      	blx	r8
 8020bd2:	3001      	adds	r0, #1
 8020bd4:	d01e      	beq.n	8020c14 <_printf_common+0xa4>
 8020bd6:	6823      	ldr	r3, [r4, #0]
 8020bd8:	68e5      	ldr	r5, [r4, #12]
 8020bda:	6832      	ldr	r2, [r6, #0]
 8020bdc:	f003 0306 	and.w	r3, r3, #6
 8020be0:	2b04      	cmp	r3, #4
 8020be2:	bf08      	it	eq
 8020be4:	1aad      	subeq	r5, r5, r2
 8020be6:	68a3      	ldr	r3, [r4, #8]
 8020be8:	6922      	ldr	r2, [r4, #16]
 8020bea:	bf0c      	ite	eq
 8020bec:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8020bf0:	2500      	movne	r5, #0
 8020bf2:	4293      	cmp	r3, r2
 8020bf4:	bfc4      	itt	gt
 8020bf6:	1a9b      	subgt	r3, r3, r2
 8020bf8:	18ed      	addgt	r5, r5, r3
 8020bfa:	2600      	movs	r6, #0
 8020bfc:	341a      	adds	r4, #26
 8020bfe:	42b5      	cmp	r5, r6
 8020c00:	d11a      	bne.n	8020c38 <_printf_common+0xc8>
 8020c02:	2000      	movs	r0, #0
 8020c04:	e008      	b.n	8020c18 <_printf_common+0xa8>
 8020c06:	2301      	movs	r3, #1
 8020c08:	4652      	mov	r2, sl
 8020c0a:	4649      	mov	r1, r9
 8020c0c:	4638      	mov	r0, r7
 8020c0e:	47c0      	blx	r8
 8020c10:	3001      	adds	r0, #1
 8020c12:	d103      	bne.n	8020c1c <_printf_common+0xac>
 8020c14:	f04f 30ff 	mov.w	r0, #4294967295
 8020c18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020c1c:	3501      	adds	r5, #1
 8020c1e:	e7c6      	b.n	8020bae <_printf_common+0x3e>
 8020c20:	18e1      	adds	r1, r4, r3
 8020c22:	1c5a      	adds	r2, r3, #1
 8020c24:	2030      	movs	r0, #48	; 0x30
 8020c26:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8020c2a:	4422      	add	r2, r4
 8020c2c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8020c30:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8020c34:	3302      	adds	r3, #2
 8020c36:	e7c7      	b.n	8020bc8 <_printf_common+0x58>
 8020c38:	2301      	movs	r3, #1
 8020c3a:	4622      	mov	r2, r4
 8020c3c:	4649      	mov	r1, r9
 8020c3e:	4638      	mov	r0, r7
 8020c40:	47c0      	blx	r8
 8020c42:	3001      	adds	r0, #1
 8020c44:	d0e6      	beq.n	8020c14 <_printf_common+0xa4>
 8020c46:	3601      	adds	r6, #1
 8020c48:	e7d9      	b.n	8020bfe <_printf_common+0x8e>
	...

08020c4c <_printf_i>:
 8020c4c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8020c50:	7e0f      	ldrb	r7, [r1, #24]
 8020c52:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8020c54:	2f78      	cmp	r7, #120	; 0x78
 8020c56:	4691      	mov	r9, r2
 8020c58:	4680      	mov	r8, r0
 8020c5a:	460c      	mov	r4, r1
 8020c5c:	469a      	mov	sl, r3
 8020c5e:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8020c62:	d807      	bhi.n	8020c74 <_printf_i+0x28>
 8020c64:	2f62      	cmp	r7, #98	; 0x62
 8020c66:	d80a      	bhi.n	8020c7e <_printf_i+0x32>
 8020c68:	2f00      	cmp	r7, #0
 8020c6a:	f000 80d8 	beq.w	8020e1e <_printf_i+0x1d2>
 8020c6e:	2f58      	cmp	r7, #88	; 0x58
 8020c70:	f000 80a3 	beq.w	8020dba <_printf_i+0x16e>
 8020c74:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8020c78:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8020c7c:	e03a      	b.n	8020cf4 <_printf_i+0xa8>
 8020c7e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8020c82:	2b15      	cmp	r3, #21
 8020c84:	d8f6      	bhi.n	8020c74 <_printf_i+0x28>
 8020c86:	a101      	add	r1, pc, #4	; (adr r1, 8020c8c <_printf_i+0x40>)
 8020c88:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8020c8c:	08020ce5 	.word	0x08020ce5
 8020c90:	08020cf9 	.word	0x08020cf9
 8020c94:	08020c75 	.word	0x08020c75
 8020c98:	08020c75 	.word	0x08020c75
 8020c9c:	08020c75 	.word	0x08020c75
 8020ca0:	08020c75 	.word	0x08020c75
 8020ca4:	08020cf9 	.word	0x08020cf9
 8020ca8:	08020c75 	.word	0x08020c75
 8020cac:	08020c75 	.word	0x08020c75
 8020cb0:	08020c75 	.word	0x08020c75
 8020cb4:	08020c75 	.word	0x08020c75
 8020cb8:	08020e05 	.word	0x08020e05
 8020cbc:	08020d29 	.word	0x08020d29
 8020cc0:	08020de7 	.word	0x08020de7
 8020cc4:	08020c75 	.word	0x08020c75
 8020cc8:	08020c75 	.word	0x08020c75
 8020ccc:	08020e27 	.word	0x08020e27
 8020cd0:	08020c75 	.word	0x08020c75
 8020cd4:	08020d29 	.word	0x08020d29
 8020cd8:	08020c75 	.word	0x08020c75
 8020cdc:	08020c75 	.word	0x08020c75
 8020ce0:	08020def 	.word	0x08020def
 8020ce4:	682b      	ldr	r3, [r5, #0]
 8020ce6:	1d1a      	adds	r2, r3, #4
 8020ce8:	681b      	ldr	r3, [r3, #0]
 8020cea:	602a      	str	r2, [r5, #0]
 8020cec:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8020cf0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8020cf4:	2301      	movs	r3, #1
 8020cf6:	e0a3      	b.n	8020e40 <_printf_i+0x1f4>
 8020cf8:	6820      	ldr	r0, [r4, #0]
 8020cfa:	6829      	ldr	r1, [r5, #0]
 8020cfc:	0606      	lsls	r6, r0, #24
 8020cfe:	f101 0304 	add.w	r3, r1, #4
 8020d02:	d50a      	bpl.n	8020d1a <_printf_i+0xce>
 8020d04:	680e      	ldr	r6, [r1, #0]
 8020d06:	602b      	str	r3, [r5, #0]
 8020d08:	2e00      	cmp	r6, #0
 8020d0a:	da03      	bge.n	8020d14 <_printf_i+0xc8>
 8020d0c:	232d      	movs	r3, #45	; 0x2d
 8020d0e:	4276      	negs	r6, r6
 8020d10:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8020d14:	485e      	ldr	r0, [pc, #376]	; (8020e90 <_printf_i+0x244>)
 8020d16:	230a      	movs	r3, #10
 8020d18:	e019      	b.n	8020d4e <_printf_i+0x102>
 8020d1a:	680e      	ldr	r6, [r1, #0]
 8020d1c:	602b      	str	r3, [r5, #0]
 8020d1e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8020d22:	bf18      	it	ne
 8020d24:	b236      	sxthne	r6, r6
 8020d26:	e7ef      	b.n	8020d08 <_printf_i+0xbc>
 8020d28:	682b      	ldr	r3, [r5, #0]
 8020d2a:	6820      	ldr	r0, [r4, #0]
 8020d2c:	1d19      	adds	r1, r3, #4
 8020d2e:	6029      	str	r1, [r5, #0]
 8020d30:	0601      	lsls	r1, r0, #24
 8020d32:	d501      	bpl.n	8020d38 <_printf_i+0xec>
 8020d34:	681e      	ldr	r6, [r3, #0]
 8020d36:	e002      	b.n	8020d3e <_printf_i+0xf2>
 8020d38:	0646      	lsls	r6, r0, #25
 8020d3a:	d5fb      	bpl.n	8020d34 <_printf_i+0xe8>
 8020d3c:	881e      	ldrh	r6, [r3, #0]
 8020d3e:	4854      	ldr	r0, [pc, #336]	; (8020e90 <_printf_i+0x244>)
 8020d40:	2f6f      	cmp	r7, #111	; 0x6f
 8020d42:	bf0c      	ite	eq
 8020d44:	2308      	moveq	r3, #8
 8020d46:	230a      	movne	r3, #10
 8020d48:	2100      	movs	r1, #0
 8020d4a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8020d4e:	6865      	ldr	r5, [r4, #4]
 8020d50:	60a5      	str	r5, [r4, #8]
 8020d52:	2d00      	cmp	r5, #0
 8020d54:	bfa2      	ittt	ge
 8020d56:	6821      	ldrge	r1, [r4, #0]
 8020d58:	f021 0104 	bicge.w	r1, r1, #4
 8020d5c:	6021      	strge	r1, [r4, #0]
 8020d5e:	b90e      	cbnz	r6, 8020d64 <_printf_i+0x118>
 8020d60:	2d00      	cmp	r5, #0
 8020d62:	d04d      	beq.n	8020e00 <_printf_i+0x1b4>
 8020d64:	4615      	mov	r5, r2
 8020d66:	fbb6 f1f3 	udiv	r1, r6, r3
 8020d6a:	fb03 6711 	mls	r7, r3, r1, r6
 8020d6e:	5dc7      	ldrb	r7, [r0, r7]
 8020d70:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8020d74:	4637      	mov	r7, r6
 8020d76:	42bb      	cmp	r3, r7
 8020d78:	460e      	mov	r6, r1
 8020d7a:	d9f4      	bls.n	8020d66 <_printf_i+0x11a>
 8020d7c:	2b08      	cmp	r3, #8
 8020d7e:	d10b      	bne.n	8020d98 <_printf_i+0x14c>
 8020d80:	6823      	ldr	r3, [r4, #0]
 8020d82:	07de      	lsls	r6, r3, #31
 8020d84:	d508      	bpl.n	8020d98 <_printf_i+0x14c>
 8020d86:	6923      	ldr	r3, [r4, #16]
 8020d88:	6861      	ldr	r1, [r4, #4]
 8020d8a:	4299      	cmp	r1, r3
 8020d8c:	bfde      	ittt	le
 8020d8e:	2330      	movle	r3, #48	; 0x30
 8020d90:	f805 3c01 	strble.w	r3, [r5, #-1]
 8020d94:	f105 35ff 	addle.w	r5, r5, #4294967295
 8020d98:	1b52      	subs	r2, r2, r5
 8020d9a:	6122      	str	r2, [r4, #16]
 8020d9c:	f8cd a000 	str.w	sl, [sp]
 8020da0:	464b      	mov	r3, r9
 8020da2:	aa03      	add	r2, sp, #12
 8020da4:	4621      	mov	r1, r4
 8020da6:	4640      	mov	r0, r8
 8020da8:	f7ff fee2 	bl	8020b70 <_printf_common>
 8020dac:	3001      	adds	r0, #1
 8020dae:	d14c      	bne.n	8020e4a <_printf_i+0x1fe>
 8020db0:	f04f 30ff 	mov.w	r0, #4294967295
 8020db4:	b004      	add	sp, #16
 8020db6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020dba:	4835      	ldr	r0, [pc, #212]	; (8020e90 <_printf_i+0x244>)
 8020dbc:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8020dc0:	6829      	ldr	r1, [r5, #0]
 8020dc2:	6823      	ldr	r3, [r4, #0]
 8020dc4:	f851 6b04 	ldr.w	r6, [r1], #4
 8020dc8:	6029      	str	r1, [r5, #0]
 8020dca:	061d      	lsls	r5, r3, #24
 8020dcc:	d514      	bpl.n	8020df8 <_printf_i+0x1ac>
 8020dce:	07df      	lsls	r7, r3, #31
 8020dd0:	bf44      	itt	mi
 8020dd2:	f043 0320 	orrmi.w	r3, r3, #32
 8020dd6:	6023      	strmi	r3, [r4, #0]
 8020dd8:	b91e      	cbnz	r6, 8020de2 <_printf_i+0x196>
 8020dda:	6823      	ldr	r3, [r4, #0]
 8020ddc:	f023 0320 	bic.w	r3, r3, #32
 8020de0:	6023      	str	r3, [r4, #0]
 8020de2:	2310      	movs	r3, #16
 8020de4:	e7b0      	b.n	8020d48 <_printf_i+0xfc>
 8020de6:	6823      	ldr	r3, [r4, #0]
 8020de8:	f043 0320 	orr.w	r3, r3, #32
 8020dec:	6023      	str	r3, [r4, #0]
 8020dee:	2378      	movs	r3, #120	; 0x78
 8020df0:	4828      	ldr	r0, [pc, #160]	; (8020e94 <_printf_i+0x248>)
 8020df2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8020df6:	e7e3      	b.n	8020dc0 <_printf_i+0x174>
 8020df8:	0659      	lsls	r1, r3, #25
 8020dfa:	bf48      	it	mi
 8020dfc:	b2b6      	uxthmi	r6, r6
 8020dfe:	e7e6      	b.n	8020dce <_printf_i+0x182>
 8020e00:	4615      	mov	r5, r2
 8020e02:	e7bb      	b.n	8020d7c <_printf_i+0x130>
 8020e04:	682b      	ldr	r3, [r5, #0]
 8020e06:	6826      	ldr	r6, [r4, #0]
 8020e08:	6961      	ldr	r1, [r4, #20]
 8020e0a:	1d18      	adds	r0, r3, #4
 8020e0c:	6028      	str	r0, [r5, #0]
 8020e0e:	0635      	lsls	r5, r6, #24
 8020e10:	681b      	ldr	r3, [r3, #0]
 8020e12:	d501      	bpl.n	8020e18 <_printf_i+0x1cc>
 8020e14:	6019      	str	r1, [r3, #0]
 8020e16:	e002      	b.n	8020e1e <_printf_i+0x1d2>
 8020e18:	0670      	lsls	r0, r6, #25
 8020e1a:	d5fb      	bpl.n	8020e14 <_printf_i+0x1c8>
 8020e1c:	8019      	strh	r1, [r3, #0]
 8020e1e:	2300      	movs	r3, #0
 8020e20:	6123      	str	r3, [r4, #16]
 8020e22:	4615      	mov	r5, r2
 8020e24:	e7ba      	b.n	8020d9c <_printf_i+0x150>
 8020e26:	682b      	ldr	r3, [r5, #0]
 8020e28:	1d1a      	adds	r2, r3, #4
 8020e2a:	602a      	str	r2, [r5, #0]
 8020e2c:	681d      	ldr	r5, [r3, #0]
 8020e2e:	6862      	ldr	r2, [r4, #4]
 8020e30:	2100      	movs	r1, #0
 8020e32:	4628      	mov	r0, r5
 8020e34:	f7df f9fc 	bl	8000230 <memchr>
 8020e38:	b108      	cbz	r0, 8020e3e <_printf_i+0x1f2>
 8020e3a:	1b40      	subs	r0, r0, r5
 8020e3c:	6060      	str	r0, [r4, #4]
 8020e3e:	6863      	ldr	r3, [r4, #4]
 8020e40:	6123      	str	r3, [r4, #16]
 8020e42:	2300      	movs	r3, #0
 8020e44:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8020e48:	e7a8      	b.n	8020d9c <_printf_i+0x150>
 8020e4a:	6923      	ldr	r3, [r4, #16]
 8020e4c:	462a      	mov	r2, r5
 8020e4e:	4649      	mov	r1, r9
 8020e50:	4640      	mov	r0, r8
 8020e52:	47d0      	blx	sl
 8020e54:	3001      	adds	r0, #1
 8020e56:	d0ab      	beq.n	8020db0 <_printf_i+0x164>
 8020e58:	6823      	ldr	r3, [r4, #0]
 8020e5a:	079b      	lsls	r3, r3, #30
 8020e5c:	d413      	bmi.n	8020e86 <_printf_i+0x23a>
 8020e5e:	68e0      	ldr	r0, [r4, #12]
 8020e60:	9b03      	ldr	r3, [sp, #12]
 8020e62:	4298      	cmp	r0, r3
 8020e64:	bfb8      	it	lt
 8020e66:	4618      	movlt	r0, r3
 8020e68:	e7a4      	b.n	8020db4 <_printf_i+0x168>
 8020e6a:	2301      	movs	r3, #1
 8020e6c:	4632      	mov	r2, r6
 8020e6e:	4649      	mov	r1, r9
 8020e70:	4640      	mov	r0, r8
 8020e72:	47d0      	blx	sl
 8020e74:	3001      	adds	r0, #1
 8020e76:	d09b      	beq.n	8020db0 <_printf_i+0x164>
 8020e78:	3501      	adds	r5, #1
 8020e7a:	68e3      	ldr	r3, [r4, #12]
 8020e7c:	9903      	ldr	r1, [sp, #12]
 8020e7e:	1a5b      	subs	r3, r3, r1
 8020e80:	42ab      	cmp	r3, r5
 8020e82:	dcf2      	bgt.n	8020e6a <_printf_i+0x21e>
 8020e84:	e7eb      	b.n	8020e5e <_printf_i+0x212>
 8020e86:	2500      	movs	r5, #0
 8020e88:	f104 0619 	add.w	r6, r4, #25
 8020e8c:	e7f5      	b.n	8020e7a <_printf_i+0x22e>
 8020e8e:	bf00      	nop
 8020e90:	08027025 	.word	0x08027025
 8020e94:	08027036 	.word	0x08027036

08020e98 <_putc_r>:
 8020e98:	b570      	push	{r4, r5, r6, lr}
 8020e9a:	460d      	mov	r5, r1
 8020e9c:	4614      	mov	r4, r2
 8020e9e:	4606      	mov	r6, r0
 8020ea0:	b118      	cbz	r0, 8020eaa <_putc_r+0x12>
 8020ea2:	6983      	ldr	r3, [r0, #24]
 8020ea4:	b90b      	cbnz	r3, 8020eaa <_putc_r+0x12>
 8020ea6:	f7ff fb01 	bl	80204ac <__sinit>
 8020eaa:	4b1c      	ldr	r3, [pc, #112]	; (8020f1c <_putc_r+0x84>)
 8020eac:	429c      	cmp	r4, r3
 8020eae:	d124      	bne.n	8020efa <_putc_r+0x62>
 8020eb0:	6874      	ldr	r4, [r6, #4]
 8020eb2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020eb4:	07d8      	lsls	r0, r3, #31
 8020eb6:	d405      	bmi.n	8020ec4 <_putc_r+0x2c>
 8020eb8:	89a3      	ldrh	r3, [r4, #12]
 8020eba:	0599      	lsls	r1, r3, #22
 8020ebc:	d402      	bmi.n	8020ec4 <_putc_r+0x2c>
 8020ebe:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020ec0:	f7ff fb92 	bl	80205e8 <__retarget_lock_acquire_recursive>
 8020ec4:	68a3      	ldr	r3, [r4, #8]
 8020ec6:	3b01      	subs	r3, #1
 8020ec8:	2b00      	cmp	r3, #0
 8020eca:	60a3      	str	r3, [r4, #8]
 8020ecc:	da05      	bge.n	8020eda <_putc_r+0x42>
 8020ece:	69a2      	ldr	r2, [r4, #24]
 8020ed0:	4293      	cmp	r3, r2
 8020ed2:	db1c      	blt.n	8020f0e <_putc_r+0x76>
 8020ed4:	b2eb      	uxtb	r3, r5
 8020ed6:	2b0a      	cmp	r3, #10
 8020ed8:	d019      	beq.n	8020f0e <_putc_r+0x76>
 8020eda:	6823      	ldr	r3, [r4, #0]
 8020edc:	1c5a      	adds	r2, r3, #1
 8020ede:	6022      	str	r2, [r4, #0]
 8020ee0:	701d      	strb	r5, [r3, #0]
 8020ee2:	b2ed      	uxtb	r5, r5
 8020ee4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020ee6:	07da      	lsls	r2, r3, #31
 8020ee8:	d405      	bmi.n	8020ef6 <_putc_r+0x5e>
 8020eea:	89a3      	ldrh	r3, [r4, #12]
 8020eec:	059b      	lsls	r3, r3, #22
 8020eee:	d402      	bmi.n	8020ef6 <_putc_r+0x5e>
 8020ef0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020ef2:	f7ff fb7a 	bl	80205ea <__retarget_lock_release_recursive>
 8020ef6:	4628      	mov	r0, r5
 8020ef8:	bd70      	pop	{r4, r5, r6, pc}
 8020efa:	4b09      	ldr	r3, [pc, #36]	; (8020f20 <_putc_r+0x88>)
 8020efc:	429c      	cmp	r4, r3
 8020efe:	d101      	bne.n	8020f04 <_putc_r+0x6c>
 8020f00:	68b4      	ldr	r4, [r6, #8]
 8020f02:	e7d6      	b.n	8020eb2 <_putc_r+0x1a>
 8020f04:	4b07      	ldr	r3, [pc, #28]	; (8020f24 <_putc_r+0x8c>)
 8020f06:	429c      	cmp	r4, r3
 8020f08:	bf08      	it	eq
 8020f0a:	68f4      	ldreq	r4, [r6, #12]
 8020f0c:	e7d1      	b.n	8020eb2 <_putc_r+0x1a>
 8020f0e:	4629      	mov	r1, r5
 8020f10:	4622      	mov	r2, r4
 8020f12:	4630      	mov	r0, r6
 8020f14:	f000 f84c 	bl	8020fb0 <__swbuf_r>
 8020f18:	4605      	mov	r5, r0
 8020f1a:	e7e3      	b.n	8020ee4 <_putc_r+0x4c>
 8020f1c:	08026fd4 	.word	0x08026fd4
 8020f20:	08026ff4 	.word	0x08026ff4
 8020f24:	08026fb4 	.word	0x08026fb4

08020f28 <__sread>:
 8020f28:	b510      	push	{r4, lr}
 8020f2a:	460c      	mov	r4, r1
 8020f2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020f30:	f000 fa8a 	bl	8021448 <_read_r>
 8020f34:	2800      	cmp	r0, #0
 8020f36:	bfab      	itete	ge
 8020f38:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8020f3a:	89a3      	ldrhlt	r3, [r4, #12]
 8020f3c:	181b      	addge	r3, r3, r0
 8020f3e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8020f42:	bfac      	ite	ge
 8020f44:	6563      	strge	r3, [r4, #84]	; 0x54
 8020f46:	81a3      	strhlt	r3, [r4, #12]
 8020f48:	bd10      	pop	{r4, pc}

08020f4a <__swrite>:
 8020f4a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020f4e:	461f      	mov	r7, r3
 8020f50:	898b      	ldrh	r3, [r1, #12]
 8020f52:	05db      	lsls	r3, r3, #23
 8020f54:	4605      	mov	r5, r0
 8020f56:	460c      	mov	r4, r1
 8020f58:	4616      	mov	r6, r2
 8020f5a:	d505      	bpl.n	8020f68 <__swrite+0x1e>
 8020f5c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020f60:	2302      	movs	r3, #2
 8020f62:	2200      	movs	r2, #0
 8020f64:	f000 f9c8 	bl	80212f8 <_lseek_r>
 8020f68:	89a3      	ldrh	r3, [r4, #12]
 8020f6a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8020f6e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8020f72:	81a3      	strh	r3, [r4, #12]
 8020f74:	4632      	mov	r2, r6
 8020f76:	463b      	mov	r3, r7
 8020f78:	4628      	mov	r0, r5
 8020f7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8020f7e:	f000 b869 	b.w	8021054 <_write_r>

08020f82 <__sseek>:
 8020f82:	b510      	push	{r4, lr}
 8020f84:	460c      	mov	r4, r1
 8020f86:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020f8a:	f000 f9b5 	bl	80212f8 <_lseek_r>
 8020f8e:	1c43      	adds	r3, r0, #1
 8020f90:	89a3      	ldrh	r3, [r4, #12]
 8020f92:	bf15      	itete	ne
 8020f94:	6560      	strne	r0, [r4, #84]	; 0x54
 8020f96:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8020f9a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8020f9e:	81a3      	strheq	r3, [r4, #12]
 8020fa0:	bf18      	it	ne
 8020fa2:	81a3      	strhne	r3, [r4, #12]
 8020fa4:	bd10      	pop	{r4, pc}

08020fa6 <__sclose>:
 8020fa6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020faa:	f000 b8d3 	b.w	8021154 <_close_r>
	...

08020fb0 <__swbuf_r>:
 8020fb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020fb2:	460e      	mov	r6, r1
 8020fb4:	4614      	mov	r4, r2
 8020fb6:	4605      	mov	r5, r0
 8020fb8:	b118      	cbz	r0, 8020fc2 <__swbuf_r+0x12>
 8020fba:	6983      	ldr	r3, [r0, #24]
 8020fbc:	b90b      	cbnz	r3, 8020fc2 <__swbuf_r+0x12>
 8020fbe:	f7ff fa75 	bl	80204ac <__sinit>
 8020fc2:	4b21      	ldr	r3, [pc, #132]	; (8021048 <__swbuf_r+0x98>)
 8020fc4:	429c      	cmp	r4, r3
 8020fc6:	d12b      	bne.n	8021020 <__swbuf_r+0x70>
 8020fc8:	686c      	ldr	r4, [r5, #4]
 8020fca:	69a3      	ldr	r3, [r4, #24]
 8020fcc:	60a3      	str	r3, [r4, #8]
 8020fce:	89a3      	ldrh	r3, [r4, #12]
 8020fd0:	071a      	lsls	r2, r3, #28
 8020fd2:	d52f      	bpl.n	8021034 <__swbuf_r+0x84>
 8020fd4:	6923      	ldr	r3, [r4, #16]
 8020fd6:	b36b      	cbz	r3, 8021034 <__swbuf_r+0x84>
 8020fd8:	6923      	ldr	r3, [r4, #16]
 8020fda:	6820      	ldr	r0, [r4, #0]
 8020fdc:	1ac0      	subs	r0, r0, r3
 8020fde:	6963      	ldr	r3, [r4, #20]
 8020fe0:	b2f6      	uxtb	r6, r6
 8020fe2:	4283      	cmp	r3, r0
 8020fe4:	4637      	mov	r7, r6
 8020fe6:	dc04      	bgt.n	8020ff2 <__swbuf_r+0x42>
 8020fe8:	4621      	mov	r1, r4
 8020fea:	4628      	mov	r0, r5
 8020fec:	f000 f948 	bl	8021280 <_fflush_r>
 8020ff0:	bb30      	cbnz	r0, 8021040 <__swbuf_r+0x90>
 8020ff2:	68a3      	ldr	r3, [r4, #8]
 8020ff4:	3b01      	subs	r3, #1
 8020ff6:	60a3      	str	r3, [r4, #8]
 8020ff8:	6823      	ldr	r3, [r4, #0]
 8020ffa:	1c5a      	adds	r2, r3, #1
 8020ffc:	6022      	str	r2, [r4, #0]
 8020ffe:	701e      	strb	r6, [r3, #0]
 8021000:	6963      	ldr	r3, [r4, #20]
 8021002:	3001      	adds	r0, #1
 8021004:	4283      	cmp	r3, r0
 8021006:	d004      	beq.n	8021012 <__swbuf_r+0x62>
 8021008:	89a3      	ldrh	r3, [r4, #12]
 802100a:	07db      	lsls	r3, r3, #31
 802100c:	d506      	bpl.n	802101c <__swbuf_r+0x6c>
 802100e:	2e0a      	cmp	r6, #10
 8021010:	d104      	bne.n	802101c <__swbuf_r+0x6c>
 8021012:	4621      	mov	r1, r4
 8021014:	4628      	mov	r0, r5
 8021016:	f000 f933 	bl	8021280 <_fflush_r>
 802101a:	b988      	cbnz	r0, 8021040 <__swbuf_r+0x90>
 802101c:	4638      	mov	r0, r7
 802101e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021020:	4b0a      	ldr	r3, [pc, #40]	; (802104c <__swbuf_r+0x9c>)
 8021022:	429c      	cmp	r4, r3
 8021024:	d101      	bne.n	802102a <__swbuf_r+0x7a>
 8021026:	68ac      	ldr	r4, [r5, #8]
 8021028:	e7cf      	b.n	8020fca <__swbuf_r+0x1a>
 802102a:	4b09      	ldr	r3, [pc, #36]	; (8021050 <__swbuf_r+0xa0>)
 802102c:	429c      	cmp	r4, r3
 802102e:	bf08      	it	eq
 8021030:	68ec      	ldreq	r4, [r5, #12]
 8021032:	e7ca      	b.n	8020fca <__swbuf_r+0x1a>
 8021034:	4621      	mov	r1, r4
 8021036:	4628      	mov	r0, r5
 8021038:	f000 f81e 	bl	8021078 <__swsetup_r>
 802103c:	2800      	cmp	r0, #0
 802103e:	d0cb      	beq.n	8020fd8 <__swbuf_r+0x28>
 8021040:	f04f 37ff 	mov.w	r7, #4294967295
 8021044:	e7ea      	b.n	802101c <__swbuf_r+0x6c>
 8021046:	bf00      	nop
 8021048:	08026fd4 	.word	0x08026fd4
 802104c:	08026ff4 	.word	0x08026ff4
 8021050:	08026fb4 	.word	0x08026fb4

08021054 <_write_r>:
 8021054:	b538      	push	{r3, r4, r5, lr}
 8021056:	4d07      	ldr	r5, [pc, #28]	; (8021074 <_write_r+0x20>)
 8021058:	4604      	mov	r4, r0
 802105a:	4608      	mov	r0, r1
 802105c:	4611      	mov	r1, r2
 802105e:	2200      	movs	r2, #0
 8021060:	602a      	str	r2, [r5, #0]
 8021062:	461a      	mov	r2, r3
 8021064:	f7fd f970 	bl	801e348 <_write>
 8021068:	1c43      	adds	r3, r0, #1
 802106a:	d102      	bne.n	8021072 <_write_r+0x1e>
 802106c:	682b      	ldr	r3, [r5, #0]
 802106e:	b103      	cbz	r3, 8021072 <_write_r+0x1e>
 8021070:	6023      	str	r3, [r4, #0]
 8021072:	bd38      	pop	{r3, r4, r5, pc}
 8021074:	20019830 	.word	0x20019830

08021078 <__swsetup_r>:
 8021078:	4b32      	ldr	r3, [pc, #200]	; (8021144 <__swsetup_r+0xcc>)
 802107a:	b570      	push	{r4, r5, r6, lr}
 802107c:	681d      	ldr	r5, [r3, #0]
 802107e:	4606      	mov	r6, r0
 8021080:	460c      	mov	r4, r1
 8021082:	b125      	cbz	r5, 802108e <__swsetup_r+0x16>
 8021084:	69ab      	ldr	r3, [r5, #24]
 8021086:	b913      	cbnz	r3, 802108e <__swsetup_r+0x16>
 8021088:	4628      	mov	r0, r5
 802108a:	f7ff fa0f 	bl	80204ac <__sinit>
 802108e:	4b2e      	ldr	r3, [pc, #184]	; (8021148 <__swsetup_r+0xd0>)
 8021090:	429c      	cmp	r4, r3
 8021092:	d10f      	bne.n	80210b4 <__swsetup_r+0x3c>
 8021094:	686c      	ldr	r4, [r5, #4]
 8021096:	89a3      	ldrh	r3, [r4, #12]
 8021098:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802109c:	0719      	lsls	r1, r3, #28
 802109e:	d42c      	bmi.n	80210fa <__swsetup_r+0x82>
 80210a0:	06dd      	lsls	r5, r3, #27
 80210a2:	d411      	bmi.n	80210c8 <__swsetup_r+0x50>
 80210a4:	2309      	movs	r3, #9
 80210a6:	6033      	str	r3, [r6, #0]
 80210a8:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80210ac:	81a3      	strh	r3, [r4, #12]
 80210ae:	f04f 30ff 	mov.w	r0, #4294967295
 80210b2:	e03e      	b.n	8021132 <__swsetup_r+0xba>
 80210b4:	4b25      	ldr	r3, [pc, #148]	; (802114c <__swsetup_r+0xd4>)
 80210b6:	429c      	cmp	r4, r3
 80210b8:	d101      	bne.n	80210be <__swsetup_r+0x46>
 80210ba:	68ac      	ldr	r4, [r5, #8]
 80210bc:	e7eb      	b.n	8021096 <__swsetup_r+0x1e>
 80210be:	4b24      	ldr	r3, [pc, #144]	; (8021150 <__swsetup_r+0xd8>)
 80210c0:	429c      	cmp	r4, r3
 80210c2:	bf08      	it	eq
 80210c4:	68ec      	ldreq	r4, [r5, #12]
 80210c6:	e7e6      	b.n	8021096 <__swsetup_r+0x1e>
 80210c8:	0758      	lsls	r0, r3, #29
 80210ca:	d512      	bpl.n	80210f2 <__swsetup_r+0x7a>
 80210cc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80210ce:	b141      	cbz	r1, 80210e2 <__swsetup_r+0x6a>
 80210d0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80210d4:	4299      	cmp	r1, r3
 80210d6:	d002      	beq.n	80210de <__swsetup_r+0x66>
 80210d8:	4630      	mov	r0, r6
 80210da:	f7ff f81d 	bl	8020118 <_free_r>
 80210de:	2300      	movs	r3, #0
 80210e0:	6363      	str	r3, [r4, #52]	; 0x34
 80210e2:	89a3      	ldrh	r3, [r4, #12]
 80210e4:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80210e8:	81a3      	strh	r3, [r4, #12]
 80210ea:	2300      	movs	r3, #0
 80210ec:	6063      	str	r3, [r4, #4]
 80210ee:	6923      	ldr	r3, [r4, #16]
 80210f0:	6023      	str	r3, [r4, #0]
 80210f2:	89a3      	ldrh	r3, [r4, #12]
 80210f4:	f043 0308 	orr.w	r3, r3, #8
 80210f8:	81a3      	strh	r3, [r4, #12]
 80210fa:	6923      	ldr	r3, [r4, #16]
 80210fc:	b94b      	cbnz	r3, 8021112 <__swsetup_r+0x9a>
 80210fe:	89a3      	ldrh	r3, [r4, #12]
 8021100:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8021104:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8021108:	d003      	beq.n	8021112 <__swsetup_r+0x9a>
 802110a:	4621      	mov	r1, r4
 802110c:	4630      	mov	r0, r6
 802110e:	f000 f92b 	bl	8021368 <__smakebuf_r>
 8021112:	89a0      	ldrh	r0, [r4, #12]
 8021114:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8021118:	f010 0301 	ands.w	r3, r0, #1
 802111c:	d00a      	beq.n	8021134 <__swsetup_r+0xbc>
 802111e:	2300      	movs	r3, #0
 8021120:	60a3      	str	r3, [r4, #8]
 8021122:	6963      	ldr	r3, [r4, #20]
 8021124:	425b      	negs	r3, r3
 8021126:	61a3      	str	r3, [r4, #24]
 8021128:	6923      	ldr	r3, [r4, #16]
 802112a:	b943      	cbnz	r3, 802113e <__swsetup_r+0xc6>
 802112c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8021130:	d1ba      	bne.n	80210a8 <__swsetup_r+0x30>
 8021132:	bd70      	pop	{r4, r5, r6, pc}
 8021134:	0781      	lsls	r1, r0, #30
 8021136:	bf58      	it	pl
 8021138:	6963      	ldrpl	r3, [r4, #20]
 802113a:	60a3      	str	r3, [r4, #8]
 802113c:	e7f4      	b.n	8021128 <__swsetup_r+0xb0>
 802113e:	2000      	movs	r0, #0
 8021140:	e7f7      	b.n	8021132 <__swsetup_r+0xba>
 8021142:	bf00      	nop
 8021144:	200000ac 	.word	0x200000ac
 8021148:	08026fd4 	.word	0x08026fd4
 802114c:	08026ff4 	.word	0x08026ff4
 8021150:	08026fb4 	.word	0x08026fb4

08021154 <_close_r>:
 8021154:	b538      	push	{r3, r4, r5, lr}
 8021156:	4d06      	ldr	r5, [pc, #24]	; (8021170 <_close_r+0x1c>)
 8021158:	2300      	movs	r3, #0
 802115a:	4604      	mov	r4, r0
 802115c:	4608      	mov	r0, r1
 802115e:	602b      	str	r3, [r5, #0]
 8021160:	f7fd f920 	bl	801e3a4 <_close>
 8021164:	1c43      	adds	r3, r0, #1
 8021166:	d102      	bne.n	802116e <_close_r+0x1a>
 8021168:	682b      	ldr	r3, [r5, #0]
 802116a:	b103      	cbz	r3, 802116e <_close_r+0x1a>
 802116c:	6023      	str	r3, [r4, #0]
 802116e:	bd38      	pop	{r3, r4, r5, pc}
 8021170:	20019830 	.word	0x20019830

08021174 <__sflush_r>:
 8021174:	898a      	ldrh	r2, [r1, #12]
 8021176:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802117a:	4605      	mov	r5, r0
 802117c:	0710      	lsls	r0, r2, #28
 802117e:	460c      	mov	r4, r1
 8021180:	d458      	bmi.n	8021234 <__sflush_r+0xc0>
 8021182:	684b      	ldr	r3, [r1, #4]
 8021184:	2b00      	cmp	r3, #0
 8021186:	dc05      	bgt.n	8021194 <__sflush_r+0x20>
 8021188:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 802118a:	2b00      	cmp	r3, #0
 802118c:	dc02      	bgt.n	8021194 <__sflush_r+0x20>
 802118e:	2000      	movs	r0, #0
 8021190:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021194:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8021196:	2e00      	cmp	r6, #0
 8021198:	d0f9      	beq.n	802118e <__sflush_r+0x1a>
 802119a:	2300      	movs	r3, #0
 802119c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 80211a0:	682f      	ldr	r7, [r5, #0]
 80211a2:	602b      	str	r3, [r5, #0]
 80211a4:	d032      	beq.n	802120c <__sflush_r+0x98>
 80211a6:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80211a8:	89a3      	ldrh	r3, [r4, #12]
 80211aa:	075a      	lsls	r2, r3, #29
 80211ac:	d505      	bpl.n	80211ba <__sflush_r+0x46>
 80211ae:	6863      	ldr	r3, [r4, #4]
 80211b0:	1ac0      	subs	r0, r0, r3
 80211b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80211b4:	b10b      	cbz	r3, 80211ba <__sflush_r+0x46>
 80211b6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80211b8:	1ac0      	subs	r0, r0, r3
 80211ba:	2300      	movs	r3, #0
 80211bc:	4602      	mov	r2, r0
 80211be:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80211c0:	6a21      	ldr	r1, [r4, #32]
 80211c2:	4628      	mov	r0, r5
 80211c4:	47b0      	blx	r6
 80211c6:	1c43      	adds	r3, r0, #1
 80211c8:	89a3      	ldrh	r3, [r4, #12]
 80211ca:	d106      	bne.n	80211da <__sflush_r+0x66>
 80211cc:	6829      	ldr	r1, [r5, #0]
 80211ce:	291d      	cmp	r1, #29
 80211d0:	d82c      	bhi.n	802122c <__sflush_r+0xb8>
 80211d2:	4a2a      	ldr	r2, [pc, #168]	; (802127c <__sflush_r+0x108>)
 80211d4:	40ca      	lsrs	r2, r1
 80211d6:	07d6      	lsls	r6, r2, #31
 80211d8:	d528      	bpl.n	802122c <__sflush_r+0xb8>
 80211da:	2200      	movs	r2, #0
 80211dc:	6062      	str	r2, [r4, #4]
 80211de:	04d9      	lsls	r1, r3, #19
 80211e0:	6922      	ldr	r2, [r4, #16]
 80211e2:	6022      	str	r2, [r4, #0]
 80211e4:	d504      	bpl.n	80211f0 <__sflush_r+0x7c>
 80211e6:	1c42      	adds	r2, r0, #1
 80211e8:	d101      	bne.n	80211ee <__sflush_r+0x7a>
 80211ea:	682b      	ldr	r3, [r5, #0]
 80211ec:	b903      	cbnz	r3, 80211f0 <__sflush_r+0x7c>
 80211ee:	6560      	str	r0, [r4, #84]	; 0x54
 80211f0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80211f2:	602f      	str	r7, [r5, #0]
 80211f4:	2900      	cmp	r1, #0
 80211f6:	d0ca      	beq.n	802118e <__sflush_r+0x1a>
 80211f8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80211fc:	4299      	cmp	r1, r3
 80211fe:	d002      	beq.n	8021206 <__sflush_r+0x92>
 8021200:	4628      	mov	r0, r5
 8021202:	f7fe ff89 	bl	8020118 <_free_r>
 8021206:	2000      	movs	r0, #0
 8021208:	6360      	str	r0, [r4, #52]	; 0x34
 802120a:	e7c1      	b.n	8021190 <__sflush_r+0x1c>
 802120c:	6a21      	ldr	r1, [r4, #32]
 802120e:	2301      	movs	r3, #1
 8021210:	4628      	mov	r0, r5
 8021212:	47b0      	blx	r6
 8021214:	1c41      	adds	r1, r0, #1
 8021216:	d1c7      	bne.n	80211a8 <__sflush_r+0x34>
 8021218:	682b      	ldr	r3, [r5, #0]
 802121a:	2b00      	cmp	r3, #0
 802121c:	d0c4      	beq.n	80211a8 <__sflush_r+0x34>
 802121e:	2b1d      	cmp	r3, #29
 8021220:	d001      	beq.n	8021226 <__sflush_r+0xb2>
 8021222:	2b16      	cmp	r3, #22
 8021224:	d101      	bne.n	802122a <__sflush_r+0xb6>
 8021226:	602f      	str	r7, [r5, #0]
 8021228:	e7b1      	b.n	802118e <__sflush_r+0x1a>
 802122a:	89a3      	ldrh	r3, [r4, #12]
 802122c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021230:	81a3      	strh	r3, [r4, #12]
 8021232:	e7ad      	b.n	8021190 <__sflush_r+0x1c>
 8021234:	690f      	ldr	r7, [r1, #16]
 8021236:	2f00      	cmp	r7, #0
 8021238:	d0a9      	beq.n	802118e <__sflush_r+0x1a>
 802123a:	0793      	lsls	r3, r2, #30
 802123c:	680e      	ldr	r6, [r1, #0]
 802123e:	bf08      	it	eq
 8021240:	694b      	ldreq	r3, [r1, #20]
 8021242:	600f      	str	r7, [r1, #0]
 8021244:	bf18      	it	ne
 8021246:	2300      	movne	r3, #0
 8021248:	eba6 0807 	sub.w	r8, r6, r7
 802124c:	608b      	str	r3, [r1, #8]
 802124e:	f1b8 0f00 	cmp.w	r8, #0
 8021252:	dd9c      	ble.n	802118e <__sflush_r+0x1a>
 8021254:	6a21      	ldr	r1, [r4, #32]
 8021256:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8021258:	4643      	mov	r3, r8
 802125a:	463a      	mov	r2, r7
 802125c:	4628      	mov	r0, r5
 802125e:	47b0      	blx	r6
 8021260:	2800      	cmp	r0, #0
 8021262:	dc06      	bgt.n	8021272 <__sflush_r+0xfe>
 8021264:	89a3      	ldrh	r3, [r4, #12]
 8021266:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802126a:	81a3      	strh	r3, [r4, #12]
 802126c:	f04f 30ff 	mov.w	r0, #4294967295
 8021270:	e78e      	b.n	8021190 <__sflush_r+0x1c>
 8021272:	4407      	add	r7, r0
 8021274:	eba8 0800 	sub.w	r8, r8, r0
 8021278:	e7e9      	b.n	802124e <__sflush_r+0xda>
 802127a:	bf00      	nop
 802127c:	20400001 	.word	0x20400001

08021280 <_fflush_r>:
 8021280:	b538      	push	{r3, r4, r5, lr}
 8021282:	690b      	ldr	r3, [r1, #16]
 8021284:	4605      	mov	r5, r0
 8021286:	460c      	mov	r4, r1
 8021288:	b913      	cbnz	r3, 8021290 <_fflush_r+0x10>
 802128a:	2500      	movs	r5, #0
 802128c:	4628      	mov	r0, r5
 802128e:	bd38      	pop	{r3, r4, r5, pc}
 8021290:	b118      	cbz	r0, 802129a <_fflush_r+0x1a>
 8021292:	6983      	ldr	r3, [r0, #24]
 8021294:	b90b      	cbnz	r3, 802129a <_fflush_r+0x1a>
 8021296:	f7ff f909 	bl	80204ac <__sinit>
 802129a:	4b14      	ldr	r3, [pc, #80]	; (80212ec <_fflush_r+0x6c>)
 802129c:	429c      	cmp	r4, r3
 802129e:	d11b      	bne.n	80212d8 <_fflush_r+0x58>
 80212a0:	686c      	ldr	r4, [r5, #4]
 80212a2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80212a6:	2b00      	cmp	r3, #0
 80212a8:	d0ef      	beq.n	802128a <_fflush_r+0xa>
 80212aa:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80212ac:	07d0      	lsls	r0, r2, #31
 80212ae:	d404      	bmi.n	80212ba <_fflush_r+0x3a>
 80212b0:	0599      	lsls	r1, r3, #22
 80212b2:	d402      	bmi.n	80212ba <_fflush_r+0x3a>
 80212b4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80212b6:	f7ff f997 	bl	80205e8 <__retarget_lock_acquire_recursive>
 80212ba:	4628      	mov	r0, r5
 80212bc:	4621      	mov	r1, r4
 80212be:	f7ff ff59 	bl	8021174 <__sflush_r>
 80212c2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80212c4:	07da      	lsls	r2, r3, #31
 80212c6:	4605      	mov	r5, r0
 80212c8:	d4e0      	bmi.n	802128c <_fflush_r+0xc>
 80212ca:	89a3      	ldrh	r3, [r4, #12]
 80212cc:	059b      	lsls	r3, r3, #22
 80212ce:	d4dd      	bmi.n	802128c <_fflush_r+0xc>
 80212d0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80212d2:	f7ff f98a 	bl	80205ea <__retarget_lock_release_recursive>
 80212d6:	e7d9      	b.n	802128c <_fflush_r+0xc>
 80212d8:	4b05      	ldr	r3, [pc, #20]	; (80212f0 <_fflush_r+0x70>)
 80212da:	429c      	cmp	r4, r3
 80212dc:	d101      	bne.n	80212e2 <_fflush_r+0x62>
 80212de:	68ac      	ldr	r4, [r5, #8]
 80212e0:	e7df      	b.n	80212a2 <_fflush_r+0x22>
 80212e2:	4b04      	ldr	r3, [pc, #16]	; (80212f4 <_fflush_r+0x74>)
 80212e4:	429c      	cmp	r4, r3
 80212e6:	bf08      	it	eq
 80212e8:	68ec      	ldreq	r4, [r5, #12]
 80212ea:	e7da      	b.n	80212a2 <_fflush_r+0x22>
 80212ec:	08026fd4 	.word	0x08026fd4
 80212f0:	08026ff4 	.word	0x08026ff4
 80212f4:	08026fb4 	.word	0x08026fb4

080212f8 <_lseek_r>:
 80212f8:	b538      	push	{r3, r4, r5, lr}
 80212fa:	4d07      	ldr	r5, [pc, #28]	; (8021318 <_lseek_r+0x20>)
 80212fc:	4604      	mov	r4, r0
 80212fe:	4608      	mov	r0, r1
 8021300:	4611      	mov	r1, r2
 8021302:	2200      	movs	r2, #0
 8021304:	602a      	str	r2, [r5, #0]
 8021306:	461a      	mov	r2, r3
 8021308:	f7fd f858 	bl	801e3bc <_lseek>
 802130c:	1c43      	adds	r3, r0, #1
 802130e:	d102      	bne.n	8021316 <_lseek_r+0x1e>
 8021310:	682b      	ldr	r3, [r5, #0]
 8021312:	b103      	cbz	r3, 8021316 <_lseek_r+0x1e>
 8021314:	6023      	str	r3, [r4, #0]
 8021316:	bd38      	pop	{r3, r4, r5, pc}
 8021318:	20019830 	.word	0x20019830

0802131c <__swhatbuf_r>:
 802131c:	b570      	push	{r4, r5, r6, lr}
 802131e:	460e      	mov	r6, r1
 8021320:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021324:	2900      	cmp	r1, #0
 8021326:	b096      	sub	sp, #88	; 0x58
 8021328:	4614      	mov	r4, r2
 802132a:	461d      	mov	r5, r3
 802132c:	da08      	bge.n	8021340 <__swhatbuf_r+0x24>
 802132e:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 8021332:	2200      	movs	r2, #0
 8021334:	602a      	str	r2, [r5, #0]
 8021336:	061a      	lsls	r2, r3, #24
 8021338:	d410      	bmi.n	802135c <__swhatbuf_r+0x40>
 802133a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802133e:	e00e      	b.n	802135e <__swhatbuf_r+0x42>
 8021340:	466a      	mov	r2, sp
 8021342:	f000 f893 	bl	802146c <_fstat_r>
 8021346:	2800      	cmp	r0, #0
 8021348:	dbf1      	blt.n	802132e <__swhatbuf_r+0x12>
 802134a:	9a01      	ldr	r2, [sp, #4]
 802134c:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8021350:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8021354:	425a      	negs	r2, r3
 8021356:	415a      	adcs	r2, r3
 8021358:	602a      	str	r2, [r5, #0]
 802135a:	e7ee      	b.n	802133a <__swhatbuf_r+0x1e>
 802135c:	2340      	movs	r3, #64	; 0x40
 802135e:	2000      	movs	r0, #0
 8021360:	6023      	str	r3, [r4, #0]
 8021362:	b016      	add	sp, #88	; 0x58
 8021364:	bd70      	pop	{r4, r5, r6, pc}
	...

08021368 <__smakebuf_r>:
 8021368:	898b      	ldrh	r3, [r1, #12]
 802136a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802136c:	079d      	lsls	r5, r3, #30
 802136e:	4606      	mov	r6, r0
 8021370:	460c      	mov	r4, r1
 8021372:	d507      	bpl.n	8021384 <__smakebuf_r+0x1c>
 8021374:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8021378:	6023      	str	r3, [r4, #0]
 802137a:	6123      	str	r3, [r4, #16]
 802137c:	2301      	movs	r3, #1
 802137e:	6163      	str	r3, [r4, #20]
 8021380:	b002      	add	sp, #8
 8021382:	bd70      	pop	{r4, r5, r6, pc}
 8021384:	ab01      	add	r3, sp, #4
 8021386:	466a      	mov	r2, sp
 8021388:	f7ff ffc8 	bl	802131c <__swhatbuf_r>
 802138c:	9900      	ldr	r1, [sp, #0]
 802138e:	4605      	mov	r5, r0
 8021390:	4630      	mov	r0, r6
 8021392:	f7fe ff2d 	bl	80201f0 <_malloc_r>
 8021396:	b948      	cbnz	r0, 80213ac <__smakebuf_r+0x44>
 8021398:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802139c:	059a      	lsls	r2, r3, #22
 802139e:	d4ef      	bmi.n	8021380 <__smakebuf_r+0x18>
 80213a0:	f023 0303 	bic.w	r3, r3, #3
 80213a4:	f043 0302 	orr.w	r3, r3, #2
 80213a8:	81a3      	strh	r3, [r4, #12]
 80213aa:	e7e3      	b.n	8021374 <__smakebuf_r+0xc>
 80213ac:	4b0d      	ldr	r3, [pc, #52]	; (80213e4 <__smakebuf_r+0x7c>)
 80213ae:	62b3      	str	r3, [r6, #40]	; 0x28
 80213b0:	89a3      	ldrh	r3, [r4, #12]
 80213b2:	6020      	str	r0, [r4, #0]
 80213b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80213b8:	81a3      	strh	r3, [r4, #12]
 80213ba:	9b00      	ldr	r3, [sp, #0]
 80213bc:	6163      	str	r3, [r4, #20]
 80213be:	9b01      	ldr	r3, [sp, #4]
 80213c0:	6120      	str	r0, [r4, #16]
 80213c2:	b15b      	cbz	r3, 80213dc <__smakebuf_r+0x74>
 80213c4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80213c8:	4630      	mov	r0, r6
 80213ca:	f000 f861 	bl	8021490 <_isatty_r>
 80213ce:	b128      	cbz	r0, 80213dc <__smakebuf_r+0x74>
 80213d0:	89a3      	ldrh	r3, [r4, #12]
 80213d2:	f023 0303 	bic.w	r3, r3, #3
 80213d6:	f043 0301 	orr.w	r3, r3, #1
 80213da:	81a3      	strh	r3, [r4, #12]
 80213dc:	89a0      	ldrh	r0, [r4, #12]
 80213de:	4305      	orrs	r5, r0
 80213e0:	81a5      	strh	r5, [r4, #12]
 80213e2:	e7cd      	b.n	8021380 <__smakebuf_r+0x18>
 80213e4:	08020445 	.word	0x08020445

080213e8 <_realloc_r>:
 80213e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80213ec:	4680      	mov	r8, r0
 80213ee:	4614      	mov	r4, r2
 80213f0:	460e      	mov	r6, r1
 80213f2:	b921      	cbnz	r1, 80213fe <_realloc_r+0x16>
 80213f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80213f8:	4611      	mov	r1, r2
 80213fa:	f7fe bef9 	b.w	80201f0 <_malloc_r>
 80213fe:	b92a      	cbnz	r2, 802140c <_realloc_r+0x24>
 8021400:	f7fe fe8a 	bl	8020118 <_free_r>
 8021404:	4625      	mov	r5, r4
 8021406:	4628      	mov	r0, r5
 8021408:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802140c:	f000 f850 	bl	80214b0 <_malloc_usable_size_r>
 8021410:	4284      	cmp	r4, r0
 8021412:	4607      	mov	r7, r0
 8021414:	d802      	bhi.n	802141c <_realloc_r+0x34>
 8021416:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 802141a:	d812      	bhi.n	8021442 <_realloc_r+0x5a>
 802141c:	4621      	mov	r1, r4
 802141e:	4640      	mov	r0, r8
 8021420:	f7fe fee6 	bl	80201f0 <_malloc_r>
 8021424:	4605      	mov	r5, r0
 8021426:	2800      	cmp	r0, #0
 8021428:	d0ed      	beq.n	8021406 <_realloc_r+0x1e>
 802142a:	42bc      	cmp	r4, r7
 802142c:	4622      	mov	r2, r4
 802142e:	4631      	mov	r1, r6
 8021430:	bf28      	it	cs
 8021432:	463a      	movcs	r2, r7
 8021434:	f7fe fe2a 	bl	802008c <memcpy>
 8021438:	4631      	mov	r1, r6
 802143a:	4640      	mov	r0, r8
 802143c:	f7fe fe6c 	bl	8020118 <_free_r>
 8021440:	e7e1      	b.n	8021406 <_realloc_r+0x1e>
 8021442:	4635      	mov	r5, r6
 8021444:	e7df      	b.n	8021406 <_realloc_r+0x1e>
	...

08021448 <_read_r>:
 8021448:	b538      	push	{r3, r4, r5, lr}
 802144a:	4d07      	ldr	r5, [pc, #28]	; (8021468 <_read_r+0x20>)
 802144c:	4604      	mov	r4, r0
 802144e:	4608      	mov	r0, r1
 8021450:	4611      	mov	r1, r2
 8021452:	2200      	movs	r2, #0
 8021454:	602a      	str	r2, [r5, #0]
 8021456:	461a      	mov	r2, r3
 8021458:	f7fc ff68 	bl	801e32c <_read>
 802145c:	1c43      	adds	r3, r0, #1
 802145e:	d102      	bne.n	8021466 <_read_r+0x1e>
 8021460:	682b      	ldr	r3, [r5, #0]
 8021462:	b103      	cbz	r3, 8021466 <_read_r+0x1e>
 8021464:	6023      	str	r3, [r4, #0]
 8021466:	bd38      	pop	{r3, r4, r5, pc}
 8021468:	20019830 	.word	0x20019830

0802146c <_fstat_r>:
 802146c:	b538      	push	{r3, r4, r5, lr}
 802146e:	4d07      	ldr	r5, [pc, #28]	; (802148c <_fstat_r+0x20>)
 8021470:	2300      	movs	r3, #0
 8021472:	4604      	mov	r4, r0
 8021474:	4608      	mov	r0, r1
 8021476:	4611      	mov	r1, r2
 8021478:	602b      	str	r3, [r5, #0]
 802147a:	f7fc ff97 	bl	801e3ac <_fstat>
 802147e:	1c43      	adds	r3, r0, #1
 8021480:	d102      	bne.n	8021488 <_fstat_r+0x1c>
 8021482:	682b      	ldr	r3, [r5, #0]
 8021484:	b103      	cbz	r3, 8021488 <_fstat_r+0x1c>
 8021486:	6023      	str	r3, [r4, #0]
 8021488:	bd38      	pop	{r3, r4, r5, pc}
 802148a:	bf00      	nop
 802148c:	20019830 	.word	0x20019830

08021490 <_isatty_r>:
 8021490:	b538      	push	{r3, r4, r5, lr}
 8021492:	4d06      	ldr	r5, [pc, #24]	; (80214ac <_isatty_r+0x1c>)
 8021494:	2300      	movs	r3, #0
 8021496:	4604      	mov	r4, r0
 8021498:	4608      	mov	r0, r1
 802149a:	602b      	str	r3, [r5, #0]
 802149c:	f7fc ff8c 	bl	801e3b8 <_isatty>
 80214a0:	1c43      	adds	r3, r0, #1
 80214a2:	d102      	bne.n	80214aa <_isatty_r+0x1a>
 80214a4:	682b      	ldr	r3, [r5, #0]
 80214a6:	b103      	cbz	r3, 80214aa <_isatty_r+0x1a>
 80214a8:	6023      	str	r3, [r4, #0]
 80214aa:	bd38      	pop	{r3, r4, r5, pc}
 80214ac:	20019830 	.word	0x20019830

080214b0 <_malloc_usable_size_r>:
 80214b0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80214b4:	1f18      	subs	r0, r3, #4
 80214b6:	2b00      	cmp	r3, #0
 80214b8:	bfbc      	itt	lt
 80214ba:	580b      	ldrlt	r3, [r1, r0]
 80214bc:	18c0      	addlt	r0, r0, r3
 80214be:	4770      	bx	lr

080214c0 <_init>:
 80214c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80214c2:	bf00      	nop
 80214c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80214c6:	bc08      	pop	{r3}
 80214c8:	469e      	mov	lr, r3
 80214ca:	4770      	bx	lr

080214cc <_fini>:
 80214cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80214ce:	bf00      	nop
 80214d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80214d2:	bc08      	pop	{r3}
 80214d4:	469e      	mov	lr, r3
 80214d6:	4770      	bx	lr
